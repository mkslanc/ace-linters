(self["webpackChunkace_linters_root"] = self["webpackChunkace_linters_root"] || []).push([[1066],{

/***/ 21066:
/***/ (function(module) {

function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
(function webpackUniversalModuleDefinition(root, factory) {
    if (true) module.exports = factory();
    else { var i, a; }
})(this, ()=>{
    return /******/ (()=>{
        /******/ var __webpack_modules__ = {
            /***/ 6093: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_810__)=>{
                "use strict";
                /* provided dependency */ var process = __nested_webpack_require_810__(9907);
                /* provided dependency */ var console = __nested_webpack_require_810__(4364);
                // Currently in sync with Node.js lib/assert.js
                // https://github.com/nodejs/node/commit/2a51ae424a513ec9a6aa3466baa0cc1d55dd4f3b
                // Originally from narwhal.js (http://narwhaljs.org)
                // Copyright (c) 2009 Thomas Robinson <280north.com>
                //
                // Permission is hereby granted, free of charge, to any person obtaining a copy
                // of this software and associated documentation files (the 'Software'), to
                // deal in the Software without restriction, including without limitation the
                // rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
                // sell copies of the Software, and to permit persons to whom the Software is
                // furnished to do so, subject to the following conditions:
                //
                // The above copyright notice and this permission notice shall be included in
                // all copies or substantial portions of the Software.
                //
                // THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
                // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
                // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
                // AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
                // ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
                // WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
                function _typeof(obj) {
                    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                        _typeof = function _typeof(obj) {
                            return typeof obj;
                        };
                    } else {
                        _typeof = function _typeof(obj) {
                            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
                        };
                    }
                    return _typeof(obj);
                }
                function _classCallCheck(instance, Constructor) {
                    if (!(instance instanceof Constructor)) {
                        throw new TypeError("Cannot call a class as a function");
                    }
                }
                var _require = __nested_webpack_require_810__(1342), _require$codes = _require.codes, ERR_AMBIGUOUS_ARGUMENT = _require$codes.ERR_AMBIGUOUS_ARGUMENT, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_INVALID_ARG_VALUE = _require$codes.ERR_INVALID_ARG_VALUE, ERR_INVALID_RETURN_VALUE = _require$codes.ERR_INVALID_RETURN_VALUE, ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
                var AssertionError = __nested_webpack_require_810__(9801);
                var _require2 = __nested_webpack_require_810__(6827), inspect = _require2.inspect;
                var _require$types = __nested_webpack_require_810__(6827).types, isPromise = _require$types.isPromise, isRegExp = _require$types.isRegExp;
                var objectAssign = Object.assign ? Object.assign : __nested_webpack_require_810__(3046).assign;
                var objectIs = Object.is ? Object.is : __nested_webpack_require_810__(5968);
                var errorCache = new Map();
                var isDeepEqual;
                var isDeepStrictEqual;
                var parseExpressionAt;
                var findNodeAround;
                var decoder;
                function lazyLoadComparison() {
                    var comparison = __nested_webpack_require_810__(5656);
                    isDeepEqual = comparison.isDeepEqual;
                    isDeepStrictEqual = comparison.isDeepStrictEqual;
                } // Escape control characters but not \n and \t to keep the line breaks and
                // indentation intact.
                // eslint-disable-next-line no-control-regex
                var escapeSequencesRegExp = /[\x00-\x08\x0b\x0c\x0e-\x1f]/g;
                var meta = /* unused pure expression or super */ null && 0;
                var escapeFn = function escapeFn(str) {
                    return meta[str.charCodeAt(0)];
                };
                var warned = false; // The assert module provides functions that throw
                // AssertionError's when particular conditions are not met. The
                // assert module must conform to the following interface.
                var assert = module1.exports = ok;
                var NO_EXCEPTION_SENTINEL = {}; // All of the following functions must throw an AssertionError
                // when a corresponding condition is not met, with a message that
                // may be undefined if not provided. All assertion methods provide
                // both the actual and expected values to the assertion error for
                // display purposes.
                function innerFail(obj) {
                    if (obj.message instanceof Error) throw obj.message;
                    throw new AssertionError(obj);
                }
                function fail(actual, expected, message, operator, stackStartFn) {
                    var argsLen = arguments.length;
                    var internalMessage;
                    if (argsLen === 0) {
                        internalMessage = 'Failed';
                    } else if (argsLen === 1) {
                        message = actual;
                        actual = undefined;
                    } else {
                        if (warned === false) {
                            warned = true;
                            var warn = process.emitWarning ? process.emitWarning : console.warn.bind(console);
                            warn('assert.fail() with more than one argument is deprecated. ' + 'Please use assert.strictEqual() instead or only pass a message.', 'DeprecationWarning', 'DEP0094');
                        }
                        if (argsLen === 2) operator = '!=';
                    }
                    if (message instanceof Error) throw message;
                    var errArgs = {
                        actual: actual,
                        expected: expected,
                        operator: operator === undefined ? 'fail' : operator,
                        stackStartFn: stackStartFn || fail
                    };
                    if (message !== undefined) {
                        errArgs.message = message;
                    }
                    var err = new AssertionError(errArgs);
                    if (internalMessage) {
                        err.message = internalMessage;
                        err.generatedMessage = true;
                    }
                    throw err;
                }
                assert.fail = fail; // The AssertionError is defined in internal/error.
                assert.AssertionError = AssertionError;
                function innerOk(fn, argLen, value, message) {
                    if (!value) {
                        var generatedMessage = false;
                        if (argLen === 0) {
                            generatedMessage = true;
                            message = 'No value argument passed to `assert.ok()`';
                        } else if (message instanceof Error) {
                            throw message;
                        }
                        var err = new AssertionError({
                            actual: value,
                            expected: true,
                            message: message,
                            operator: '==',
                            stackStartFn: fn
                        });
                        err.generatedMessage = generatedMessage;
                        throw err;
                    }
                } // Pure assertion tests whether a value is truthy, as determined
                // by !!value.
                function ok() {
                    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                        args[_key] = arguments[_key];
                    }
                    innerOk.apply(void 0, [
                        ok,
                        args.length
                    ].concat(args));
                }
                assert.ok = ok; // The equality assertion tests shallow, coercive equality with ==.
                /* eslint-disable no-restricted-properties */ assert.equal = function equal(actual, expected, message) {
                    if (arguments.length < 2) {
                        throw new ERR_MISSING_ARGS('actual', 'expected');
                    } // eslint-disable-next-line eqeqeq
                    if (actual != expected) {
                        innerFail({
                            actual: actual,
                            expected: expected,
                            message: message,
                            operator: '==',
                            stackStartFn: equal
                        });
                    }
                }; // The non-equality assertion tests for whether two objects are not
                // equal with !=.
                assert.notEqual = function notEqual(actual, expected, message) {
                    if (arguments.length < 2) {
                        throw new ERR_MISSING_ARGS('actual', 'expected');
                    } // eslint-disable-next-line eqeqeq
                    if (actual == expected) {
                        innerFail({
                            actual: actual,
                            expected: expected,
                            message: message,
                            operator: '!=',
                            stackStartFn: notEqual
                        });
                    }
                }; // The equivalence assertion tests a deep equality relation.
                assert.deepEqual = function deepEqual(actual, expected, message) {
                    if (arguments.length < 2) {
                        throw new ERR_MISSING_ARGS('actual', 'expected');
                    }
                    if (isDeepEqual === undefined) lazyLoadComparison();
                    if (!isDeepEqual(actual, expected)) {
                        innerFail({
                            actual: actual,
                            expected: expected,
                            message: message,
                            operator: 'deepEqual',
                            stackStartFn: deepEqual
                        });
                    }
                }; // The non-equivalence assertion tests for any deep inequality.
                assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
                    if (arguments.length < 2) {
                        throw new ERR_MISSING_ARGS('actual', 'expected');
                    }
                    if (isDeepEqual === undefined) lazyLoadComparison();
                    if (isDeepEqual(actual, expected)) {
                        innerFail({
                            actual: actual,
                            expected: expected,
                            message: message,
                            operator: 'notDeepEqual',
                            stackStartFn: notDeepEqual
                        });
                    }
                };
                /* eslint-enable */ assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
                    if (arguments.length < 2) {
                        throw new ERR_MISSING_ARGS('actual', 'expected');
                    }
                    if (isDeepEqual === undefined) lazyLoadComparison();
                    if (!isDeepStrictEqual(actual, expected)) {
                        innerFail({
                            actual: actual,
                            expected: expected,
                            message: message,
                            operator: 'deepStrictEqual',
                            stackStartFn: deepStrictEqual
                        });
                    }
                };
                assert.notDeepStrictEqual = notDeepStrictEqual;
                function notDeepStrictEqual(actual, expected, message) {
                    if (arguments.length < 2) {
                        throw new ERR_MISSING_ARGS('actual', 'expected');
                    }
                    if (isDeepEqual === undefined) lazyLoadComparison();
                    if (isDeepStrictEqual(actual, expected)) {
                        innerFail({
                            actual: actual,
                            expected: expected,
                            message: message,
                            operator: 'notDeepStrictEqual',
                            stackStartFn: notDeepStrictEqual
                        });
                    }
                }
                assert.strictEqual = function strictEqual(actual, expected, message) {
                    if (arguments.length < 2) {
                        throw new ERR_MISSING_ARGS('actual', 'expected');
                    }
                    if (!objectIs(actual, expected)) {
                        innerFail({
                            actual: actual,
                            expected: expected,
                            message: message,
                            operator: 'strictEqual',
                            stackStartFn: strictEqual
                        });
                    }
                };
                assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
                    if (arguments.length < 2) {
                        throw new ERR_MISSING_ARGS('actual', 'expected');
                    }
                    if (objectIs(actual, expected)) {
                        innerFail({
                            actual: actual,
                            expected: expected,
                            message: message,
                            operator: 'notStrictEqual',
                            stackStartFn: notStrictEqual
                        });
                    }
                };
                var Comparison = function Comparison(obj, keys, actual) {
                    var _this = this;
                    _classCallCheck(this, Comparison);
                    keys.forEach(function(key) {
                        if (key in obj) {
                            if (actual !== undefined && typeof actual[key] === 'string' && isRegExp(obj[key]) && obj[key].test(actual[key])) {
                                _this[key] = actual[key];
                            } else {
                                _this[key] = obj[key];
                            }
                        }
                    });
                };
                function compareExceptionKey(actual, expected, key, message, keys, fn) {
                    if (!(key in actual) || !isDeepStrictEqual(actual[key], expected[key])) {
                        if (!message) {
                            // Create placeholder objects to create a nice output.
                            var a = new Comparison(actual, keys);
                            var b = new Comparison(expected, keys, actual);
                            var err = new AssertionError({
                                actual: a,
                                expected: b,
                                operator: 'deepStrictEqual',
                                stackStartFn: fn
                            });
                            err.actual = actual;
                            err.expected = expected;
                            err.operator = fn.name;
                            throw err;
                        }
                        innerFail({
                            actual: actual,
                            expected: expected,
                            message: message,
                            operator: fn.name,
                            stackStartFn: fn
                        });
                    }
                }
                function expectedException(actual, expected, msg, fn) {
                    if (typeof expected !== 'function') {
                        if (isRegExp(expected)) return expected.test(actual); // assert.doesNotThrow does not accept objects.
                        if (arguments.length === 2) {
                            throw new ERR_INVALID_ARG_TYPE('expected', [
                                'Function',
                                'RegExp'
                            ], expected);
                        } // Handle primitives properly.
                        if (_typeof(actual) !== 'object' || actual === null) {
                            var err = new AssertionError({
                                actual: actual,
                                expected: expected,
                                message: msg,
                                operator: 'deepStrictEqual',
                                stackStartFn: fn
                            });
                            err.operator = fn.name;
                            throw err;
                        }
                        var keys = Object.keys(expected); // Special handle errors to make sure the name and the message are compared
                        // as well.
                        if (expected instanceof Error) {
                            keys.push('name', 'message');
                        } else if (keys.length === 0) {
                            throw new ERR_INVALID_ARG_VALUE('error', expected, 'may not be an empty object');
                        }
                        if (isDeepEqual === undefined) lazyLoadComparison();
                        keys.forEach(function(key) {
                            if (typeof actual[key] === 'string' && isRegExp(expected[key]) && expected[key].test(actual[key])) {
                                return;
                            }
                            compareExceptionKey(actual, expected, key, msg, keys, fn);
                        });
                        return true;
                    } // Guard instanceof against arrow functions as they don't have a prototype.
                    if (expected.prototype !== undefined && actual instanceof expected) {
                        return true;
                    }
                    if (Error.isPrototypeOf(expected)) {
                        return false;
                    }
                    return expected.call({}, actual) === true;
                }
                function getActual(fn) {
                    if (typeof fn !== 'function') {
                        throw new ERR_INVALID_ARG_TYPE('fn', 'Function', fn);
                    }
                    try {
                        fn();
                    } catch (e) {
                        return e;
                    }
                    return NO_EXCEPTION_SENTINEL;
                }
                function checkIsPromise(obj) {
                    // Accept native ES6 promises and promises that are implemented in a similar
                    // way. Do not accept thenables that use a function as `obj` and that have no
                    // `catch` handler.
                    // TODO: thenables are checked up until they have the correct methods,
                    // but according to documentation, the `then` method should receive
                    // the `fulfill` and `reject` arguments as well or it may be never resolved.
                    return isPromise(obj) || obj !== null && _typeof(obj) === 'object' && typeof obj.then === 'function' && typeof obj.catch === 'function';
                }
                function waitForActual(promiseFn) {
                    return Promise.resolve().then(function() {
                        var resultPromise;
                        if (typeof promiseFn === 'function') {
                            // Return a rejected promise if `promiseFn` throws synchronously.
                            resultPromise = promiseFn(); // Fail in case no promise is returned.
                            if (!checkIsPromise(resultPromise)) {
                                throw new ERR_INVALID_RETURN_VALUE('instance of Promise', 'promiseFn', resultPromise);
                            }
                        } else if (checkIsPromise(promiseFn)) {
                            resultPromise = promiseFn;
                        } else {
                            throw new ERR_INVALID_ARG_TYPE('promiseFn', [
                                'Function',
                                'Promise'
                            ], promiseFn);
                        }
                        return Promise.resolve().then(function() {
                            return resultPromise;
                        }).then(function() {
                            return NO_EXCEPTION_SENTINEL;
                        }).catch(function(e) {
                            return e;
                        });
                    });
                }
                function expectsError(stackStartFn, actual, error, message) {
                    if (typeof error === 'string') {
                        if (arguments.length === 4) {
                            throw new ERR_INVALID_ARG_TYPE('error', [
                                'Object',
                                'Error',
                                'Function',
                                'RegExp'
                            ], error);
                        }
                        if (_typeof(actual) === 'object' && actual !== null) {
                            if (actual.message === error) {
                                throw new ERR_AMBIGUOUS_ARGUMENT('error/message', "The error message \"".concat(actual.message, "\" is identical to the message."));
                            }
                        } else if (actual === error) {
                            throw new ERR_AMBIGUOUS_ARGUMENT('error/message', "The error \"".concat(actual, "\" is identical to the message."));
                        }
                        message = error;
                        error = undefined;
                    } else if (error != null && _typeof(error) !== 'object' && typeof error !== 'function') {
                        throw new ERR_INVALID_ARG_TYPE('error', [
                            'Object',
                            'Error',
                            'Function',
                            'RegExp'
                        ], error);
                    }
                    if (actual === NO_EXCEPTION_SENTINEL) {
                        var details = '';
                        if (error && error.name) {
                            details += " (".concat(error.name, ")");
                        }
                        details += message ? ": ".concat(message) : '.';
                        var fnType = stackStartFn.name === 'rejects' ? 'rejection' : 'exception';
                        innerFail({
                            actual: undefined,
                            expected: error,
                            operator: stackStartFn.name,
                            message: "Missing expected ".concat(fnType).concat(details),
                            stackStartFn: stackStartFn
                        });
                    }
                    if (error && !expectedException(actual, error, message, stackStartFn)) {
                        throw actual;
                    }
                }
                function expectsNoError(stackStartFn, actual, error, message) {
                    if (actual === NO_EXCEPTION_SENTINEL) return;
                    if (typeof error === 'string') {
                        message = error;
                        error = undefined;
                    }
                    if (!error || expectedException(actual, error)) {
                        var details = message ? ": ".concat(message) : '.';
                        var fnType = stackStartFn.name === 'doesNotReject' ? 'rejection' : 'exception';
                        innerFail({
                            actual: actual,
                            expected: error,
                            operator: stackStartFn.name,
                            message: "Got unwanted ".concat(fnType).concat(details, "\n") + "Actual message: \"".concat(actual && actual.message, "\""),
                            stackStartFn: stackStartFn
                        });
                    }
                    throw actual;
                }
                assert.throws = function throws(promiseFn) {
                    for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){
                        args[_key2 - 1] = arguments[_key2];
                    }
                    expectsError.apply(void 0, [
                        throws,
                        getActual(promiseFn)
                    ].concat(args));
                };
                assert.rejects = function rejects(promiseFn) {
                    for(var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++){
                        args[_key3 - 1] = arguments[_key3];
                    }
                    return waitForActual(promiseFn).then(function(result) {
                        return expectsError.apply(void 0, [
                            rejects,
                            result
                        ].concat(args));
                    });
                };
                assert.doesNotThrow = function doesNotThrow(fn) {
                    for(var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++){
                        args[_key4 - 1] = arguments[_key4];
                    }
                    expectsNoError.apply(void 0, [
                        doesNotThrow,
                        getActual(fn)
                    ].concat(args));
                };
                assert.doesNotReject = function doesNotReject(fn) {
                    for(var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++){
                        args[_key5 - 1] = arguments[_key5];
                    }
                    return waitForActual(fn).then(function(result) {
                        return expectsNoError.apply(void 0, [
                            doesNotReject,
                            result
                        ].concat(args));
                    });
                };
                assert.ifError = function ifError(err) {
                    if (err !== null && err !== undefined) {
                        var message = 'ifError got unwanted exception: ';
                        if (_typeof(err) === 'object' && typeof err.message === 'string') {
                            if (err.message.length === 0 && err.constructor) {
                                message += err.constructor.name;
                            } else {
                                message += err.message;
                            }
                        } else {
                            message += inspect(err);
                        }
                        var newErr = new AssertionError({
                            actual: err,
                            expected: null,
                            operator: 'ifError',
                            message: message,
                            stackStartFn: ifError
                        }); // Make sure we actually have a stack trace!
                        var origStack = err.stack;
                        if (typeof origStack === 'string') {
                            // This will remove any duplicated frames from the error frames taken
                            // from within `ifError` and add the original error frames to the newly
                            // created ones.
                            var tmp2 = origStack.split('\n');
                            tmp2.shift(); // Filter all frames existing in err.stack.
                            var tmp1 = newErr.stack.split('\n');
                            for(var i = 0; i < tmp2.length; i++){
                                // Find the first occurrence of the frame.
                                var pos = tmp1.indexOf(tmp2[i]);
                                if (pos !== -1) {
                                    // Only keep new frames.
                                    tmp1 = tmp1.slice(0, pos);
                                    break;
                                }
                            }
                            newErr.stack = "".concat(tmp1.join('\n'), "\n").concat(tmp2.join('\n'));
                        }
                        throw newErr;
                    }
                }; // Expose a strict only variant of assert
                function strict() {
                    for(var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++){
                        args[_key6] = arguments[_key6];
                    }
                    innerOk.apply(void 0, [
                        strict,
                        args.length
                    ].concat(args));
                }
                assert.strict = objectAssign(strict, assert, {
                    equal: assert.strictEqual,
                    deepEqual: assert.deepStrictEqual,
                    notEqual: assert.notStrictEqual,
                    notDeepEqual: assert.notDeepStrictEqual
                });
                assert.strict.strict = assert.strict;
            /***/ },
            /***/ 9801: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_32028__)=>{
                "use strict";
                /* provided dependency */ var process = __nested_webpack_require_32028__(9907);
                // Currently in sync with Node.js lib/internal/assert/assertion_error.js
                // https://github.com/nodejs/node/commit/0817840f775032169ddd70c85ac059f18ffcc81c
                function _objectSpread(target) {
                    for(var i = 1; i < arguments.length; i++){
                        var source = arguments[i] != null ? arguments[i] : {};
                        var ownKeys = Object.keys(source);
                        if (typeof Object.getOwnPropertySymbols === 'function') {
                            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
                                return Object.getOwnPropertyDescriptor(source, sym).enumerable;
                            }));
                        }
                        ownKeys.forEach(function(key) {
                            _defineProperty(target, key, source[key]);
                        });
                    }
                    return target;
                }
                function _defineProperty(obj, key, value) {
                    if (key in obj) {
                        Object.defineProperty(obj, key, {
                            value: value,
                            enumerable: true,
                            configurable: true,
                            writable: true
                        });
                    } else {
                        obj[key] = value;
                    }
                    return obj;
                }
                function _classCallCheck(instance, Constructor) {
                    if (!(instance instanceof Constructor)) {
                        throw new TypeError("Cannot call a class as a function");
                    }
                }
                function _defineProperties(target, props) {
                    for(var i = 0; i < props.length; i++){
                        var descriptor = props[i];
                        descriptor.enumerable = descriptor.enumerable || false;
                        descriptor.configurable = true;
                        if ("value" in descriptor) descriptor.writable = true;
                        Object.defineProperty(target, descriptor.key, descriptor);
                    }
                }
                function _createClass(Constructor, protoProps, staticProps) {
                    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
                    if (staticProps) _defineProperties(Constructor, staticProps);
                    return Constructor;
                }
                function _possibleConstructorReturn(self, call) {
                    if (call && (_typeof(call) === "object" || typeof call === "function")) {
                        return call;
                    }
                    return _assertThisInitialized(self);
                }
                function _assertThisInitialized(self) {
                    if (self === void 0) {
                        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    }
                    return self;
                }
                function _inherits(subClass, superClass) {
                    if (typeof superClass !== "function" && superClass !== null) {
                        throw new TypeError("Super expression must either be null or a function");
                    }
                    subClass.prototype = Object.create(superClass && superClass.prototype, {
                        constructor: {
                            value: subClass,
                            writable: true,
                            configurable: true
                        }
                    });
                    if (superClass) _setPrototypeOf(subClass, superClass);
                }
                function _wrapNativeSuper(Class) {
                    var _cache = typeof Map === "function" ? new Map() : undefined;
                    _wrapNativeSuper = function _wrapNativeSuper(Class) {
                        if (Class === null || !_isNativeFunction(Class)) return Class;
                        if (typeof Class !== "function") {
                            throw new TypeError("Super expression must either be null or a function");
                        }
                        if (typeof _cache !== "undefined") {
                            if (_cache.has(Class)) return _cache.get(Class);
                            _cache.set(Class, Wrapper);
                        }
                        function Wrapper() {
                            return _construct(Class, arguments, _getPrototypeOf(this).constructor);
                        }
                        Wrapper.prototype = Object.create(Class.prototype, {
                            constructor: {
                                value: Wrapper,
                                enumerable: false,
                                writable: true,
                                configurable: true
                            }
                        });
                        return _setPrototypeOf(Wrapper, Class);
                    };
                    return _wrapNativeSuper(Class);
                }
                function isNativeReflectConstruct() {
                    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
                    if (Reflect.construct.sham) return false;
                    if (typeof Proxy === "function") return true;
                    try {
                        Date.prototype.toString.call(Reflect.construct(Date, [], function() {}));
                        return true;
                    } catch (e) {
                        return false;
                    }
                }
                function _construct(Parent, args, Class) {
                    if (isNativeReflectConstruct()) {
                        _construct = Reflect.construct;
                    } else {
                        _construct = function _construct(Parent, args, Class) {
                            var a = [
                                null
                            ];
                            a.push.apply(a, args);
                            var Constructor = Function.bind.apply(Parent, a);
                            var instance = new Constructor();
                            if (Class) _setPrototypeOf(instance, Class.prototype);
                            return instance;
                        };
                    }
                    return _construct.apply(null, arguments);
                }
                function _isNativeFunction(fn) {
                    return Function.toString.call(fn).indexOf("[native code]") !== -1;
                }
                function _setPrototypeOf(o, p) {
                    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
                        o.__proto__ = p;
                        return o;
                    };
                    return _setPrototypeOf(o, p);
                }
                function _getPrototypeOf(o) {
                    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
                        return o.__proto__ || Object.getPrototypeOf(o);
                    };
                    return _getPrototypeOf(o);
                }
                function _typeof(obj) {
                    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                        _typeof = function _typeof(obj) {
                            return typeof obj;
                        };
                    } else {
                        _typeof = function _typeof(obj) {
                            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
                        };
                    }
                    return _typeof(obj);
                }
                var _require = __nested_webpack_require_32028__(6827), inspect = _require.inspect;
                var _require2 = __nested_webpack_require_32028__(1342), ERR_INVALID_ARG_TYPE = _require2.codes.ERR_INVALID_ARG_TYPE; // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith
                function endsWith(str, search, this_len) {
                    if (this_len === undefined || this_len > str.length) {
                        this_len = str.length;
                    }
                    return str.substring(this_len - search.length, this_len) === search;
                } // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/repeat
                function repeat(str, count) {
                    count = Math.floor(count);
                    if (str.length == 0 || count == 0) return '';
                    var maxCount = str.length * count;
                    count = Math.floor(Math.log(count) / Math.log(2));
                    while(count){
                        str += str;
                        count--;
                    }
                    str += str.substring(0, maxCount - str.length);
                    return str;
                }
                var blue = '';
                var green = '';
                var red = '';
                var white = '';
                var kReadableOperator = {
                    deepStrictEqual: 'Expected values to be strictly deep-equal:',
                    strictEqual: 'Expected values to be strictly equal:',
                    strictEqualObject: 'Expected "actual" to be reference-equal to "expected":',
                    deepEqual: 'Expected values to be loosely deep-equal:',
                    equal: 'Expected values to be loosely equal:',
                    notDeepStrictEqual: 'Expected "actual" not to be strictly deep-equal to:',
                    notStrictEqual: 'Expected "actual" to be strictly unequal to:',
                    notStrictEqualObject: 'Expected "actual" not to be reference-equal to "expected":',
                    notDeepEqual: 'Expected "actual" not to be loosely deep-equal to:',
                    notEqual: 'Expected "actual" to be loosely unequal to:',
                    notIdentical: 'Values identical but not reference-equal:'
                }; // Comparing short primitives should just show === / !== instead of using the
                // diff.
                var kMaxShortLength = 10;
                function copyError(source) {
                    var keys = Object.keys(source);
                    var target = Object.create(Object.getPrototypeOf(source));
                    keys.forEach(function(key) {
                        target[key] = source[key];
                    });
                    Object.defineProperty(target, 'message', {
                        value: source.message
                    });
                    return target;
                }
                function inspectValue(val) {
                    // The util.inspect default values could be changed. This makes sure the
                    // error messages contain the necessary information nevertheless.
                    return inspect(val, {
                        compact: false,
                        customInspect: false,
                        depth: 1000,
                        maxArrayLength: Infinity,
                        // Assert compares only enumerable properties (with a few exceptions).
                        showHidden: false,
                        // Having a long line as error is better than wrapping the line for
                        // comparison for now.
                        // TODO(BridgeAR): `breakLength` should be limited as soon as soon as we
                        // have meta information about the inspected properties (i.e., know where
                        // in what line the property starts and ends).
                        breakLength: Infinity,
                        // Assert does not detect proxies currently.
                        showProxy: false,
                        sorted: true,
                        // Inspect getters as we also check them when comparing entries.
                        getters: true
                    });
                }
                function createErrDiff(actual, expected, operator) {
                    var other = '';
                    var res = '';
                    var lastPos = 0;
                    var end = '';
                    var skipped = false;
                    var actualInspected = inspectValue(actual);
                    var actualLines = actualInspected.split('\n');
                    var expectedLines = inspectValue(expected).split('\n');
                    var i = 0;
                    var indicator = ''; // In case both values are objects explicitly mark them as not reference equal
                    // for the `strictEqual` operator.
                    if (operator === 'strictEqual' && _typeof(actual) === 'object' && _typeof(expected) === 'object' && actual !== null && expected !== null) {
                        operator = 'strictEqualObject';
                    } // If "actual" and "expected" fit on a single line and they are not strictly
                    // equal, check further special handling.
                    if (actualLines.length === 1 && expectedLines.length === 1 && actualLines[0] !== expectedLines[0]) {
                        var inputLength = actualLines[0].length + expectedLines[0].length; // If the character length of "actual" and "expected" together is less than
                        // kMaxShortLength and if neither is an object and at least one of them is
                        // not `zero`, use the strict equal comparison to visualize the output.
                        if (inputLength <= kMaxShortLength) {
                            if ((_typeof(actual) !== 'object' || actual === null) && (_typeof(expected) !== 'object' || expected === null) && (actual !== 0 || expected !== 0)) {
                                // -0 === +0
                                return "".concat(kReadableOperator[operator], "\n\n") + "".concat(actualLines[0], " !== ").concat(expectedLines[0], "\n");
                            }
                        } else if (operator !== 'strictEqualObject') {
                            // If the stderr is a tty and the input length is lower than the current
                            // columns per line, add a mismatch indicator below the output. If it is
                            // not a tty, use a default value of 80 characters.
                            var maxLength = process.stderr && process.stderr.isTTY ? process.stderr.columns : 80;
                            if (inputLength < maxLength) {
                                while(actualLines[0][i] === expectedLines[0][i]){
                                    i++;
                                } // Ignore the first characters.
                                if (i > 2) {
                                    // Add position indicator for the first mismatch in case it is a
                                    // single line and the input length is less than the column length.
                                    indicator = "\n  ".concat(repeat(' ', i), "^");
                                    i = 0;
                                }
                            }
                        }
                    } // Remove all ending lines that match (this optimizes the output for
                    // readability by reducing the number of total changed lines).
                    var a = actualLines[actualLines.length - 1];
                    var b = expectedLines[expectedLines.length - 1];
                    while(a === b){
                        if (i++ < 2) {
                            end = "\n  ".concat(a).concat(end);
                        } else {
                            other = a;
                        }
                        actualLines.pop();
                        expectedLines.pop();
                        if (actualLines.length === 0 || expectedLines.length === 0) break;
                        a = actualLines[actualLines.length - 1];
                        b = expectedLines[expectedLines.length - 1];
                    }
                    var maxLines = Math.max(actualLines.length, expectedLines.length); // Strict equal with identical objects that are not identical by reference.
                    // E.g., assert.deepStrictEqual({ a: Symbol() }, { a: Symbol() })
                    if (maxLines === 0) {
                        // We have to get the result again. The lines were all removed before.
                        var _actualLines = actualInspected.split('\n'); // Only remove lines in case it makes sense to collapse those.
                        // TODO: Accept env to always show the full error.
                        if (_actualLines.length > 30) {
                            _actualLines[26] = "".concat(blue, "...").concat(white);
                            while(_actualLines.length > 27){
                                _actualLines.pop();
                            }
                        }
                        return "".concat(kReadableOperator.notIdentical, "\n\n").concat(_actualLines.join('\n'), "\n");
                    }
                    if (i > 3) {
                        end = "\n".concat(blue, "...").concat(white).concat(end);
                        skipped = true;
                    }
                    if (other !== '') {
                        end = "\n  ".concat(other).concat(end);
                        other = '';
                    }
                    var printedLines = 0;
                    var msg = kReadableOperator[operator] + "\n".concat(green, "+ actual").concat(white, " ").concat(red, "- expected").concat(white);
                    var skippedMsg = " ".concat(blue, "...").concat(white, " Lines skipped");
                    for(i = 0; i < maxLines; i++){
                        // Only extra expected lines exist
                        var cur = i - lastPos;
                        if (actualLines.length < i + 1) {
                            // If the last diverging line is more than one line above and the
                            // current line is at least line three, add some of the former lines and
                            // also add dots to indicate skipped entries.
                            if (cur > 1 && i > 2) {
                                if (cur > 4) {
                                    res += "\n".concat(blue, "...").concat(white);
                                    skipped = true;
                                } else if (cur > 3) {
                                    res += "\n  ".concat(expectedLines[i - 2]);
                                    printedLines++;
                                }
                                res += "\n  ".concat(expectedLines[i - 1]);
                                printedLines++;
                            } // Mark the current line as the last diverging one.
                            lastPos = i; // Add the expected line to the cache.
                            other += "\n".concat(red, "-").concat(white, " ").concat(expectedLines[i]);
                            printedLines++; // Only extra actual lines exist
                        } else if (expectedLines.length < i + 1) {
                            // If the last diverging line is more than one line above and the
                            // current line is at least line three, add some of the former lines and
                            // also add dots to indicate skipped entries.
                            if (cur > 1 && i > 2) {
                                if (cur > 4) {
                                    res += "\n".concat(blue, "...").concat(white);
                                    skipped = true;
                                } else if (cur > 3) {
                                    res += "\n  ".concat(actualLines[i - 2]);
                                    printedLines++;
                                }
                                res += "\n  ".concat(actualLines[i - 1]);
                                printedLines++;
                            } // Mark the current line as the last diverging one.
                            lastPos = i; // Add the actual line to the result.
                            res += "\n".concat(green, "+").concat(white, " ").concat(actualLines[i]);
                            printedLines++; // Lines diverge
                        } else {
                            var expectedLine = expectedLines[i];
                            var actualLine = actualLines[i]; // If the lines diverge, specifically check for lines that only diverge by
                            // a trailing comma. In that case it is actually identical and we should
                            // mark it as such.
                            var divergingLines = actualLine !== expectedLine && (!endsWith(actualLine, ',') || actualLine.slice(0, -1) !== expectedLine); // If the expected line has a trailing comma but is otherwise identical,
                            // add a comma at the end of the actual line. Otherwise the output could
                            // look weird as in:
                            //
                            //   [
                            //     1         // No comma at the end!
                            // +   2
                            //   ]
                            //
                            if (divergingLines && endsWith(expectedLine, ',') && expectedLine.slice(0, -1) === actualLine) {
                                divergingLines = false;
                                actualLine += ',';
                            }
                            if (divergingLines) {
                                // If the last diverging line is more than one line above and the
                                // current line is at least line three, add some of the former lines and
                                // also add dots to indicate skipped entries.
                                if (cur > 1 && i > 2) {
                                    if (cur > 4) {
                                        res += "\n".concat(blue, "...").concat(white);
                                        skipped = true;
                                    } else if (cur > 3) {
                                        res += "\n  ".concat(actualLines[i - 2]);
                                        printedLines++;
                                    }
                                    res += "\n  ".concat(actualLines[i - 1]);
                                    printedLines++;
                                } // Mark the current line as the last diverging one.
                                lastPos = i; // Add the actual line to the result and cache the expected diverging
                                // line so consecutive diverging lines show up as +++--- and not +-+-+-.
                                res += "\n".concat(green, "+").concat(white, " ").concat(actualLine);
                                other += "\n".concat(red, "-").concat(white, " ").concat(expectedLine);
                                printedLines += 2; // Lines are identical
                            } else {
                                // Add all cached information to the result before adding other things
                                // and reset the cache.
                                res += other;
                                other = ''; // If the last diverging line is exactly one line above or if it is the
                                // very first line, add the line to the result.
                                if (cur === 1 || i === 0) {
                                    res += "\n  ".concat(actualLine);
                                    printedLines++;
                                }
                            }
                        } // Inspected object to big (Show ~20 rows max)
                        if (printedLines > 20 && i < maxLines - 2) {
                            return "".concat(msg).concat(skippedMsg, "\n").concat(res, "\n").concat(blue, "...").concat(white).concat(other, "\n") + "".concat(blue, "...").concat(white);
                        }
                    }
                    return "".concat(msg).concat(skipped ? skippedMsg : '', "\n").concat(res).concat(other).concat(end).concat(indicator);
                }
                var AssertionError = /*#__PURE__*/ function(_Error) {
                    _inherits(AssertionError, _Error);
                    function AssertionError(options) {
                        var _this;
                        _classCallCheck(this, AssertionError);
                        if (_typeof(options) !== 'object' || options === null) {
                            throw new ERR_INVALID_ARG_TYPE('options', 'Object', options);
                        }
                        var message = options.message, operator = options.operator, stackStartFn = options.stackStartFn;
                        var actual = options.actual, expected = options.expected;
                        var limit = Error.stackTraceLimit;
                        Error.stackTraceLimit = 0;
                        if (message != null) {
                            _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError).call(this, String(message)));
                        } else {
                            if (process.stderr && process.stderr.isTTY) {
                                // Reset on each call to make sure we handle dynamically set environment
                                // variables correct.
                                if (process.stderr && process.stderr.getColorDepth && process.stderr.getColorDepth() !== 1) {
                                    blue = "\x1B[34m";
                                    green = "\x1B[32m";
                                    white = "\x1B[39m";
                                    red = "\x1B[31m";
                                } else {
                                    blue = '';
                                    green = '';
                                    white = '';
                                    red = '';
                                }
                            } // Prevent the error stack from being visible by duplicating the error
                            // in a very close way to the original in case both sides are actually
                            // instances of Error.
                            if (_typeof(actual) === 'object' && actual !== null && _typeof(expected) === 'object' && expected !== null && 'stack' in actual && actual instanceof Error && 'stack' in expected && expected instanceof Error) {
                                actual = copyError(actual);
                                expected = copyError(expected);
                            }
                            if (operator === 'deepStrictEqual' || operator === 'strictEqual') {
                                _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError).call(this, createErrDiff(actual, expected, operator)));
                            } else if (operator === 'notDeepStrictEqual' || operator === 'notStrictEqual') {
                                // In case the objects are equal but the operator requires unequal, show
                                // the first object and say A equals B
                                var base = kReadableOperator[operator];
                                var res = inspectValue(actual).split('\n'); // In case "actual" is an object, it should not be reference equal.
                                if (operator === 'notStrictEqual' && _typeof(actual) === 'object' && actual !== null) {
                                    base = kReadableOperator.notStrictEqualObject;
                                } // Only remove lines in case it makes sense to collapse those.
                                // TODO: Accept env to always show the full error.
                                if (res.length > 30) {
                                    res[26] = "".concat(blue, "...").concat(white);
                                    while(res.length > 27){
                                        res.pop();
                                    }
                                } // Only print a single input.
                                if (res.length === 1) {
                                    _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError).call(this, "".concat(base, " ").concat(res[0])));
                                } else {
                                    _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError).call(this, "".concat(base, "\n\n").concat(res.join('\n'), "\n")));
                                }
                            } else {
                                var _res = inspectValue(actual);
                                var other = '';
                                var knownOperators = kReadableOperator[operator];
                                if (operator === 'notDeepEqual' || operator === 'notEqual') {
                                    _res = "".concat(kReadableOperator[operator], "\n\n").concat(_res);
                                    if (_res.length > 1024) {
                                        _res = "".concat(_res.slice(0, 1021), "...");
                                    }
                                } else {
                                    other = "".concat(inspectValue(expected));
                                    if (_res.length > 512) {
                                        _res = "".concat(_res.slice(0, 509), "...");
                                    }
                                    if (other.length > 512) {
                                        other = "".concat(other.slice(0, 509), "...");
                                    }
                                    if (operator === 'deepEqual' || operator === 'equal') {
                                        _res = "".concat(knownOperators, "\n\n").concat(_res, "\n\nshould equal\n\n");
                                    } else {
                                        other = " ".concat(operator, " ").concat(other);
                                    }
                                }
                                _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError).call(this, "".concat(_res).concat(other)));
                            }
                        }
                        Error.stackTraceLimit = limit;
                        _this.generatedMessage = !message;
                        Object.defineProperty(_assertThisInitialized(_this), 'name', {
                            value: 'AssertionError [ERR_ASSERTION]',
                            enumerable: false,
                            writable: true,
                            configurable: true
                        });
                        _this.code = 'ERR_ASSERTION';
                        _this.actual = actual;
                        _this.expected = expected;
                        _this.operator = operator;
                        if (Error.captureStackTrace) {
                            // eslint-disable-next-line no-restricted-syntax
                            Error.captureStackTrace(_assertThisInitialized(_this), stackStartFn);
                        } // Create error message including the error code in the name.
                        _this.stack; // Reset the name.
                        _this.name = 'AssertionError';
                        return _possibleConstructorReturn(_this);
                    }
                    _createClass(AssertionError, [
                        {
                            key: "toString",
                            value: function toString() {
                                return "".concat(this.name, " [").concat(this.code, "]: ").concat(this.message);
                            }
                        },
                        {
                            key: inspect.custom,
                            value: function value(recurseTimes, ctx) {
                                // This limits the `actual` and `expected` property default inspection to
                                // the minimum depth. Otherwise those values would be too verbose compared
                                // to the actual error message which contains a combined view of these two
                                // input values.
                                return inspect(this, _objectSpread({}, ctx, {
                                    customInspect: false,
                                    depth: 0
                                }));
                            }
                        }
                    ]);
                    return AssertionError;
                }(_wrapNativeSuper(Error));
                module1.exports = AssertionError;
            /***/ },
            /***/ 1342: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_65617__)=>{
                "use strict";
                // Currently in sync with Node.js lib/internal/errors.js
                // https://github.com/nodejs/node/commit/3b044962c48fe313905877a96b5d0894a5404f6f
                /* eslint node-core/documented-errors: "error" */ /* eslint node-core/alphabetize-errors: "error" */ /* eslint node-core/prefer-util-format-errors: "error" */ // The whole point behind this internal module is to allow Node.js to no
                // longer be forced to treat every error message change as a semver-major
                // change. The NodeError classes here all expose a `code` property whose
                // value statically and permanently identifies the error. While the error
                // message may change, the code should not.
                function _typeof(obj) {
                    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                        _typeof = function _typeof(obj) {
                            return typeof obj;
                        };
                    } else {
                        _typeof = function _typeof(obj) {
                            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
                        };
                    }
                    return _typeof(obj);
                }
                function _classCallCheck(instance, Constructor) {
                    if (!(instance instanceof Constructor)) {
                        throw new TypeError("Cannot call a class as a function");
                    }
                }
                function _possibleConstructorReturn(self, call) {
                    if (call && (_typeof(call) === "object" || typeof call === "function")) {
                        return call;
                    }
                    return _assertThisInitialized(self);
                }
                function _assertThisInitialized(self) {
                    if (self === void 0) {
                        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    }
                    return self;
                }
                function _getPrototypeOf(o) {
                    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
                        return o.__proto__ || Object.getPrototypeOf(o);
                    };
                    return _getPrototypeOf(o);
                }
                function _inherits(subClass, superClass) {
                    if (typeof superClass !== "function" && superClass !== null) {
                        throw new TypeError("Super expression must either be null or a function");
                    }
                    subClass.prototype = Object.create(superClass && superClass.prototype, {
                        constructor: {
                            value: subClass,
                            writable: true,
                            configurable: true
                        }
                    });
                    if (superClass) _setPrototypeOf(subClass, superClass);
                }
                function _setPrototypeOf(o, p) {
                    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
                        o.__proto__ = p;
                        return o;
                    };
                    return _setPrototypeOf(o, p);
                }
                var codes = {}; // Lazy loaded
                var assert;
                var util;
                function createErrorType(code, message, Base) {
                    if (!Base) {
                        Base = Error;
                    }
                    function getMessage(arg1, arg2, arg3) {
                        if (typeof message === 'string') {
                            return message;
                        } else {
                            return message(arg1, arg2, arg3);
                        }
                    }
                    var NodeError = /*#__PURE__*/ function(_Base) {
                        _inherits(NodeError, _Base);
                        function NodeError(arg1, arg2, arg3) {
                            var _this;
                            _classCallCheck(this, NodeError);
                            _this = _possibleConstructorReturn(this, _getPrototypeOf(NodeError).call(this, getMessage(arg1, arg2, arg3)));
                            _this.code = code;
                            return _this;
                        }
                        return NodeError;
                    }(Base);
                    codes[code] = NodeError;
                } // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js
                function oneOf(expected, thing) {
                    if (Array.isArray(expected)) {
                        var len = expected.length;
                        expected = expected.map(function(i) {
                            return String(i);
                        });
                        if (len > 2) {
                            return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(', '), ", or ") + expected[len - 1];
                        } else if (len === 2) {
                            return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
                        } else {
                            return "of ".concat(thing, " ").concat(expected[0]);
                        }
                    } else {
                        return "of ".concat(thing, " ").concat(String(expected));
                    }
                } // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith
                function startsWith(str, search, pos) {
                    return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
                } // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith
                function endsWith(str, search, this_len) {
                    if (this_len === undefined || this_len > str.length) {
                        this_len = str.length;
                    }
                    return str.substring(this_len - search.length, this_len) === search;
                } // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes
                function includes(str, search, start) {
                    if (typeof start !== 'number') {
                        start = 0;
                    }
                    if (start + search.length > str.length) {
                        return false;
                    } else {
                        return str.indexOf(search, start) !== -1;
                    }
                }
                createErrorType('ERR_AMBIGUOUS_ARGUMENT', 'The "%s" argument is ambiguous. %s', TypeError);
                createErrorType('ERR_INVALID_ARG_TYPE', function(name, expected, actual) {
                    if (assert === undefined) assert = __nested_webpack_require_65617__(6093);
                    assert(typeof name === 'string', "'name' must be a string"); // determiner: 'must be' or 'must not be'
                    var determiner;
                    if (typeof expected === 'string' && startsWith(expected, 'not ')) {
                        determiner = 'must not be';
                        expected = expected.replace(/^not /, '');
                    } else {
                        determiner = 'must be';
                    }
                    var msg;
                    if (endsWith(name, ' argument')) {
                        // For cases like 'first argument'
                        msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
                    } else {
                        var type = includes(name, '.') ? 'property' : 'argument';
                        msg = "The \"".concat(name, "\" ").concat(type, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
                    } // TODO(BridgeAR): Improve the output by showing `null` and similar.
                    msg += ". Received type ".concat(_typeof(actual));
                    return msg;
                }, TypeError);
                createErrorType('ERR_INVALID_ARG_VALUE', function(name, value) {
                    var reason = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'is invalid';
                    if (util === undefined) util = __nested_webpack_require_65617__(6827);
                    var inspected = util.inspect(value);
                    if (inspected.length > 128) {
                        inspected = "".concat(inspected.slice(0, 128), "...");
                    }
                    return "The argument '".concat(name, "' ").concat(reason, ". Received ").concat(inspected);
                }, TypeError, RangeError);
                createErrorType('ERR_INVALID_RETURN_VALUE', function(input, name, value) {
                    var type;
                    if (value && value.constructor && value.constructor.name) {
                        type = "instance of ".concat(value.constructor.name);
                    } else {
                        type = "type ".concat(_typeof(value));
                    }
                    return "Expected ".concat(input, " to be returned from the \"").concat(name, "\"") + " function but got ".concat(type, ".");
                }, TypeError);
                createErrorType('ERR_MISSING_ARGS', function() {
                    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                        args[_key] = arguments[_key];
                    }
                    if (assert === undefined) assert = __nested_webpack_require_65617__(6093);
                    assert(args.length > 0, 'At least one arg needs to be specified');
                    var msg = 'The ';
                    var len = args.length;
                    args = args.map(function(a) {
                        return "\"".concat(a, "\"");
                    });
                    switch(len){
                        case 1:
                            msg += "".concat(args[0], " argument");
                            break;
                        case 2:
                            msg += "".concat(args[0], " and ").concat(args[1], " arguments");
                            break;
                        default:
                            msg += args.slice(0, len - 1).join(', ');
                            msg += ", and ".concat(args[len - 1], " arguments");
                            break;
                    }
                    return "".concat(msg, " must be specified");
                }, TypeError);
                module1.exports.codes = codes;
            /***/ },
            /***/ 5656: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_76678__)=>{
                "use strict";
                // Currently in sync with Node.js lib/internal/util/comparisons.js
                // https://github.com/nodejs/node/commit/112cc7c27551254aa2b17098fb774867f05ed0d9
                function _slicedToArray(arr, i) {
                    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
                }
                function _nonIterableRest() {
                    throw new TypeError("Invalid attempt to destructure non-iterable instance");
                }
                function _iterableToArrayLimit(arr, i) {
                    var _arr = [];
                    var _n = true;
                    var _d = false;
                    var _e = undefined;
                    try {
                        for(var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true){
                            _arr.push(_s.value);
                            if (i && _arr.length === i) break;
                        }
                    } catch (err) {
                        _d = true;
                        _e = err;
                    } finally{
                        try {
                            if (!_n && _i["return"] != null) _i["return"]();
                        } finally{
                            if (_d) throw _e;
                        }
                    }
                    return _arr;
                }
                function _arrayWithHoles(arr) {
                    if (Array.isArray(arr)) return arr;
                }
                function _typeof(obj) {
                    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                        _typeof = function _typeof(obj) {
                            return typeof obj;
                        };
                    } else {
                        _typeof = function _typeof(obj) {
                            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
                        };
                    }
                    return _typeof(obj);
                }
                var regexFlagsSupported = /a/g.flags !== undefined;
                var arrayFromSet = function arrayFromSet(set) {
                    var array = [];
                    set.forEach(function(value) {
                        return array.push(value);
                    });
                    return array;
                };
                var arrayFromMap = function arrayFromMap(map) {
                    var array = [];
                    map.forEach(function(value, key) {
                        return array.push([
                            key,
                            value
                        ]);
                    });
                    return array;
                };
                var objectIs = Object.is ? Object.is : __nested_webpack_require_76678__(5968);
                var objectGetOwnPropertySymbols = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols : function() {
                    return [];
                };
                var numberIsNaN = Number.isNaN ? Number.isNaN : __nested_webpack_require_76678__(7838);
                function uncurryThis(f) {
                    return f.call.bind(f);
                }
                var hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);
                var propertyIsEnumerable = uncurryThis(Object.prototype.propertyIsEnumerable);
                var objectToString = uncurryThis(Object.prototype.toString);
                var _require$types = __nested_webpack_require_76678__(6827).types, isAnyArrayBuffer = _require$types.isAnyArrayBuffer, isArrayBufferView = _require$types.isArrayBufferView, isDate = _require$types.isDate, isMap = _require$types.isMap, isRegExp = _require$types.isRegExp, isSet = _require$types.isSet, isNativeError = _require$types.isNativeError, isBoxedPrimitive = _require$types.isBoxedPrimitive, isNumberObject = _require$types.isNumberObject, isStringObject = _require$types.isStringObject, isBooleanObject = _require$types.isBooleanObject, isBigIntObject = _require$types.isBigIntObject, isSymbolObject = _require$types.isSymbolObject, isFloat32Array = _require$types.isFloat32Array, isFloat64Array = _require$types.isFloat64Array;
                function isNonIndex(key) {
                    if (key.length === 0 || key.length > 10) return true;
                    for(var i = 0; i < key.length; i++){
                        var code = key.charCodeAt(i);
                        if (code < 48 || code > 57) return true;
                    } // The maximum size for an array is 2 ** 32 -1.
                    return key.length === 10 && key >= Math.pow(2, 32);
                }
                function getOwnNonIndexProperties(value) {
                    return Object.keys(value).filter(isNonIndex).concat(objectGetOwnPropertySymbols(value).filter(Object.prototype.propertyIsEnumerable.bind(value)));
                } // Taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js
                // original notice:
                /*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */ function compare(a, b) {
                    if (a === b) {
                        return 0;
                    }
                    var x = a.length;
                    var y = b.length;
                    for(var i = 0, len = Math.min(x, y); i < len; ++i){
                        if (a[i] !== b[i]) {
                            x = a[i];
                            y = b[i];
                            break;
                        }
                    }
                    if (x < y) {
                        return -1;
                    }
                    if (y < x) {
                        return 1;
                    }
                    return 0;
                }
                var ONLY_ENUMERABLE = undefined;
                var kStrict = true;
                var kLoose = false;
                var kNoIterator = 0;
                var kIsArray = 1;
                var kIsSet = 2;
                var kIsMap = 3; // Check if they have the same source and flags
                function areSimilarRegExps(a, b) {
                    return regexFlagsSupported ? a.source === b.source && a.flags === b.flags : RegExp.prototype.toString.call(a) === RegExp.prototype.toString.call(b);
                }
                function areSimilarFloatArrays(a, b) {
                    if (a.byteLength !== b.byteLength) {
                        return false;
                    }
                    for(var offset = 0; offset < a.byteLength; offset++){
                        if (a[offset] !== b[offset]) {
                            return false;
                        }
                    }
                    return true;
                }
                function areSimilarTypedArrays(a, b) {
                    if (a.byteLength !== b.byteLength) {
                        return false;
                    }
                    return compare(new Uint8Array(a.buffer, a.byteOffset, a.byteLength), new Uint8Array(b.buffer, b.byteOffset, b.byteLength)) === 0;
                }
                function areEqualArrayBuffers(buf1, buf2) {
                    return buf1.byteLength === buf2.byteLength && compare(new Uint8Array(buf1), new Uint8Array(buf2)) === 0;
                }
                function isEqualBoxedPrimitive(val1, val2) {
                    if (isNumberObject(val1)) {
                        return isNumberObject(val2) && objectIs(Number.prototype.valueOf.call(val1), Number.prototype.valueOf.call(val2));
                    }
                    if (isStringObject(val1)) {
                        return isStringObject(val2) && String.prototype.valueOf.call(val1) === String.prototype.valueOf.call(val2);
                    }
                    if (isBooleanObject(val1)) {
                        return isBooleanObject(val2) && Boolean.prototype.valueOf.call(val1) === Boolean.prototype.valueOf.call(val2);
                    }
                    if (isBigIntObject(val1)) {
                        return isBigIntObject(val2) && BigInt.prototype.valueOf.call(val1) === BigInt.prototype.valueOf.call(val2);
                    }
                    return isSymbolObject(val2) && Symbol.prototype.valueOf.call(val1) === Symbol.prototype.valueOf.call(val2);
                } // Notes: Type tags are historical [[Class]] properties that can be set by
                // FunctionTemplate::SetClassName() in C++ or Symbol.toStringTag in JS
                // and retrieved using Object.prototype.toString.call(obj) in JS
                // See https://tc39.github.io/ecma262/#sec-object.prototype.tostring
                // for a list of tags pre-defined in the spec.
                // There are some unspecified tags in the wild too (e.g. typed array tags).
                // Since tags can be altered, they only serve fast failures
                //
                // Typed arrays and buffers are checked by comparing the content in their
                // underlying ArrayBuffer. This optimization requires that it's
                // reasonable to interpret their underlying memory in the same way,
                // which is checked by comparing their type tags.
                // (e.g. a Uint8Array and a Uint16Array with the same memory content
                // could still be different because they will be interpreted differently).
                //
                // For strict comparison, objects should have
                // a) The same built-in type tags
                // b) The same prototypes.
                function innerDeepEqual(val1, val2, strict, memos) {
                    // All identical values are equivalent, as determined by ===.
                    if (val1 === val2) {
                        if (val1 !== 0) return true;
                        return strict ? objectIs(val1, val2) : true;
                    } // Check more closely if val1 and val2 are equal.
                    if (strict) {
                        if (_typeof(val1) !== 'object') {
                            return typeof val1 === 'number' && numberIsNaN(val1) && numberIsNaN(val2);
                        }
                        if (_typeof(val2) !== 'object' || val1 === null || val2 === null) {
                            return false;
                        }
                        if (Object.getPrototypeOf(val1) !== Object.getPrototypeOf(val2)) {
                            return false;
                        }
                    } else {
                        if (val1 === null || _typeof(val1) !== 'object') {
                            if (val2 === null || _typeof(val2) !== 'object') {
                                // eslint-disable-next-line eqeqeq
                                return val1 == val2;
                            }
                            return false;
                        }
                        if (val2 === null || _typeof(val2) !== 'object') {
                            return false;
                        }
                    }
                    var val1Tag = objectToString(val1);
                    var val2Tag = objectToString(val2);
                    if (val1Tag !== val2Tag) {
                        return false;
                    }
                    if (Array.isArray(val1)) {
                        // Check for sparse arrays and general fast path
                        if (val1.length !== val2.length) {
                            return false;
                        }
                        var keys1 = getOwnNonIndexProperties(val1, ONLY_ENUMERABLE);
                        var keys2 = getOwnNonIndexProperties(val2, ONLY_ENUMERABLE);
                        if (keys1.length !== keys2.length) {
                            return false;
                        }
                        return keyCheck(val1, val2, strict, memos, kIsArray, keys1);
                    } // [browserify] This triggers on certain types in IE (Map/Set) so we don't
                    // wan't to early return out of the rest of the checks. However we can check
                    // if the second value is one of these values and the first isn't.
                    if (val1Tag === '[object Object]') {
                        // return keyCheck(val1, val2, strict, memos, kNoIterator);
                        if (!isMap(val1) && isMap(val2) || !isSet(val1) && isSet(val2)) {
                            return false;
                        }
                    }
                    if (isDate(val1)) {
                        if (!isDate(val2) || Date.prototype.getTime.call(val1) !== Date.prototype.getTime.call(val2)) {
                            return false;
                        }
                    } else if (isRegExp(val1)) {
                        if (!isRegExp(val2) || !areSimilarRegExps(val1, val2)) {
                            return false;
                        }
                    } else if (isNativeError(val1) || val1 instanceof Error) {
                        // Do not compare the stack as it might differ even though the error itself
                        // is otherwise identical.
                        if (val1.message !== val2.message || val1.name !== val2.name) {
                            return false;
                        }
                    } else if (isArrayBufferView(val1)) {
                        if (!strict && (isFloat32Array(val1) || isFloat64Array(val1))) {
                            if (!areSimilarFloatArrays(val1, val2)) {
                                return false;
                            }
                        } else if (!areSimilarTypedArrays(val1, val2)) {
                            return false;
                        } // Buffer.compare returns true, so val1.length === val2.length. If they both
                        // only contain numeric keys, we don't need to exam further than checking
                        // the symbols.
                        var _keys = getOwnNonIndexProperties(val1, ONLY_ENUMERABLE);
                        var _keys2 = getOwnNonIndexProperties(val2, ONLY_ENUMERABLE);
                        if (_keys.length !== _keys2.length) {
                            return false;
                        }
                        return keyCheck(val1, val2, strict, memos, kNoIterator, _keys);
                    } else if (isSet(val1)) {
                        if (!isSet(val2) || val1.size !== val2.size) {
                            return false;
                        }
                        return keyCheck(val1, val2, strict, memos, kIsSet);
                    } else if (isMap(val1)) {
                        if (!isMap(val2) || val1.size !== val2.size) {
                            return false;
                        }
                        return keyCheck(val1, val2, strict, memos, kIsMap);
                    } else if (isAnyArrayBuffer(val1)) {
                        if (!areEqualArrayBuffers(val1, val2)) {
                            return false;
                        }
                    } else if (isBoxedPrimitive(val1) && !isEqualBoxedPrimitive(val1, val2)) {
                        return false;
                    }
                    return keyCheck(val1, val2, strict, memos, kNoIterator);
                }
                function getEnumerables(val, keys) {
                    return keys.filter(function(k) {
                        return propertyIsEnumerable(val, k);
                    });
                }
                function keyCheck(val1, val2, strict, memos, iterationType, aKeys) {
                    // For all remaining Object pairs, including Array, objects and Maps,
                    // equivalence is determined by having:
                    // a) The same number of owned enumerable properties
                    // b) The same set of keys/indexes (although not necessarily the same order)
                    // c) Equivalent values for every corresponding key/index
                    // d) For Sets and Maps, equal contents
                    // Note: this accounts for both named and indexed properties on Arrays.
                    if (arguments.length === 5) {
                        aKeys = Object.keys(val1);
                        var bKeys = Object.keys(val2); // The pair must have the same number of owned properties.
                        if (aKeys.length !== bKeys.length) {
                            return false;
                        }
                    } // Cheap key test
                    var i = 0;
                    for(; i < aKeys.length; i++){
                        if (!hasOwnProperty(val2, aKeys[i])) {
                            return false;
                        }
                    }
                    if (strict && arguments.length === 5) {
                        var symbolKeysA = objectGetOwnPropertySymbols(val1);
                        if (symbolKeysA.length !== 0) {
                            var count = 0;
                            for(i = 0; i < symbolKeysA.length; i++){
                                var key = symbolKeysA[i];
                                if (propertyIsEnumerable(val1, key)) {
                                    if (!propertyIsEnumerable(val2, key)) {
                                        return false;
                                    }
                                    aKeys.push(key);
                                    count++;
                                } else if (propertyIsEnumerable(val2, key)) {
                                    return false;
                                }
                            }
                            var symbolKeysB = objectGetOwnPropertySymbols(val2);
                            if (symbolKeysA.length !== symbolKeysB.length && getEnumerables(val2, symbolKeysB).length !== count) {
                                return false;
                            }
                        } else {
                            var _symbolKeysB = objectGetOwnPropertySymbols(val2);
                            if (_symbolKeysB.length !== 0 && getEnumerables(val2, _symbolKeysB).length !== 0) {
                                return false;
                            }
                        }
                    }
                    if (aKeys.length === 0 && (iterationType === kNoIterator || iterationType === kIsArray && val1.length === 0 || val1.size === 0)) {
                        return true;
                    } // Use memos to handle cycles.
                    if (memos === undefined) {
                        memos = {
                            val1: new Map(),
                            val2: new Map(),
                            position: 0
                        };
                    } else {
                        // We prevent up to two map.has(x) calls by directly retrieving the value
                        // and checking for undefined. The map can only contain numbers, so it is
                        // safe to check for undefined only.
                        var val2MemoA = memos.val1.get(val1);
                        if (val2MemoA !== undefined) {
                            var val2MemoB = memos.val2.get(val2);
                            if (val2MemoB !== undefined) {
                                return val2MemoA === val2MemoB;
                            }
                        }
                        memos.position++;
                    }
                    memos.val1.set(val1, memos.position);
                    memos.val2.set(val2, memos.position);
                    var areEq = objEquiv(val1, val2, strict, aKeys, memos, iterationType);
                    memos.val1.delete(val1);
                    memos.val2.delete(val2);
                    return areEq;
                }
                function setHasEqualElement(set, val1, strict, memo) {
                    // Go looking.
                    var setValues = arrayFromSet(set);
                    for(var i = 0; i < setValues.length; i++){
                        var val2 = setValues[i];
                        if (innerDeepEqual(val1, val2, strict, memo)) {
                            // Remove the matching element to make sure we do not check that again.
                            set.delete(val2);
                            return true;
                        }
                    }
                    return false;
                } // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness#Loose_equality_using
                // Sadly it is not possible to detect corresponding values properly in case the
                // type is a string, number, bigint or boolean. The reason is that those values
                // can match lots of different string values (e.g., 1n == '+00001').
                function findLooseMatchingPrimitives(prim) {
                    switch(_typeof(prim)){
                        case 'undefined':
                            return null;
                        case 'object':
                            // Only pass in null as object!
                            return undefined;
                        case 'symbol':
                            return false;
                        case 'string':
                            prim = +prim;
                        // Loose equal entries exist only if the string is possible to convert to
                        // a regular number and not NaN.
                        // Fall through
                        case 'number':
                            if (numberIsNaN(prim)) {
                                return false;
                            }
                    }
                    return true;
                }
                function setMightHaveLoosePrim(a, b, prim) {
                    var altValue = findLooseMatchingPrimitives(prim);
                    if (altValue != null) return altValue;
                    return b.has(altValue) && !a.has(altValue);
                }
                function mapMightHaveLoosePrim(a, b, prim, item, memo) {
                    var altValue = findLooseMatchingPrimitives(prim);
                    if (altValue != null) {
                        return altValue;
                    }
                    var curB = b.get(altValue);
                    if (curB === undefined && !b.has(altValue) || !innerDeepEqual(item, curB, false, memo)) {
                        return false;
                    }
                    return !a.has(altValue) && innerDeepEqual(item, curB, false, memo);
                }
                function setEquiv(a, b, strict, memo) {
                    // This is a lazily initiated Set of entries which have to be compared
                    // pairwise.
                    var set = null;
                    var aValues = arrayFromSet(a);
                    for(var i = 0; i < aValues.length; i++){
                        var val = aValues[i]; // Note: Checking for the objects first improves the performance for object
                        // heavy sets but it is a minor slow down for primitives. As they are fast
                        // to check this improves the worst case scenario instead.
                        if (_typeof(val) === 'object' && val !== null) {
                            if (set === null) {
                                set = new Set();
                            } // If the specified value doesn't exist in the second set its an not null
                            // object (or non strict only: a not matching primitive) we'll need to go
                            // hunting for something thats deep-(strict-)equal to it. To make this
                            // O(n log n) complexity we have to copy these values in a new set first.
                            set.add(val);
                        } else if (!b.has(val)) {
                            if (strict) return false; // Fast path to detect missing string, symbol, undefined and null values.
                            if (!setMightHaveLoosePrim(a, b, val)) {
                                return false;
                            }
                            if (set === null) {
                                set = new Set();
                            }
                            set.add(val);
                        }
                    }
                    if (set !== null) {
                        var bValues = arrayFromSet(b);
                        for(var _i = 0; _i < bValues.length; _i++){
                            var _val = bValues[_i]; // We have to check if a primitive value is already
                            // matching and only if it's not, go hunting for it.
                            if (_typeof(_val) === 'object' && _val !== null) {
                                if (!setHasEqualElement(set, _val, strict, memo)) return false;
                            } else if (!strict && !a.has(_val) && !setHasEqualElement(set, _val, strict, memo)) {
                                return false;
                            }
                        }
                        return set.size === 0;
                    }
                    return true;
                }
                function mapHasEqualEntry(set, map, key1, item1, strict, memo) {
                    // To be able to handle cases like:
                    //   Map([[{}, 'a'], [{}, 'b']]) vs Map([[{}, 'b'], [{}, 'a']])
                    // ... we need to consider *all* matching keys, not just the first we find.
                    var setValues = arrayFromSet(set);
                    for(var i = 0; i < setValues.length; i++){
                        var key2 = setValues[i];
                        if (innerDeepEqual(key1, key2, strict, memo) && innerDeepEqual(item1, map.get(key2), strict, memo)) {
                            set.delete(key2);
                            return true;
                        }
                    }
                    return false;
                }
                function mapEquiv(a, b, strict, memo) {
                    var set = null;
                    var aEntries = arrayFromMap(a);
                    for(var i = 0; i < aEntries.length; i++){
                        var _aEntries$i = _slicedToArray(aEntries[i], 2), key = _aEntries$i[0], item1 = _aEntries$i[1];
                        if (_typeof(key) === 'object' && key !== null) {
                            if (set === null) {
                                set = new Set();
                            }
                            set.add(key);
                        } else {
                            // By directly retrieving the value we prevent another b.has(key) check in
                            // almost all possible cases.
                            var item2 = b.get(key);
                            if (item2 === undefined && !b.has(key) || !innerDeepEqual(item1, item2, strict, memo)) {
                                if (strict) return false; // Fast path to detect missing string, symbol, undefined and null
                                // keys.
                                if (!mapMightHaveLoosePrim(a, b, key, item1, memo)) return false;
                                if (set === null) {
                                    set = new Set();
                                }
                                set.add(key);
                            }
                        }
                    }
                    if (set !== null) {
                        var bEntries = arrayFromMap(b);
                        for(var _i2 = 0; _i2 < bEntries.length; _i2++){
                            var _bEntries$_i = _slicedToArray(bEntries[_i2], 2), key = _bEntries$_i[0], item = _bEntries$_i[1];
                            if (_typeof(key) === 'object' && key !== null) {
                                if (!mapHasEqualEntry(set, a, key, item, strict, memo)) return false;
                            } else if (!strict && (!a.has(key) || !innerDeepEqual(a.get(key), item, false, memo)) && !mapHasEqualEntry(set, a, key, item, false, memo)) {
                                return false;
                            }
                        }
                        return set.size === 0;
                    }
                    return true;
                }
                function objEquiv(a, b, strict, keys, memos, iterationType) {
                    // Sets and maps don't have their entries accessible via normal object
                    // properties.
                    var i = 0;
                    if (iterationType === kIsSet) {
                        if (!setEquiv(a, b, strict, memos)) {
                            return false;
                        }
                    } else if (iterationType === kIsMap) {
                        if (!mapEquiv(a, b, strict, memos)) {
                            return false;
                        }
                    } else if (iterationType === kIsArray) {
                        for(; i < a.length; i++){
                            if (hasOwnProperty(a, i)) {
                                if (!hasOwnProperty(b, i) || !innerDeepEqual(a[i], b[i], strict, memos)) {
                                    return false;
                                }
                            } else if (hasOwnProperty(b, i)) {
                                return false;
                            } else {
                                // Array is sparse.
                                var keysA = Object.keys(a);
                                for(; i < keysA.length; i++){
                                    var key = keysA[i];
                                    if (!hasOwnProperty(b, key) || !innerDeepEqual(a[key], b[key], strict, memos)) {
                                        return false;
                                    }
                                }
                                if (keysA.length !== Object.keys(b).length) {
                                    return false;
                                }
                                return true;
                            }
                        }
                    } // The pair must have equivalent values for every corresponding key.
                    // Possibly expensive deep test:
                    for(i = 0; i < keys.length; i++){
                        var _key = keys[i];
                        if (!innerDeepEqual(a[_key], b[_key], strict, memos)) {
                            return false;
                        }
                    }
                    return true;
                }
                function isDeepEqual(val1, val2) {
                    return innerDeepEqual(val1, val2, kLoose);
                }
                function isDeepStrictEqual(val1, val2) {
                    return innerDeepEqual(val1, val2, kStrict);
                }
                module1.exports = {
                    isDeepEqual: isDeepEqual,
                    isDeepStrictEqual: isDeepStrictEqual
                };
            /***/ },
            /***/ 9818: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_108232__)=>{
                "use strict";
                var GetIntrinsic = __nested_webpack_require_108232__(528);
                var callBind = __nested_webpack_require_108232__(8498);
                var $indexOf = callBind(GetIntrinsic('String.prototype.indexOf'));
                module1.exports = function callBoundIntrinsic(name, allowMissing) {
                    var intrinsic = GetIntrinsic(name, !!allowMissing);
                    if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {
                        return callBind(intrinsic);
                    }
                    return intrinsic;
                };
            /***/ },
            /***/ 8498: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_108959__)=>{
                "use strict";
                var bind = __nested_webpack_require_108959__(9138);
                var GetIntrinsic = __nested_webpack_require_108959__(528);
                var setFunctionLength = __nested_webpack_require_108959__(6108);
                var $TypeError = __nested_webpack_require_108959__(3468);
                var $apply = GetIntrinsic('%Function.prototype.apply%');
                var $call = GetIntrinsic('%Function.prototype.call%');
                var $reflectApply = GetIntrinsic('%Reflect.apply%', true) || bind.call($call, $apply);
                var $defineProperty = __nested_webpack_require_108959__(4940);
                var $max = GetIntrinsic('%Math.max%');
                module1.exports = function callBind(originalFunction) {
                    if (typeof originalFunction !== 'function') {
                        throw new $TypeError('a function is required');
                    }
                    var func = $reflectApply(bind, $call, arguments);
                    return setFunctionLength(func, 1 + $max(0, originalFunction.length - (arguments.length - 1)), true);
                };
                var applyBind = function applyBind() {
                    return $reflectApply(bind, $apply, arguments);
                };
                if ($defineProperty) {
                    $defineProperty(module1.exports, 'apply', {
                        value: applyBind
                    });
                } else {
                    module1.exports.apply = applyBind;
                }
            /***/ },
            /***/ 4364: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_110558__)=>{
                /*global window, global*/ var util = __nested_webpack_require_110558__(6827);
                var assert = __nested_webpack_require_110558__(6093);
                function now() {
                    return new Date().getTime();
                }
                var slice = Array.prototype.slice;
                var console;
                var times = {};
                if (typeof __nested_webpack_require_110558__.g !== "undefined" && __nested_webpack_require_110558__.g.console) {
                    console = __nested_webpack_require_110558__.g.console;
                } else if (typeof window !== "undefined" && window.console) {
                    console = window.console;
                } else {
                    console = {};
                }
                var functions = [
                    [
                        log,
                        "log"
                    ],
                    [
                        info,
                        "info"
                    ],
                    [
                        warn,
                        "warn"
                    ],
                    [
                        error,
                        "error"
                    ],
                    [
                        time,
                        "time"
                    ],
                    [
                        timeEnd,
                        "timeEnd"
                    ],
                    [
                        trace,
                        "trace"
                    ],
                    [
                        dir,
                        "dir"
                    ],
                    [
                        consoleAssert,
                        "assert"
                    ]
                ];
                for(var i = 0; i < functions.length; i++){
                    var tuple = functions[i];
                    var f = tuple[0];
                    var name = tuple[1];
                    if (!console[name]) {
                        console[name] = f;
                    }
                }
                module1.exports = console;
                function log() {}
                function info() {
                    console.log.apply(console, arguments);
                }
                function warn() {
                    console.log.apply(console, arguments);
                }
                function error() {
                    console.warn.apply(console, arguments);
                }
                function time(label) {
                    times[label] = now();
                }
                function timeEnd(label) {
                    var time = times[label];
                    if (!time) {
                        throw new Error("No such label: " + label);
                    }
                    delete times[label];
                    var duration = now() - time;
                    console.log(label + ": " + duration + "ms");
                }
                function trace() {
                    var err = new Error();
                    err.name = "Trace";
                    err.message = util.format.apply(null, arguments);
                    console.error(err.stack);
                }
                function dir(object) {
                    console.log(util.inspect(object) + "\n");
                }
                function consoleAssert(expression) {
                    if (!expression) {
                        var arr = slice.call(arguments, 1);
                        assert.ok(false, util.format.apply(null, arr));
                    }
                }
            /***/ },
            /***/ 686: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_114240__)=>{
                "use strict";
                var $defineProperty = __nested_webpack_require_114240__(4940);
                var $SyntaxError = __nested_webpack_require_114240__(5731);
                var $TypeError = __nested_webpack_require_114240__(3468);
                var gopd = __nested_webpack_require_114240__(9336);
                /** @type {import('.')} */ module1.exports = function defineDataProperty(obj, property, value) {
                    if (!obj || typeof obj !== 'object' && typeof obj !== 'function') {
                        throw new $TypeError('`obj` must be an object or a function`');
                    }
                    if (typeof property !== 'string' && typeof property !== 'symbol') {
                        throw new $TypeError('`property` must be a string or a symbol`');
                    }
                    if (arguments.length > 3 && typeof arguments[3] !== 'boolean' && arguments[3] !== null) {
                        throw new $TypeError('`nonEnumerable`, if provided, must be a boolean or null');
                    }
                    if (arguments.length > 4 && typeof arguments[4] !== 'boolean' && arguments[4] !== null) {
                        throw new $TypeError('`nonWritable`, if provided, must be a boolean or null');
                    }
                    if (arguments.length > 5 && typeof arguments[5] !== 'boolean' && arguments[5] !== null) {
                        throw new $TypeError('`nonConfigurable`, if provided, must be a boolean or null');
                    }
                    if (arguments.length > 6 && typeof arguments[6] !== 'boolean') {
                        throw new $TypeError('`loose`, if provided, must be a boolean');
                    }
                    var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
                    var nonWritable = arguments.length > 4 ? arguments[4] : null;
                    var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
                    var loose = arguments.length > 6 ? arguments[6] : false;
                    /* @type {false | TypedPropertyDescriptor<unknown>} */ var desc = !!gopd && gopd(obj, property);
                    if ($defineProperty) {
                        $defineProperty(obj, property, {
                            configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
                            enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
                            value: value,
                            writable: nonWritable === null && desc ? desc.writable : !nonWritable
                        });
                    } else if (loose || !nonEnumerable && !nonWritable && !nonConfigurable) {
                        // must fall back to [[Set]], and was not explicitly asked to make non-enumerable, non-writable, or non-configurable
                        obj[property] = value; // eslint-disable-line no-param-reassign
                    } else {
                        throw new $SyntaxError('This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.');
                    }
                };
            /***/ },
            /***/ 1857: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_117528__)=>{
                "use strict";
                var keys = __nested_webpack_require_117528__(9228);
                var hasSymbols = typeof Symbol === 'function' && typeof Symbol('foo') === 'symbol';
                var toStr = Object.prototype.toString;
                var concat = Array.prototype.concat;
                var origDefineProperty = Object.defineProperty;
                var isFunction = function(fn) {
                    return typeof fn === 'function' && toStr.call(fn) === '[object Function]';
                };
                var hasPropertyDescriptors = __nested_webpack_require_117528__(7239)();
                var supportsDescriptors = origDefineProperty && hasPropertyDescriptors;
                var defineProperty = function(object, name, value, predicate) {
                    if (name in object) {
                        if (predicate === true) {
                            if (object[name] === value) {
                                return;
                            }
                        } else if (!isFunction(predicate) || !predicate()) {
                            return;
                        }
                    }
                    if (supportsDescriptors) {
                        origDefineProperty(object, name, {
                            configurable: true,
                            enumerable: false,
                            value: value,
                            writable: true
                        });
                    } else {
                        object[name] = value; // eslint-disable-line no-param-reassign
                    }
                };
                var defineProperties = function(object, map) {
                    var predicates = arguments.length > 2 ? arguments[2] : {};
                    var props = keys(map);
                    if (hasSymbols) {
                        props = concat.call(props, Object.getOwnPropertySymbols(map));
                    }
                    for(var i = 0; i < props.length; i += 1){
                        defineProperty(object, props[i], map[props[i]], predicates[props[i]]);
                    }
                };
                defineProperties.supportsDescriptors = !!supportsDescriptors;
                module1.exports = defineProperties;
            /***/ },
            /***/ 4940: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_119911__)=>{
                "use strict";
                var GetIntrinsic = __nested_webpack_require_119911__(528);
                /** @type {import('.')} */ var $defineProperty = GetIntrinsic('%Object.defineProperty%', true) || false;
                if ($defineProperty) {
                    try {
                        $defineProperty({}, 'a', {
                            value: 1
                        });
                    } catch (e) {
                        // IE 8 has a broken defineProperty
                        $defineProperty = false;
                    }
                }
                module1.exports = $defineProperty;
            /***/ },
            /***/ 6729: /***/ (module1)=>{
                "use strict";
                /** @type {import('./eval')} */ module1.exports = EvalError;
            /***/ },
            /***/ 9838: /***/ (module1)=>{
                "use strict";
                /** @type {import('.')} */ module1.exports = Error;
            /***/ },
            /***/ 1155: /***/ (module1)=>{
                "use strict";
                /** @type {import('./range')} */ module1.exports = RangeError;
            /***/ },
            /***/ 4943: /***/ (module1)=>{
                "use strict";
                /** @type {import('./ref')} */ module1.exports = ReferenceError;
            /***/ },
            /***/ 5731: /***/ (module1)=>{
                "use strict";
                /** @type {import('./syntax')} */ module1.exports = SyntaxError;
            /***/ },
            /***/ 3468: /***/ (module1)=>{
                "use strict";
                /** @type {import('./type')} */ module1.exports = TypeError;
            /***/ },
            /***/ 2140: /***/ (module1)=>{
                "use strict";
                /** @type {import('./uri')} */ module1.exports = URIError;
            /***/ },
            /***/ 3046: /***/ (module1)=>{
                "use strict";
                /**
 * Code refactored from Mozilla Developer Network:
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
 */ function assign(target, firstSource) {
                    if (target === undefined || target === null) {
                        throw new TypeError('Cannot convert first argument to object');
                    }
                    var to = Object(target);
                    for(var i = 1; i < arguments.length; i++){
                        var nextSource = arguments[i];
                        if (nextSource === undefined || nextSource === null) {
                            continue;
                        }
                        var keysArray = Object.keys(Object(nextSource));
                        for(var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex++){
                            var nextKey = keysArray[nextIndex];
                            var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
                            if (desc !== undefined && desc.enumerable) {
                                to[nextKey] = nextSource[nextKey];
                            }
                        }
                    }
                    return to;
                }
                function polyfill() {
                    if (!Object.assign) {
                        Object.defineProperty(Object, 'assign', {
                            enumerable: false,
                            configurable: true,
                            writable: true,
                            value: assign
                        });
                    }
                }
                module1.exports = {
                    assign: assign,
                    polyfill: polyfill
                };
            /***/ },
            /***/ 705: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_123757__)=>{
                "use strict";
                var isCallable = __nested_webpack_require_123757__(9617);
                var toStr = Object.prototype.toString;
                var hasOwnProperty = Object.prototype.hasOwnProperty;
                var forEachArray = function forEachArray(array, iterator, receiver) {
                    for(var i = 0, len = array.length; i < len; i++){
                        if (hasOwnProperty.call(array, i)) {
                            if (receiver == null) {
                                iterator(array[i], i, array);
                            } else {
                                iterator.call(receiver, array[i], i, array);
                            }
                        }
                    }
                };
                var forEachString = function forEachString(string, iterator, receiver) {
                    for(var i = 0, len = string.length; i < len; i++){
                        // no such thing as a sparse string.
                        if (receiver == null) {
                            iterator(string.charAt(i), i, string);
                        } else {
                            iterator.call(receiver, string.charAt(i), i, string);
                        }
                    }
                };
                var forEachObject = function forEachObject(object, iterator, receiver) {
                    for(var k in object){
                        if (hasOwnProperty.call(object, k)) {
                            if (receiver == null) {
                                iterator(object[k], k, object);
                            } else {
                                iterator.call(receiver, object[k], k, object);
                            }
                        }
                    }
                };
                var forEach = function forEach(list, iterator, thisArg) {
                    if (!isCallable(iterator)) {
                        throw new TypeError('iterator must be a function');
                    }
                    var receiver;
                    if (arguments.length >= 3) {
                        receiver = thisArg;
                    }
                    if (toStr.call(list) === '[object Array]') {
                        forEachArray(list, iterator, receiver);
                    } else if (typeof list === 'string') {
                        forEachString(list, iterator, receiver);
                    } else {
                        forEachObject(list, iterator, receiver);
                    }
                };
                module1.exports = forEach;
            /***/ },
            /***/ 8794: /***/ (module1)=>{
                "use strict";
                /* eslint no-invalid-this: 1 */ var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
                var toStr = Object.prototype.toString;
                var max = Math.max;
                var funcType = '[object Function]';
                var concatty = function concatty(a, b) {
                    var arr = [];
                    for(var i = 0; i < a.length; i += 1){
                        arr[i] = a[i];
                    }
                    for(var j = 0; j < b.length; j += 1){
                        arr[j + a.length] = b[j];
                    }
                    return arr;
                };
                var slicy = function slicy(arrLike, offset) {
                    var arr = [];
                    for(var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1){
                        arr[j] = arrLike[i];
                    }
                    return arr;
                };
                var joiny = function(arr, joiner) {
                    var str = '';
                    for(var i = 0; i < arr.length; i += 1){
                        str += arr[i];
                        if (i + 1 < arr.length) {
                            str += joiner;
                        }
                    }
                    return str;
                };
                module1.exports = function bind(that) {
                    var target = this;
                    if (typeof target !== 'function' || toStr.apply(target) !== funcType) {
                        throw new TypeError(ERROR_MESSAGE + target);
                    }
                    var args = slicy(arguments, 1);
                    var bound;
                    var binder = function() {
                        if (this instanceof bound) {
                            var result = target.apply(this, concatty(args, arguments));
                            if (Object(result) === result) {
                                return result;
                            }
                            return this;
                        }
                        return target.apply(that, concatty(args, arguments));
                    };
                    var boundLength = max(0, target.length - args.length);
                    var boundArgs = [];
                    for(var i = 0; i < boundLength; i++){
                        boundArgs[i] = '$' + i;
                    }
                    bound = Function('binder', 'return function (' + joiny(boundArgs, ',') + '){ return binder.apply(this,arguments); }')(binder);
                    if (target.prototype) {
                        var Empty = function Empty() {};
                        Empty.prototype = target.prototype;
                        bound.prototype = new Empty();
                        Empty.prototype = null;
                    }
                    return bound;
                };
            /***/ },
            /***/ 9138: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_129476__)=>{
                "use strict";
                var implementation = __nested_webpack_require_129476__(8794);
                module1.exports = Function.prototype.bind || implementation;
            /***/ },
            /***/ 528: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_129757__)=>{
                "use strict";
                var undefined1;
                var $Error = __nested_webpack_require_129757__(9838);
                var $EvalError = __nested_webpack_require_129757__(6729);
                var $RangeError = __nested_webpack_require_129757__(1155);
                var $ReferenceError = __nested_webpack_require_129757__(4943);
                var $SyntaxError = __nested_webpack_require_129757__(5731);
                var $TypeError = __nested_webpack_require_129757__(3468);
                var $URIError = __nested_webpack_require_129757__(2140);
                var $Function = Function;
                // eslint-disable-next-line consistent-return
                var getEvalledConstructor = function(expressionSyntax) {
                    try {
                        return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
                    } catch (e) {}
                };
                var $gOPD = Object.getOwnPropertyDescriptor;
                if ($gOPD) {
                    try {
                        $gOPD({}, '');
                    } catch (e) {
                        $gOPD = null; // this is IE 8, which has a broken gOPD
                    }
                }
                var throwTypeError = function() {
                    throw new $TypeError();
                };
                var ThrowTypeError = $gOPD ? function() {
                    try {
                        // eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
                        arguments.callee; // IE 8 does not throw here
                        return throwTypeError;
                    } catch (calleeThrows) {
                        try {
                            // IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
                            return $gOPD(arguments, 'callee').get;
                        } catch (gOPDthrows) {
                            return throwTypeError;
                        }
                    }
                }() : throwTypeError;
                var hasSymbols = __nested_webpack_require_129757__(3558)();
                var hasProto = __nested_webpack_require_129757__(6869)();
                var getProto = Object.getPrototypeOf || (hasProto ? function(x) {
                    return x.__proto__;
                } // eslint-disable-line no-proto
                 : null);
                var needsEval = {};
                var TypedArray = typeof Uint8Array === 'undefined' || !getProto ? undefined1 : getProto(Uint8Array);
                var INTRINSICS = {
                    __proto__: null,
                    '%AggregateError%': typeof AggregateError === 'undefined' ? undefined1 : AggregateError,
                    '%Array%': Array,
                    '%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined1 : ArrayBuffer,
                    '%ArrayIteratorPrototype%': hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined1,
                    '%AsyncFromSyncIteratorPrototype%': undefined1,
                    '%AsyncFunction%': needsEval,
                    '%AsyncGenerator%': needsEval,
                    '%AsyncGeneratorFunction%': needsEval,
                    '%AsyncIteratorPrototype%': needsEval,
                    '%Atomics%': typeof Atomics === 'undefined' ? undefined1 : Atomics,
                    '%BigInt%': typeof BigInt === 'undefined' ? undefined1 : BigInt,
                    '%BigInt64Array%': typeof BigInt64Array === 'undefined' ? undefined1 : BigInt64Array,
                    '%BigUint64Array%': typeof BigUint64Array === 'undefined' ? undefined1 : BigUint64Array,
                    '%Boolean%': Boolean,
                    '%DataView%': typeof DataView === 'undefined' ? undefined1 : DataView,
                    '%Date%': Date,
                    '%decodeURI%': decodeURI,
                    '%decodeURIComponent%': decodeURIComponent,
                    '%encodeURI%': encodeURI,
                    '%encodeURIComponent%': encodeURIComponent,
                    '%Error%': $Error,
                    '%eval%': eval,
                    '%EvalError%': $EvalError,
                    '%Float32Array%': typeof Float32Array === 'undefined' ? undefined1 : Float32Array,
                    '%Float64Array%': typeof Float64Array === 'undefined' ? undefined1 : Float64Array,
                    '%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined1 : FinalizationRegistry,
                    '%Function%': $Function,
                    '%GeneratorFunction%': needsEval,
                    '%Int8Array%': typeof Int8Array === 'undefined' ? undefined1 : Int8Array,
                    '%Int16Array%': typeof Int16Array === 'undefined' ? undefined1 : Int16Array,
                    '%Int32Array%': typeof Int32Array === 'undefined' ? undefined1 : Int32Array,
                    '%isFinite%': isFinite,
                    '%isNaN%': isNaN,
                    '%IteratorPrototype%': hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined1,
                    '%JSON%': typeof JSON === 'object' ? JSON : undefined1,
                    '%Map%': typeof Map === 'undefined' ? undefined1 : Map,
                    '%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols || !getProto ? undefined1 : getProto(new Map()[Symbol.iterator]()),
                    '%Math%': Math,
                    '%Number%': Number,
                    '%Object%': Object,
                    '%parseFloat%': parseFloat,
                    '%parseInt%': parseInt,
                    '%Promise%': typeof Promise === 'undefined' ? undefined1 : Promise,
                    '%Proxy%': typeof Proxy === 'undefined' ? undefined1 : Proxy,
                    '%RangeError%': $RangeError,
                    '%ReferenceError%': $ReferenceError,
                    '%Reflect%': typeof Reflect === 'undefined' ? undefined1 : Reflect,
                    '%RegExp%': RegExp,
                    '%Set%': typeof Set === 'undefined' ? undefined1 : Set,
                    '%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols || !getProto ? undefined1 : getProto(new Set()[Symbol.iterator]()),
                    '%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined1 : SharedArrayBuffer,
                    '%String%': String,
                    '%StringIteratorPrototype%': hasSymbols && getProto ? getProto(''[Symbol.iterator]()) : undefined1,
                    '%Symbol%': hasSymbols ? Symbol : undefined1,
                    '%SyntaxError%': $SyntaxError,
                    '%ThrowTypeError%': ThrowTypeError,
                    '%TypedArray%': TypedArray,
                    '%TypeError%': $TypeError,
                    '%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined1 : Uint8Array,
                    '%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined1 : Uint8ClampedArray,
                    '%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined1 : Uint16Array,
                    '%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined1 : Uint32Array,
                    '%URIError%': $URIError,
                    '%WeakMap%': typeof WeakMap === 'undefined' ? undefined1 : WeakMap,
                    '%WeakRef%': typeof WeakRef === 'undefined' ? undefined1 : WeakRef,
                    '%WeakSet%': typeof WeakSet === 'undefined' ? undefined1 : WeakSet
                };
                if (getProto) {
                    try {
                        null.error; // eslint-disable-line no-unused-expressions
                    } catch (e) {
                        // https://github.com/tc39/proposal-shadowrealm/pull/384#issuecomment-1364264229
                        var errorProto = getProto(getProto(e));
                        INTRINSICS['%Error.prototype%'] = errorProto;
                    }
                }
                var doEval = function doEval(name) {
                    var value;
                    if (name === '%AsyncFunction%') {
                        value = getEvalledConstructor('async function () {}');
                    } else if (name === '%GeneratorFunction%') {
                        value = getEvalledConstructor('function* () {}');
                    } else if (name === '%AsyncGeneratorFunction%') {
                        value = getEvalledConstructor('async function* () {}');
                    } else if (name === '%AsyncGenerator%') {
                        var fn = doEval('%AsyncGeneratorFunction%');
                        if (fn) {
                            value = fn.prototype;
                        }
                    } else if (name === '%AsyncIteratorPrototype%') {
                        var gen = doEval('%AsyncGenerator%');
                        if (gen && getProto) {
                            value = getProto(gen.prototype);
                        }
                    }
                    INTRINSICS[name] = value;
                    return value;
                };
                var LEGACY_ALIASES = {
                    __proto__: null,
                    '%ArrayBufferPrototype%': [
                        'ArrayBuffer',
                        'prototype'
                    ],
                    '%ArrayPrototype%': [
                        'Array',
                        'prototype'
                    ],
                    '%ArrayProto_entries%': [
                        'Array',
                        'prototype',
                        'entries'
                    ],
                    '%ArrayProto_forEach%': [
                        'Array',
                        'prototype',
                        'forEach'
                    ],
                    '%ArrayProto_keys%': [
                        'Array',
                        'prototype',
                        'keys'
                    ],
                    '%ArrayProto_values%': [
                        'Array',
                        'prototype',
                        'values'
                    ],
                    '%AsyncFunctionPrototype%': [
                        'AsyncFunction',
                        'prototype'
                    ],
                    '%AsyncGenerator%': [
                        'AsyncGeneratorFunction',
                        'prototype'
                    ],
                    '%AsyncGeneratorPrototype%': [
                        'AsyncGeneratorFunction',
                        'prototype',
                        'prototype'
                    ],
                    '%BooleanPrototype%': [
                        'Boolean',
                        'prototype'
                    ],
                    '%DataViewPrototype%': [
                        'DataView',
                        'prototype'
                    ],
                    '%DatePrototype%': [
                        'Date',
                        'prototype'
                    ],
                    '%ErrorPrototype%': [
                        'Error',
                        'prototype'
                    ],
                    '%EvalErrorPrototype%': [
                        'EvalError',
                        'prototype'
                    ],
                    '%Float32ArrayPrototype%': [
                        'Float32Array',
                        'prototype'
                    ],
                    '%Float64ArrayPrototype%': [
                        'Float64Array',
                        'prototype'
                    ],
                    '%FunctionPrototype%': [
                        'Function',
                        'prototype'
                    ],
                    '%Generator%': [
                        'GeneratorFunction',
                        'prototype'
                    ],
                    '%GeneratorPrototype%': [
                        'GeneratorFunction',
                        'prototype',
                        'prototype'
                    ],
                    '%Int8ArrayPrototype%': [
                        'Int8Array',
                        'prototype'
                    ],
                    '%Int16ArrayPrototype%': [
                        'Int16Array',
                        'prototype'
                    ],
                    '%Int32ArrayPrototype%': [
                        'Int32Array',
                        'prototype'
                    ],
                    '%JSONParse%': [
                        'JSON',
                        'parse'
                    ],
                    '%JSONStringify%': [
                        'JSON',
                        'stringify'
                    ],
                    '%MapPrototype%': [
                        'Map',
                        'prototype'
                    ],
                    '%NumberPrototype%': [
                        'Number',
                        'prototype'
                    ],
                    '%ObjectPrototype%': [
                        'Object',
                        'prototype'
                    ],
                    '%ObjProto_toString%': [
                        'Object',
                        'prototype',
                        'toString'
                    ],
                    '%ObjProto_valueOf%': [
                        'Object',
                        'prototype',
                        'valueOf'
                    ],
                    '%PromisePrototype%': [
                        'Promise',
                        'prototype'
                    ],
                    '%PromiseProto_then%': [
                        'Promise',
                        'prototype',
                        'then'
                    ],
                    '%Promise_all%': [
                        'Promise',
                        'all'
                    ],
                    '%Promise_reject%': [
                        'Promise',
                        'reject'
                    ],
                    '%Promise_resolve%': [
                        'Promise',
                        'resolve'
                    ],
                    '%RangeErrorPrototype%': [
                        'RangeError',
                        'prototype'
                    ],
                    '%ReferenceErrorPrototype%': [
                        'ReferenceError',
                        'prototype'
                    ],
                    '%RegExpPrototype%': [
                        'RegExp',
                        'prototype'
                    ],
                    '%SetPrototype%': [
                        'Set',
                        'prototype'
                    ],
                    '%SharedArrayBufferPrototype%': [
                        'SharedArrayBuffer',
                        'prototype'
                    ],
                    '%StringPrototype%': [
                        'String',
                        'prototype'
                    ],
                    '%SymbolPrototype%': [
                        'Symbol',
                        'prototype'
                    ],
                    '%SyntaxErrorPrototype%': [
                        'SyntaxError',
                        'prototype'
                    ],
                    '%TypedArrayPrototype%': [
                        'TypedArray',
                        'prototype'
                    ],
                    '%TypeErrorPrototype%': [
                        'TypeError',
                        'prototype'
                    ],
                    '%Uint8ArrayPrototype%': [
                        'Uint8Array',
                        'prototype'
                    ],
                    '%Uint8ClampedArrayPrototype%': [
                        'Uint8ClampedArray',
                        'prototype'
                    ],
                    '%Uint16ArrayPrototype%': [
                        'Uint16Array',
                        'prototype'
                    ],
                    '%Uint32ArrayPrototype%': [
                        'Uint32Array',
                        'prototype'
                    ],
                    '%URIErrorPrototype%': [
                        'URIError',
                        'prototype'
                    ],
                    '%WeakMapPrototype%': [
                        'WeakMap',
                        'prototype'
                    ],
                    '%WeakSetPrototype%': [
                        'WeakSet',
                        'prototype'
                    ]
                };
                var bind = __nested_webpack_require_129757__(9138);
                var hasOwn = __nested_webpack_require_129757__(8554);
                var $concat = bind.call(Function.call, Array.prototype.concat);
                var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
                var $replace = bind.call(Function.call, String.prototype.replace);
                var $strSlice = bind.call(Function.call, String.prototype.slice);
                var $exec = bind.call(Function.call, RegExp.prototype.exec);
                /* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */ var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
                var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */ 
                var stringToPath = function stringToPath(string) {
                    var first = $strSlice(string, 0, 1);
                    var last = $strSlice(string, -1);
                    if (first === '%' && last !== '%') {
                        throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
                    } else if (last === '%' && first !== '%') {
                        throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
                    }
                    var result = [];
                    $replace(string, rePropName, function(match, number, quote, subString) {
                        result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
                    });
                    return result;
                };
                /* end adaptation */ var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
                    var intrinsicName = name;
                    var alias;
                    if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
                        alias = LEGACY_ALIASES[intrinsicName];
                        intrinsicName = '%' + alias[0] + '%';
                    }
                    if (hasOwn(INTRINSICS, intrinsicName)) {
                        var value = INTRINSICS[intrinsicName];
                        if (value === needsEval) {
                            value = doEval(intrinsicName);
                        }
                        if (typeof value === 'undefined' && !allowMissing) {
                            throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
                        }
                        return {
                            alias: alias,
                            name: intrinsicName,
                            value: value
                        };
                    }
                    throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
                };
                module1.exports = function GetIntrinsic(name, allowMissing) {
                    if (typeof name !== 'string' || name.length === 0) {
                        throw new $TypeError('intrinsic name must be a non-empty string');
                    }
                    if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
                        throw new $TypeError('"allowMissing" argument must be a boolean');
                    }
                    if ($exec(/^%?[^%]*%?$/, name) === null) {
                        throw new $SyntaxError('`%` may not be present anywhere but at the beginning and end of the intrinsic name');
                    }
                    var parts = stringToPath(name);
                    var intrinsicBaseName = parts.length > 0 ? parts[0] : '';
                    var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
                    var intrinsicRealName = intrinsic.name;
                    var value = intrinsic.value;
                    var skipFurtherCaching = false;
                    var alias = intrinsic.alias;
                    if (alias) {
                        intrinsicBaseName = alias[0];
                        $spliceApply(parts, $concat([
                            0,
                            1
                        ], alias));
                    }
                    for(var i = 1, isOwn = true; i < parts.length; i += 1){
                        var part = parts[i];
                        var first = $strSlice(part, 0, 1);
                        var last = $strSlice(part, -1);
                        if ((first === '"' || first === "'" || first === '`' || last === '"' || last === "'" || last === '`') && first !== last) {
                            throw new $SyntaxError('property names with quotes must have matching quotes');
                        }
                        if (part === 'constructor' || !isOwn) {
                            skipFurtherCaching = true;
                        }
                        intrinsicBaseName += '.' + part;
                        intrinsicRealName = '%' + intrinsicBaseName + '%';
                        if (hasOwn(INTRINSICS, intrinsicRealName)) {
                            value = INTRINSICS[intrinsicRealName];
                        } else if (value != null) {
                            if (!(part in value)) {
                                if (!allowMissing) {
                                    throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
                                }
                                return void undefined1;
                            }
                            if ($gOPD && i + 1 >= parts.length) {
                                var desc = $gOPD(value, part);
                                isOwn = !!desc;
                                // By convention, when a data property is converted to an accessor
                                // property to emulate a data property that does not suffer from
                                // the override mistake, that accessor's getter is marked with
                                // an `originalValue` property. Here, when we detect this, we
                                // uphold the illusion by pretending to see that original data
                                // property, i.e., returning the value rather than the getter
                                // itself.
                                if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
                                    value = desc.get;
                                } else {
                                    value = value[part];
                                }
                            } else {
                                isOwn = hasOwn(value, part);
                                value = value[part];
                            }
                            if (isOwn && !skipFurtherCaching) {
                                INTRINSICS[intrinsicRealName] = value;
                            }
                        }
                    }
                    return value;
                };
            /***/ },
            /***/ 9336: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_153635__)=>{
                "use strict";
                var GetIntrinsic = __nested_webpack_require_153635__(528);
                var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);
                if ($gOPD) {
                    try {
                        $gOPD([], 'length');
                    } catch (e) {
                        // IE 8 has a broken gOPD
                        $gOPD = null;
                    }
                }
                module1.exports = $gOPD;
            /***/ },
            /***/ 7239: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_154225__)=>{
                "use strict";
                var $defineProperty = __nested_webpack_require_154225__(4940);
                var hasPropertyDescriptors = function hasPropertyDescriptors() {
                    return !!$defineProperty;
                };
                hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
                    // node v0.6 has a bug where array lengths can be Set but not Defined
                    if (!$defineProperty) {
                        return null;
                    }
                    try {
                        return $defineProperty([], 'length', {
                            value: 1
                        }).length !== 1;
                    } catch (e) {
                        // In Firefox 4-22, defining length on an array throws an exception.
                        return true;
                    }
                };
                module1.exports = hasPropertyDescriptors;
            /***/ },
            /***/ 6869: /***/ (module1)=>{
                "use strict";
                var test = {
                    foo: {}
                };
                var $Object = Object;
                module1.exports = function hasProto() {
                    return ({
                        __proto__: test
                    }).foo === test.foo && !(({
                        __proto__: null
                    }) instanceof $Object);
                };
            /***/ },
            /***/ 3558: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_155787__)=>{
                "use strict";
                var origSymbol = typeof Symbol !== 'undefined' && Symbol;
                var hasSymbolSham = __nested_webpack_require_155787__(2908);
                module1.exports = function hasNativeSymbols() {
                    if (typeof origSymbol !== 'function') {
                        return false;
                    }
                    if (typeof Symbol !== 'function') {
                        return false;
                    }
                    if (typeof origSymbol('foo') !== 'symbol') {
                        return false;
                    }
                    if (typeof Symbol('bar') !== 'symbol') {
                        return false;
                    }
                    return hasSymbolSham();
                };
            /***/ },
            /***/ 2908: /***/ (module1)=>{
                "use strict";
                /* eslint complexity: [2, 18], max-statements: [2, 33] */ module1.exports = function hasSymbols() {
                    if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') {
                        return false;
                    }
                    if (typeof Symbol.iterator === 'symbol') {
                        return true;
                    }
                    var obj = {};
                    var sym = Symbol('test');
                    var symObj = Object(sym);
                    if (typeof sym === 'string') {
                        return false;
                    }
                    if (Object.prototype.toString.call(sym) !== '[object Symbol]') {
                        return false;
                    }
                    if (Object.prototype.toString.call(symObj) !== '[object Symbol]') {
                        return false;
                    }
                    // temp disabled per https://github.com/ljharb/object.assign/issues/17
                    // if (sym instanceof Symbol) { return false; }
                    // temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
                    // if (!(symObj instanceof Symbol)) { return false; }
                    // if (typeof Symbol.prototype.toString !== 'function') { return false; }
                    // if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }
                    var symVal = 42;
                    obj[sym] = symVal;
                    for(sym in obj){
                        return false;
                    } // eslint-disable-line no-restricted-syntax, no-unreachable-loop
                    if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) {
                        return false;
                    }
                    if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) {
                        return false;
                    }
                    var syms = Object.getOwnPropertySymbols(obj);
                    if (syms.length !== 1 || syms[0] !== sym) {
                        return false;
                    }
                    if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
                        return false;
                    }
                    if (typeof Object.getOwnPropertyDescriptor === 'function') {
                        var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
                        if (descriptor.value !== symVal || descriptor.enumerable !== true) {
                            return false;
                        }
                    }
                    return true;
                };
            /***/ },
            /***/ 1913: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_159546__)=>{
                "use strict";
                var hasSymbols = __nested_webpack_require_159546__(2908);
                module1.exports = function hasToStringTagShams() {
                    return hasSymbols() && !!Symbol.toStringTag;
                };
            /***/ },
            /***/ 8554: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_159898__)=>{
                "use strict";
                var call = Function.prototype.call;
                var $hasOwn = Object.prototype.hasOwnProperty;
                var bind = __nested_webpack_require_159898__(9138);
                /** @type {import('.')} */ module1.exports = bind.call(call, $hasOwn);
            /***/ },
            /***/ 5615: /***/ (module1)=>{
                if (typeof Object.create === 'function') {
                    // implementation from standard node.js 'util' module
                    module1.exports = function inherits(ctor, superCtor) {
                        if (superCtor) {
                            ctor.super_ = superCtor;
                            ctor.prototype = Object.create(superCtor.prototype, {
                                constructor: {
                                    value: ctor,
                                    enumerable: false,
                                    writable: true,
                                    configurable: true
                                }
                            });
                        }
                    };
                } else {
                    // old school shim for old browsers
                    module1.exports = function inherits(ctor, superCtor) {
                        if (superCtor) {
                            ctor.super_ = superCtor;
                            var TempCtor = function() {};
                            TempCtor.prototype = superCtor.prototype;
                            ctor.prototype = new TempCtor();
                            ctor.prototype.constructor = ctor;
                        }
                    };
                }
            /***/ },
            /***/ 5387: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_161685__)=>{
                "use strict";
                var hasToStringTag = __nested_webpack_require_161685__(1913)();
                var callBound = __nested_webpack_require_161685__(9818);
                var $toString = callBound('Object.prototype.toString');
                var isStandardArguments = function isArguments(value) {
                    if (hasToStringTag && value && typeof value === 'object' && Symbol.toStringTag in value) {
                        return false;
                    }
                    return $toString(value) === '[object Arguments]';
                };
                var isLegacyArguments = function isArguments(value) {
                    if (isStandardArguments(value)) {
                        return true;
                    }
                    return value !== null && typeof value === 'object' && typeof value.length === 'number' && value.length >= 0 && $toString(value) !== '[object Array]' && $toString(value.callee) === '[object Function]';
                };
                var supportsStandardArguments = function() {
                    return isStandardArguments(arguments);
                }();
                isStandardArguments.isLegacyArguments = isLegacyArguments; // for tests
                module1.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;
            /***/ },
            /***/ 9617: /***/ (module1)=>{
                "use strict";
                var fnToStr = Function.prototype.toString;
                var reflectApply = typeof Reflect === 'object' && Reflect !== null && Reflect.apply;
                var badArrayLike;
                var isCallableMarker;
                if (typeof reflectApply === 'function' && typeof Object.defineProperty === 'function') {
                    try {
                        badArrayLike = Object.defineProperty({}, 'length', {
                            get: function() {
                                throw isCallableMarker;
                            }
                        });
                        isCallableMarker = {};
                        // eslint-disable-next-line no-throw-literal
                        reflectApply(function() {
                            throw 42;
                        }, null, badArrayLike);
                    } catch (_) {
                        if (_ !== isCallableMarker) {
                            reflectApply = null;
                        }
                    }
                } else {
                    reflectApply = null;
                }
                var constructorRegex = /^\s*class\b/;
                var isES6ClassFn = function isES6ClassFunction(value) {
                    try {
                        var fnStr = fnToStr.call(value);
                        return constructorRegex.test(fnStr);
                    } catch (e) {
                        return false; // not a function
                    }
                };
                var tryFunctionObject = function tryFunctionToStr(value) {
                    try {
                        if (isES6ClassFn(value)) {
                            return false;
                        }
                        fnToStr.call(value);
                        return true;
                    } catch (e) {
                        return false;
                    }
                };
                var toStr = Object.prototype.toString;
                var objectClass = '[object Object]';
                var fnClass = '[object Function]';
                var genClass = '[object GeneratorFunction]';
                var ddaClass = '[object HTMLAllCollection]'; // IE 11
                var ddaClass2 = '[object HTML document.all class]';
                var ddaClass3 = '[object HTMLCollection]'; // IE 9-10
                var hasToStringTag = typeof Symbol === 'function' && !!Symbol.toStringTag; // better: use `has-tostringtag`
                var isIE68 = !(0 in [
                    , 
                ]); // eslint-disable-line no-sparse-arrays, comma-spacing
                var isDDA = function isDocumentDotAll() {
                    return false;
                };
                if (typeof document === 'object') {
                    // Firefox 3 canonicalizes DDA to undefined when it's not accessed directly
                    var all = document.all;
                    if (toStr.call(all) === toStr.call(document.all)) {
                        isDDA = function isDocumentDotAll(value) {
                            /* globals document: false */ // in IE 6-8, typeof document.all is "object" and it's truthy
                            if ((isIE68 || !value) && (typeof value === 'undefined' || typeof value === 'object')) {
                                try {
                                    var str = toStr.call(value);
                                    return (str === ddaClass || str === ddaClass2 || str === ddaClass3 // opera 12.16
                                     || str === objectClass // IE 6-8
                                    ) && value('') == null; // eslint-disable-line eqeqeq
                                } catch (e) {}
                            }
                            return false;
                        };
                    }
                }
                module1.exports = reflectApply ? function isCallable(value) {
                    if (isDDA(value)) {
                        return true;
                    }
                    if (!value) {
                        return false;
                    }
                    if (typeof value !== 'function' && typeof value !== 'object') {
                        return false;
                    }
                    try {
                        reflectApply(value, null, badArrayLike);
                    } catch (e) {
                        if (e !== isCallableMarker) {
                            return false;
                        }
                    }
                    return !isES6ClassFn(value) && tryFunctionObject(value);
                } : function isCallable(value) {
                    if (isDDA(value)) {
                        return true;
                    }
                    if (!value) {
                        return false;
                    }
                    if (typeof value !== 'function' && typeof value !== 'object') {
                        return false;
                    }
                    if (hasToStringTag) {
                        return tryFunctionObject(value);
                    }
                    if (isES6ClassFn(value)) {
                        return false;
                    }
                    var strClass = toStr.call(value);
                    if (strClass !== fnClass && strClass !== genClass && !/^\[object HTML/.test(strClass)) {
                        return false;
                    }
                    return tryFunctionObject(value);
                };
            /***/ },
            /***/ 2625: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_168745__)=>{
                "use strict";
                var toStr = Object.prototype.toString;
                var fnToStr = Function.prototype.toString;
                var isFnRegex = /^\s*(?:function)?\*/;
                var hasToStringTag = __nested_webpack_require_168745__(1913)();
                var getProto = Object.getPrototypeOf;
                var getGeneratorFunc = function() {
                    if (!hasToStringTag) {
                        return false;
                    }
                    try {
                        return Function('return function*() {}')();
                    } catch (e) {}
                };
                var GeneratorFunction;
                module1.exports = function isGeneratorFunction(fn) {
                    if (typeof fn !== 'function') {
                        return false;
                    }
                    if (isFnRegex.test(fnToStr.call(fn))) {
                        return true;
                    }
                    if (!hasToStringTag) {
                        var str = toStr.call(fn);
                        return str === '[object GeneratorFunction]';
                    }
                    if (!getProto) {
                        return false;
                    }
                    if (typeof GeneratorFunction === 'undefined') {
                        var generatorFunc = getGeneratorFunc();
                        GeneratorFunction = generatorFunc ? getProto(generatorFunc) : false;
                    }
                    return getProto(fn) === GeneratorFunction;
                };
            /***/ },
            /***/ 8006: /***/ (module1)=>{
                "use strict";
                /* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */ module1.exports = function isNaN1(value) {
                    return value !== value;
                };
            /***/ },
            /***/ 7838: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_170714__)=>{
                "use strict";
                var callBind = __nested_webpack_require_170714__(8498);
                var define1 = __nested_webpack_require_170714__(1857);
                var implementation = __nested_webpack_require_170714__(8006);
                var getPolyfill = __nested_webpack_require_170714__(1591);
                var shim = __nested_webpack_require_170714__(1641);
                var polyfill = callBind(getPolyfill(), Number);
                /* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */ define1(polyfill, {
                    getPolyfill: getPolyfill,
                    implementation: implementation,
                    shim: shim
                });
                module1.exports = polyfill;
            /***/ },
            /***/ 1591: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_171513__)=>{
                "use strict";
                var implementation = __nested_webpack_require_171513__(8006);
                module1.exports = function getPolyfill() {
                    if (Number.isNaN && Number.isNaN(NaN) && !Number.isNaN('a')) {
                        return Number.isNaN;
                    }
                    return implementation;
                };
            /***/ },
            /***/ 1641: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_171989__)=>{
                "use strict";
                var define1 = __nested_webpack_require_171989__(1857);
                var getPolyfill = __nested_webpack_require_171989__(1591);
                /* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */ module1.exports = function shimNumberIsNaN() {
                    var polyfill = getPolyfill();
                    define1(Number, {
                        isNaN: polyfill
                    }, {
                        isNaN: function testIsNaN() {
                            return Number.isNaN !== polyfill;
                        }
                    });
                    return polyfill;
                };
            /***/ },
            /***/ 5943: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_172757__)=>{
                "use strict";
                var whichTypedArray = __nested_webpack_require_172757__(2730);
                module1.exports = function isTypedArray(value) {
                    return !!whichTypedArray(value);
                };
            /***/ },
            /***/ 2372: /***/ (module1)=>{
                "use strict";
                var numberIsNaN = function(value) {
                    return value !== value;
                };
                module1.exports = function is(a, b) {
                    if (a === 0 && b === 0) {
                        return 1 / a === 1 / b;
                    }
                    if (a === b) {
                        return true;
                    }
                    if (numberIsNaN(a) && numberIsNaN(b)) {
                        return true;
                    }
                    return false;
                };
            /***/ },
            /***/ 5968: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_173745__)=>{
                "use strict";
                var define1 = __nested_webpack_require_173745__(1857);
                var callBind = __nested_webpack_require_173745__(8498);
                var implementation = __nested_webpack_require_173745__(2372);
                var getPolyfill = __nested_webpack_require_173745__(1937);
                var shim = __nested_webpack_require_173745__(5087);
                var polyfill = callBind(getPolyfill(), Object);
                define1(polyfill, {
                    getPolyfill: getPolyfill,
                    implementation: implementation,
                    shim: shim
                });
                module1.exports = polyfill;
            /***/ },
            /***/ 1937: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_174473__)=>{
                "use strict";
                var implementation = __nested_webpack_require_174473__(2372);
                module1.exports = function getPolyfill() {
                    return typeof Object.is === 'function' ? Object.is : implementation;
                };
            /***/ },
            /***/ 5087: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_174845__)=>{
                "use strict";
                var getPolyfill = __nested_webpack_require_174845__(1937);
                var define1 = __nested_webpack_require_174845__(1857);
                module1.exports = function shimObjectIs() {
                    var polyfill = getPolyfill();
                    define1(Object, {
                        is: polyfill
                    }, {
                        is: function testObjectIs() {
                            return Object.is !== polyfill;
                        }
                    });
                    return polyfill;
                };
            /***/ },
            /***/ 8160: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_175533__)=>{
                "use strict";
                var keysShim;
                if (!Object.keys) {
                    // modified from https://github.com/es-shims/es5-shim
                    var has = Object.prototype.hasOwnProperty;
                    var toStr = Object.prototype.toString;
                    var isArgs = __nested_webpack_require_175533__(968); // eslint-disable-line global-require
                    var isEnumerable = Object.prototype.propertyIsEnumerable;
                    var hasDontEnumBug = !isEnumerable.call({
                        toString: null
                    }, 'toString');
                    var hasProtoEnumBug = isEnumerable.call(function() {}, 'prototype');
                    var dontEnums = [
                        'toString',
                        'toLocaleString',
                        'valueOf',
                        'hasOwnProperty',
                        'isPrototypeOf',
                        'propertyIsEnumerable',
                        'constructor'
                    ];
                    var equalsConstructorPrototype = function(o) {
                        var ctor = o.constructor;
                        return ctor && ctor.prototype === o;
                    };
                    var excludedKeys = {
                        $applicationCache: true,
                        $console: true,
                        $external: true,
                        $frame: true,
                        $frameElement: true,
                        $frames: true,
                        $innerHeight: true,
                        $innerWidth: true,
                        $onmozfullscreenchange: true,
                        $onmozfullscreenerror: true,
                        $outerHeight: true,
                        $outerWidth: true,
                        $pageXOffset: true,
                        $pageYOffset: true,
                        $parent: true,
                        $scrollLeft: true,
                        $scrollTop: true,
                        $scrollX: true,
                        $scrollY: true,
                        $self: true,
                        $webkitIndexedDB: true,
                        $webkitStorageInfo: true,
                        $window: true
                    };
                    var hasAutomationEqualityBug = function() {
                        /* global window */ if (typeof window === 'undefined') {
                            return false;
                        }
                        for(var k in window){
                            try {
                                if (!excludedKeys['$' + k] && has.call(window, k) && window[k] !== null && typeof window[k] === 'object') {
                                    try {
                                        equalsConstructorPrototype(window[k]);
                                    } catch (e) {
                                        return true;
                                    }
                                }
                            } catch (e) {
                                return true;
                            }
                        }
                        return false;
                    }();
                    var equalsConstructorPrototypeIfNotBuggy = function(o) {
                        /* global window */ if (typeof window === 'undefined' || !hasAutomationEqualityBug) {
                            return equalsConstructorPrototype(o);
                        }
                        try {
                            return equalsConstructorPrototype(o);
                        } catch (e) {
                            return false;
                        }
                    };
                    keysShim = function keys(object) {
                        var isObject = object !== null && typeof object === 'object';
                        var isFunction = toStr.call(object) === '[object Function]';
                        var isArguments = isArgs(object);
                        var isString = isObject && toStr.call(object) === '[object String]';
                        var theKeys = [];
                        if (!isObject && !isFunction && !isArguments) {
                            throw new TypeError('Object.keys called on a non-object');
                        }
                        var skipProto = hasProtoEnumBug && isFunction;
                        if (isString && object.length > 0 && !has.call(object, 0)) {
                            for(var i = 0; i < object.length; ++i){
                                theKeys.push(String(i));
                            }
                        }
                        if (isArguments && object.length > 0) {
                            for(var j = 0; j < object.length; ++j){
                                theKeys.push(String(j));
                            }
                        } else {
                            for(var name in object){
                                if (!(skipProto && name === 'prototype') && has.call(object, name)) {
                                    theKeys.push(String(name));
                                }
                            }
                        }
                        if (hasDontEnumBug) {
                            var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);
                            for(var k = 0; k < dontEnums.length; ++k){
                                if (!(skipConstructor && dontEnums[k] === 'constructor') && has.call(object, dontEnums[k])) {
                                    theKeys.push(dontEnums[k]);
                                }
                            }
                        }
                        return theKeys;
                    };
                }
                module1.exports = keysShim;
            /***/ },
            /***/ 9228: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_181502__)=>{
                "use strict";
                var slice = Array.prototype.slice;
                var isArgs = __nested_webpack_require_181502__(968);
                var origKeys = Object.keys;
                var keysShim = origKeys ? function keys(o) {
                    return origKeys(o);
                } : __nested_webpack_require_181502__(8160);
                var originalKeys = Object.keys;
                keysShim.shim = function shimObjectKeys() {
                    if (Object.keys) {
                        var keysWorksWithArguments = function() {
                            // Safari 5.0 bug
                            var args = Object.keys(arguments);
                            return args && args.length === arguments.length;
                        }(1, 2);
                        if (!keysWorksWithArguments) {
                            Object.keys = function keys(object) {
                                if (isArgs(object)) {
                                    return originalKeys(slice.call(object));
                                }
                                return originalKeys(object);
                            };
                        }
                    } else {
                        Object.keys = keysShim;
                    }
                    return Object.keys || keysShim;
                };
                module1.exports = keysShim;
            /***/ },
            /***/ 968: /***/ (module1)=>{
                "use strict";
                var toStr = Object.prototype.toString;
                module1.exports = function isArguments(value) {
                    var str = toStr.call(value);
                    var isArgs = str === '[object Arguments]';
                    if (!isArgs) {
                        isArgs = str !== '[object Array]' && value !== null && typeof value === 'object' && typeof value.length === 'number' && value.length >= 0 && toStr.call(value.callee) === '[object Function]';
                    }
                    return isArgs;
                };
            /***/ },
            /***/ 9907: /***/ (module1)=>{
                // shim for using process in browser
                var process = module1.exports = {};
                // cached from whatever global is present so that test runners that stub it
                // don't break things.  But we need to wrap it in a try catch in case it is
                // wrapped in strict mode code which doesn't define any globals.  It's inside a
                // function because try/catches deoptimize in certain engines.
                var cachedSetTimeout;
                var cachedClearTimeout;
                function defaultSetTimout() {
                    throw new Error('setTimeout has not been defined');
                }
                function defaultClearTimeout() {
                    throw new Error('clearTimeout has not been defined');
                }
                (function() {
                    try {
                        if (typeof setTimeout === 'function') {
                            cachedSetTimeout = setTimeout;
                        } else {
                            cachedSetTimeout = defaultSetTimout;
                        }
                    } catch (e) {
                        cachedSetTimeout = defaultSetTimout;
                    }
                    try {
                        if (typeof clearTimeout === 'function') {
                            cachedClearTimeout = clearTimeout;
                        } else {
                            cachedClearTimeout = defaultClearTimeout;
                        }
                    } catch (e) {
                        cachedClearTimeout = defaultClearTimeout;
                    }
                })();
                function runTimeout(fun) {
                    if (cachedSetTimeout === setTimeout) {
                        //normal enviroments in sane situations
                        return setTimeout(fun, 0);
                    }
                    // if setTimeout wasn't available but was latter defined
                    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
                        cachedSetTimeout = setTimeout;
                        return setTimeout(fun, 0);
                    }
                    try {
                        // when when somebody has screwed with setTimeout but no I.E. maddness
                        return cachedSetTimeout(fun, 0);
                    } catch (e) {
                        try {
                            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
                            return cachedSetTimeout.call(null, fun, 0);
                        } catch (e) {
                            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
                            return cachedSetTimeout.call(this, fun, 0);
                        }
                    }
                }
                function runClearTimeout(marker) {
                    if (cachedClearTimeout === clearTimeout) {
                        //normal enviroments in sane situations
                        return clearTimeout(marker);
                    }
                    // if clearTimeout wasn't available but was latter defined
                    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
                        cachedClearTimeout = clearTimeout;
                        return clearTimeout(marker);
                    }
                    try {
                        // when when somebody has screwed with setTimeout but no I.E. maddness
                        return cachedClearTimeout(marker);
                    } catch (e) {
                        try {
                            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
                            return cachedClearTimeout.call(null, marker);
                        } catch (e) {
                            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
                            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
                            return cachedClearTimeout.call(this, marker);
                        }
                    }
                }
                var queue = [];
                var draining = false;
                var currentQueue;
                var queueIndex = -1;
                function cleanUpNextTick() {
                    if (!draining || !currentQueue) {
                        return;
                    }
                    draining = false;
                    if (currentQueue.length) {
                        queue = currentQueue.concat(queue);
                    } else {
                        queueIndex = -1;
                    }
                    if (queue.length) {
                        drainQueue();
                    }
                }
                function drainQueue() {
                    if (draining) {
                        return;
                    }
                    var timeout = runTimeout(cleanUpNextTick);
                    draining = true;
                    var len = queue.length;
                    while(len){
                        currentQueue = queue;
                        queue = [];
                        while(++queueIndex < len){
                            if (currentQueue) {
                                currentQueue[queueIndex].run();
                            }
                        }
                        queueIndex = -1;
                        len = queue.length;
                    }
                    currentQueue = null;
                    draining = false;
                    runClearTimeout(timeout);
                }
                process.nextTick = function(fun) {
                    var args = new Array(arguments.length - 1);
                    if (arguments.length > 1) {
                        for(var i = 1; i < arguments.length; i++){
                            args[i - 1] = arguments[i];
                        }
                    }
                    queue.push(new Item(fun, args));
                    if (queue.length === 1 && !draining) {
                        runTimeout(drainQueue);
                    }
                };
                // v8 likes predictible objects
                function Item(fun, array) {
                    this.fun = fun;
                    this.array = array;
                }
                Item.prototype.run = function() {
                    this.fun.apply(null, this.array);
                };
                process.title = 'browser';
                process.browser = true;
                process.env = {};
                process.argv = [];
                process.version = ''; // empty string to avoid regexp issues
                process.versions = {};
                function noop() {}
                process.on = noop;
                process.addListener = noop;
                process.once = noop;
                process.off = noop;
                process.removeListener = noop;
                process.removeAllListeners = noop;
                process.emit = noop;
                process.prependListener = noop;
                process.prependOnceListener = noop;
                process.listeners = function(name) {
                    return [];
                };
                process.binding = function(name) {
                    throw new Error('process.binding is not supported');
                };
                process.cwd = function() {
                    return '/';
                };
                process.chdir = function(dir) {
                    throw new Error('process.chdir is not supported');
                };
                process.umask = function() {
                    return 0;
                };
            /***/ },
            /***/ 6108: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_191866__)=>{
                "use strict";
                var GetIntrinsic = __nested_webpack_require_191866__(528);
                var define1 = __nested_webpack_require_191866__(686);
                var hasDescriptors = __nested_webpack_require_191866__(7239)();
                var gOPD = __nested_webpack_require_191866__(9336);
                var $TypeError = __nested_webpack_require_191866__(3468);
                var $floor = GetIntrinsic('%Math.floor%');
                /** @type {import('.')} */ module1.exports = function setFunctionLength(fn, length) {
                    if (typeof fn !== 'function') {
                        throw new $TypeError('`fn` is not a function');
                    }
                    if (typeof length !== 'number' || length < 0 || length > 0xFFFFFFFF || $floor(length) !== length) {
                        throw new $TypeError('`length` must be a positive 32-bit integer');
                    }
                    var loose = arguments.length > 2 && !!arguments[2];
                    var functionLengthIsConfigurable = true;
                    var functionLengthIsWritable = true;
                    if ('length' in fn && gOPD) {
                        var desc = gOPD(fn, 'length');
                        if (desc && !desc.configurable) {
                            functionLengthIsConfigurable = false;
                        }
                        if (desc && !desc.writable) {
                            functionLengthIsWritable = false;
                        }
                    }
                    if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {
                        if (hasDescriptors) {
                            define1(/** @type {Parameters<define>[0]} */ fn, 'length', length, true, true);
                        } else {
                            define1(/** @type {Parameters<define>[0]} */ fn, 'length', length);
                        }
                    }
                    return fn;
                };
            /***/ },
            /***/ 2125: /***/ (__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_193940__)=>{
                "use strict";
                /* harmony export */ __nested_webpack_require_193940__.d(__nested_webpack_exports__, {
                    /* harmony export */ BaseService: ()=>/* binding */ BaseService
                });
                /* harmony import */ var vscode_languageserver_protocol__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_193940__(5501);
                /* harmony import */ var vscode_languageserver_protocol__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/ __nested_webpack_require_193940__.n(vscode_languageserver_protocol__WEBPACK_IMPORTED_MODULE_0__);
                /* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_193940__(7770);
                /* harmony import */ var vscode_languageserver_textdocument__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_193940__(8041);
                function _define_property(obj, key, value) {
                    if (key in obj) {
                        Object.defineProperty(obj, key, {
                            value: value,
                            enumerable: true,
                            configurable: true,
                            writable: true
                        });
                    } else {
                        obj[key] = value;
                    }
                    return obj;
                }
                class BaseService {
                    addDocument(document1) {
                        this.documents[document1.uri] = vscode_languageserver_textdocument__WEBPACK_IMPORTED_MODULE_1__ /* .TextDocument */ .V.create(document1.uri, document1.languageId, document1.version, document1.text);
                    }
                    getDocument(uri) {
                        return this.documents[uri];
                    }
                    removeDocument(document1) {
                        delete this.documents[document1.uri];
                        if (this.options[document1.uri]) {
                            delete this.options[document1.uri];
                        }
                    }
                    getDocumentValue(uri) {
                        var _this_getDocument;
                        return (_this_getDocument = this.getDocument(uri)) === null || _this_getDocument === void 0 ? void 0 : _this_getDocument.getText();
                    }
                    setValue(identifier, value) {
                        let document1 = this.getDocument(identifier.uri);
                        if (document1) {
                            document1 = vscode_languageserver_textdocument__WEBPACK_IMPORTED_MODULE_1__ /* .TextDocument */ .V.create(document1.uri, document1.languageId, document1.version, value);
                            this.documents[document1.uri] = document1;
                        }
                    }
                    setGlobalOptions(options) {
                        this.globalOptions = options !== null && options !== void 0 ? options : {};
                    }
                    setWorkspace(workspaceUri) {
                        this.workspaceUri = workspaceUri;
                    }
                    setOptions(documentUri, options, merge = false) {
                        this.options[documentUri] = merge ? (0, _utils__WEBPACK_IMPORTED_MODULE_2__ /* .mergeObjects */ .rL)(options, this.options[documentUri]) : options;
                    }
                    getOption(documentUri, optionName) {
                        if (this.options[documentUri] && this.options[documentUri][optionName]) {
                            return this.options[documentUri][optionName];
                        } else {
                            return this.globalOptions[optionName];
                        }
                    }
                    applyDeltas(identifier, deltas) {
                        let document1 = this.getDocument(identifier.uri);
                        if (document1) vscode_languageserver_textdocument__WEBPACK_IMPORTED_MODULE_1__ /* .TextDocument */ .V.update(document1, deltas, identifier.version);
                    }
                    async doComplete(document1, position) {
                        return null;
                    }
                    async doHover(document1, position) {
                        return null;
                    }
                    async doResolve(item) {
                        return null;
                    }
                    async doValidation(document1) {
                        return [];
                    }
                    format(document1, range, options) {
                        return Promise.resolve([]);
                    }
                    async provideSignatureHelp(document1, position) {
                        return null;
                    }
                    async findDocumentHighlights(document1, position) {
                        return [];
                    }
                    get optionsToFilterDiagnostics() {
                        var _this_globalOptions_errorCodesToIgnore, _this_globalOptions_errorCodesToTreatAsWarning, _this_globalOptions_errorCodesToTreatAsInfo, _this_globalOptions_errorMessagesToIgnore, _this_globalOptions_errorMessagesToTreatAsWarning, _this_globalOptions_errorMessagesToTreatAsInfo;
                        return {
                            errorCodesToIgnore: (_this_globalOptions_errorCodesToIgnore = this.globalOptions.errorCodesToIgnore) !== null && _this_globalOptions_errorCodesToIgnore !== void 0 ? _this_globalOptions_errorCodesToIgnore : [],
                            errorCodesToTreatAsWarning: (_this_globalOptions_errorCodesToTreatAsWarning = this.globalOptions.errorCodesToTreatAsWarning) !== null && _this_globalOptions_errorCodesToTreatAsWarning !== void 0 ? _this_globalOptions_errorCodesToTreatAsWarning : [],
                            errorCodesToTreatAsInfo: (_this_globalOptions_errorCodesToTreatAsInfo = this.globalOptions.errorCodesToTreatAsInfo) !== null && _this_globalOptions_errorCodesToTreatAsInfo !== void 0 ? _this_globalOptions_errorCodesToTreatAsInfo : [],
                            errorMessagesToIgnore: (_this_globalOptions_errorMessagesToIgnore = this.globalOptions.errorMessagesToIgnore) !== null && _this_globalOptions_errorMessagesToIgnore !== void 0 ? _this_globalOptions_errorMessagesToIgnore : [],
                            errorMessagesToTreatAsWarning: (_this_globalOptions_errorMessagesToTreatAsWarning = this.globalOptions.errorMessagesToTreatAsWarning) !== null && _this_globalOptions_errorMessagesToTreatAsWarning !== void 0 ? _this_globalOptions_errorMessagesToTreatAsWarning : [],
                            errorMessagesToTreatAsInfo: (_this_globalOptions_errorMessagesToTreatAsInfo = this.globalOptions.errorMessagesToTreatAsInfo) !== null && _this_globalOptions_errorMessagesToTreatAsInfo !== void 0 ? _this_globalOptions_errorMessagesToTreatAsInfo : []
                        };
                    }
                    getSemanticTokens(document1, range) {
                        return Promise.resolve(null);
                    }
                    dispose() {
                        return Promise.resolve();
                    }
                    closeConnection() {
                        return Promise.resolve();
                    }
                    getCodeActions(document1, range, context) {
                        return Promise.resolve(null);
                    }
                    executeCommand(command, args) {
                        return Promise.resolve(null);
                    }
                    sendAppliedResult(result, callbackId) {}
                    constructor(mode, workspaceUri){
                        _define_property(this, "serviceName", void 0);
                        _define_property(this, "mode", void 0);
                        _define_property(this, "documents", {});
                        _define_property(this, "options", {});
                        _define_property(this, "globalOptions", {});
                        _define_property(this, "serviceData", void 0);
                        _define_property(this, "serviceCapabilities", {});
                        _define_property(this, "workspaceUri", void 0);
                        _define_property(this, "clientCapabilities", {
                            textDocument: {
                                diagnostic: {
                                    dynamicRegistration: true,
                                    relatedDocumentSupport: true
                                },
                                publishDiagnostics: {
                                    relatedInformation: true,
                                    versionSupport: false,
                                    tagSupport: {
                                        valueSet: [
                                            vscode_languageserver_protocol__WEBPACK_IMPORTED_MODULE_0__.DiagnosticTag.Unnecessary,
                                            vscode_languageserver_protocol__WEBPACK_IMPORTED_MODULE_0__.DiagnosticTag.Deprecated
                                        ]
                                    }
                                },
                                hover: {
                                    dynamicRegistration: true,
                                    contentFormat: [
                                        'markdown',
                                        'plaintext'
                                    ]
                                },
                                synchronization: {
                                    dynamicRegistration: true,
                                    willSave: false,
                                    didSave: false,
                                    willSaveWaitUntil: false
                                },
                                formatting: {
                                    dynamicRegistration: true
                                },
                                completion: {
                                    dynamicRegistration: true,
                                    completionItem: {
                                        snippetSupport: true,
                                        commitCharactersSupport: false,
                                        documentationFormat: [
                                            'markdown',
                                            'plaintext'
                                        ],
                                        deprecatedSupport: false,
                                        preselectSupport: false
                                    },
                                    contextSupport: false
                                },
                                signatureHelp: {
                                    signatureInformation: {
                                        documentationFormat: [
                                            'markdown',
                                            'plaintext'
                                        ],
                                        activeParameterSupport: true
                                    }
                                },
                                documentHighlight: {
                                    dynamicRegistration: true
                                },
                                semanticTokens: {
                                    multilineTokenSupport: false,
                                    overlappingTokenSupport: false,
                                    tokenTypes: [],
                                    tokenModifiers: [],
                                    formats: [
                                        "relative"
                                    ],
                                    requests: {
                                        full: {
                                            delta: false
                                        },
                                        range: true
                                    },
                                    augmentsSyntaxTokens: true
                                },
                                codeAction: {
                                    dynamicRegistration: true
                                }
                            },
                            workspace: {
                                didChangeConfiguration: {
                                    dynamicRegistration: true
                                },
                                executeCommand: {
                                    dynamicRegistration: true
                                },
                                applyEdit: true,
                                workspaceEdit: {
                                    failureHandling: "abort",
                                    normalizesLineEndings: false,
                                    documentChanges: false
                                }
                            }
                        });
                        this.mode = mode;
                        this.workspaceUri = workspaceUri;
                    }
                }
            /***/ },
            /***/ 7770: /***/ (__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_207268__)=>{
                "use strict";
                /* harmony export */ __nested_webpack_require_207268__.d(__nested_webpack_exports__, {
                    /* harmony export */ rL: ()=>/* binding */ mergeObjects
                });
                /* unused harmony exports notEmpty, mergeRanges, checkValueAgainstRegexpArray, convertToUri */ function mergeObjects(obj1, obj2, excludeUndefined = false) {
                    if (!obj1) return obj2;
                    if (!obj2) return obj1;
                    if (excludeUndefined) {
                        obj1 = excludeUndefinedValues(obj1);
                        obj2 = excludeUndefinedValues(obj2);
                    }
                    const mergedObjects = {
                        ...obj2,
                        ...obj1
                    }; // Give priority to obj1 values by spreading obj2 first, then obj1
                    for (const key of Object.keys(mergedObjects)){
                        if (obj1[key] && obj2[key]) {
                            if (Array.isArray(obj1[key])) {
                                mergedObjects[key] = obj1[key].concat(obj2[key]);
                            } else if (Array.isArray(obj2[key])) {
                                mergedObjects[key] = obj2[key].concat(obj1[key]);
                            } else if (typeof obj1[key] === 'object' && typeof obj2[key] === 'object') {
                                mergedObjects[key] = mergeObjects(obj1[key], obj2[key]);
                            }
                        }
                    }
                    return mergedObjects;
                }
                function excludeUndefinedValues(obj) {
                    const filteredEntries = Object.entries(obj).filter(([_, value])=>value !== undefined);
                    return Object.fromEntries(filteredEntries);
                }
                function notEmpty(value) {
                    return value !== null && value !== undefined;
                }
                //taken with small changes from ace-code
                function mergeRanges(ranges) {
                    var list = ranges;
                    list = list.sort(function(a, b) {
                        return comparePoints(a.start, b.start);
                    });
                    var next = list[0], range;
                    for(var i = 1; i < list.length; i++){
                        range = next;
                        next = list[i];
                        var cmp = comparePoints(range.end, next.start);
                        if (cmp < 0) continue;
                        if (cmp == 0 && !range.isEmpty() && !next.isEmpty()) continue;
                        if (comparePoints(range.end, next.end) < 0) {
                            range.end.row = next.end.row;
                            range.end.column = next.end.column;
                        }
                        list.splice(i, 1);
                        next = range;
                        i--;
                    }
                    return list;
                }
                function comparePoints(p1, p2) {
                    return p1.row - p2.row || p1.column - p2.column;
                }
                function checkValueAgainstRegexpArray(value, regexpArray) {
                    if (!regexpArray) {
                        return false;
                    }
                    for(let i = 0; i < regexpArray.length; i++){
                        if (regexpArray[i].test(value)) {
                            return true;
                        }
                    }
                    return false;
                }
                function convertToUri(filePath) {
                    //already URI
                    if (filePath.startsWith("file:///")) {
                        return filePath;
                    }
                    return URI.file(filePath).toString();
                }
            /***/ },
            /***/ 5272: /***/ (module1)=>{
                module1.exports = function isBuffer(arg) {
                    return arg && typeof arg === 'object' && typeof arg.copy === 'function' && typeof arg.fill === 'function' && typeof arg.readUInt8 === 'function';
                };
            /***/ },
            /***/ 1531: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_211591__)=>{
                "use strict";
                // Currently in sync with Node.js lib/internal/util/types.js
                // https://github.com/nodejs/node/commit/112cc7c27551254aa2b17098fb774867f05ed0d9
                var isArgumentsObject = __nested_webpack_require_211591__(5387);
                var isGeneratorFunction = __nested_webpack_require_211591__(2625);
                var whichTypedArray = __nested_webpack_require_211591__(2730);
                var isTypedArray = __nested_webpack_require_211591__(5943);
                function uncurryThis(f) {
                    return f.call.bind(f);
                }
                var BigIntSupported = typeof BigInt !== 'undefined';
                var SymbolSupported = typeof Symbol !== 'undefined';
                var ObjectToString = uncurryThis(Object.prototype.toString);
                var numberValue = uncurryThis(Number.prototype.valueOf);
                var stringValue = uncurryThis(String.prototype.valueOf);
                var booleanValue = uncurryThis(Boolean.prototype.valueOf);
                if (BigIntSupported) {
                    var bigIntValue = uncurryThis(BigInt.prototype.valueOf);
                }
                if (SymbolSupported) {
                    var symbolValue = uncurryThis(Symbol.prototype.valueOf);
                }
                function checkBoxedPrimitive(value, prototypeValueOf) {
                    if (typeof value !== 'object') {
                        return false;
                    }
                    try {
                        prototypeValueOf(value);
                        return true;
                    } catch (e) {
                        return false;
                    }
                }
                exports1.isArgumentsObject = isArgumentsObject;
                exports1.isGeneratorFunction = isGeneratorFunction;
                exports1.isTypedArray = isTypedArray;
                // Taken from here and modified for better browser support
                // https://github.com/sindresorhus/p-is-promise/blob/cda35a513bda03f977ad5cde3a079d237e82d7ef/index.js
                function isPromise(input) {
                    return typeof Promise !== 'undefined' && input instanceof Promise || input !== null && typeof input === 'object' && typeof input.then === 'function' && typeof input.catch === 'function';
                }
                exports1.isPromise = isPromise;
                function isArrayBufferView(value) {
                    if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {
                        return ArrayBuffer.isView(value);
                    }
                    return isTypedArray(value) || isDataView(value);
                }
                exports1.isArrayBufferView = isArrayBufferView;
                function isUint8Array(value) {
                    return whichTypedArray(value) === 'Uint8Array';
                }
                exports1.isUint8Array = isUint8Array;
                function isUint8ClampedArray(value) {
                    return whichTypedArray(value) === 'Uint8ClampedArray';
                }
                exports1.isUint8ClampedArray = isUint8ClampedArray;
                function isUint16Array(value) {
                    return whichTypedArray(value) === 'Uint16Array';
                }
                exports1.isUint16Array = isUint16Array;
                function isUint32Array(value) {
                    return whichTypedArray(value) === 'Uint32Array';
                }
                exports1.isUint32Array = isUint32Array;
                function isInt8Array(value) {
                    return whichTypedArray(value) === 'Int8Array';
                }
                exports1.isInt8Array = isInt8Array;
                function isInt16Array(value) {
                    return whichTypedArray(value) === 'Int16Array';
                }
                exports1.isInt16Array = isInt16Array;
                function isInt32Array(value) {
                    return whichTypedArray(value) === 'Int32Array';
                }
                exports1.isInt32Array = isInt32Array;
                function isFloat32Array(value) {
                    return whichTypedArray(value) === 'Float32Array';
                }
                exports1.isFloat32Array = isFloat32Array;
                function isFloat64Array(value) {
                    return whichTypedArray(value) === 'Float64Array';
                }
                exports1.isFloat64Array = isFloat64Array;
                function isBigInt64Array(value) {
                    return whichTypedArray(value) === 'BigInt64Array';
                }
                exports1.isBigInt64Array = isBigInt64Array;
                function isBigUint64Array(value) {
                    return whichTypedArray(value) === 'BigUint64Array';
                }
                exports1.isBigUint64Array = isBigUint64Array;
                function isMapToString(value) {
                    return ObjectToString(value) === '[object Map]';
                }
                isMapToString.working = typeof Map !== 'undefined' && isMapToString(new Map());
                function isMap(value) {
                    if (typeof Map === 'undefined') {
                        return false;
                    }
                    return isMapToString.working ? isMapToString(value) : value instanceof Map;
                }
                exports1.isMap = isMap;
                function isSetToString(value) {
                    return ObjectToString(value) === '[object Set]';
                }
                isSetToString.working = typeof Set !== 'undefined' && isSetToString(new Set());
                function isSet(value) {
                    if (typeof Set === 'undefined') {
                        return false;
                    }
                    return isSetToString.working ? isSetToString(value) : value instanceof Set;
                }
                exports1.isSet = isSet;
                function isWeakMapToString(value) {
                    return ObjectToString(value) === '[object WeakMap]';
                }
                isWeakMapToString.working = typeof WeakMap !== 'undefined' && isWeakMapToString(new WeakMap());
                function isWeakMap(value) {
                    if (typeof WeakMap === 'undefined') {
                        return false;
                    }
                    return isWeakMapToString.working ? isWeakMapToString(value) : value instanceof WeakMap;
                }
                exports1.isWeakMap = isWeakMap;
                function isWeakSetToString(value) {
                    return ObjectToString(value) === '[object WeakSet]';
                }
                isWeakSetToString.working = typeof WeakSet !== 'undefined' && isWeakSetToString(new WeakSet());
                function isWeakSet(value) {
                    return isWeakSetToString(value);
                }
                exports1.isWeakSet = isWeakSet;
                function isArrayBufferToString(value) {
                    return ObjectToString(value) === '[object ArrayBuffer]';
                }
                isArrayBufferToString.working = typeof ArrayBuffer !== 'undefined' && isArrayBufferToString(new ArrayBuffer());
                function isArrayBuffer(value) {
                    if (typeof ArrayBuffer === 'undefined') {
                        return false;
                    }
                    return isArrayBufferToString.working ? isArrayBufferToString(value) : value instanceof ArrayBuffer;
                }
                exports1.isArrayBuffer = isArrayBuffer;
                function isDataViewToString(value) {
                    return ObjectToString(value) === '[object DataView]';
                }
                isDataViewToString.working = typeof ArrayBuffer !== 'undefined' && typeof DataView !== 'undefined' && isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1));
                function isDataView(value) {
                    if (typeof DataView === 'undefined') {
                        return false;
                    }
                    return isDataViewToString.working ? isDataViewToString(value) : value instanceof DataView;
                }
                exports1.isDataView = isDataView;
                // Store a copy of SharedArrayBuffer in case it's deleted elsewhere
                var SharedArrayBufferCopy = typeof SharedArrayBuffer !== 'undefined' ? SharedArrayBuffer : undefined;
                function isSharedArrayBufferToString(value) {
                    return ObjectToString(value) === '[object SharedArrayBuffer]';
                }
                function isSharedArrayBuffer(value) {
                    if (typeof SharedArrayBufferCopy === 'undefined') {
                        return false;
                    }
                    if (typeof isSharedArrayBufferToString.working === 'undefined') {
                        isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());
                    }
                    return isSharedArrayBufferToString.working ? isSharedArrayBufferToString(value) : value instanceof SharedArrayBufferCopy;
                }
                exports1.isSharedArrayBuffer = isSharedArrayBuffer;
                function isAsyncFunction(value) {
                    return ObjectToString(value) === '[object AsyncFunction]';
                }
                exports1.isAsyncFunction = isAsyncFunction;
                function isMapIterator(value) {
                    return ObjectToString(value) === '[object Map Iterator]';
                }
                exports1.isMapIterator = isMapIterator;
                function isSetIterator(value) {
                    return ObjectToString(value) === '[object Set Iterator]';
                }
                exports1.isSetIterator = isSetIterator;
                function isGeneratorObject(value) {
                    return ObjectToString(value) === '[object Generator]';
                }
                exports1.isGeneratorObject = isGeneratorObject;
                function isWebAssemblyCompiledModule(value) {
                    return ObjectToString(value) === '[object WebAssembly.Module]';
                }
                exports1.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;
                function isNumberObject(value) {
                    return checkBoxedPrimitive(value, numberValue);
                }
                exports1.isNumberObject = isNumberObject;
                function isStringObject(value) {
                    return checkBoxedPrimitive(value, stringValue);
                }
                exports1.isStringObject = isStringObject;
                function isBooleanObject(value) {
                    return checkBoxedPrimitive(value, booleanValue);
                }
                exports1.isBooleanObject = isBooleanObject;
                function isBigIntObject(value) {
                    return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
                }
                exports1.isBigIntObject = isBigIntObject;
                function isSymbolObject(value) {
                    return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
                }
                exports1.isSymbolObject = isSymbolObject;
                function isBoxedPrimitive(value) {
                    return isNumberObject(value) || isStringObject(value) || isBooleanObject(value) || isBigIntObject(value) || isSymbolObject(value);
                }
                exports1.isBoxedPrimitive = isBoxedPrimitive;
                function isAnyArrayBuffer(value) {
                    return typeof Uint8Array !== 'undefined' && (isArrayBuffer(value) || isSharedArrayBuffer(value));
                }
                exports1.isAnyArrayBuffer = isAnyArrayBuffer;
                [
                    'isProxy',
                    'isExternal',
                    'isModuleNamespaceObject'
                ].forEach(function(method) {
                    Object.defineProperty(exports1, method, {
                        enumerable: false,
                        value: function() {
                            throw new Error(method + ' is not supported in userland');
                        }
                    });
                });
            /***/ },
            /***/ 6827: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_224068__)=>{
                /* provided dependency */ var process = __nested_webpack_require_224068__(9907);
                /* provided dependency */ var console = __nested_webpack_require_224068__(4364);
                // Copyright Joyent, Inc. and other Node contributors.
                //
                // Permission is hereby granted, free of charge, to any person obtaining a
                // copy of this software and associated documentation files (the
                // "Software"), to deal in the Software without restriction, including
                // without limitation the rights to use, copy, modify, merge, publish,
                // distribute, sublicense, and/or sell copies of the Software, and to permit
                // persons to whom the Software is furnished to do so, subject to the
                // following conditions:
                //
                // The above copyright notice and this permission notice shall be included
                // in all copies or substantial portions of the Software.
                //
                // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
                // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
                // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
                // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
                // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
                // USE OR OTHER DEALINGS IN THE SOFTWARE.
                var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors(obj) {
                    var keys = Object.keys(obj);
                    var descriptors = {};
                    for(var i = 0; i < keys.length; i++){
                        descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
                    }
                    return descriptors;
                };
                var formatRegExp = /%[sdj%]/g;
                exports1.format = function(f) {
                    if (!isString(f)) {
                        var objects = [];
                        for(var i = 0; i < arguments.length; i++){
                            objects.push(inspect(arguments[i]));
                        }
                        return objects.join(' ');
                    }
                    var i = 1;
                    var args = arguments;
                    var len = args.length;
                    var str = String(f).replace(formatRegExp, function(x) {
                        if (x === '%%') return '%';
                        if (i >= len) return x;
                        switch(x){
                            case '%s':
                                return String(args[i++]);
                            case '%d':
                                return Number(args[i++]);
                            case '%j':
                                try {
                                    return JSON.stringify(args[i++]);
                                } catch (_) {
                                    return '[Circular]';
                                }
                            default:
                                return x;
                        }
                    });
                    for(var x = args[i]; i < len; x = args[++i]){
                        if (isNull(x) || !isObject(x)) {
                            str += ' ' + x;
                        } else {
                            str += ' ' + inspect(x);
                        }
                    }
                    return str;
                };
                // Mark that a method should not be used.
                // Returns a modified function which warns once by default.
                // If --no-deprecation is set, then it is a no-op.
                exports1.deprecate = function(fn, msg) {
                    if (typeof process !== 'undefined' && process.noDeprecation === true) {
                        return fn;
                    }
                    // Allow for deprecating things in the process of starting up.
                    if (typeof process === 'undefined') {
                        return function() {
                            return exports1.deprecate(fn, msg).apply(this, arguments);
                        };
                    }
                    var warned = false;
                    function deprecated() {
                        if (!warned) {
                            if (process.throwDeprecation) {
                                throw new Error(msg);
                            } else if (process.traceDeprecation) {
                                console.trace(msg);
                            } else {
                                console.error(msg);
                            }
                            warned = true;
                        }
                        return fn.apply(this, arguments);
                    }
                    return deprecated;
                };
                var debugs = {};
                var debugEnvRegex = /^$/;
                if (process.env.NODE_DEBUG) {
                    var debugEnv = process.env.NODE_DEBUG;
                    debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, '\\$&').replace(/\*/g, '.*').replace(/,/g, '$|^').toUpperCase();
                    debugEnvRegex = new RegExp('^' + debugEnv + '$', 'i');
                }
                exports1.debuglog = function(set) {
                    set = set.toUpperCase();
                    if (!debugs[set]) {
                        if (debugEnvRegex.test(set)) {
                            var pid = process.pid;
                            debugs[set] = function() {
                                var msg = exports1.format.apply(exports1, arguments);
                                console.error('%s %d: %s', set, pid, msg);
                            };
                        } else {
                            debugs[set] = function() {};
                        }
                    }
                    return debugs[set];
                };
                /**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */ /* legacy: obj, showHidden, depth, colors*/ function inspect(obj, opts) {
                    // default options
                    var ctx = {
                        seen: [],
                        stylize: stylizeNoColor
                    };
                    // legacy...
                    if (arguments.length >= 3) ctx.depth = arguments[2];
                    if (arguments.length >= 4) ctx.colors = arguments[3];
                    if (isBoolean(opts)) {
                        // legacy...
                        ctx.showHidden = opts;
                    } else if (opts) {
                        // got an "options" object
                        exports1._extend(ctx, opts);
                    }
                    // set default options
                    if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
                    if (isUndefined(ctx.depth)) ctx.depth = 2;
                    if (isUndefined(ctx.colors)) ctx.colors = false;
                    if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
                    if (ctx.colors) ctx.stylize = stylizeWithColor;
                    return formatValue(ctx, obj, ctx.depth);
                }
                exports1.inspect = inspect;
                // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
                inspect.colors = {
                    'bold': [
                        1,
                        22
                    ],
                    'italic': [
                        3,
                        23
                    ],
                    'underline': [
                        4,
                        24
                    ],
                    'inverse': [
                        7,
                        27
                    ],
                    'white': [
                        37,
                        39
                    ],
                    'grey': [
                        90,
                        39
                    ],
                    'black': [
                        30,
                        39
                    ],
                    'blue': [
                        34,
                        39
                    ],
                    'cyan': [
                        36,
                        39
                    ],
                    'green': [
                        32,
                        39
                    ],
                    'magenta': [
                        35,
                        39
                    ],
                    'red': [
                        31,
                        39
                    ],
                    'yellow': [
                        33,
                        39
                    ]
                };
                // Don't use 'blue' not visible on cmd.exe
                inspect.styles = {
                    'special': 'cyan',
                    'number': 'yellow',
                    'boolean': 'yellow',
                    'undefined': 'grey',
                    'null': 'bold',
                    'string': 'green',
                    'date': 'magenta',
                    // "name": intentionally not styling
                    'regexp': 'red'
                };
                function stylizeWithColor(str, styleType) {
                    var style = inspect.styles[styleType];
                    if (style) {
                        return '\u001b[' + inspect.colors[style][0] + 'm' + str + '\u001b[' + inspect.colors[style][1] + 'm';
                    } else {
                        return str;
                    }
                }
                function stylizeNoColor(str, styleType) {
                    return str;
                }
                function arrayToHash(array) {
                    var hash = {};
                    array.forEach(function(val, idx) {
                        hash[val] = true;
                    });
                    return hash;
                }
                function formatValue(ctx, value, recurseTimes) {
                    // Provide a hook for user-specified inspect functions.
                    // Check that value is an object with an inspect function on it
                    if (ctx.customInspect && value && isFunction(value.inspect) && // Filter out the util module, it's inspect function is special
                    value.inspect !== exports1.inspect && // Also filter out any prototype objects using the circular check.
                    !(value.constructor && value.constructor.prototype === value)) {
                        var ret = value.inspect(recurseTimes, ctx);
                        if (!isString(ret)) {
                            ret = formatValue(ctx, ret, recurseTimes);
                        }
                        return ret;
                    }
                    // Primitive types cannot have properties
                    var primitive = formatPrimitive(ctx, value);
                    if (primitive) {
                        return primitive;
                    }
                    // Look up the keys of the object.
                    var keys = Object.keys(value);
                    var visibleKeys = arrayToHash(keys);
                    if (ctx.showHidden) {
                        keys = Object.getOwnPropertyNames(value);
                    }
                    // IE doesn't make error fields non-enumerable
                    // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
                    if (isError(value) && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
                        return formatError(value);
                    }
                    // Some type of object without properties can be shortcutted.
                    if (keys.length === 0) {
                        if (isFunction(value)) {
                            var name = value.name ? ': ' + value.name : '';
                            return ctx.stylize('[Function' + name + ']', 'special');
                        }
                        if (isRegExp(value)) {
                            return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
                        }
                        if (isDate(value)) {
                            return ctx.stylize(Date.prototype.toString.call(value), 'date');
                        }
                        if (isError(value)) {
                            return formatError(value);
                        }
                    }
                    var base = '', array = false, braces = [
                        '{',
                        '}'
                    ];
                    // Make Array say that they are Array
                    if (isArray(value)) {
                        array = true;
                        braces = [
                            '[',
                            ']'
                        ];
                    }
                    // Make functions say that they are functions
                    if (isFunction(value)) {
                        var n = value.name ? ': ' + value.name : '';
                        base = ' [Function' + n + ']';
                    }
                    // Make RegExps say that they are RegExps
                    if (isRegExp(value)) {
                        base = ' ' + RegExp.prototype.toString.call(value);
                    }
                    // Make dates with properties first say the date
                    if (isDate(value)) {
                        base = ' ' + Date.prototype.toUTCString.call(value);
                    }
                    // Make error with message first say the error
                    if (isError(value)) {
                        base = ' ' + formatError(value);
                    }
                    if (keys.length === 0 && (!array || value.length == 0)) {
                        return braces[0] + base + braces[1];
                    }
                    if (recurseTimes < 0) {
                        if (isRegExp(value)) {
                            return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
                        } else {
                            return ctx.stylize('[Object]', 'special');
                        }
                    }
                    ctx.seen.push(value);
                    var output;
                    if (array) {
                        output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
                    } else {
                        output = keys.map(function(key) {
                            return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
                        });
                    }
                    ctx.seen.pop();
                    return reduceToSingleString(output, base, braces);
                }
                function formatPrimitive(ctx, value) {
                    if (isUndefined(value)) return ctx.stylize('undefined', 'undefined');
                    if (isString(value)) {
                        var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"') + '\'';
                        return ctx.stylize(simple, 'string');
                    }
                    if (isNumber(value)) return ctx.stylize('' + value, 'number');
                    if (isBoolean(value)) return ctx.stylize('' + value, 'boolean');
                    // For some reason typeof null is "object", so special case here.
                    if (isNull(value)) return ctx.stylize('null', 'null');
                }
                function formatError(value) {
                    return '[' + Error.prototype.toString.call(value) + ']';
                }
                function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
                    var output = [];
                    for(var i = 0, l = value.length; i < l; ++i){
                        if (hasOwnProperty(value, String(i))) {
                            output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
                        } else {
                            output.push('');
                        }
                    }
                    keys.forEach(function(key) {
                        if (!key.match(/^\d+$/)) {
                            output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
                        }
                    });
                    return output;
                }
                function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
                    var name, str, desc;
                    desc = Object.getOwnPropertyDescriptor(value, key) || {
                        value: value[key]
                    };
                    if (desc.get) {
                        if (desc.set) {
                            str = ctx.stylize('[Getter/Setter]', 'special');
                        } else {
                            str = ctx.stylize('[Getter]', 'special');
                        }
                    } else {
                        if (desc.set) {
                            str = ctx.stylize('[Setter]', 'special');
                        }
                    }
                    if (!hasOwnProperty(visibleKeys, key)) {
                        name = '[' + key + ']';
                    }
                    if (!str) {
                        if (ctx.seen.indexOf(desc.value) < 0) {
                            if (isNull(recurseTimes)) {
                                str = formatValue(ctx, desc.value, null);
                            } else {
                                str = formatValue(ctx, desc.value, recurseTimes - 1);
                            }
                            if (str.indexOf('\n') > -1) {
                                if (array) {
                                    str = str.split('\n').map(function(line) {
                                        return '  ' + line;
                                    }).join('\n').slice(2);
                                } else {
                                    str = '\n' + str.split('\n').map(function(line) {
                                        return '   ' + line;
                                    }).join('\n');
                                }
                            }
                        } else {
                            str = ctx.stylize('[Circular]', 'special');
                        }
                    }
                    if (isUndefined(name)) {
                        if (array && key.match(/^\d+$/)) {
                            return str;
                        }
                        name = JSON.stringify('' + key);
                        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
                            name = name.slice(1, -1);
                            name = ctx.stylize(name, 'name');
                        } else {
                            name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
                            name = ctx.stylize(name, 'string');
                        }
                    }
                    return name + ': ' + str;
                }
                function reduceToSingleString(output, base, braces) {
                    var numLinesEst = 0;
                    var length = output.reduce(function(prev, cur) {
                        numLinesEst++;
                        if (cur.indexOf('\n') >= 0) numLinesEst++;
                        return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
                    }, 0);
                    if (length > 60) {
                        return braces[0] + (base === '' ? '' : base + '\n ') + ' ' + output.join(',\n  ') + ' ' + braces[1];
                    }
                    return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
                }
                // NOTE: These type checking functions intentionally don't use `instanceof`
                // because it is fragile and can be easily faked with `Object.create()`.
                exports1.types = __nested_webpack_require_224068__(1531);
                function isArray(ar) {
                    return Array.isArray(ar);
                }
                exports1.isArray = isArray;
                function isBoolean(arg) {
                    return typeof arg === 'boolean';
                }
                exports1.isBoolean = isBoolean;
                function isNull(arg) {
                    return arg === null;
                }
                exports1.isNull = isNull;
                function isNullOrUndefined(arg) {
                    return arg == null;
                }
                exports1.isNullOrUndefined = isNullOrUndefined;
                function isNumber(arg) {
                    return typeof arg === 'number';
                }
                exports1.isNumber = isNumber;
                function isString(arg) {
                    return typeof arg === 'string';
                }
                exports1.isString = isString;
                function isSymbol(arg) {
                    return typeof arg === 'symbol';
                }
                exports1.isSymbol = isSymbol;
                function isUndefined(arg) {
                    return arg === void 0;
                }
                exports1.isUndefined = isUndefined;
                function isRegExp(re) {
                    return isObject(re) && objectToString(re) === '[object RegExp]';
                }
                exports1.isRegExp = isRegExp;
                exports1.types.isRegExp = isRegExp;
                function isObject(arg) {
                    return typeof arg === 'object' && arg !== null;
                }
                exports1.isObject = isObject;
                function isDate(d) {
                    return isObject(d) && objectToString(d) === '[object Date]';
                }
                exports1.isDate = isDate;
                exports1.types.isDate = isDate;
                function isError(e) {
                    return isObject(e) && (objectToString(e) === '[object Error]' || e instanceof Error);
                }
                exports1.isError = isError;
                exports1.types.isNativeError = isError;
                function isFunction(arg) {
                    return typeof arg === 'function';
                }
                exports1.isFunction = isFunction;
                function isPrimitive(arg) {
                    return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || typeof arg === 'symbol' || // ES6 symbol
                    typeof arg === 'undefined';
                }
                exports1.isPrimitive = isPrimitive;
                exports1.isBuffer = __nested_webpack_require_224068__(5272);
                function objectToString(o) {
                    return Object.prototype.toString.call(o);
                }
                function pad(n) {
                    return n < 10 ? '0' + n.toString(10) : n.toString(10);
                }
                var months = [
                    'Jan',
                    'Feb',
                    'Mar',
                    'Apr',
                    'May',
                    'Jun',
                    'Jul',
                    'Aug',
                    'Sep',
                    'Oct',
                    'Nov',
                    'Dec'
                ];
                // 26 Feb 16:19:34
                function timestamp() {
                    var d = new Date();
                    var time = [
                        pad(d.getHours()),
                        pad(d.getMinutes()),
                        pad(d.getSeconds())
                    ].join(':');
                    return [
                        d.getDate(),
                        months[d.getMonth()],
                        time
                    ].join(' ');
                }
                // log is just a thin wrapper to console.log that prepends a timestamp
                exports1.log = function() {
                    console.log('%s - %s', timestamp(), exports1.format.apply(exports1, arguments));
                };
                /**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */ exports1.inherits = __nested_webpack_require_224068__(5615);
                exports1._extend = function(origin, add) {
                    // Don't do anything if add isn't an object
                    if (!add || !isObject(add)) return origin;
                    var keys = Object.keys(add);
                    var i = keys.length;
                    while(i--){
                        origin[keys[i]] = add[keys[i]];
                    }
                    return origin;
                };
                function hasOwnProperty(obj, prop) {
                    return Object.prototype.hasOwnProperty.call(obj, prop);
                }
                var kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;
                exports1.promisify = function promisify(original) {
                    if (typeof original !== 'function') throw new TypeError('The "original" argument must be of type Function');
                    if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
                        var fn = original[kCustomPromisifiedSymbol];
                        if (typeof fn !== 'function') {
                            throw new TypeError('The "util.promisify.custom" argument must be of type Function');
                        }
                        Object.defineProperty(fn, kCustomPromisifiedSymbol, {
                            value: fn,
                            enumerable: false,
                            writable: false,
                            configurable: true
                        });
                        return fn;
                    }
                    function fn() {
                        var promiseResolve, promiseReject;
                        var promise = new Promise(function(resolve, reject) {
                            promiseResolve = resolve;
                            promiseReject = reject;
                        });
                        var args = [];
                        for(var i = 0; i < arguments.length; i++){
                            args.push(arguments[i]);
                        }
                        args.push(function(err, value) {
                            if (err) {
                                promiseReject(err);
                            } else {
                                promiseResolve(value);
                            }
                        });
                        try {
                            original.apply(this, args);
                        } catch (err) {
                            promiseReject(err);
                        }
                        return promise;
                    }
                    Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
                    if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
                        value: fn,
                        enumerable: false,
                        writable: false,
                        configurable: true
                    });
                    return Object.defineProperties(fn, getOwnPropertyDescriptors(original));
                };
                exports1.promisify.custom = kCustomPromisifiedSymbol;
                function callbackifyOnRejected(reason, cb) {
                    // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).
                    // Because `null` is a special error value in callbacks which means "no error
                    // occurred", we error-wrap so the callback consumer can distinguish between
                    // "the promise rejected with null" or "the promise fulfilled with undefined".
                    if (!reason) {
                        var newReason = new Error('Promise was rejected with a falsy value');
                        newReason.reason = reason;
                        reason = newReason;
                    }
                    return cb(reason);
                }
                function callbackify(original) {
                    if (typeof original !== 'function') {
                        throw new TypeError('The "original" argument must be of type Function');
                    }
                    // We DO NOT return the promise as it gives the user a false sense that
                    // the promise is actually somehow related to the callback's execution
                    // and that the callback throwing will reject the promise.
                    function callbackified() {
                        var args = [];
                        for(var i = 0; i < arguments.length; i++){
                            args.push(arguments[i]);
                        }
                        var maybeCb = args.pop();
                        if (typeof maybeCb !== 'function') {
                            throw new TypeError('The last argument must be of type Function');
                        }
                        var self = this;
                        var cb = function() {
                            return maybeCb.apply(self, arguments);
                        };
                        // In true node style we process the callback on `nextTick` with all the
                        // implications (stack, `uncaughtException`, `async_hooks`)
                        original.apply(this, args).then(function(ret) {
                            process.nextTick(cb.bind(null, null, ret));
                        }, function(rej) {
                            process.nextTick(callbackifyOnRejected.bind(null, rej, cb));
                        });
                    }
                    Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
                    Object.defineProperties(callbackified, getOwnPropertyDescriptors(original));
                    return callbackified;
                }
                exports1.callbackify = callbackify;
            /***/ },
            /***/ 9208: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_255666__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ----------------------------------------------------------------------------------------- */ module1.exports = __nested_webpack_require_255666__(9110);
            /***/ },
            /***/ 9110: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_256225__) {
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
                    if (k2 === undefined) k2 = k;
                    var desc = Object.getOwnPropertyDescriptor(m, k);
                    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
                        desc = {
                            enumerable: true,
                            get: function() {
                                return m[k];
                            }
                        };
                    }
                    Object.defineProperty(o, k2, desc);
                } : function(o, m, k, k2) {
                    if (k2 === undefined) k2 = k;
                    o[k2] = m[k];
                });
                var __exportStar = this && this.__exportStar || function(m, exports1) {
                    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
                };
                Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.createMessageConnection = exports1.BrowserMessageWriter = exports1.BrowserMessageReader = void 0;
                const ril_1 = __nested_webpack_require_256225__(3312);
                // Install the browser runtime abstract.
                ril_1.default.install();
                const api_1 = __nested_webpack_require_256225__(7672);
                __exportStar(__nested_webpack_require_256225__(7672), exports1);
                class BrowserMessageReader extends api_1.AbstractMessageReader {
                    listen(callback) {
                        return this._onData.event(callback);
                    }
                    constructor(port){
                        super();
                        this._onData = new api_1.Emitter();
                        this._messageListener = (event)=>{
                            this._onData.fire(event.data);
                        };
                        port.addEventListener('error', (event)=>this.fireError(event));
                        port.onmessage = this._messageListener;
                    }
                }
                exports1.BrowserMessageReader = BrowserMessageReader;
                class BrowserMessageWriter extends api_1.AbstractMessageWriter {
                    write(msg) {
                        try {
                            this.port.postMessage(msg);
                            return Promise.resolve();
                        } catch (error) {
                            this.handleError(error, msg);
                            return Promise.reject(error);
                        }
                    }
                    handleError(error, msg) {
                        this.errorCount++;
                        this.fireError(error, msg, this.errorCount);
                    }
                    end() {}
                    constructor(port){
                        super();
                        this.port = port;
                        this.errorCount = 0;
                        port.addEventListener('error', (event)=>this.fireError(event));
                    }
                }
                exports1.BrowserMessageWriter = BrowserMessageWriter;
                function createMessageConnection(reader, writer, logger, options) {
                    if (logger === undefined) {
                        logger = api_1.NullLogger;
                    }
                    if (api_1.ConnectionStrategy.is(options)) {
                        options = {
                            connectionStrategy: options
                        };
                    }
                    return (0, api_1.createMessageConnection)(reader, writer, logger, options);
                }
                exports1.createMessageConnection = createMessageConnection;
            /***/ },
            /***/ 3312: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_260640__)=>{
                "use strict";
                /* provided dependency */ var console = __nested_webpack_require_260640__(4364);
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                const api_1 = __nested_webpack_require_260640__(7672);
                class MessageBuffer extends api_1.AbstractMessageBuffer {
                    emptyBuffer() {
                        return MessageBuffer.emptyBuffer;
                    }
                    fromString(value, _encoding) {
                        return new TextEncoder().encode(value);
                    }
                    toString(value, encoding) {
                        if (encoding === 'ascii') {
                            return this.asciiDecoder.decode(value);
                        } else {
                            return new TextDecoder(encoding).decode(value);
                        }
                    }
                    asNative(buffer, length) {
                        if (length === undefined) {
                            return buffer;
                        } else {
                            return buffer.slice(0, length);
                        }
                    }
                    allocNative(length) {
                        return new Uint8Array(length);
                    }
                    constructor(encoding = 'utf-8'){
                        super(encoding);
                        this.asciiDecoder = new TextDecoder('ascii');
                    }
                }
                MessageBuffer.emptyBuffer = new Uint8Array(0);
                class ReadableStreamWrapper {
                    onClose(listener) {
                        this.socket.addEventListener('close', listener);
                        return api_1.Disposable.create(()=>this.socket.removeEventListener('close', listener));
                    }
                    onError(listener) {
                        this.socket.addEventListener('error', listener);
                        return api_1.Disposable.create(()=>this.socket.removeEventListener('error', listener));
                    }
                    onEnd(listener) {
                        this.socket.addEventListener('end', listener);
                        return api_1.Disposable.create(()=>this.socket.removeEventListener('end', listener));
                    }
                    onData(listener) {
                        return this._onData.event(listener);
                    }
                    constructor(socket){
                        this.socket = socket;
                        this._onData = new api_1.Emitter();
                        this._messageListener = (event)=>{
                            const blob = event.data;
                            blob.arrayBuffer().then((buffer)=>{
                                this._onData.fire(new Uint8Array(buffer));
                            }, ()=>{
                                (0, api_1.RAL)().console.error(`Converting blob to array buffer failed.`);
                            });
                        };
                        this.socket.addEventListener('message', this._messageListener);
                    }
                }
                class WritableStreamWrapper {
                    onClose(listener) {
                        this.socket.addEventListener('close', listener);
                        return api_1.Disposable.create(()=>this.socket.removeEventListener('close', listener));
                    }
                    onError(listener) {
                        this.socket.addEventListener('error', listener);
                        return api_1.Disposable.create(()=>this.socket.removeEventListener('error', listener));
                    }
                    onEnd(listener) {
                        this.socket.addEventListener('end', listener);
                        return api_1.Disposable.create(()=>this.socket.removeEventListener('end', listener));
                    }
                    write(data, encoding) {
                        if (typeof data === 'string') {
                            if (encoding !== undefined && encoding !== 'utf-8') {
                                throw new Error(`In a Browser environments only utf-8 text encoding is supported. But got encoding: ${encoding}`);
                            }
                            this.socket.send(data);
                        } else {
                            this.socket.send(data);
                        }
                        return Promise.resolve();
                    }
                    end() {
                        this.socket.close();
                    }
                    constructor(socket){
                        this.socket = socket;
                    }
                }
                const _textEncoder = new TextEncoder();
                const _ril = Object.freeze({
                    messageBuffer: Object.freeze({
                        create: (encoding)=>new MessageBuffer(encoding)
                    }),
                    applicationJson: Object.freeze({
                        encoder: Object.freeze({
                            name: 'application/json',
                            encode: (msg, options)=>{
                                if (options.charset !== 'utf-8') {
                                    throw new Error(`In a Browser environments only utf-8 text encoding is supported. But got encoding: ${options.charset}`);
                                }
                                return Promise.resolve(_textEncoder.encode(JSON.stringify(msg, undefined, 0)));
                            }
                        }),
                        decoder: Object.freeze({
                            name: 'application/json',
                            decode: (buffer, options)=>{
                                if (!(buffer instanceof Uint8Array)) {
                                    throw new Error(`In a Browser environments only Uint8Arrays are supported.`);
                                }
                                return Promise.resolve(JSON.parse(new TextDecoder(options.charset).decode(buffer)));
                            }
                        })
                    }),
                    stream: Object.freeze({
                        asReadableStream: (socket)=>new ReadableStreamWrapper(socket),
                        asWritableStream: (socket)=>new WritableStreamWrapper(socket)
                    }),
                    console: console,
                    timer: Object.freeze({
                        setTimeout (callback, ms, ...args) {
                            const handle = setTimeout(callback, ms, ...args);
                            return {
                                dispose: ()=>clearTimeout(handle)
                            };
                        },
                        setImmediate (callback, ...args) {
                            const handle = setTimeout(callback, 0, ...args);
                            return {
                                dispose: ()=>clearTimeout(handle)
                            };
                        },
                        setInterval (callback, ms, ...args) {
                            const handle = setInterval(callback, ms, ...args);
                            return {
                                dispose: ()=>clearInterval(handle)
                            };
                        }
                    })
                });
                function RIL() {
                    return _ril;
                }
                (function(RIL) {
                    function install() {
                        api_1.RAL.install(_ril);
                    }
                    RIL.install = install;
                })(RIL || (RIL = {}));
                exports1["default"] = RIL;
            /***/ },
            /***/ 7672: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_269019__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ /// <reference path="../../typings/thenable.d.ts" />
                Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.ProgressType = exports1.ProgressToken = exports1.createMessageConnection = exports1.NullLogger = exports1.ConnectionOptions = exports1.ConnectionStrategy = exports1.AbstractMessageBuffer = exports1.WriteableStreamMessageWriter = exports1.AbstractMessageWriter = exports1.MessageWriter = exports1.ReadableStreamMessageReader = exports1.AbstractMessageReader = exports1.MessageReader = exports1.SharedArrayReceiverStrategy = exports1.SharedArraySenderStrategy = exports1.CancellationToken = exports1.CancellationTokenSource = exports1.Emitter = exports1.Event = exports1.Disposable = exports1.LRUCache = exports1.Touch = exports1.LinkedMap = exports1.ParameterStructures = exports1.NotificationType9 = exports1.NotificationType8 = exports1.NotificationType7 = exports1.NotificationType6 = exports1.NotificationType5 = exports1.NotificationType4 = exports1.NotificationType3 = exports1.NotificationType2 = exports1.NotificationType1 = exports1.NotificationType0 = exports1.NotificationType = exports1.ErrorCodes = exports1.ResponseError = exports1.RequestType9 = exports1.RequestType8 = exports1.RequestType7 = exports1.RequestType6 = exports1.RequestType5 = exports1.RequestType4 = exports1.RequestType3 = exports1.RequestType2 = exports1.RequestType1 = exports1.RequestType0 = exports1.RequestType = exports1.Message = exports1.RAL = void 0;
                exports1.MessageStrategy = exports1.CancellationStrategy = exports1.CancellationSenderStrategy = exports1.CancellationReceiverStrategy = exports1.ConnectionError = exports1.ConnectionErrors = exports1.LogTraceNotification = exports1.SetTraceNotification = exports1.TraceFormat = exports1.TraceValues = exports1.Trace = void 0;
                const messages_1 = __nested_webpack_require_269019__(7162);
                Object.defineProperty(exports1, "Message", {
                    enumerable: true,
                    get: function() {
                        return messages_1.Message;
                    }
                });
                Object.defineProperty(exports1, "RequestType", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType;
                    }
                });
                Object.defineProperty(exports1, "RequestType0", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType0;
                    }
                });
                Object.defineProperty(exports1, "RequestType1", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType1;
                    }
                });
                Object.defineProperty(exports1, "RequestType2", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType2;
                    }
                });
                Object.defineProperty(exports1, "RequestType3", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType3;
                    }
                });
                Object.defineProperty(exports1, "RequestType4", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType4;
                    }
                });
                Object.defineProperty(exports1, "RequestType5", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType5;
                    }
                });
                Object.defineProperty(exports1, "RequestType6", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType6;
                    }
                });
                Object.defineProperty(exports1, "RequestType7", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType7;
                    }
                });
                Object.defineProperty(exports1, "RequestType8", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType8;
                    }
                });
                Object.defineProperty(exports1, "RequestType9", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType9;
                    }
                });
                Object.defineProperty(exports1, "ResponseError", {
                    enumerable: true,
                    get: function() {
                        return messages_1.ResponseError;
                    }
                });
                Object.defineProperty(exports1, "ErrorCodes", {
                    enumerable: true,
                    get: function() {
                        return messages_1.ErrorCodes;
                    }
                });
                Object.defineProperty(exports1, "NotificationType", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType;
                    }
                });
                Object.defineProperty(exports1, "NotificationType0", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType0;
                    }
                });
                Object.defineProperty(exports1, "NotificationType1", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType1;
                    }
                });
                Object.defineProperty(exports1, "NotificationType2", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType2;
                    }
                });
                Object.defineProperty(exports1, "NotificationType3", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType3;
                    }
                });
                Object.defineProperty(exports1, "NotificationType4", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType4;
                    }
                });
                Object.defineProperty(exports1, "NotificationType5", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType5;
                    }
                });
                Object.defineProperty(exports1, "NotificationType6", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType6;
                    }
                });
                Object.defineProperty(exports1, "NotificationType7", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType7;
                    }
                });
                Object.defineProperty(exports1, "NotificationType8", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType8;
                    }
                });
                Object.defineProperty(exports1, "NotificationType9", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType9;
                    }
                });
                Object.defineProperty(exports1, "ParameterStructures", {
                    enumerable: true,
                    get: function() {
                        return messages_1.ParameterStructures;
                    }
                });
                const linkedMap_1 = __nested_webpack_require_269019__(1109);
                Object.defineProperty(exports1, "LinkedMap", {
                    enumerable: true,
                    get: function() {
                        return linkedMap_1.LinkedMap;
                    }
                });
                Object.defineProperty(exports1, "LRUCache", {
                    enumerable: true,
                    get: function() {
                        return linkedMap_1.LRUCache;
                    }
                });
                Object.defineProperty(exports1, "Touch", {
                    enumerable: true,
                    get: function() {
                        return linkedMap_1.Touch;
                    }
                });
                const disposable_1 = __nested_webpack_require_269019__(8844);
                Object.defineProperty(exports1, "Disposable", {
                    enumerable: true,
                    get: function() {
                        return disposable_1.Disposable;
                    }
                });
                const events_1 = __nested_webpack_require_269019__(2479);
                Object.defineProperty(exports1, "Event", {
                    enumerable: true,
                    get: function() {
                        return events_1.Event;
                    }
                });
                Object.defineProperty(exports1, "Emitter", {
                    enumerable: true,
                    get: function() {
                        return events_1.Emitter;
                    }
                });
                const cancellation_1 = __nested_webpack_require_269019__(6957);
                Object.defineProperty(exports1, "CancellationTokenSource", {
                    enumerable: true,
                    get: function() {
                        return cancellation_1.CancellationTokenSource;
                    }
                });
                Object.defineProperty(exports1, "CancellationToken", {
                    enumerable: true,
                    get: function() {
                        return cancellation_1.CancellationToken;
                    }
                });
                const sharedArrayCancellation_1 = __nested_webpack_require_269019__(3489);
                Object.defineProperty(exports1, "SharedArraySenderStrategy", {
                    enumerable: true,
                    get: function() {
                        return sharedArrayCancellation_1.SharedArraySenderStrategy;
                    }
                });
                Object.defineProperty(exports1, "SharedArrayReceiverStrategy", {
                    enumerable: true,
                    get: function() {
                        return sharedArrayCancellation_1.SharedArrayReceiverStrategy;
                    }
                });
                const messageReader_1 = __nested_webpack_require_269019__(656);
                Object.defineProperty(exports1, "MessageReader", {
                    enumerable: true,
                    get: function() {
                        return messageReader_1.MessageReader;
                    }
                });
                Object.defineProperty(exports1, "AbstractMessageReader", {
                    enumerable: true,
                    get: function() {
                        return messageReader_1.AbstractMessageReader;
                    }
                });
                Object.defineProperty(exports1, "ReadableStreamMessageReader", {
                    enumerable: true,
                    get: function() {
                        return messageReader_1.ReadableStreamMessageReader;
                    }
                });
                const messageWriter_1 = __nested_webpack_require_269019__(9036);
                Object.defineProperty(exports1, "MessageWriter", {
                    enumerable: true,
                    get: function() {
                        return messageWriter_1.MessageWriter;
                    }
                });
                Object.defineProperty(exports1, "AbstractMessageWriter", {
                    enumerable: true,
                    get: function() {
                        return messageWriter_1.AbstractMessageWriter;
                    }
                });
                Object.defineProperty(exports1, "WriteableStreamMessageWriter", {
                    enumerable: true,
                    get: function() {
                        return messageWriter_1.WriteableStreamMessageWriter;
                    }
                });
                const messageBuffer_1 = __nested_webpack_require_269019__(9805);
                Object.defineProperty(exports1, "AbstractMessageBuffer", {
                    enumerable: true,
                    get: function() {
                        return messageBuffer_1.AbstractMessageBuffer;
                    }
                });
                const connection_1 = __nested_webpack_require_269019__(4054);
                Object.defineProperty(exports1, "ConnectionStrategy", {
                    enumerable: true,
                    get: function() {
                        return connection_1.ConnectionStrategy;
                    }
                });
                Object.defineProperty(exports1, "ConnectionOptions", {
                    enumerable: true,
                    get: function() {
                        return connection_1.ConnectionOptions;
                    }
                });
                Object.defineProperty(exports1, "NullLogger", {
                    enumerable: true,
                    get: function() {
                        return connection_1.NullLogger;
                    }
                });
                Object.defineProperty(exports1, "createMessageConnection", {
                    enumerable: true,
                    get: function() {
                        return connection_1.createMessageConnection;
                    }
                });
                Object.defineProperty(exports1, "ProgressToken", {
                    enumerable: true,
                    get: function() {
                        return connection_1.ProgressToken;
                    }
                });
                Object.defineProperty(exports1, "ProgressType", {
                    enumerable: true,
                    get: function() {
                        return connection_1.ProgressType;
                    }
                });
                Object.defineProperty(exports1, "Trace", {
                    enumerable: true,
                    get: function() {
                        return connection_1.Trace;
                    }
                });
                Object.defineProperty(exports1, "TraceValues", {
                    enumerable: true,
                    get: function() {
                        return connection_1.TraceValues;
                    }
                });
                Object.defineProperty(exports1, "TraceFormat", {
                    enumerable: true,
                    get: function() {
                        return connection_1.TraceFormat;
                    }
                });
                Object.defineProperty(exports1, "SetTraceNotification", {
                    enumerable: true,
                    get: function() {
                        return connection_1.SetTraceNotification;
                    }
                });
                Object.defineProperty(exports1, "LogTraceNotification", {
                    enumerable: true,
                    get: function() {
                        return connection_1.LogTraceNotification;
                    }
                });
                Object.defineProperty(exports1, "ConnectionErrors", {
                    enumerable: true,
                    get: function() {
                        return connection_1.ConnectionErrors;
                    }
                });
                Object.defineProperty(exports1, "ConnectionError", {
                    enumerable: true,
                    get: function() {
                        return connection_1.ConnectionError;
                    }
                });
                Object.defineProperty(exports1, "CancellationReceiverStrategy", {
                    enumerable: true,
                    get: function() {
                        return connection_1.CancellationReceiverStrategy;
                    }
                });
                Object.defineProperty(exports1, "CancellationSenderStrategy", {
                    enumerable: true,
                    get: function() {
                        return connection_1.CancellationSenderStrategy;
                    }
                });
                Object.defineProperty(exports1, "CancellationStrategy", {
                    enumerable: true,
                    get: function() {
                        return connection_1.CancellationStrategy;
                    }
                });
                Object.defineProperty(exports1, "MessageStrategy", {
                    enumerable: true,
                    get: function() {
                        return connection_1.MessageStrategy;
                    }
                });
                const ral_1 = __nested_webpack_require_269019__(5091);
                exports1.RAL = ral_1.default;
            /***/ },
            /***/ 6957: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_287083__)=>{
                "use strict";
                /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.CancellationTokenSource = exports1.CancellationToken = void 0;
                const ral_1 = __nested_webpack_require_287083__(5091);
                const Is = __nested_webpack_require_287083__(6618);
                const events_1 = __nested_webpack_require_287083__(2479);
                var CancellationToken;
                (function(CancellationToken) {
                    CancellationToken.None = Object.freeze({
                        isCancellationRequested: false,
                        onCancellationRequested: events_1.Event.None
                    });
                    CancellationToken.Cancelled = Object.freeze({
                        isCancellationRequested: true,
                        onCancellationRequested: events_1.Event.None
                    });
                    function is(value) {
                        const candidate = value;
                        return candidate && (candidate === CancellationToken.None || candidate === CancellationToken.Cancelled || Is.boolean(candidate.isCancellationRequested) && !!candidate.onCancellationRequested);
                    }
                    CancellationToken.is = is;
                })(CancellationToken = exports1.CancellationToken || (exports1.CancellationToken = {}));
                const shortcutEvent = Object.freeze(function(callback, context) {
                    const handle = (0, ral_1.default)().timer.setTimeout(callback.bind(context), 0);
                    return {
                        dispose () {
                            handle.dispose();
                        }
                    };
                });
                class MutableToken {
                    cancel() {
                        if (!this._isCancelled) {
                            this._isCancelled = true;
                            if (this._emitter) {
                                this._emitter.fire(undefined);
                                this.dispose();
                            }
                        }
                    }
                    get isCancellationRequested() {
                        return this._isCancelled;
                    }
                    get onCancellationRequested() {
                        if (this._isCancelled) {
                            return shortcutEvent;
                        }
                        if (!this._emitter) {
                            this._emitter = new events_1.Emitter();
                        }
                        return this._emitter.event;
                    }
                    dispose() {
                        if (this._emitter) {
                            this._emitter.dispose();
                            this._emitter = undefined;
                        }
                    }
                    constructor(){
                        this._isCancelled = false;
                    }
                }
                class CancellationTokenSource {
                    get token() {
                        if (!this._token) {
                            // be lazy and create the token only when
                            // actually needed
                            this._token = new MutableToken();
                        }
                        return this._token;
                    }
                    cancel() {
                        if (!this._token) {
                            // save an object by returning the default
                            // cancelled token when cancellation happens
                            // before someone asks for the token
                            this._token = CancellationToken.Cancelled;
                        } else {
                            this._token.cancel();
                        }
                    }
                    dispose() {
                        if (!this._token) {
                            // ensure to initialize with an empty token if we had none
                            this._token = CancellationToken.None;
                        } else if (this._token instanceof MutableToken) {
                            // actually dispose
                            this._token.dispose();
                        }
                    }
                }
                exports1.CancellationTokenSource = CancellationTokenSource;
            /***/ },
            /***/ 4054: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_292017__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.createMessageConnection = exports1.ConnectionOptions = exports1.MessageStrategy = exports1.CancellationStrategy = exports1.CancellationSenderStrategy = exports1.CancellationReceiverStrategy = exports1.RequestCancellationReceiverStrategy = exports1.IdCancellationReceiverStrategy = exports1.ConnectionStrategy = exports1.ConnectionError = exports1.ConnectionErrors = exports1.LogTraceNotification = exports1.SetTraceNotification = exports1.TraceFormat = exports1.TraceValues = exports1.Trace = exports1.NullLogger = exports1.ProgressType = exports1.ProgressToken = void 0;
                const ral_1 = __nested_webpack_require_292017__(5091);
                const Is = __nested_webpack_require_292017__(6618);
                const messages_1 = __nested_webpack_require_292017__(7162);
                const linkedMap_1 = __nested_webpack_require_292017__(1109);
                const events_1 = __nested_webpack_require_292017__(2479);
                const cancellation_1 = __nested_webpack_require_292017__(6957);
                var CancelNotification;
                (function(CancelNotification) {
                    CancelNotification.type = new messages_1.NotificationType('$/cancelRequest');
                })(CancelNotification || (CancelNotification = {}));
                var ProgressToken;
                (function(ProgressToken) {
                    function is(value) {
                        return typeof value === 'string' || typeof value === 'number';
                    }
                    ProgressToken.is = is;
                })(ProgressToken = exports1.ProgressToken || (exports1.ProgressToken = {}));
                var ProgressNotification;
                (function(ProgressNotification) {
                    ProgressNotification.type = new messages_1.NotificationType('$/progress');
                })(ProgressNotification || (ProgressNotification = {}));
                class ProgressType {
                    constructor(){}
                }
                exports1.ProgressType = ProgressType;
                var StarRequestHandler;
                (function(StarRequestHandler) {
                    function is(value) {
                        return Is.func(value);
                    }
                    StarRequestHandler.is = is;
                })(StarRequestHandler || (StarRequestHandler = {}));
                exports1.NullLogger = Object.freeze({
                    error: ()=>{},
                    warn: ()=>{},
                    info: ()=>{},
                    log: ()=>{}
                });
                var Trace;
                (function(Trace) {
                    Trace[Trace["Off"] = 0] = "Off";
                    Trace[Trace["Messages"] = 1] = "Messages";
                    Trace[Trace["Compact"] = 2] = "Compact";
                    Trace[Trace["Verbose"] = 3] = "Verbose";
                })(Trace = exports1.Trace || (exports1.Trace = {}));
                var TraceValues;
                (function(TraceValues) {
                    /**
     * Turn tracing off.
     */ TraceValues.Off = 'off';
                    /**
     * Trace messages only.
     */ TraceValues.Messages = 'messages';
                    /**
     * Compact message tracing.
     */ TraceValues.Compact = 'compact';
                    /**
     * Verbose message tracing.
     */ TraceValues.Verbose = 'verbose';
                })(TraceValues = exports1.TraceValues || (exports1.TraceValues = {}));
                (function(Trace) {
                    function fromString(value) {
                        if (!Is.string(value)) {
                            return Trace.Off;
                        }
                        value = value.toLowerCase();
                        switch(value){
                            case 'off':
                                return Trace.Off;
                            case 'messages':
                                return Trace.Messages;
                            case 'compact':
                                return Trace.Compact;
                            case 'verbose':
                                return Trace.Verbose;
                            default:
                                return Trace.Off;
                        }
                    }
                    Trace.fromString = fromString;
                    function toString(value) {
                        switch(value){
                            case Trace.Off:
                                return 'off';
                            case Trace.Messages:
                                return 'messages';
                            case Trace.Compact:
                                return 'compact';
                            case Trace.Verbose:
                                return 'verbose';
                            default:
                                return 'off';
                        }
                    }
                    Trace.toString = toString;
                })(Trace = exports1.Trace || (exports1.Trace = {}));
                var TraceFormat;
                (function(TraceFormat) {
                    TraceFormat["Text"] = "text";
                    TraceFormat["JSON"] = "json";
                })(TraceFormat = exports1.TraceFormat || (exports1.TraceFormat = {}));
                (function(TraceFormat) {
                    function fromString(value) {
                        if (!Is.string(value)) {
                            return TraceFormat.Text;
                        }
                        value = value.toLowerCase();
                        if (value === 'json') {
                            return TraceFormat.JSON;
                        } else {
                            return TraceFormat.Text;
                        }
                    }
                    TraceFormat.fromString = fromString;
                })(TraceFormat = exports1.TraceFormat || (exports1.TraceFormat = {}));
                var SetTraceNotification;
                (function(SetTraceNotification) {
                    SetTraceNotification.type = new messages_1.NotificationType('$/setTrace');
                })(SetTraceNotification = exports1.SetTraceNotification || (exports1.SetTraceNotification = {}));
                var LogTraceNotification;
                (function(LogTraceNotification) {
                    LogTraceNotification.type = new messages_1.NotificationType('$/logTrace');
                })(LogTraceNotification = exports1.LogTraceNotification || (exports1.LogTraceNotification = {}));
                var ConnectionErrors;
                (function(ConnectionErrors) {
                    /**
     * The connection is closed.
     */ ConnectionErrors[ConnectionErrors["Closed"] = 1] = "Closed";
                    /**
     * The connection got disposed.
     */ ConnectionErrors[ConnectionErrors["Disposed"] = 2] = "Disposed";
                    /**
     * The connection is already in listening mode.
     */ ConnectionErrors[ConnectionErrors["AlreadyListening"] = 3] = "AlreadyListening";
                })(ConnectionErrors = exports1.ConnectionErrors || (exports1.ConnectionErrors = {}));
                class ConnectionError extends Error {
                    constructor(code, message){
                        super(message);
                        this.code = code;
                        Object.setPrototypeOf(this, ConnectionError.prototype);
                    }
                }
                exports1.ConnectionError = ConnectionError;
                var ConnectionStrategy;
                (function(ConnectionStrategy) {
                    function is(value) {
                        const candidate = value;
                        return candidate && Is.func(candidate.cancelUndispatched);
                    }
                    ConnectionStrategy.is = is;
                })(ConnectionStrategy = exports1.ConnectionStrategy || (exports1.ConnectionStrategy = {}));
                var IdCancellationReceiverStrategy;
                (function(IdCancellationReceiverStrategy) {
                    function is(value) {
                        const candidate = value;
                        return candidate && (candidate.kind === undefined || candidate.kind === 'id') && Is.func(candidate.createCancellationTokenSource) && (candidate.dispose === undefined || Is.func(candidate.dispose));
                    }
                    IdCancellationReceiverStrategy.is = is;
                })(IdCancellationReceiverStrategy = exports1.IdCancellationReceiverStrategy || (exports1.IdCancellationReceiverStrategy = {}));
                var RequestCancellationReceiverStrategy;
                (function(RequestCancellationReceiverStrategy) {
                    function is(value) {
                        const candidate = value;
                        return candidate && candidate.kind === 'request' && Is.func(candidate.createCancellationTokenSource) && (candidate.dispose === undefined || Is.func(candidate.dispose));
                    }
                    RequestCancellationReceiverStrategy.is = is;
                })(RequestCancellationReceiverStrategy = exports1.RequestCancellationReceiverStrategy || (exports1.RequestCancellationReceiverStrategy = {}));
                var CancellationReceiverStrategy;
                (function(CancellationReceiverStrategy) {
                    CancellationReceiverStrategy.Message = Object.freeze({
                        createCancellationTokenSource (_) {
                            return new cancellation_1.CancellationTokenSource();
                        }
                    });
                    function is(value) {
                        return IdCancellationReceiverStrategy.is(value) || RequestCancellationReceiverStrategy.is(value);
                    }
                    CancellationReceiverStrategy.is = is;
                })(CancellationReceiverStrategy = exports1.CancellationReceiverStrategy || (exports1.CancellationReceiverStrategy = {}));
                var CancellationSenderStrategy;
                (function(CancellationSenderStrategy) {
                    CancellationSenderStrategy.Message = Object.freeze({
                        sendCancellation (conn, id) {
                            return conn.sendNotification(CancelNotification.type, {
                                id
                            });
                        },
                        cleanup (_) {}
                    });
                    function is(value) {
                        const candidate = value;
                        return candidate && Is.func(candidate.sendCancellation) && Is.func(candidate.cleanup);
                    }
                    CancellationSenderStrategy.is = is;
                })(CancellationSenderStrategy = exports1.CancellationSenderStrategy || (exports1.CancellationSenderStrategy = {}));
                var CancellationStrategy;
                (function(CancellationStrategy) {
                    CancellationStrategy.Message = Object.freeze({
                        receiver: CancellationReceiverStrategy.Message,
                        sender: CancellationSenderStrategy.Message
                    });
                    function is(value) {
                        const candidate = value;
                        return candidate && CancellationReceiverStrategy.is(candidate.receiver) && CancellationSenderStrategy.is(candidate.sender);
                    }
                    CancellationStrategy.is = is;
                })(CancellationStrategy = exports1.CancellationStrategy || (exports1.CancellationStrategy = {}));
                var MessageStrategy;
                (function(MessageStrategy) {
                    function is(value) {
                        const candidate = value;
                        return candidate && Is.func(candidate.handleMessage);
                    }
                    MessageStrategy.is = is;
                })(MessageStrategy = exports1.MessageStrategy || (exports1.MessageStrategy = {}));
                var ConnectionOptions;
                (function(ConnectionOptions) {
                    function is(value) {
                        const candidate = value;
                        return candidate && (CancellationStrategy.is(candidate.cancellationStrategy) || ConnectionStrategy.is(candidate.connectionStrategy) || MessageStrategy.is(candidate.messageStrategy));
                    }
                    ConnectionOptions.is = is;
                })(ConnectionOptions = exports1.ConnectionOptions || (exports1.ConnectionOptions = {}));
                var ConnectionState;
                (function(ConnectionState) {
                    ConnectionState[ConnectionState["New"] = 1] = "New";
                    ConnectionState[ConnectionState["Listening"] = 2] = "Listening";
                    ConnectionState[ConnectionState["Closed"] = 3] = "Closed";
                    ConnectionState[ConnectionState["Disposed"] = 4] = "Disposed";
                })(ConnectionState || (ConnectionState = {}));
                function createMessageConnection(messageReader, messageWriter, _logger, options) {
                    const logger = _logger !== undefined ? _logger : exports1.NullLogger;
                    let sequenceNumber = 0;
                    let notificationSequenceNumber = 0;
                    let unknownResponseSequenceNumber = 0;
                    const version = '2.0';
                    let starRequestHandler = undefined;
                    const requestHandlers = new Map();
                    let starNotificationHandler = undefined;
                    const notificationHandlers = new Map();
                    const progressHandlers = new Map();
                    let timer;
                    let messageQueue = new linkedMap_1.LinkedMap();
                    let responsePromises = new Map();
                    let knownCanceledRequests = new Set();
                    let requestTokens = new Map();
                    let trace = Trace.Off;
                    let traceFormat = TraceFormat.Text;
                    let tracer;
                    let state = ConnectionState.New;
                    const errorEmitter = new events_1.Emitter();
                    const closeEmitter = new events_1.Emitter();
                    const unhandledNotificationEmitter = new events_1.Emitter();
                    const unhandledProgressEmitter = new events_1.Emitter();
                    const disposeEmitter = new events_1.Emitter();
                    const cancellationStrategy = options && options.cancellationStrategy ? options.cancellationStrategy : CancellationStrategy.Message;
                    function createRequestQueueKey(id) {
                        if (id === null) {
                            throw new Error(`Can't send requests with id null since the response can't be correlated.`);
                        }
                        return 'req-' + id.toString();
                    }
                    function createResponseQueueKey(id) {
                        if (id === null) {
                            return 'res-unknown-' + (++unknownResponseSequenceNumber).toString();
                        } else {
                            return 'res-' + id.toString();
                        }
                    }
                    function createNotificationQueueKey() {
                        return 'not-' + (++notificationSequenceNumber).toString();
                    }
                    function addMessageToQueue(queue, message) {
                        if (messages_1.Message.isRequest(message)) {
                            queue.set(createRequestQueueKey(message.id), message);
                        } else if (messages_1.Message.isResponse(message)) {
                            queue.set(createResponseQueueKey(message.id), message);
                        } else {
                            queue.set(createNotificationQueueKey(), message);
                        }
                    }
                    function cancelUndispatched(_message) {
                        return undefined;
                    }
                    function isListening() {
                        return state === ConnectionState.Listening;
                    }
                    function isClosed() {
                        return state === ConnectionState.Closed;
                    }
                    function isDisposed() {
                        return state === ConnectionState.Disposed;
                    }
                    function closeHandler() {
                        if (state === ConnectionState.New || state === ConnectionState.Listening) {
                            state = ConnectionState.Closed;
                            closeEmitter.fire(undefined);
                        }
                    // If the connection is disposed don't sent close events.
                    }
                    function readErrorHandler(error) {
                        errorEmitter.fire([
                            error,
                            undefined,
                            undefined
                        ]);
                    }
                    function writeErrorHandler(data) {
                        errorEmitter.fire(data);
                    }
                    messageReader.onClose(closeHandler);
                    messageReader.onError(readErrorHandler);
                    messageWriter.onClose(closeHandler);
                    messageWriter.onError(writeErrorHandler);
                    function triggerMessageQueue() {
                        if (timer || messageQueue.size === 0) {
                            return;
                        }
                        timer = (0, ral_1.default)().timer.setImmediate(()=>{
                            timer = undefined;
                            processMessageQueue();
                        });
                    }
                    function handleMessage(message) {
                        if (messages_1.Message.isRequest(message)) {
                            handleRequest(message);
                        } else if (messages_1.Message.isNotification(message)) {
                            handleNotification(message);
                        } else if (messages_1.Message.isResponse(message)) {
                            handleResponse(message);
                        } else {
                            handleInvalidMessage(message);
                        }
                    }
                    function processMessageQueue() {
                        if (messageQueue.size === 0) {
                            return;
                        }
                        const message = messageQueue.shift();
                        try {
                            var _options;
                            const messageStrategy = (_options = options) === null || _options === void 0 ? void 0 : _options.messageStrategy;
                            if (MessageStrategy.is(messageStrategy)) {
                                messageStrategy.handleMessage(message, handleMessage);
                            } else {
                                handleMessage(message);
                            }
                        } finally{
                            triggerMessageQueue();
                        }
                    }
                    const callback = (message)=>{
                        try {
                            // We have received a cancellation message. Check if the message is still in the queue
                            // and cancel it if allowed to do so.
                            if (messages_1.Message.isNotification(message) && message.method === CancelNotification.type.method) {
                                const cancelId = message.params.id;
                                const key = createRequestQueueKey(cancelId);
                                const toCancel = messageQueue.get(key);
                                if (messages_1.Message.isRequest(toCancel)) {
                                    var _options;
                                    const strategy = (_options = options) === null || _options === void 0 ? void 0 : _options.connectionStrategy;
                                    const response = strategy && strategy.cancelUndispatched ? strategy.cancelUndispatched(toCancel, cancelUndispatched) : cancelUndispatched(toCancel);
                                    if (response && (response.error !== undefined || response.result !== undefined)) {
                                        messageQueue.delete(key);
                                        requestTokens.delete(cancelId);
                                        response.id = toCancel.id;
                                        traceSendingResponse(response, message.method, Date.now());
                                        messageWriter.write(response).catch(()=>logger.error(`Sending response for canceled message failed.`));
                                        return;
                                    }
                                }
                                const cancellationToken = requestTokens.get(cancelId);
                                // The request is already running. Cancel the token
                                if (cancellationToken !== undefined) {
                                    cancellationToken.cancel();
                                    traceReceivedNotification(message);
                                    return;
                                } else {
                                    // Remember the cancel but still queue the message to
                                    // clean up state in process message.
                                    knownCanceledRequests.add(cancelId);
                                }
                            }
                            addMessageToQueue(messageQueue, message);
                        } finally{
                            triggerMessageQueue();
                        }
                    };
                    function handleRequest(requestMessage) {
                        if (isDisposed()) {
                            // we return here silently since we fired an event when the
                            // connection got disposed.
                            return;
                        }
                        function reply(resultOrError, method, startTime) {
                            const message = {
                                jsonrpc: version,
                                id: requestMessage.id
                            };
                            if (resultOrError instanceof messages_1.ResponseError) {
                                message.error = resultOrError.toJson();
                            } else {
                                message.result = resultOrError === undefined ? null : resultOrError;
                            }
                            traceSendingResponse(message, method, startTime);
                            messageWriter.write(message).catch(()=>logger.error(`Sending response failed.`));
                        }
                        function replyError(error, method, startTime) {
                            const message = {
                                jsonrpc: version,
                                id: requestMessage.id,
                                error: error.toJson()
                            };
                            traceSendingResponse(message, method, startTime);
                            messageWriter.write(message).catch(()=>logger.error(`Sending response failed.`));
                        }
                        function replySuccess(result, method, startTime) {
                            // The JSON RPC defines that a response must either have a result or an error
                            // So we can't treat undefined as a valid response result.
                            if (result === undefined) {
                                result = null;
                            }
                            const message = {
                                jsonrpc: version,
                                id: requestMessage.id,
                                result: result
                            };
                            traceSendingResponse(message, method, startTime);
                            messageWriter.write(message).catch(()=>logger.error(`Sending response failed.`));
                        }
                        traceReceivedRequest(requestMessage);
                        const element = requestHandlers.get(requestMessage.method);
                        let type;
                        let requestHandler;
                        if (element) {
                            type = element.type;
                            requestHandler = element.handler;
                        }
                        const startTime = Date.now();
                        if (requestHandler || starRequestHandler) {
                            var _requestMessage_id;
                            const tokenKey = (_requestMessage_id = requestMessage.id) !== null && _requestMessage_id !== void 0 ? _requestMessage_id : String(Date.now()); //
                            const cancellationSource = IdCancellationReceiverStrategy.is(cancellationStrategy.receiver) ? cancellationStrategy.receiver.createCancellationTokenSource(tokenKey) : cancellationStrategy.receiver.createCancellationTokenSource(requestMessage);
                            if (requestMessage.id !== null && knownCanceledRequests.has(requestMessage.id)) {
                                cancellationSource.cancel();
                            }
                            if (requestMessage.id !== null) {
                                requestTokens.set(tokenKey, cancellationSource);
                            }
                            try {
                                let handlerResult;
                                if (requestHandler) {
                                    if (requestMessage.params === undefined) {
                                        if (type !== undefined && type.numberOfParams !== 0) {
                                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines ${type.numberOfParams} params but received none.`), requestMessage.method, startTime);
                                            return;
                                        }
                                        handlerResult = requestHandler(cancellationSource.token);
                                    } else if (Array.isArray(requestMessage.params)) {
                                        if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byName) {
                                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by name but received parameters by position`), requestMessage.method, startTime);
                                            return;
                                        }
                                        handlerResult = requestHandler(...requestMessage.params, cancellationSource.token);
                                    } else {
                                        if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by position but received parameters by name`), requestMessage.method, startTime);
                                            return;
                                        }
                                        handlerResult = requestHandler(requestMessage.params, cancellationSource.token);
                                    }
                                } else if (starRequestHandler) {
                                    handlerResult = starRequestHandler(requestMessage.method, requestMessage.params, cancellationSource.token);
                                }
                                const promise = handlerResult;
                                if (!handlerResult) {
                                    requestTokens.delete(tokenKey);
                                    replySuccess(handlerResult, requestMessage.method, startTime);
                                } else if (promise.then) {
                                    promise.then((resultOrError)=>{
                                        requestTokens.delete(tokenKey);
                                        reply(resultOrError, requestMessage.method, startTime);
                                    }, (error)=>{
                                        requestTokens.delete(tokenKey);
                                        if (error instanceof messages_1.ResponseError) {
                                            replyError(error, requestMessage.method, startTime);
                                        } else if (error && Is.string(error.message)) {
                                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
                                        } else {
                                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
                                        }
                                    });
                                } else {
                                    requestTokens.delete(tokenKey);
                                    reply(handlerResult, requestMessage.method, startTime);
                                }
                            } catch (error) {
                                requestTokens.delete(tokenKey);
                                if (error instanceof messages_1.ResponseError) {
                                    reply(error, requestMessage.method, startTime);
                                } else if (error && Is.string(error.message)) {
                                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
                                } else {
                                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
                                }
                            }
                        } else {
                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.MethodNotFound, `Unhandled method ${requestMessage.method}`), requestMessage.method, startTime);
                        }
                    }
                    function handleResponse(responseMessage) {
                        if (isDisposed()) {
                            // See handle request.
                            return;
                        }
                        if (responseMessage.id === null) {
                            if (responseMessage.error) {
                                logger.error(`Received response message without id: Error is: \n${JSON.stringify(responseMessage.error, undefined, 4)}`);
                            } else {
                                logger.error(`Received response message without id. No further error information provided.`);
                            }
                        } else {
                            const key = responseMessage.id;
                            const responsePromise = responsePromises.get(key);
                            traceReceivedResponse(responseMessage, responsePromise);
                            if (responsePromise !== undefined) {
                                responsePromises.delete(key);
                                try {
                                    if (responseMessage.error) {
                                        const error = responseMessage.error;
                                        responsePromise.reject(new messages_1.ResponseError(error.code, error.message, error.data));
                                    } else if (responseMessage.result !== undefined) {
                                        responsePromise.resolve(responseMessage.result);
                                    } else {
                                        throw new Error('Should never happen.');
                                    }
                                } catch (error) {
                                    if (error.message) {
                                        logger.error(`Response handler '${responsePromise.method}' failed with message: ${error.message}`);
                                    } else {
                                        logger.error(`Response handler '${responsePromise.method}' failed unexpectedly.`);
                                    }
                                }
                            }
                        }
                    }
                    function handleNotification(message) {
                        if (isDisposed()) {
                            // See handle request.
                            return;
                        }
                        let type = undefined;
                        let notificationHandler;
                        if (message.method === CancelNotification.type.method) {
                            const cancelId = message.params.id;
                            knownCanceledRequests.delete(cancelId);
                            traceReceivedNotification(message);
                            return;
                        } else {
                            const element = notificationHandlers.get(message.method);
                            if (element) {
                                notificationHandler = element.handler;
                                type = element.type;
                            }
                        }
                        if (notificationHandler || starNotificationHandler) {
                            try {
                                traceReceivedNotification(message);
                                if (notificationHandler) {
                                    if (message.params === undefined) {
                                        if (type !== undefined) {
                                            if (type.numberOfParams !== 0 && type.parameterStructures !== messages_1.ParameterStructures.byName) {
                                                logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received none.`);
                                            }
                                        }
                                        notificationHandler();
                                    } else if (Array.isArray(message.params)) {
                                        // There are JSON-RPC libraries that send progress message as positional params although
                                        // specified as named. So convert them if this is the case.
                                        const params = message.params;
                                        if (message.method === ProgressNotification.type.method && params.length === 2 && ProgressToken.is(params[0])) {
                                            notificationHandler({
                                                token: params[0],
                                                value: params[1]
                                            });
                                        } else {
                                            if (type !== undefined) {
                                                if (type.parameterStructures === messages_1.ParameterStructures.byName) {
                                                    logger.error(`Notification ${message.method} defines parameters by name but received parameters by position`);
                                                }
                                                if (type.numberOfParams !== message.params.length) {
                                                    logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received ${params.length} arguments`);
                                                }
                                            }
                                            notificationHandler(...params);
                                        }
                                    } else {
                                        if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                                            logger.error(`Notification ${message.method} defines parameters by position but received parameters by name`);
                                        }
                                        notificationHandler(message.params);
                                    }
                                } else if (starNotificationHandler) {
                                    starNotificationHandler(message.method, message.params);
                                }
                            } catch (error) {
                                if (error.message) {
                                    logger.error(`Notification handler '${message.method}' failed with message: ${error.message}`);
                                } else {
                                    logger.error(`Notification handler '${message.method}' failed unexpectedly.`);
                                }
                            }
                        } else {
                            unhandledNotificationEmitter.fire(message);
                        }
                    }
                    function handleInvalidMessage(message) {
                        if (!message) {
                            logger.error('Received empty message.');
                            return;
                        }
                        logger.error(`Received message which is neither a response nor a notification message:\n${JSON.stringify(message, null, 4)}`);
                        // Test whether we find an id to reject the promise
                        const responseMessage = message;
                        if (Is.string(responseMessage.id) || Is.number(responseMessage.id)) {
                            const key = responseMessage.id;
                            const responseHandler = responsePromises.get(key);
                            if (responseHandler) {
                                responseHandler.reject(new Error('The received response has neither a result nor an error property.'));
                            }
                        }
                    }
                    function stringifyTrace(params) {
                        if (params === undefined || params === null) {
                            return undefined;
                        }
                        switch(trace){
                            case Trace.Verbose:
                                return JSON.stringify(params, null, 4);
                            case Trace.Compact:
                                return JSON.stringify(params);
                            default:
                                return undefined;
                        }
                    }
                    function traceSendingRequest(message) {
                        if (trace === Trace.Off || !tracer) {
                            return;
                        }
                        if (traceFormat === TraceFormat.Text) {
                            let data = undefined;
                            if ((trace === Trace.Verbose || trace === Trace.Compact) && message.params) {
                                data = `Params: ${stringifyTrace(message.params)}\n\n`;
                            }
                            tracer.log(`Sending request '${message.method} - (${message.id})'.`, data);
                        } else {
                            logLSPMessage('send-request', message);
                        }
                    }
                    function traceSendingNotification(message) {
                        if (trace === Trace.Off || !tracer) {
                            return;
                        }
                        if (traceFormat === TraceFormat.Text) {
                            let data = undefined;
                            if (trace === Trace.Verbose || trace === Trace.Compact) {
                                if (message.params) {
                                    data = `Params: ${stringifyTrace(message.params)}\n\n`;
                                } else {
                                    data = 'No parameters provided.\n\n';
                                }
                            }
                            tracer.log(`Sending notification '${message.method}'.`, data);
                        } else {
                            logLSPMessage('send-notification', message);
                        }
                    }
                    function traceSendingResponse(message, method, startTime) {
                        if (trace === Trace.Off || !tracer) {
                            return;
                        }
                        if (traceFormat === TraceFormat.Text) {
                            let data = undefined;
                            if (trace === Trace.Verbose || trace === Trace.Compact) {
                                if (message.error && message.error.data) {
                                    data = `Error data: ${stringifyTrace(message.error.data)}\n\n`;
                                } else {
                                    if (message.result) {
                                        data = `Result: ${stringifyTrace(message.result)}\n\n`;
                                    } else if (message.error === undefined) {
                                        data = 'No result returned.\n\n';
                                    }
                                }
                            }
                            tracer.log(`Sending response '${method} - (${message.id})'. Processing request took ${Date.now() - startTime}ms`, data);
                        } else {
                            logLSPMessage('send-response', message);
                        }
                    }
                    function traceReceivedRequest(message) {
                        if (trace === Trace.Off || !tracer) {
                            return;
                        }
                        if (traceFormat === TraceFormat.Text) {
                            let data = undefined;
                            if ((trace === Trace.Verbose || trace === Trace.Compact) && message.params) {
                                data = `Params: ${stringifyTrace(message.params)}\n\n`;
                            }
                            tracer.log(`Received request '${message.method} - (${message.id})'.`, data);
                        } else {
                            logLSPMessage('receive-request', message);
                        }
                    }
                    function traceReceivedNotification(message) {
                        if (trace === Trace.Off || !tracer || message.method === LogTraceNotification.type.method) {
                            return;
                        }
                        if (traceFormat === TraceFormat.Text) {
                            let data = undefined;
                            if (trace === Trace.Verbose || trace === Trace.Compact) {
                                if (message.params) {
                                    data = `Params: ${stringifyTrace(message.params)}\n\n`;
                                } else {
                                    data = 'No parameters provided.\n\n';
                                }
                            }
                            tracer.log(`Received notification '${message.method}'.`, data);
                        } else {
                            logLSPMessage('receive-notification', message);
                        }
                    }
                    function traceReceivedResponse(message, responsePromise) {
                        if (trace === Trace.Off || !tracer) {
                            return;
                        }
                        if (traceFormat === TraceFormat.Text) {
                            let data = undefined;
                            if (trace === Trace.Verbose || trace === Trace.Compact) {
                                if (message.error && message.error.data) {
                                    data = `Error data: ${stringifyTrace(message.error.data)}\n\n`;
                                } else {
                                    if (message.result) {
                                        data = `Result: ${stringifyTrace(message.result)}\n\n`;
                                    } else if (message.error === undefined) {
                                        data = 'No result returned.\n\n';
                                    }
                                }
                            }
                            if (responsePromise) {
                                const error = message.error ? ` Request failed: ${message.error.message} (${message.error.code}).` : '';
                                tracer.log(`Received response '${responsePromise.method} - (${message.id})' in ${Date.now() - responsePromise.timerStart}ms.${error}`, data);
                            } else {
                                tracer.log(`Received response ${message.id} without active response promise.`, data);
                            }
                        } else {
                            logLSPMessage('receive-response', message);
                        }
                    }
                    function logLSPMessage(type, message) {
                        if (!tracer || trace === Trace.Off) {
                            return;
                        }
                        const lspMessage = {
                            isLSPMessage: true,
                            type,
                            message,
                            timestamp: Date.now()
                        };
                        tracer.log(lspMessage);
                    }
                    function throwIfClosedOrDisposed() {
                        if (isClosed()) {
                            throw new ConnectionError(ConnectionErrors.Closed, 'Connection is closed.');
                        }
                        if (isDisposed()) {
                            throw new ConnectionError(ConnectionErrors.Disposed, 'Connection is disposed.');
                        }
                    }
                    function throwIfListening() {
                        if (isListening()) {
                            throw new ConnectionError(ConnectionErrors.AlreadyListening, 'Connection is already listening');
                        }
                    }
                    function throwIfNotListening() {
                        if (!isListening()) {
                            throw new Error('Call listen() first.');
                        }
                    }
                    function undefinedToNull(param) {
                        if (param === undefined) {
                            return null;
                        } else {
                            return param;
                        }
                    }
                    function nullToUndefined(param) {
                        if (param === null) {
                            return undefined;
                        } else {
                            return param;
                        }
                    }
                    function isNamedParam(param) {
                        return param !== undefined && param !== null && !Array.isArray(param) && typeof param === 'object';
                    }
                    function computeSingleParam(parameterStructures, param) {
                        switch(parameterStructures){
                            case messages_1.ParameterStructures.auto:
                                if (isNamedParam(param)) {
                                    return nullToUndefined(param);
                                } else {
                                    return [
                                        undefinedToNull(param)
                                    ];
                                }
                            case messages_1.ParameterStructures.byName:
                                if (!isNamedParam(param)) {
                                    throw new Error(`Received parameters by name but param is not an object literal.`);
                                }
                                return nullToUndefined(param);
                            case messages_1.ParameterStructures.byPosition:
                                return [
                                    undefinedToNull(param)
                                ];
                            default:
                                throw new Error(`Unknown parameter structure ${parameterStructures.toString()}`);
                        }
                    }
                    function computeMessageParams(type, params) {
                        let result;
                        const numberOfParams = type.numberOfParams;
                        switch(numberOfParams){
                            case 0:
                                result = undefined;
                                break;
                            case 1:
                                result = computeSingleParam(type.parameterStructures, params[0]);
                                break;
                            default:
                                result = [];
                                for(let i = 0; i < params.length && i < numberOfParams; i++){
                                    result.push(undefinedToNull(params[i]));
                                }
                                if (params.length < numberOfParams) {
                                    for(let i = params.length; i < numberOfParams; i++){
                                        result.push(null);
                                    }
                                }
                                break;
                        }
                        return result;
                    }
                    const connection = {
                        sendNotification: (type, ...args)=>{
                            throwIfClosedOrDisposed();
                            let method;
                            let messageParams;
                            if (Is.string(type)) {
                                method = type;
                                const first = args[0];
                                let paramStart = 0;
                                let parameterStructures = messages_1.ParameterStructures.auto;
                                if (messages_1.ParameterStructures.is(first)) {
                                    paramStart = 1;
                                    parameterStructures = first;
                                }
                                let paramEnd = args.length;
                                const numberOfParams = paramEnd - paramStart;
                                switch(numberOfParams){
                                    case 0:
                                        messageParams = undefined;
                                        break;
                                    case 1:
                                        messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                                        break;
                                    default:
                                        if (parameterStructures === messages_1.ParameterStructures.byName) {
                                            throw new Error(`Received ${numberOfParams} parameters for 'by Name' notification parameter structure.`);
                                        }
                                        messageParams = args.slice(paramStart, paramEnd).map((value)=>undefinedToNull(value));
                                        break;
                                }
                            } else {
                                const params = args;
                                method = type.method;
                                messageParams = computeMessageParams(type, params);
                            }
                            const notificationMessage = {
                                jsonrpc: version,
                                method: method,
                                params: messageParams
                            };
                            traceSendingNotification(notificationMessage);
                            return messageWriter.write(notificationMessage).catch((error)=>{
                                logger.error(`Sending notification failed.`);
                                throw error;
                            });
                        },
                        onNotification: (type, handler)=>{
                            throwIfClosedOrDisposed();
                            let method;
                            if (Is.func(type)) {
                                starNotificationHandler = type;
                            } else if (handler) {
                                if (Is.string(type)) {
                                    method = type;
                                    notificationHandlers.set(type, {
                                        type: undefined,
                                        handler
                                    });
                                } else {
                                    method = type.method;
                                    notificationHandlers.set(type.method, {
                                        type,
                                        handler
                                    });
                                }
                            }
                            return {
                                dispose: ()=>{
                                    if (method !== undefined) {
                                        notificationHandlers.delete(method);
                                    } else {
                                        starNotificationHandler = undefined;
                                    }
                                }
                            };
                        },
                        onProgress: (_type, token, handler)=>{
                            if (progressHandlers.has(token)) {
                                throw new Error(`Progress handler for token ${token} already registered`);
                            }
                            progressHandlers.set(token, handler);
                            return {
                                dispose: ()=>{
                                    progressHandlers.delete(token);
                                }
                            };
                        },
                        sendProgress: (_type, token, value)=>{
                            // This should not await but simple return to ensure that we don't have another
                            // async scheduling. Otherwise one send could overtake another send.
                            return connection.sendNotification(ProgressNotification.type, {
                                token,
                                value
                            });
                        },
                        onUnhandledProgress: unhandledProgressEmitter.event,
                        sendRequest: (type, ...args)=>{
                            throwIfClosedOrDisposed();
                            throwIfNotListening();
                            let method;
                            let messageParams;
                            let token = undefined;
                            if (Is.string(type)) {
                                method = type;
                                const first = args[0];
                                const last = args[args.length - 1];
                                let paramStart = 0;
                                let parameterStructures = messages_1.ParameterStructures.auto;
                                if (messages_1.ParameterStructures.is(first)) {
                                    paramStart = 1;
                                    parameterStructures = first;
                                }
                                let paramEnd = args.length;
                                if (cancellation_1.CancellationToken.is(last)) {
                                    paramEnd = paramEnd - 1;
                                    token = last;
                                }
                                const numberOfParams = paramEnd - paramStart;
                                switch(numberOfParams){
                                    case 0:
                                        messageParams = undefined;
                                        break;
                                    case 1:
                                        messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                                        break;
                                    default:
                                        if (parameterStructures === messages_1.ParameterStructures.byName) {
                                            throw new Error(`Received ${numberOfParams} parameters for 'by Name' request parameter structure.`);
                                        }
                                        messageParams = args.slice(paramStart, paramEnd).map((value)=>undefinedToNull(value));
                                        break;
                                }
                            } else {
                                const params = args;
                                method = type.method;
                                messageParams = computeMessageParams(type, params);
                                const numberOfParams = type.numberOfParams;
                                token = cancellation_1.CancellationToken.is(params[numberOfParams]) ? params[numberOfParams] : undefined;
                            }
                            const id = sequenceNumber++;
                            let disposable;
                            if (token) {
                                disposable = token.onCancellationRequested(()=>{
                                    const p = cancellationStrategy.sender.sendCancellation(connection, id);
                                    if (p === undefined) {
                                        logger.log(`Received no promise from cancellation strategy when cancelling id ${id}`);
                                        return Promise.resolve();
                                    } else {
                                        return p.catch(()=>{
                                            logger.log(`Sending cancellation messages for id ${id} failed`);
                                        });
                                    }
                                });
                            }
                            const requestMessage = {
                                jsonrpc: version,
                                id: id,
                                method: method,
                                params: messageParams
                            };
                            traceSendingRequest(requestMessage);
                            if (typeof cancellationStrategy.sender.enableCancellation === 'function') {
                                cancellationStrategy.sender.enableCancellation(requestMessage);
                            }
                            return new Promise(async (resolve, reject)=>{
                                const resolveWithCleanup = (r)=>{
                                    var _disposable;
                                    resolve(r);
                                    cancellationStrategy.sender.cleanup(id);
                                    (_disposable = disposable) === null || _disposable === void 0 ? void 0 : _disposable.dispose();
                                };
                                const rejectWithCleanup = (r)=>{
                                    var _disposable;
                                    reject(r);
                                    cancellationStrategy.sender.cleanup(id);
                                    (_disposable = disposable) === null || _disposable === void 0 ? void 0 : _disposable.dispose();
                                };
                                const responsePromise = {
                                    method: method,
                                    timerStart: Date.now(),
                                    resolve: resolveWithCleanup,
                                    reject: rejectWithCleanup
                                };
                                try {
                                    await messageWriter.write(requestMessage);
                                    responsePromises.set(id, responsePromise);
                                } catch (error) {
                                    logger.error(`Sending request failed.`);
                                    // Writing the message failed. So we need to reject the promise.
                                    responsePromise.reject(new messages_1.ResponseError(messages_1.ErrorCodes.MessageWriteError, error.message ? error.message : 'Unknown reason'));
                                    throw error;
                                }
                            });
                        },
                        onRequest: (type, handler)=>{
                            throwIfClosedOrDisposed();
                            let method = null;
                            if (StarRequestHandler.is(type)) {
                                method = undefined;
                                starRequestHandler = type;
                            } else if (Is.string(type)) {
                                method = null;
                                if (handler !== undefined) {
                                    method = type;
                                    requestHandlers.set(type, {
                                        handler: handler,
                                        type: undefined
                                    });
                                }
                            } else {
                                if (handler !== undefined) {
                                    method = type.method;
                                    requestHandlers.set(type.method, {
                                        type,
                                        handler
                                    });
                                }
                            }
                            return {
                                dispose: ()=>{
                                    if (method === null) {
                                        return;
                                    }
                                    if (method !== undefined) {
                                        requestHandlers.delete(method);
                                    } else {
                                        starRequestHandler = undefined;
                                    }
                                }
                            };
                        },
                        hasPendingResponse: ()=>{
                            return responsePromises.size > 0;
                        },
                        trace: async (_value, _tracer, sendNotificationOrTraceOptions)=>{
                            let _sendNotification = false;
                            let _traceFormat = TraceFormat.Text;
                            if (sendNotificationOrTraceOptions !== undefined) {
                                if (Is.boolean(sendNotificationOrTraceOptions)) {
                                    _sendNotification = sendNotificationOrTraceOptions;
                                } else {
                                    _sendNotification = sendNotificationOrTraceOptions.sendNotification || false;
                                    _traceFormat = sendNotificationOrTraceOptions.traceFormat || TraceFormat.Text;
                                }
                            }
                            trace = _value;
                            traceFormat = _traceFormat;
                            if (trace === Trace.Off) {
                                tracer = undefined;
                            } else {
                                tracer = _tracer;
                            }
                            if (_sendNotification && !isClosed() && !isDisposed()) {
                                await connection.sendNotification(SetTraceNotification.type, {
                                    value: Trace.toString(_value)
                                });
                            }
                        },
                        onError: errorEmitter.event,
                        onClose: closeEmitter.event,
                        onUnhandledNotification: unhandledNotificationEmitter.event,
                        onDispose: disposeEmitter.event,
                        end: ()=>{
                            messageWriter.end();
                        },
                        dispose: ()=>{
                            if (isDisposed()) {
                                return;
                            }
                            state = ConnectionState.Disposed;
                            disposeEmitter.fire(undefined);
                            const error = new messages_1.ResponseError(messages_1.ErrorCodes.PendingResponseRejected, 'Pending response rejected since connection got disposed');
                            for (const promise of responsePromises.values()){
                                promise.reject(error);
                            }
                            responsePromises = new Map();
                            requestTokens = new Map();
                            knownCanceledRequests = new Set();
                            messageQueue = new linkedMap_1.LinkedMap();
                            // Test for backwards compatibility
                            if (Is.func(messageWriter.dispose)) {
                                messageWriter.dispose();
                            }
                            if (Is.func(messageReader.dispose)) {
                                messageReader.dispose();
                            }
                        },
                        listen: ()=>{
                            throwIfClosedOrDisposed();
                            throwIfListening();
                            state = ConnectionState.Listening;
                            messageReader.listen(callback);
                        },
                        inspect: ()=>{
                            // eslint-disable-next-line no-console
                            (0, ral_1.default)().console.log('inspect');
                        }
                    };
                    connection.onNotification(LogTraceNotification.type, (params)=>{
                        if (trace === Trace.Off || !tracer) {
                            return;
                        }
                        const verbose = trace === Trace.Verbose || trace === Trace.Compact;
                        tracer.log(params.message, verbose ? params.verbose : undefined);
                    });
                    connection.onNotification(ProgressNotification.type, (params)=>{
                        const handler = progressHandlers.get(params.token);
                        if (handler) {
                            handler(params.value);
                        } else {
                            unhandledProgressEmitter.fire(params);
                        }
                    });
                    return connection;
                }
                exports1.createMessageConnection = createMessageConnection;
            /***/ },
            /***/ 8844: /***/ (__unused_webpack_module, exports1)=>{
                "use strict";
                /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.Disposable = void 0;
                var Disposable;
                (function(Disposable) {
                    function create(func) {
                        return {
                            dispose: func
                        };
                    }
                    Disposable.create = create;
                })(Disposable = exports1.Disposable || (exports1.Disposable = {}));
            /***/ },
            /***/ 2479: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_363109__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.Emitter = exports1.Event = void 0;
                const ral_1 = __nested_webpack_require_363109__(5091);
                var Event1;
                (function(Event1) {
                    const _disposable = {
                        dispose () {}
                    };
                    Event1.None = function() {
                        return _disposable;
                    };
                })(Event1 = exports1.Event || (exports1.Event = {}));
                class CallbackList {
                    add(callback, context = null, bucket) {
                        if (!this._callbacks) {
                            this._callbacks = [];
                            this._contexts = [];
                        }
                        this._callbacks.push(callback);
                        this._contexts.push(context);
                        if (Array.isArray(bucket)) {
                            bucket.push({
                                dispose: ()=>this.remove(callback, context)
                            });
                        }
                    }
                    remove(callback, context = null) {
                        if (!this._callbacks) {
                            return;
                        }
                        let foundCallbackWithDifferentContext = false;
                        for(let i = 0, len = this._callbacks.length; i < len; i++){
                            if (this._callbacks[i] === callback) {
                                if (this._contexts[i] === context) {
                                    // callback & context match => remove it
                                    this._callbacks.splice(i, 1);
                                    this._contexts.splice(i, 1);
                                    return;
                                } else {
                                    foundCallbackWithDifferentContext = true;
                                }
                            }
                        }
                        if (foundCallbackWithDifferentContext) {
                            throw new Error('When adding a listener with a context, you should remove it with the same context');
                        }
                    }
                    invoke(...args) {
                        if (!this._callbacks) {
                            return [];
                        }
                        const ret = [], callbacks = this._callbacks.slice(0), contexts = this._contexts.slice(0);
                        for(let i = 0, len = callbacks.length; i < len; i++){
                            try {
                                ret.push(callbacks[i].apply(contexts[i], args));
                            } catch (e) {
                                // eslint-disable-next-line no-console
                                (0, ral_1.default)().console.error(e);
                            }
                        }
                        return ret;
                    }
                    isEmpty() {
                        return !this._callbacks || this._callbacks.length === 0;
                    }
                    dispose() {
                        this._callbacks = undefined;
                        this._contexts = undefined;
                    }
                }
                class Emitter {
                    /**
     * For the public to allow to subscribe
     * to events from this Emitter
     */ get event() {
                        if (!this._event) {
                            this._event = (listener, thisArgs, disposables)=>{
                                if (!this._callbacks) {
                                    this._callbacks = new CallbackList();
                                }
                                if (this._options && this._options.onFirstListenerAdd && this._callbacks.isEmpty()) {
                                    this._options.onFirstListenerAdd(this);
                                }
                                this._callbacks.add(listener, thisArgs);
                                const result = {
                                    dispose: ()=>{
                                        if (!this._callbacks) {
                                            // disposable is disposed after emitter is disposed.
                                            return;
                                        }
                                        this._callbacks.remove(listener, thisArgs);
                                        result.dispose = Emitter._noop;
                                        if (this._options && this._options.onLastListenerRemove && this._callbacks.isEmpty()) {
                                            this._options.onLastListenerRemove(this);
                                        }
                                    }
                                };
                                if (Array.isArray(disposables)) {
                                    disposables.push(result);
                                }
                                return result;
                            };
                        }
                        return this._event;
                    }
                    /**
     * To be kept private to fire an event to
     * subscribers
     */ fire(event) {
                        if (this._callbacks) {
                            this._callbacks.invoke.call(this._callbacks, event);
                        }
                    }
                    dispose() {
                        if (this._callbacks) {
                            this._callbacks.dispose();
                            this._callbacks = undefined;
                        }
                    }
                    constructor(_options){
                        this._options = _options;
                    }
                }
                exports1.Emitter = Emitter;
                Emitter._noop = function() {};
            /***/ },
            /***/ 6618: /***/ (__unused_webpack_module, exports1)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.stringArray = exports1.array = exports1.func = exports1.error = exports1.number = exports1.string = exports1.boolean = void 0;
                function boolean(value) {
                    return value === true || value === false;
                }
                exports1.boolean = boolean;
                function string(value) {
                    return typeof value === 'string' || value instanceof String;
                }
                exports1.string = string;
                function number(value) {
                    return typeof value === 'number' || value instanceof Number;
                }
                exports1.number = number;
                function error(value) {
                    return value instanceof Error;
                }
                exports1.error = error;
                function func(value) {
                    return typeof value === 'function';
                }
                exports1.func = func;
                function array(value) {
                    return Array.isArray(value);
                }
                exports1.array = array;
                function stringArray(value) {
                    return array(value) && value.every((elem)=>string(elem));
                }
                exports1.stringArray = stringArray;
            /***/ },
            /***/ 1109: /***/ (__unused_webpack_module, exports1)=>{
                "use strict";
                /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ var _a;
                Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.LRUCache = exports1.LinkedMap = exports1.Touch = void 0;
                var Touch;
                (function(Touch) {
                    Touch.None = 0;
                    Touch.First = 1;
                    Touch.AsOld = Touch.First;
                    Touch.Last = 2;
                    Touch.AsNew = Touch.Last;
                })(Touch = exports1.Touch || (exports1.Touch = {}));
                class LinkedMap {
                    clear() {
                        this._map.clear();
                        this._head = undefined;
                        this._tail = undefined;
                        this._size = 0;
                        this._state++;
                    }
                    isEmpty() {
                        return !this._head && !this._tail;
                    }
                    get size() {
                        return this._size;
                    }
                    get first() {
                        var _this__head;
                        return (_this__head = this._head) === null || _this__head === void 0 ? void 0 : _this__head.value;
                    }
                    get last() {
                        var _this__tail;
                        return (_this__tail = this._tail) === null || _this__tail === void 0 ? void 0 : _this__tail.value;
                    }
                    has(key) {
                        return this._map.has(key);
                    }
                    get(key, touch = Touch.None) {
                        const item = this._map.get(key);
                        if (!item) {
                            return undefined;
                        }
                        if (touch !== Touch.None) {
                            this.touch(item, touch);
                        }
                        return item.value;
                    }
                    set(key, value, touch = Touch.None) {
                        let item = this._map.get(key);
                        if (item) {
                            item.value = value;
                            if (touch !== Touch.None) {
                                this.touch(item, touch);
                            }
                        } else {
                            item = {
                                key,
                                value,
                                next: undefined,
                                previous: undefined
                            };
                            switch(touch){
                                case Touch.None:
                                    this.addItemLast(item);
                                    break;
                                case Touch.First:
                                    this.addItemFirst(item);
                                    break;
                                case Touch.Last:
                                    this.addItemLast(item);
                                    break;
                                default:
                                    this.addItemLast(item);
                                    break;
                            }
                            this._map.set(key, item);
                            this._size++;
                        }
                        return this;
                    }
                    delete(key) {
                        return !!this.remove(key);
                    }
                    remove(key) {
                        const item = this._map.get(key);
                        if (!item) {
                            return undefined;
                        }
                        this._map.delete(key);
                        this.removeItem(item);
                        this._size--;
                        return item.value;
                    }
                    shift() {
                        if (!this._head && !this._tail) {
                            return undefined;
                        }
                        if (!this._head || !this._tail) {
                            throw new Error('Invalid list');
                        }
                        const item = this._head;
                        this._map.delete(item.key);
                        this.removeItem(item);
                        this._size--;
                        return item.value;
                    }
                    forEach(callbackfn, thisArg) {
                        const state = this._state;
                        let current = this._head;
                        while(current){
                            if (thisArg) {
                                callbackfn.bind(thisArg)(current.value, current.key, this);
                            } else {
                                callbackfn(current.value, current.key, this);
                            }
                            if (this._state !== state) {
                                throw new Error(`LinkedMap got modified during iteration.`);
                            }
                            current = current.next;
                        }
                    }
                    keys() {
                        const state = this._state;
                        let current = this._head;
                        const iterator = {
                            [Symbol.iterator]: ()=>{
                                return iterator;
                            },
                            next: ()=>{
                                if (this._state !== state) {
                                    throw new Error(`LinkedMap got modified during iteration.`);
                                }
                                if (current) {
                                    const result = {
                                        value: current.key,
                                        done: false
                                    };
                                    current = current.next;
                                    return result;
                                } else {
                                    return {
                                        value: undefined,
                                        done: true
                                    };
                                }
                            }
                        };
                        return iterator;
                    }
                    values() {
                        const state = this._state;
                        let current = this._head;
                        const iterator = {
                            [Symbol.iterator]: ()=>{
                                return iterator;
                            },
                            next: ()=>{
                                if (this._state !== state) {
                                    throw new Error(`LinkedMap got modified during iteration.`);
                                }
                                if (current) {
                                    const result = {
                                        value: current.value,
                                        done: false
                                    };
                                    current = current.next;
                                    return result;
                                } else {
                                    return {
                                        value: undefined,
                                        done: true
                                    };
                                }
                            }
                        };
                        return iterator;
                    }
                    entries() {
                        const state = this._state;
                        let current = this._head;
                        const iterator = {
                            [Symbol.iterator]: ()=>{
                                return iterator;
                            },
                            next: ()=>{
                                if (this._state !== state) {
                                    throw new Error(`LinkedMap got modified during iteration.`);
                                }
                                if (current) {
                                    const result = {
                                        value: [
                                            current.key,
                                            current.value
                                        ],
                                        done: false
                                    };
                                    current = current.next;
                                    return result;
                                } else {
                                    return {
                                        value: undefined,
                                        done: true
                                    };
                                }
                            }
                        };
                        return iterator;
                    }
                    [(_a = Symbol.toStringTag, Symbol.iterator)]() {
                        return this.entries();
                    }
                    trimOld(newSize) {
                        if (newSize >= this.size) {
                            return;
                        }
                        if (newSize === 0) {
                            this.clear();
                            return;
                        }
                        let current = this._head;
                        let currentSize = this.size;
                        while(current && currentSize > newSize){
                            this._map.delete(current.key);
                            current = current.next;
                            currentSize--;
                        }
                        this._head = current;
                        this._size = currentSize;
                        if (current) {
                            current.previous = undefined;
                        }
                        this._state++;
                    }
                    addItemFirst(item) {
                        // First time Insert
                        if (!this._head && !this._tail) {
                            this._tail = item;
                        } else if (!this._head) {
                            throw new Error('Invalid list');
                        } else {
                            item.next = this._head;
                            this._head.previous = item;
                        }
                        this._head = item;
                        this._state++;
                    }
                    addItemLast(item) {
                        // First time Insert
                        if (!this._head && !this._tail) {
                            this._head = item;
                        } else if (!this._tail) {
                            throw new Error('Invalid list');
                        } else {
                            item.previous = this._tail;
                            this._tail.next = item;
                        }
                        this._tail = item;
                        this._state++;
                    }
                    removeItem(item) {
                        if (item === this._head && item === this._tail) {
                            this._head = undefined;
                            this._tail = undefined;
                        } else if (item === this._head) {
                            // This can only happened if size === 1 which is handle
                            // by the case above.
                            if (!item.next) {
                                throw new Error('Invalid list');
                            }
                            item.next.previous = undefined;
                            this._head = item.next;
                        } else if (item === this._tail) {
                            // This can only happened if size === 1 which is handle
                            // by the case above.
                            if (!item.previous) {
                                throw new Error('Invalid list');
                            }
                            item.previous.next = undefined;
                            this._tail = item.previous;
                        } else {
                            const next = item.next;
                            const previous = item.previous;
                            if (!next || !previous) {
                                throw new Error('Invalid list');
                            }
                            next.previous = previous;
                            previous.next = next;
                        }
                        item.next = undefined;
                        item.previous = undefined;
                        this._state++;
                    }
                    touch(item, touch) {
                        if (!this._head || !this._tail) {
                            throw new Error('Invalid list');
                        }
                        if (touch !== Touch.First && touch !== Touch.Last) {
                            return;
                        }
                        if (touch === Touch.First) {
                            if (item === this._head) {
                                return;
                            }
                            const next = item.next;
                            const previous = item.previous;
                            // Unlink the item
                            if (item === this._tail) {
                                // previous must be defined since item was not head but is tail
                                // So there are more than on item in the map
                                previous.next = undefined;
                                this._tail = previous;
                            } else {
                                // Both next and previous are not undefined since item was neither head nor tail.
                                next.previous = previous;
                                previous.next = next;
                            }
                            // Insert the node at head
                            item.previous = undefined;
                            item.next = this._head;
                            this._head.previous = item;
                            this._head = item;
                            this._state++;
                        } else if (touch === Touch.Last) {
                            if (item === this._tail) {
                                return;
                            }
                            const next = item.next;
                            const previous = item.previous;
                            // Unlink the item.
                            if (item === this._head) {
                                // next must be defined since item was not tail but is head
                                // So there are more than on item in the map
                                next.previous = undefined;
                                this._head = next;
                            } else {
                                // Both next and previous are not undefined since item was neither head nor tail.
                                next.previous = previous;
                                previous.next = next;
                            }
                            item.next = undefined;
                            item.previous = this._tail;
                            this._tail.next = item;
                            this._tail = item;
                            this._state++;
                        }
                    }
                    toJSON() {
                        const data = [];
                        this.forEach((value, key)=>{
                            data.push([
                                key,
                                value
                            ]);
                        });
                        return data;
                    }
                    fromJSON(data) {
                        this.clear();
                        for (const [key, value] of data){
                            this.set(key, value);
                        }
                    }
                    constructor(){
                        this[_a] = 'LinkedMap';
                        this._map = new Map();
                        this._head = undefined;
                        this._tail = undefined;
                        this._size = 0;
                        this._state = 0;
                    }
                }
                exports1.LinkedMap = LinkedMap;
                class LRUCache extends LinkedMap {
                    get limit() {
                        return this._limit;
                    }
                    set limit(limit) {
                        this._limit = limit;
                        this.checkTrim();
                    }
                    get ratio() {
                        return this._ratio;
                    }
                    set ratio(ratio) {
                        this._ratio = Math.min(Math.max(0, ratio), 1);
                        this.checkTrim();
                    }
                    get(key, touch = Touch.AsNew) {
                        return super.get(key, touch);
                    }
                    peek(key) {
                        return super.get(key, Touch.None);
                    }
                    set(key, value) {
                        super.set(key, value, Touch.Last);
                        this.checkTrim();
                        return this;
                    }
                    checkTrim() {
                        if (this.size > this._limit) {
                            this.trimOld(Math.round(this._limit * this._ratio));
                        }
                    }
                    constructor(limit, ratio = 1){
                        super();
                        this._limit = limit;
                        this._ratio = Math.min(Math.max(0, ratio), 1);
                    }
                }
                exports1.LRUCache = LRUCache;
            /***/ },
            /***/ 9805: /***/ (__unused_webpack_module, exports1)=>{
                "use strict";
                /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.AbstractMessageBuffer = void 0;
                const CR = 13;
                const LF = 10;
                const CRLF = '\r\n';
                class AbstractMessageBuffer {
                    get encoding() {
                        return this._encoding;
                    }
                    append(chunk) {
                        const toAppend = typeof chunk === 'string' ? this.fromString(chunk, this._encoding) : chunk;
                        this._chunks.push(toAppend);
                        this._totalLength += toAppend.byteLength;
                    }
                    tryReadHeaders(lowerCaseKeys = false) {
                        if (this._chunks.length === 0) {
                            return undefined;
                        }
                        let state = 0;
                        let chunkIndex = 0;
                        let offset = 0;
                        let chunkBytesRead = 0;
                        row: while(chunkIndex < this._chunks.length){
                            const chunk = this._chunks[chunkIndex];
                            offset = 0;
                            column: while(offset < chunk.length){
                                const value = chunk[offset];
                                switch(value){
                                    case CR:
                                        switch(state){
                                            case 0:
                                                state = 1;
                                                break;
                                            case 2:
                                                state = 3;
                                                break;
                                            default:
                                                state = 0;
                                        }
                                        break;
                                    case LF:
                                        switch(state){
                                            case 1:
                                                state = 2;
                                                break;
                                            case 3:
                                                state = 4;
                                                offset++;
                                                break row;
                                            default:
                                                state = 0;
                                        }
                                        break;
                                    default:
                                        state = 0;
                                }
                                offset++;
                            }
                            chunkBytesRead += chunk.byteLength;
                            chunkIndex++;
                        }
                        if (state !== 4) {
                            return undefined;
                        }
                        // The buffer contains the two CRLF at the end. So we will
                        // have two empty lines after the split at the end as well.
                        const buffer = this._read(chunkBytesRead + offset);
                        const result = new Map();
                        const headers = this.toString(buffer, 'ascii').split(CRLF);
                        if (headers.length < 2) {
                            return result;
                        }
                        for(let i = 0; i < headers.length - 2; i++){
                            const header = headers[i];
                            const index = header.indexOf(':');
                            if (index === -1) {
                                throw new Error('Message header must separate key and value using :');
                            }
                            const key = header.substr(0, index);
                            const value = header.substr(index + 1).trim();
                            result.set(lowerCaseKeys ? key.toLowerCase() : key, value);
                        }
                        return result;
                    }
                    tryReadBody(length) {
                        if (this._totalLength < length) {
                            return undefined;
                        }
                        return this._read(length);
                    }
                    get numberOfBytes() {
                        return this._totalLength;
                    }
                    _read(byteCount) {
                        if (byteCount === 0) {
                            return this.emptyBuffer();
                        }
                        if (byteCount > this._totalLength) {
                            throw new Error(`Cannot read so many bytes!`);
                        }
                        if (this._chunks[0].byteLength === byteCount) {
                            // super fast path, precisely first chunk must be returned
                            const chunk = this._chunks[0];
                            this._chunks.shift();
                            this._totalLength -= byteCount;
                            return this.asNative(chunk);
                        }
                        if (this._chunks[0].byteLength > byteCount) {
                            // fast path, the reading is entirely within the first chunk
                            const chunk = this._chunks[0];
                            const result = this.asNative(chunk, byteCount);
                            this._chunks[0] = chunk.slice(byteCount);
                            this._totalLength -= byteCount;
                            return result;
                        }
                        const result = this.allocNative(byteCount);
                        let resultOffset = 0;
                        let chunkIndex = 0;
                        while(byteCount > 0){
                            const chunk = this._chunks[chunkIndex];
                            if (chunk.byteLength > byteCount) {
                                // this chunk will survive
                                const chunkPart = chunk.slice(0, byteCount);
                                result.set(chunkPart, resultOffset);
                                resultOffset += byteCount;
                                this._chunks[chunkIndex] = chunk.slice(byteCount);
                                this._totalLength -= byteCount;
                                byteCount -= byteCount;
                            } else {
                                // this chunk will be entirely read
                                result.set(chunk, resultOffset);
                                resultOffset += chunk.byteLength;
                                this._chunks.shift();
                                this._totalLength -= chunk.byteLength;
                                byteCount -= chunk.byteLength;
                            }
                        }
                        return result;
                    }
                    constructor(encoding = 'utf-8'){
                        this._encoding = encoding;
                        this._chunks = [];
                        this._totalLength = 0;
                    }
                }
                exports1.AbstractMessageBuffer = AbstractMessageBuffer;
            /***/ },
            /***/ 656: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_398805__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.ReadableStreamMessageReader = exports1.AbstractMessageReader = exports1.MessageReader = void 0;
                const ral_1 = __nested_webpack_require_398805__(5091);
                const Is = __nested_webpack_require_398805__(6618);
                const events_1 = __nested_webpack_require_398805__(2479);
                const semaphore_1 = __nested_webpack_require_398805__(418);
                var MessageReader;
                (function(MessageReader) {
                    function is(value) {
                        let candidate = value;
                        return candidate && Is.func(candidate.listen) && Is.func(candidate.dispose) && Is.func(candidate.onError) && Is.func(candidate.onClose) && Is.func(candidate.onPartialMessage);
                    }
                    MessageReader.is = is;
                })(MessageReader = exports1.MessageReader || (exports1.MessageReader = {}));
                class AbstractMessageReader {
                    dispose() {
                        this.errorEmitter.dispose();
                        this.closeEmitter.dispose();
                    }
                    get onError() {
                        return this.errorEmitter.event;
                    }
                    fireError(error) {
                        this.errorEmitter.fire(this.asError(error));
                    }
                    get onClose() {
                        return this.closeEmitter.event;
                    }
                    fireClose() {
                        this.closeEmitter.fire(undefined);
                    }
                    get onPartialMessage() {
                        return this.partialMessageEmitter.event;
                    }
                    firePartialMessage(info) {
                        this.partialMessageEmitter.fire(info);
                    }
                    asError(error) {
                        if (error instanceof Error) {
                            return error;
                        } else {
                            return new Error(`Reader received error. Reason: ${Is.string(error.message) ? error.message : 'unknown'}`);
                        }
                    }
                    constructor(){
                        this.errorEmitter = new events_1.Emitter();
                        this.closeEmitter = new events_1.Emitter();
                        this.partialMessageEmitter = new events_1.Emitter();
                    }
                }
                exports1.AbstractMessageReader = AbstractMessageReader;
                var ResolvedMessageReaderOptions;
                (function(ResolvedMessageReaderOptions) {
                    function fromOptions(options) {
                        let charset;
                        let result;
                        let contentDecoder;
                        const contentDecoders = new Map();
                        let contentTypeDecoder;
                        const contentTypeDecoders = new Map();
                        if (options === undefined || typeof options === 'string') {
                            charset = options !== null && options !== void 0 ? options : 'utf-8';
                        } else {
                            var _options_charset;
                            charset = (_options_charset = options.charset) !== null && _options_charset !== void 0 ? _options_charset : 'utf-8';
                            if (options.contentDecoder !== undefined) {
                                contentDecoder = options.contentDecoder;
                                contentDecoders.set(contentDecoder.name, contentDecoder);
                            }
                            if (options.contentDecoders !== undefined) {
                                for (const decoder of options.contentDecoders){
                                    contentDecoders.set(decoder.name, decoder);
                                }
                            }
                            if (options.contentTypeDecoder !== undefined) {
                                contentTypeDecoder = options.contentTypeDecoder;
                                contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
                            }
                            if (options.contentTypeDecoders !== undefined) {
                                for (const decoder of options.contentTypeDecoders){
                                    contentTypeDecoders.set(decoder.name, decoder);
                                }
                            }
                        }
                        if (contentTypeDecoder === undefined) {
                            contentTypeDecoder = (0, ral_1.default)().applicationJson.decoder;
                            contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
                        }
                        return {
                            charset,
                            contentDecoder,
                            contentDecoders,
                            contentTypeDecoder,
                            contentTypeDecoders
                        };
                    }
                    ResolvedMessageReaderOptions.fromOptions = fromOptions;
                })(ResolvedMessageReaderOptions || (ResolvedMessageReaderOptions = {}));
                class ReadableStreamMessageReader extends AbstractMessageReader {
                    set partialMessageTimeout(timeout) {
                        this._partialMessageTimeout = timeout;
                    }
                    get partialMessageTimeout() {
                        return this._partialMessageTimeout;
                    }
                    listen(callback) {
                        this.nextMessageLength = -1;
                        this.messageToken = 0;
                        this.partialMessageTimer = undefined;
                        this.callback = callback;
                        const result = this.readable.onData((data)=>{
                            this.onData(data);
                        });
                        this.readable.onError((error)=>this.fireError(error));
                        this.readable.onClose(()=>this.fireClose());
                        return result;
                    }
                    onData(data) {
                        this.buffer.append(data);
                        while(true){
                            if (this.nextMessageLength === -1) {
                                const headers = this.buffer.tryReadHeaders(true);
                                if (!headers) {
                                    return;
                                }
                                const contentLength = headers.get('content-length');
                                if (!contentLength) {
                                    this.fireError(new Error('Header must provide a Content-Length property.'));
                                    return;
                                }
                                const length = parseInt(contentLength);
                                if (isNaN(length)) {
                                    this.fireError(new Error('Content-Length value must be a number.'));
                                    return;
                                }
                                this.nextMessageLength = length;
                            }
                            const body = this.buffer.tryReadBody(this.nextMessageLength);
                            if (body === undefined) {
                                /** We haven't received the full message yet. */ this.setPartialMessageTimer();
                                return;
                            }
                            this.clearPartialMessageTimer();
                            this.nextMessageLength = -1;
                            // Make sure that we convert one received message after the
                            // other. Otherwise it could happen that a decoding of a second
                            // smaller message finished before the decoding of a first larger
                            // message and then we would deliver the second message first.
                            this.readSemaphore.lock(async ()=>{
                                const bytes = this.options.contentDecoder !== undefined ? await this.options.contentDecoder.decode(body) : body;
                                const message = await this.options.contentTypeDecoder.decode(bytes, this.options);
                                this.callback(message);
                            }).catch((error)=>{
                                this.fireError(error);
                            });
                        }
                    }
                    clearPartialMessageTimer() {
                        if (this.partialMessageTimer) {
                            this.partialMessageTimer.dispose();
                            this.partialMessageTimer = undefined;
                        }
                    }
                    setPartialMessageTimer() {
                        this.clearPartialMessageTimer();
                        if (this._partialMessageTimeout <= 0) {
                            return;
                        }
                        this.partialMessageTimer = (0, ral_1.default)().timer.setTimeout((token, timeout)=>{
                            this.partialMessageTimer = undefined;
                            if (token === this.messageToken) {
                                this.firePartialMessage({
                                    messageToken: token,
                                    waitingTime: timeout
                                });
                                this.setPartialMessageTimer();
                            }
                        }, this._partialMessageTimeout, this.messageToken, this._partialMessageTimeout);
                    }
                    constructor(readable, options){
                        super();
                        this.readable = readable;
                        this.options = ResolvedMessageReaderOptions.fromOptions(options);
                        this.buffer = (0, ral_1.default)().messageBuffer.create(this.options.charset);
                        this._partialMessageTimeout = 10000;
                        this.nextMessageLength = -1;
                        this.messageToken = 0;
                        this.readSemaphore = new semaphore_1.Semaphore(1);
                    }
                }
                exports1.ReadableStreamMessageReader = ReadableStreamMessageReader;
            /***/ },
            /***/ 9036: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_410066__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.WriteableStreamMessageWriter = exports1.AbstractMessageWriter = exports1.MessageWriter = void 0;
                const ral_1 = __nested_webpack_require_410066__(5091);
                const Is = __nested_webpack_require_410066__(6618);
                const semaphore_1 = __nested_webpack_require_410066__(418);
                const events_1 = __nested_webpack_require_410066__(2479);
                const ContentLength = 'Content-Length: ';
                const CRLF = '\r\n';
                var MessageWriter;
                (function(MessageWriter) {
                    function is(value) {
                        let candidate = value;
                        return candidate && Is.func(candidate.dispose) && Is.func(candidate.onClose) && Is.func(candidate.onError) && Is.func(candidate.write);
                    }
                    MessageWriter.is = is;
                })(MessageWriter = exports1.MessageWriter || (exports1.MessageWriter = {}));
                class AbstractMessageWriter {
                    dispose() {
                        this.errorEmitter.dispose();
                        this.closeEmitter.dispose();
                    }
                    get onError() {
                        return this.errorEmitter.event;
                    }
                    fireError(error, message, count) {
                        this.errorEmitter.fire([
                            this.asError(error),
                            message,
                            count
                        ]);
                    }
                    get onClose() {
                        return this.closeEmitter.event;
                    }
                    fireClose() {
                        this.closeEmitter.fire(undefined);
                    }
                    asError(error) {
                        if (error instanceof Error) {
                            return error;
                        } else {
                            return new Error(`Writer received error. Reason: ${Is.string(error.message) ? error.message : 'unknown'}`);
                        }
                    }
                    constructor(){
                        this.errorEmitter = new events_1.Emitter();
                        this.closeEmitter = new events_1.Emitter();
                    }
                }
                exports1.AbstractMessageWriter = AbstractMessageWriter;
                var ResolvedMessageWriterOptions;
                (function(ResolvedMessageWriterOptions) {
                    function fromOptions(options) {
                        if (options === undefined || typeof options === 'string') {
                            return {
                                charset: options !== null && options !== void 0 ? options : 'utf-8',
                                contentTypeEncoder: (0, ral_1.default)().applicationJson.encoder
                            };
                        } else {
                            var _options_charset, _options_contentTypeEncoder;
                            return {
                                charset: (_options_charset = options.charset) !== null && _options_charset !== void 0 ? _options_charset : 'utf-8',
                                contentEncoder: options.contentEncoder,
                                contentTypeEncoder: (_options_contentTypeEncoder = options.contentTypeEncoder) !== null && _options_contentTypeEncoder !== void 0 ? _options_contentTypeEncoder : (0, ral_1.default)().applicationJson.encoder
                            };
                        }
                    }
                    ResolvedMessageWriterOptions.fromOptions = fromOptions;
                })(ResolvedMessageWriterOptions || (ResolvedMessageWriterOptions = {}));
                class WriteableStreamMessageWriter extends AbstractMessageWriter {
                    async write(msg) {
                        return this.writeSemaphore.lock(async ()=>{
                            const payload = this.options.contentTypeEncoder.encode(msg, this.options).then((buffer)=>{
                                if (this.options.contentEncoder !== undefined) {
                                    return this.options.contentEncoder.encode(buffer);
                                } else {
                                    return buffer;
                                }
                            });
                            return payload.then((buffer)=>{
                                const headers = [];
                                headers.push(ContentLength, buffer.byteLength.toString(), CRLF);
                                headers.push(CRLF);
                                return this.doWrite(msg, headers, buffer);
                            }, (error)=>{
                                this.fireError(error);
                                throw error;
                            });
                        });
                    }
                    async doWrite(msg, headers, data) {
                        try {
                            await this.writable.write(headers.join(''), 'ascii');
                            return this.writable.write(data);
                        } catch (error) {
                            this.handleError(error, msg);
                            return Promise.reject(error);
                        }
                    }
                    handleError(error, msg) {
                        this.errorCount++;
                        this.fireError(error, msg, this.errorCount);
                    }
                    end() {
                        this.writable.end();
                    }
                    constructor(writable, options){
                        super();
                        this.writable = writable;
                        this.options = ResolvedMessageWriterOptions.fromOptions(options);
                        this.errorCount = 0;
                        this.writeSemaphore = new semaphore_1.Semaphore(1);
                        this.writable.onError((error)=>this.fireError(error));
                        this.writable.onClose(()=>this.fireClose());
                    }
                }
                exports1.WriteableStreamMessageWriter = WriteableStreamMessageWriter;
            /***/ },
            /***/ 7162: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_416951__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.Message = exports1.NotificationType9 = exports1.NotificationType8 = exports1.NotificationType7 = exports1.NotificationType6 = exports1.NotificationType5 = exports1.NotificationType4 = exports1.NotificationType3 = exports1.NotificationType2 = exports1.NotificationType1 = exports1.NotificationType0 = exports1.NotificationType = exports1.RequestType9 = exports1.RequestType8 = exports1.RequestType7 = exports1.RequestType6 = exports1.RequestType5 = exports1.RequestType4 = exports1.RequestType3 = exports1.RequestType2 = exports1.RequestType1 = exports1.RequestType = exports1.RequestType0 = exports1.AbstractMessageSignature = exports1.ParameterStructures = exports1.ResponseError = exports1.ErrorCodes = void 0;
                const is = __nested_webpack_require_416951__(6618);
                /**
 * Predefined error codes.
 */ var ErrorCodes;
                (function(ErrorCodes) {
                    // Defined by JSON RPC
                    ErrorCodes.ParseError = -32700;
                    ErrorCodes.InvalidRequest = -32600;
                    ErrorCodes.MethodNotFound = -32601;
                    ErrorCodes.InvalidParams = -32602;
                    ErrorCodes.InternalError = -32603;
                    /**
     * This is the start range of JSON RPC reserved error codes.
     * It doesn't denote a real error code. No application error codes should
     * be defined between the start and end range. For backwards
     * compatibility the `ServerNotInitialized` and the `UnknownErrorCode`
     * are left in the range.
     *
     * @since 3.16.0
    */ ErrorCodes.jsonrpcReservedErrorRangeStart = -32099;
                    /** @deprecated use  jsonrpcReservedErrorRangeStart */ ErrorCodes.serverErrorStart = -32099;
                    /**
     * An error occurred when write a message to the transport layer.
     */ ErrorCodes.MessageWriteError = -32099;
                    /**
     * An error occurred when reading a message from the transport layer.
     */ ErrorCodes.MessageReadError = -32098;
                    /**
     * The connection got disposed or lost and all pending responses got
     * rejected.
     */ ErrorCodes.PendingResponseRejected = -32097;
                    /**
     * The connection is inactive and a use of it failed.
     */ ErrorCodes.ConnectionInactive = -32096;
                    /**
     * Error code indicating that a server received a notification or
     * request before the server has received the `initialize` request.
     */ ErrorCodes.ServerNotInitialized = -32002;
                    ErrorCodes.UnknownErrorCode = -32001;
                    /**
     * This is the end range of JSON RPC reserved error codes.
     * It doesn't denote a real error code.
     *
     * @since 3.16.0
    */ ErrorCodes.jsonrpcReservedErrorRangeEnd = -32000;
                    /** @deprecated use  jsonrpcReservedErrorRangeEnd */ ErrorCodes.serverErrorEnd = -32000;
                })(ErrorCodes = exports1.ErrorCodes || (exports1.ErrorCodes = {}));
                /**
 * An error object return in a response in case a request
 * has failed.
 */ class ResponseError extends Error {
                    toJson() {
                        const result = {
                            code: this.code,
                            message: this.message
                        };
                        if (this.data !== undefined) {
                            result.data = this.data;
                        }
                        return result;
                    }
                    constructor(code, message, data){
                        super(message);
                        this.code = is.number(code) ? code : ErrorCodes.UnknownErrorCode;
                        this.data = data;
                        Object.setPrototypeOf(this, ResponseError.prototype);
                    }
                }
                exports1.ResponseError = ResponseError;
                class ParameterStructures {
                    static is(value) {
                        return value === ParameterStructures.auto || value === ParameterStructures.byName || value === ParameterStructures.byPosition;
                    }
                    toString() {
                        return this.kind;
                    }
                    constructor(kind){
                        this.kind = kind;
                    }
                }
                exports1.ParameterStructures = ParameterStructures;
                /**
 * The parameter structure is automatically inferred on the number of parameters
 * and the parameter type in case of a single param.
 */ ParameterStructures.auto = new ParameterStructures('auto');
                /**
 * Forces `byPosition` parameter structure. This is useful if you have a single
 * parameter which has a literal type.
 */ ParameterStructures.byPosition = new ParameterStructures('byPosition');
                /**
 * Forces `byName` parameter structure. This is only useful when having a single
 * parameter. The library will report errors if used with a different number of
 * parameters.
 */ ParameterStructures.byName = new ParameterStructures('byName');
                /**
 * An abstract implementation of a MessageType.
 */ class AbstractMessageSignature {
                    get parameterStructures() {
                        return ParameterStructures.auto;
                    }
                    constructor(method, numberOfParams){
                        this.method = method;
                        this.numberOfParams = numberOfParams;
                    }
                }
                exports1.AbstractMessageSignature = AbstractMessageSignature;
                /**
 * Classes to type request response pairs
 */ class RequestType0 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 0);
                    }
                }
                exports1.RequestType0 = RequestType0;
                class RequestType extends AbstractMessageSignature {
                    get parameterStructures() {
                        return this._parameterStructures;
                    }
                    constructor(method, _parameterStructures = ParameterStructures.auto){
                        super(method, 1);
                        this._parameterStructures = _parameterStructures;
                    }
                }
                exports1.RequestType = RequestType;
                class RequestType1 extends AbstractMessageSignature {
                    get parameterStructures() {
                        return this._parameterStructures;
                    }
                    constructor(method, _parameterStructures = ParameterStructures.auto){
                        super(method, 1);
                        this._parameterStructures = _parameterStructures;
                    }
                }
                exports1.RequestType1 = RequestType1;
                class RequestType2 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 2);
                    }
                }
                exports1.RequestType2 = RequestType2;
                class RequestType3 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 3);
                    }
                }
                exports1.RequestType3 = RequestType3;
                class RequestType4 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 4);
                    }
                }
                exports1.RequestType4 = RequestType4;
                class RequestType5 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 5);
                    }
                }
                exports1.RequestType5 = RequestType5;
                class RequestType6 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 6);
                    }
                }
                exports1.RequestType6 = RequestType6;
                class RequestType7 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 7);
                    }
                }
                exports1.RequestType7 = RequestType7;
                class RequestType8 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 8);
                    }
                }
                exports1.RequestType8 = RequestType8;
                class RequestType9 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 9);
                    }
                }
                exports1.RequestType9 = RequestType9;
                class NotificationType extends AbstractMessageSignature {
                    get parameterStructures() {
                        return this._parameterStructures;
                    }
                    constructor(method, _parameterStructures = ParameterStructures.auto){
                        super(method, 1);
                        this._parameterStructures = _parameterStructures;
                    }
                }
                exports1.NotificationType = NotificationType;
                class NotificationType0 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 0);
                    }
                }
                exports1.NotificationType0 = NotificationType0;
                class NotificationType1 extends AbstractMessageSignature {
                    get parameterStructures() {
                        return this._parameterStructures;
                    }
                    constructor(method, _parameterStructures = ParameterStructures.auto){
                        super(method, 1);
                        this._parameterStructures = _parameterStructures;
                    }
                }
                exports1.NotificationType1 = NotificationType1;
                class NotificationType2 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 2);
                    }
                }
                exports1.NotificationType2 = NotificationType2;
                class NotificationType3 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 3);
                    }
                }
                exports1.NotificationType3 = NotificationType3;
                class NotificationType4 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 4);
                    }
                }
                exports1.NotificationType4 = NotificationType4;
                class NotificationType5 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 5);
                    }
                }
                exports1.NotificationType5 = NotificationType5;
                class NotificationType6 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 6);
                    }
                }
                exports1.NotificationType6 = NotificationType6;
                class NotificationType7 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 7);
                    }
                }
                exports1.NotificationType7 = NotificationType7;
                class NotificationType8 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 8);
                    }
                }
                exports1.NotificationType8 = NotificationType8;
                class NotificationType9 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 9);
                    }
                }
                exports1.NotificationType9 = NotificationType9;
                var Message;
                (function(Message) {
                    /**
     * Tests if the given message is a request message
     */ function isRequest(message) {
                        const candidate = message;
                        return candidate && is.string(candidate.method) && (is.string(candidate.id) || is.number(candidate.id));
                    }
                    Message.isRequest = isRequest;
                    /**
     * Tests if the given message is a notification message
     */ function isNotification(message) {
                        const candidate = message;
                        return candidate && is.string(candidate.method) && message.id === void 0;
                    }
                    Message.isNotification = isNotification;
                    /**
     * Tests if the given message is a response message
     */ function isResponse(message) {
                        const candidate = message;
                        return candidate && (candidate.result !== void 0 || !!candidate.error) && (is.string(candidate.id) || is.number(candidate.id) || candidate.id === null);
                    }
                    Message.isResponse = isResponse;
                })(Message = exports1.Message || (exports1.Message = {}));
            /***/ },
            /***/ 5091: /***/ (__unused_webpack_module, exports1)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                let _ral;
                function RAL() {
                    if (_ral === undefined) {
                        throw new Error(`No runtime abstraction layer installed`);
                    }
                    return _ral;
                }
                (function(RAL) {
                    function install(ral) {
                        if (ral === undefined) {
                            throw new Error(`No runtime abstraction layer provided`);
                        }
                        _ral = ral;
                    }
                    RAL.install = install;
                })(RAL || (RAL = {}));
                exports1["default"] = RAL;
            /***/ },
            /***/ 418: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_432458__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.Semaphore = void 0;
                const ral_1 = __nested_webpack_require_432458__(5091);
                class Semaphore {
                    lock(thunk) {
                        return new Promise((resolve, reject)=>{
                            this._waiting.push({
                                thunk,
                                resolve,
                                reject
                            });
                            this.runNext();
                        });
                    }
                    get active() {
                        return this._active;
                    }
                    runNext() {
                        if (this._waiting.length === 0 || this._active === this._capacity) {
                            return;
                        }
                        (0, ral_1.default)().timer.setImmediate(()=>this.doRunNext());
                    }
                    doRunNext() {
                        if (this._waiting.length === 0 || this._active === this._capacity) {
                            return;
                        }
                        const next = this._waiting.shift();
                        this._active++;
                        if (this._active > this._capacity) {
                            throw new Error(`To many thunks active`);
                        }
                        try {
                            const result = next.thunk();
                            if (result instanceof Promise) {
                                result.then((value)=>{
                                    this._active--;
                                    next.resolve(value);
                                    this.runNext();
                                }, (err)=>{
                                    this._active--;
                                    next.reject(err);
                                    this.runNext();
                                });
                            } else {
                                this._active--;
                                next.resolve(result);
                                this.runNext();
                            }
                        } catch (err) {
                            this._active--;
                            next.reject(err);
                            this.runNext();
                        }
                    }
                    constructor(capacity = 1){
                        if (capacity <= 0) {
                            throw new Error('Capacity must be greater than 0');
                        }
                        this._capacity = capacity;
                        this._active = 0;
                        this._waiting = [];
                    }
                }
                exports1.Semaphore = Semaphore;
            /***/ },
            /***/ 3489: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_435901__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.SharedArrayReceiverStrategy = exports1.SharedArraySenderStrategy = void 0;
                const cancellation_1 = __nested_webpack_require_435901__(6957);
                var CancellationState;
                (function(CancellationState) {
                    CancellationState.Continue = 0;
                    CancellationState.Cancelled = 1;
                })(CancellationState || (CancellationState = {}));
                class SharedArraySenderStrategy {
                    enableCancellation(request) {
                        if (request.id === null) {
                            return;
                        }
                        const buffer = new SharedArrayBuffer(4);
                        const data = new Int32Array(buffer, 0, 1);
                        data[0] = CancellationState.Continue;
                        this.buffers.set(request.id, buffer);
                        request.$cancellationData = buffer;
                    }
                    async sendCancellation(_conn, id) {
                        const buffer = this.buffers.get(id);
                        if (buffer === undefined) {
                            return;
                        }
                        const data = new Int32Array(buffer, 0, 1);
                        Atomics.store(data, 0, CancellationState.Cancelled);
                    }
                    cleanup(id) {
                        this.buffers.delete(id);
                    }
                    dispose() {
                        this.buffers.clear();
                    }
                    constructor(){
                        this.buffers = new Map();
                    }
                }
                exports1.SharedArraySenderStrategy = SharedArraySenderStrategy;
                class SharedArrayBufferCancellationToken {
                    get isCancellationRequested() {
                        return Atomics.load(this.data, 0) === CancellationState.Cancelled;
                    }
                    get onCancellationRequested() {
                        throw new Error(`Cancellation over SharedArrayBuffer doesn't support cancellation events`);
                    }
                    constructor(buffer){
                        this.data = new Int32Array(buffer, 0, 1);
                    }
                }
                class SharedArrayBufferCancellationTokenSource {
                    cancel() {}
                    dispose() {}
                    constructor(buffer){
                        this.token = new SharedArrayBufferCancellationToken(buffer);
                    }
                }
                class SharedArrayReceiverStrategy {
                    createCancellationTokenSource(request) {
                        const buffer = request.$cancellationData;
                        if (buffer === undefined) {
                            return new cancellation_1.CancellationTokenSource();
                        }
                        return new SharedArrayBufferCancellationTokenSource(buffer);
                    }
                    constructor(){
                        this.kind = 'request';
                    }
                }
                exports1.SharedArrayReceiverStrategy = SharedArrayReceiverStrategy;
            /***/ },
            /***/ 8713: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_439798__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ----------------------------------------------------------------------------------------- */ module1.exports = __nested_webpack_require_439798__(5501);
            /***/ },
            /***/ 5501: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_440357__) {
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
                    if (k2 === undefined) k2 = k;
                    var desc = Object.getOwnPropertyDescriptor(m, k);
                    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
                        desc = {
                            enumerable: true,
                            get: function() {
                                return m[k];
                            }
                        };
                    }
                    Object.defineProperty(o, k2, desc);
                } : function(o, m, k, k2) {
                    if (k2 === undefined) k2 = k;
                    o[k2] = m[k];
                });
                var __exportStar = this && this.__exportStar || function(m, exports1) {
                    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
                };
                Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.createProtocolConnection = void 0;
                const browser_1 = __nested_webpack_require_440357__(9208);
                __exportStar(__nested_webpack_require_440357__(9208), exports1);
                __exportStar(__nested_webpack_require_440357__(3147), exports1);
                function createProtocolConnection(reader, writer, logger, options) {
                    return (0, browser_1.createMessageConnection)(reader, writer, logger, options);
                }
                exports1.createProtocolConnection = createProtocolConnection;
            /***/ },
            /***/ 3147: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_442546__) {
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
                    if (k2 === undefined) k2 = k;
                    var desc = Object.getOwnPropertyDescriptor(m, k);
                    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
                        desc = {
                            enumerable: true,
                            get: function() {
                                return m[k];
                            }
                        };
                    }
                    Object.defineProperty(o, k2, desc);
                } : function(o, m, k, k2) {
                    if (k2 === undefined) k2 = k;
                    o[k2] = m[k];
                });
                var __exportStar = this && this.__exportStar || function(m, exports1) {
                    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
                };
                Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.LSPErrorCodes = exports1.createProtocolConnection = void 0;
                __exportStar(__nested_webpack_require_442546__(9110), exports1);
                __exportStar(__nested_webpack_require_442546__(7717), exports1);
                __exportStar(__nested_webpack_require_442546__(8431), exports1);
                __exportStar(__nested_webpack_require_442546__(1815), exports1);
                var connection_1 = __nested_webpack_require_442546__(291);
                Object.defineProperty(exports1, "createProtocolConnection", {
                    enumerable: true,
                    get: function() {
                        return connection_1.createProtocolConnection;
                    }
                });
                var LSPErrorCodes;
                (function(LSPErrorCodes) {
                    /**
    * This is the start range of LSP reserved error codes.
    * It doesn't denote a real error code.
    *
    * @since 3.16.0
    */ LSPErrorCodes.lspReservedErrorRangeStart = -32899;
                    /**
     * A request failed but it was syntactically correct, e.g the
     * method name was known and the parameters were valid. The error
     * message should contain human readable information about why
     * the request failed.
     *
     * @since 3.17.0
     */ LSPErrorCodes.RequestFailed = -32803;
                    /**
     * The server cancelled the request. This error code should
     * only be used for requests that explicitly support being
     * server cancellable.
     *
     * @since 3.17.0
     */ LSPErrorCodes.ServerCancelled = -32802;
                    /**
     * The server detected that the content of a document got
     * modified outside normal conditions. A server should
     * NOT send this error code if it detects a content change
     * in it unprocessed messages. The result even computed
     * on an older state might still be useful for the client.
     *
     * If a client decides that a result is not of any use anymore
     * the client should cancel the request.
     */ LSPErrorCodes.ContentModified = -32801;
                    /**
     * The client has canceled a request and a server as detected
     * the cancel.
     */ LSPErrorCodes.RequestCancelled = -32800;
                    /**
    * This is the end range of LSP reserved error codes.
    * It doesn't denote a real error code.
    *
    * @since 3.16.0
    */ LSPErrorCodes.lspReservedErrorRangeEnd = -32800;
                })(LSPErrorCodes = exports1.LSPErrorCodes || (exports1.LSPErrorCodes = {}));
            /***/ },
            /***/ 291: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_446695__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.createProtocolConnection = void 0;
                const vscode_jsonrpc_1 = __nested_webpack_require_446695__(9110);
                function createProtocolConnection(input, output, logger, options) {
                    if (vscode_jsonrpc_1.ConnectionStrategy.is(options)) {
                        options = {
                            connectionStrategy: options
                        };
                    }
                    return (0, vscode_jsonrpc_1.createMessageConnection)(input, output, logger, options);
                }
                exports1.createProtocolConnection = createProtocolConnection;
            /***/ },
            /***/ 8431: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_447932__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.ProtocolNotificationType = exports1.ProtocolNotificationType0 = exports1.ProtocolRequestType = exports1.ProtocolRequestType0 = exports1.RegistrationType = exports1.MessageDirection = void 0;
                const vscode_jsonrpc_1 = __nested_webpack_require_447932__(9110);
                var MessageDirection;
                (function(MessageDirection) {
                    MessageDirection["clientToServer"] = "clientToServer";
                    MessageDirection["serverToClient"] = "serverToClient";
                    MessageDirection["both"] = "both";
                })(MessageDirection = exports1.MessageDirection || (exports1.MessageDirection = {}));
                class RegistrationType {
                    constructor(method){
                        this.method = method;
                    }
                }
                exports1.RegistrationType = RegistrationType;
                class ProtocolRequestType0 extends vscode_jsonrpc_1.RequestType0 {
                    constructor(method){
                        super(method);
                    }
                }
                exports1.ProtocolRequestType0 = ProtocolRequestType0;
                class ProtocolRequestType extends vscode_jsonrpc_1.RequestType {
                    constructor(method){
                        super(method, vscode_jsonrpc_1.ParameterStructures.byName);
                    }
                }
                exports1.ProtocolRequestType = ProtocolRequestType;
                class ProtocolNotificationType0 extends vscode_jsonrpc_1.NotificationType0 {
                    constructor(method){
                        super(method);
                    }
                }
                exports1.ProtocolNotificationType0 = ProtocolNotificationType0;
                class ProtocolNotificationType extends vscode_jsonrpc_1.NotificationType {
                    constructor(method){
                        super(method, vscode_jsonrpc_1.ParameterStructures.byName);
                    }
                }
                exports1.ProtocolNotificationType = ProtocolNotificationType;
            /***/ },
            /***/ 7602: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_450658__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) TypeFox, Microsoft and others. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.CallHierarchyOutgoingCallsRequest = exports1.CallHierarchyIncomingCallsRequest = exports1.CallHierarchyPrepareRequest = void 0;
                const messages_1 = __nested_webpack_require_450658__(8431);
                /**
 * A request to result a `CallHierarchyItem` in a document at a given position.
 * Can be used as an input to an incoming or outgoing call hierarchy.
 *
 * @since 3.16.0
 */ var CallHierarchyPrepareRequest;
                (function(CallHierarchyPrepareRequest) {
                    CallHierarchyPrepareRequest.method = 'textDocument/prepareCallHierarchy';
                    CallHierarchyPrepareRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    CallHierarchyPrepareRequest.type = new messages_1.ProtocolRequestType(CallHierarchyPrepareRequest.method);
                })(CallHierarchyPrepareRequest = exports1.CallHierarchyPrepareRequest || (exports1.CallHierarchyPrepareRequest = {}));
                /**
 * A request to resolve the incoming calls for a given `CallHierarchyItem`.
 *
 * @since 3.16.0
 */ var CallHierarchyIncomingCallsRequest;
                (function(CallHierarchyIncomingCallsRequest) {
                    CallHierarchyIncomingCallsRequest.method = 'callHierarchy/incomingCalls';
                    CallHierarchyIncomingCallsRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    CallHierarchyIncomingCallsRequest.type = new messages_1.ProtocolRequestType(CallHierarchyIncomingCallsRequest.method);
                })(CallHierarchyIncomingCallsRequest = exports1.CallHierarchyIncomingCallsRequest || (exports1.CallHierarchyIncomingCallsRequest = {}));
                /**
 * A request to resolve the outgoing calls for a given `CallHierarchyItem`.
 *
 * @since 3.16.0
 */ var CallHierarchyOutgoingCallsRequest;
                (function(CallHierarchyOutgoingCallsRequest) {
                    CallHierarchyOutgoingCallsRequest.method = 'callHierarchy/outgoingCalls';
                    CallHierarchyOutgoingCallsRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    CallHierarchyOutgoingCallsRequest.type = new messages_1.ProtocolRequestType(CallHierarchyOutgoingCallsRequest.method);
                })(CallHierarchyOutgoingCallsRequest = exports1.CallHierarchyOutgoingCallsRequest || (exports1.CallHierarchyOutgoingCallsRequest = {}));
            /***/ },
            /***/ 3747: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_453689__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.ColorPresentationRequest = exports1.DocumentColorRequest = void 0;
                const messages_1 = __nested_webpack_require_453689__(8431);
                /**
 * A request to list all color symbols found in a given text document. The request's
 * parameter is of type {@link DocumentColorParams} the
 * response is of type {@link ColorInformation ColorInformation[]} or a Thenable
 * that resolves to such.
 */ var DocumentColorRequest;
                (function(DocumentColorRequest) {
                    DocumentColorRequest.method = 'textDocument/documentColor';
                    DocumentColorRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    DocumentColorRequest.type = new messages_1.ProtocolRequestType(DocumentColorRequest.method);
                })(DocumentColorRequest = exports1.DocumentColorRequest || (exports1.DocumentColorRequest = {}));
                /**
 * A request to list all presentation for a color. The request's
 * parameter is of type {@link ColorPresentationParams} the
 * response is of type {@link ColorInformation ColorInformation[]} or a Thenable
 * that resolves to such.
 */ var ColorPresentationRequest;
                (function(ColorPresentationRequest) {
                    ColorPresentationRequest.method = 'textDocument/colorPresentation';
                    ColorPresentationRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    ColorPresentationRequest.type = new messages_1.ProtocolRequestType(ColorPresentationRequest.method);
                })(ColorPresentationRequest = exports1.ColorPresentationRequest || (exports1.ColorPresentationRequest = {}));
            /***/ },
            /***/ 7639: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_455992__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.ConfigurationRequest = void 0;
                const messages_1 = __nested_webpack_require_455992__(8431);
                //---- Get Configuration request ----
                /**
 * The 'workspace/configuration' request is sent from the server to the client to fetch a certain
 * configuration setting.
 *
 * This pull model replaces the old push model were the client signaled configuration change via an
 * event. If the server still needs to react to configuration changes (since the server caches the
 * result of `workspace/configuration` requests) the server should register for an empty configuration
 * change event and empty the cache if such an event is received.
 */ var ConfigurationRequest;
                (function(ConfigurationRequest) {
                    ConfigurationRequest.method = 'workspace/configuration';
                    ConfigurationRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    ConfigurationRequest.type = new messages_1.ProtocolRequestType(ConfigurationRequest.method);
                })(ConfigurationRequest = exports1.ConfigurationRequest || (exports1.ConfigurationRequest = {}));
            /***/ },
            /***/ 5581: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_457774__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.DeclarationRequest = void 0;
                const messages_1 = __nested_webpack_require_457774__(8431);
                // @ts-ignore: to avoid inlining LocationLink as dynamic import
                let __noDynamicImport;
                /**
 * A request to resolve the type definition locations of a symbol at a given text
 * document position. The request's parameter is of type [TextDocumentPositionParams]
 * (#TextDocumentPositionParams) the response is of type {@link Declaration}
 * or a typed array of {@link DeclarationLink} or a Thenable that resolves
 * to such.
 */ var DeclarationRequest;
                (function(DeclarationRequest) {
                    DeclarationRequest.method = 'textDocument/declaration';
                    DeclarationRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    DeclarationRequest.type = new messages_1.ProtocolRequestType(DeclarationRequest.method);
                })(DeclarationRequest = exports1.DeclarationRequest || (exports1.DeclarationRequest = {}));
            /***/ },
            /***/ 1494: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_459439__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.DiagnosticRefreshRequest = exports1.WorkspaceDiagnosticRequest = exports1.DocumentDiagnosticRequest = exports1.DocumentDiagnosticReportKind = exports1.DiagnosticServerCancellationData = void 0;
                const vscode_jsonrpc_1 = __nested_webpack_require_459439__(9110);
                const Is = __nested_webpack_require_459439__(8633);
                const messages_1 = __nested_webpack_require_459439__(8431);
                /**
 * @since 3.17.0
 */ var DiagnosticServerCancellationData;
                (function(DiagnosticServerCancellationData) {
                    function is(value) {
                        const candidate = value;
                        return candidate && Is.boolean(candidate.retriggerRequest);
                    }
                    DiagnosticServerCancellationData.is = is;
                })(DiagnosticServerCancellationData = exports1.DiagnosticServerCancellationData || (exports1.DiagnosticServerCancellationData = {}));
                /**
 * The document diagnostic report kinds.
 *
 * @since 3.17.0
 */ var DocumentDiagnosticReportKind;
                (function(DocumentDiagnosticReportKind) {
                    /**
     * A diagnostic report with a full
     * set of problems.
     */ DocumentDiagnosticReportKind.Full = 'full';
                    /**
     * A report indicating that the last
     * returned report is still accurate.
     */ DocumentDiagnosticReportKind.Unchanged = 'unchanged';
                })(DocumentDiagnosticReportKind = exports1.DocumentDiagnosticReportKind || (exports1.DocumentDiagnosticReportKind = {}));
                /**
 * The document diagnostic request definition.
 *
 * @since 3.17.0
 */ var DocumentDiagnosticRequest;
                (function(DocumentDiagnosticRequest) {
                    DocumentDiagnosticRequest.method = 'textDocument/diagnostic';
                    DocumentDiagnosticRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    DocumentDiagnosticRequest.type = new messages_1.ProtocolRequestType(DocumentDiagnosticRequest.method);
                    DocumentDiagnosticRequest.partialResult = new vscode_jsonrpc_1.ProgressType();
                })(DocumentDiagnosticRequest = exports1.DocumentDiagnosticRequest || (exports1.DocumentDiagnosticRequest = {}));
                /**
 * The workspace diagnostic request definition.
 *
 * @since 3.17.0
 */ var WorkspaceDiagnosticRequest;
                (function(WorkspaceDiagnosticRequest) {
                    WorkspaceDiagnosticRequest.method = 'workspace/diagnostic';
                    WorkspaceDiagnosticRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    WorkspaceDiagnosticRequest.type = new messages_1.ProtocolRequestType(WorkspaceDiagnosticRequest.method);
                    WorkspaceDiagnosticRequest.partialResult = new vscode_jsonrpc_1.ProgressType();
                })(WorkspaceDiagnosticRequest = exports1.WorkspaceDiagnosticRequest || (exports1.WorkspaceDiagnosticRequest = {}));
                /**
 * The diagnostic refresh request definition.
 *
 * @since 3.17.0
 */ var DiagnosticRefreshRequest;
                (function(DiagnosticRefreshRequest) {
                    DiagnosticRefreshRequest.method = `workspace/diagnostic/refresh`;
                    DiagnosticRefreshRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    DiagnosticRefreshRequest.type = new messages_1.ProtocolRequestType0(DiagnosticRefreshRequest.method);
                })(DiagnosticRefreshRequest = exports1.DiagnosticRefreshRequest || (exports1.DiagnosticRefreshRequest = {}));
            /***/ },
            /***/ 4781: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_463683__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.WillDeleteFilesRequest = exports1.DidDeleteFilesNotification = exports1.DidRenameFilesNotification = exports1.WillRenameFilesRequest = exports1.DidCreateFilesNotification = exports1.WillCreateFilesRequest = exports1.FileOperationPatternKind = void 0;
                const messages_1 = __nested_webpack_require_463683__(8431);
                /**
 * A pattern kind describing if a glob pattern matches a file a folder or
 * both.
 *
 * @since 3.16.0
 */ var FileOperationPatternKind;
                (function(FileOperationPatternKind) {
                    /**
     * The pattern matches a file only.
     */ FileOperationPatternKind.file = 'file';
                    /**
     * The pattern matches a folder only.
     */ FileOperationPatternKind.folder = 'folder';
                })(FileOperationPatternKind = exports1.FileOperationPatternKind || (exports1.FileOperationPatternKind = {}));
                /**
 * The will create files request is sent from the client to the server before files are actually
 * created as long as the creation is triggered from within the client.
 *
 * The request can return a `WorkspaceEdit` which will be applied to workspace before the
 * files are created. Hence the `WorkspaceEdit` can not manipulate the content of the file
 * to be created.
 *
 * @since 3.16.0
 */ var WillCreateFilesRequest;
                (function(WillCreateFilesRequest) {
                    WillCreateFilesRequest.method = 'workspace/willCreateFiles';
                    WillCreateFilesRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    WillCreateFilesRequest.type = new messages_1.ProtocolRequestType(WillCreateFilesRequest.method);
                })(WillCreateFilesRequest = exports1.WillCreateFilesRequest || (exports1.WillCreateFilesRequest = {}));
                /**
 * The did create files notification is sent from the client to the server when
 * files were created from within the client.
 *
 * @since 3.16.0
 */ var DidCreateFilesNotification;
                (function(DidCreateFilesNotification) {
                    DidCreateFilesNotification.method = 'workspace/didCreateFiles';
                    DidCreateFilesNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidCreateFilesNotification.type = new messages_1.ProtocolNotificationType(DidCreateFilesNotification.method);
                })(DidCreateFilesNotification = exports1.DidCreateFilesNotification || (exports1.DidCreateFilesNotification = {}));
                /**
 * The will rename files request is sent from the client to the server before files are actually
 * renamed as long as the rename is triggered from within the client.
 *
 * @since 3.16.0
 */ var WillRenameFilesRequest;
                (function(WillRenameFilesRequest) {
                    WillRenameFilesRequest.method = 'workspace/willRenameFiles';
                    WillRenameFilesRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    WillRenameFilesRequest.type = new messages_1.ProtocolRequestType(WillRenameFilesRequest.method);
                })(WillRenameFilesRequest = exports1.WillRenameFilesRequest || (exports1.WillRenameFilesRequest = {}));
                /**
 * The did rename files notification is sent from the client to the server when
 * files were renamed from within the client.
 *
 * @since 3.16.0
 */ var DidRenameFilesNotification;
                (function(DidRenameFilesNotification) {
                    DidRenameFilesNotification.method = 'workspace/didRenameFiles';
                    DidRenameFilesNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidRenameFilesNotification.type = new messages_1.ProtocolNotificationType(DidRenameFilesNotification.method);
                })(DidRenameFilesNotification = exports1.DidRenameFilesNotification || (exports1.DidRenameFilesNotification = {}));
                /**
 * The will delete files request is sent from the client to the server before files are actually
 * deleted as long as the deletion is triggered from within the client.
 *
 * @since 3.16.0
 */ var DidDeleteFilesNotification;
                (function(DidDeleteFilesNotification) {
                    DidDeleteFilesNotification.method = 'workspace/didDeleteFiles';
                    DidDeleteFilesNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidDeleteFilesNotification.type = new messages_1.ProtocolNotificationType(DidDeleteFilesNotification.method);
                })(DidDeleteFilesNotification = exports1.DidDeleteFilesNotification || (exports1.DidDeleteFilesNotification = {}));
                /**
 * The did delete files notification is sent from the client to the server when
 * files were deleted from within the client.
 *
 * @since 3.16.0
 */ var WillDeleteFilesRequest;
                (function(WillDeleteFilesRequest) {
                    WillDeleteFilesRequest.method = 'workspace/willDeleteFiles';
                    WillDeleteFilesRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    WillDeleteFilesRequest.type = new messages_1.ProtocolRequestType(WillDeleteFilesRequest.method);
                })(WillDeleteFilesRequest = exports1.WillDeleteFilesRequest || (exports1.WillDeleteFilesRequest = {}));
            /***/ },
            /***/ 1203: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_469688__)=>{
                "use strict";
                /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.FoldingRangeRequest = void 0;
                const messages_1 = __nested_webpack_require_469688__(8431);
                /**
 * A request to provide folding ranges in a document. The request's
 * parameter is of type {@link FoldingRangeParams}, the
 * response is of type {@link FoldingRangeList} or a Thenable
 * that resolves to such.
 */ var FoldingRangeRequest;
                (function(FoldingRangeRequest) {
                    FoldingRangeRequest.method = 'textDocument/foldingRange';
                    FoldingRangeRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    FoldingRangeRequest.type = new messages_1.ProtocolRequestType(FoldingRangeRequest.method);
                })(FoldingRangeRequest = exports1.FoldingRangeRequest || (exports1.FoldingRangeRequest = {}));
            /***/ },
            /***/ 7287: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_471127__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.ImplementationRequest = void 0;
                const messages_1 = __nested_webpack_require_471127__(8431);
                // @ts-ignore: to avoid inlining LocationLink as dynamic import
                let __noDynamicImport;
                /**
 * A request to resolve the implementation locations of a symbol at a given text
 * document position. The request's parameter is of type [TextDocumentPositionParams]
 * (#TextDocumentPositionParams) the response is of type {@link Definition} or a
 * Thenable that resolves to such.
 */ var ImplementationRequest;
                (function(ImplementationRequest) {
                    ImplementationRequest.method = 'textDocument/implementation';
                    ImplementationRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    ImplementationRequest.type = new messages_1.ProtocolRequestType(ImplementationRequest.method);
                })(ImplementationRequest = exports1.ImplementationRequest || (exports1.ImplementationRequest = {}));
            /***/ },
            /***/ 9383: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_472776__)=>{
                "use strict";
                /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.InlayHintRefreshRequest = exports1.InlayHintResolveRequest = exports1.InlayHintRequest = void 0;
                const messages_1 = __nested_webpack_require_472776__(8431);
                /**
 * A request to provide inlay hints in a document. The request's parameter is of
 * type {@link InlayHintsParams}, the response is of type
 * {@link InlayHint InlayHint[]} or a Thenable that resolves to such.
 *
 * @since 3.17.0
 */ var InlayHintRequest;
                (function(InlayHintRequest) {
                    InlayHintRequest.method = 'textDocument/inlayHint';
                    InlayHintRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    InlayHintRequest.type = new messages_1.ProtocolRequestType(InlayHintRequest.method);
                })(InlayHintRequest = exports1.InlayHintRequest || (exports1.InlayHintRequest = {}));
                /**
 * A request to resolve additional properties for an inlay hint.
 * The request's parameter is of type {@link InlayHint}, the response is
 * of type {@link InlayHint} or a Thenable that resolves to such.
 *
 * @since 3.17.0
 */ var InlayHintResolveRequest;
                (function(InlayHintResolveRequest) {
                    InlayHintResolveRequest.method = 'inlayHint/resolve';
                    InlayHintResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    InlayHintResolveRequest.type = new messages_1.ProtocolRequestType(InlayHintResolveRequest.method);
                })(InlayHintResolveRequest = exports1.InlayHintResolveRequest || (exports1.InlayHintResolveRequest = {}));
                /**
 * @since 3.17.0
 */ var InlayHintRefreshRequest;
                (function(InlayHintRefreshRequest) {
                    InlayHintRefreshRequest.method = `workspace/inlayHint/refresh`;
                    InlayHintRefreshRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    InlayHintRefreshRequest.type = new messages_1.ProtocolRequestType0(InlayHintRefreshRequest.method);
                })(InlayHintRefreshRequest = exports1.InlayHintRefreshRequest || (exports1.InlayHintRefreshRequest = {}));
            /***/ },
            /***/ 3491: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_475579__)=>{
                "use strict";
                /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.InlineValueRefreshRequest = exports1.InlineValueRequest = void 0;
                const messages_1 = __nested_webpack_require_475579__(8431);
                /**
 * A request to provide inline values in a document. The request's parameter is of
 * type {@link InlineValueParams}, the response is of type
 * {@link InlineValue InlineValue[]} or a Thenable that resolves to such.
 *
 * @since 3.17.0
 */ var InlineValueRequest;
                (function(InlineValueRequest) {
                    InlineValueRequest.method = 'textDocument/inlineValue';
                    InlineValueRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    InlineValueRequest.type = new messages_1.ProtocolRequestType(InlineValueRequest.method);
                })(InlineValueRequest = exports1.InlineValueRequest || (exports1.InlineValueRequest = {}));
                /**
 * @since 3.17.0
 */ var InlineValueRefreshRequest;
                (function(InlineValueRefreshRequest) {
                    InlineValueRefreshRequest.method = `workspace/inlineValue/refresh`;
                    InlineValueRefreshRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    InlineValueRefreshRequest.type = new messages_1.ProtocolRequestType0(InlineValueRefreshRequest.method);
                })(InlineValueRefreshRequest = exports1.InlineValueRefreshRequest || (exports1.InlineValueRefreshRequest = {}));
            /***/ },
            /***/ 1815: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_477645__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.WorkspaceSymbolRequest = exports1.CodeActionResolveRequest = exports1.CodeActionRequest = exports1.DocumentSymbolRequest = exports1.DocumentHighlightRequest = exports1.ReferencesRequest = exports1.DefinitionRequest = exports1.SignatureHelpRequest = exports1.SignatureHelpTriggerKind = exports1.HoverRequest = exports1.CompletionResolveRequest = exports1.CompletionRequest = exports1.CompletionTriggerKind = exports1.PublishDiagnosticsNotification = exports1.WatchKind = exports1.RelativePattern = exports1.FileChangeType = exports1.DidChangeWatchedFilesNotification = exports1.WillSaveTextDocumentWaitUntilRequest = exports1.WillSaveTextDocumentNotification = exports1.TextDocumentSaveReason = exports1.DidSaveTextDocumentNotification = exports1.DidCloseTextDocumentNotification = exports1.DidChangeTextDocumentNotification = exports1.TextDocumentContentChangeEvent = exports1.DidOpenTextDocumentNotification = exports1.TextDocumentSyncKind = exports1.TelemetryEventNotification = exports1.LogMessageNotification = exports1.ShowMessageRequest = exports1.ShowMessageNotification = exports1.MessageType = exports1.DidChangeConfigurationNotification = exports1.ExitNotification = exports1.ShutdownRequest = exports1.InitializedNotification = exports1.InitializeErrorCodes = exports1.InitializeRequest = exports1.WorkDoneProgressOptions = exports1.TextDocumentRegistrationOptions = exports1.StaticRegistrationOptions = exports1.PositionEncodingKind = exports1.FailureHandlingKind = exports1.ResourceOperationKind = exports1.UnregistrationRequest = exports1.RegistrationRequest = exports1.DocumentSelector = exports1.NotebookCellTextDocumentFilter = exports1.NotebookDocumentFilter = exports1.TextDocumentFilter = void 0;
                exports1.TypeHierarchySubtypesRequest = exports1.TypeHierarchyPrepareRequest = exports1.MonikerRequest = exports1.MonikerKind = exports1.UniquenessLevel = exports1.WillDeleteFilesRequest = exports1.DidDeleteFilesNotification = exports1.WillRenameFilesRequest = exports1.DidRenameFilesNotification = exports1.WillCreateFilesRequest = exports1.DidCreateFilesNotification = exports1.FileOperationPatternKind = exports1.LinkedEditingRangeRequest = exports1.ShowDocumentRequest = exports1.SemanticTokensRegistrationType = exports1.SemanticTokensRefreshRequest = exports1.SemanticTokensRangeRequest = exports1.SemanticTokensDeltaRequest = exports1.SemanticTokensRequest = exports1.TokenFormat = exports1.CallHierarchyPrepareRequest = exports1.CallHierarchyOutgoingCallsRequest = exports1.CallHierarchyIncomingCallsRequest = exports1.WorkDoneProgressCancelNotification = exports1.WorkDoneProgressCreateRequest = exports1.WorkDoneProgress = exports1.SelectionRangeRequest = exports1.DeclarationRequest = exports1.FoldingRangeRequest = exports1.ColorPresentationRequest = exports1.DocumentColorRequest = exports1.ConfigurationRequest = exports1.DidChangeWorkspaceFoldersNotification = exports1.WorkspaceFoldersRequest = exports1.TypeDefinitionRequest = exports1.ImplementationRequest = exports1.ApplyWorkspaceEditRequest = exports1.ExecuteCommandRequest = exports1.PrepareRenameRequest = exports1.RenameRequest = exports1.PrepareSupportDefaultBehavior = exports1.DocumentOnTypeFormattingRequest = exports1.DocumentRangeFormattingRequest = exports1.DocumentFormattingRequest = exports1.DocumentLinkResolveRequest = exports1.DocumentLinkRequest = exports1.CodeLensRefreshRequest = exports1.CodeLensResolveRequest = exports1.CodeLensRequest = exports1.WorkspaceSymbolResolveRequest = void 0;
                exports1.DidCloseNotebookDocumentNotification = exports1.DidSaveNotebookDocumentNotification = exports1.DidChangeNotebookDocumentNotification = exports1.NotebookCellArrayChange = exports1.DidOpenNotebookDocumentNotification = exports1.NotebookDocumentSyncRegistrationType = exports1.NotebookDocument = exports1.NotebookCell = exports1.ExecutionSummary = exports1.NotebookCellKind = exports1.DiagnosticRefreshRequest = exports1.WorkspaceDiagnosticRequest = exports1.DocumentDiagnosticRequest = exports1.DocumentDiagnosticReportKind = exports1.DiagnosticServerCancellationData = exports1.InlayHintRefreshRequest = exports1.InlayHintResolveRequest = exports1.InlayHintRequest = exports1.InlineValueRefreshRequest = exports1.InlineValueRequest = exports1.TypeHierarchySupertypesRequest = void 0;
                const messages_1 = __nested_webpack_require_477645__(8431);
                const vscode_languageserver_types_1 = __nested_webpack_require_477645__(7717);
                const Is = __nested_webpack_require_477645__(8633);
                const protocol_implementation_1 = __nested_webpack_require_477645__(7287);
                Object.defineProperty(exports1, "ImplementationRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_implementation_1.ImplementationRequest;
                    }
                });
                const protocol_typeDefinition_1 = __nested_webpack_require_477645__(9264);
                Object.defineProperty(exports1, "TypeDefinitionRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_typeDefinition_1.TypeDefinitionRequest;
                    }
                });
                const protocol_workspaceFolder_1 = __nested_webpack_require_477645__(6860);
                Object.defineProperty(exports1, "WorkspaceFoldersRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_workspaceFolder_1.WorkspaceFoldersRequest;
                    }
                });
                Object.defineProperty(exports1, "DidChangeWorkspaceFoldersNotification", {
                    enumerable: true,
                    get: function() {
                        return protocol_workspaceFolder_1.DidChangeWorkspaceFoldersNotification;
                    }
                });
                const protocol_configuration_1 = __nested_webpack_require_477645__(7639);
                Object.defineProperty(exports1, "ConfigurationRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_configuration_1.ConfigurationRequest;
                    }
                });
                const protocol_colorProvider_1 = __nested_webpack_require_477645__(3747);
                Object.defineProperty(exports1, "DocumentColorRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_colorProvider_1.DocumentColorRequest;
                    }
                });
                Object.defineProperty(exports1, "ColorPresentationRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_colorProvider_1.ColorPresentationRequest;
                    }
                });
                const protocol_foldingRange_1 = __nested_webpack_require_477645__(1203);
                Object.defineProperty(exports1, "FoldingRangeRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_foldingRange_1.FoldingRangeRequest;
                    }
                });
                const protocol_declaration_1 = __nested_webpack_require_477645__(5581);
                Object.defineProperty(exports1, "DeclarationRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_declaration_1.DeclarationRequest;
                    }
                });
                const protocol_selectionRange_1 = __nested_webpack_require_477645__(1530);
                Object.defineProperty(exports1, "SelectionRangeRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_selectionRange_1.SelectionRangeRequest;
                    }
                });
                const protocol_progress_1 = __nested_webpack_require_477645__(4166);
                Object.defineProperty(exports1, "WorkDoneProgress", {
                    enumerable: true,
                    get: function() {
                        return protocol_progress_1.WorkDoneProgress;
                    }
                });
                Object.defineProperty(exports1, "WorkDoneProgressCreateRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_progress_1.WorkDoneProgressCreateRequest;
                    }
                });
                Object.defineProperty(exports1, "WorkDoneProgressCancelNotification", {
                    enumerable: true,
                    get: function() {
                        return protocol_progress_1.WorkDoneProgressCancelNotification;
                    }
                });
                const protocol_callHierarchy_1 = __nested_webpack_require_477645__(7602);
                Object.defineProperty(exports1, "CallHierarchyIncomingCallsRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_callHierarchy_1.CallHierarchyIncomingCallsRequest;
                    }
                });
                Object.defineProperty(exports1, "CallHierarchyOutgoingCallsRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_callHierarchy_1.CallHierarchyOutgoingCallsRequest;
                    }
                });
                Object.defineProperty(exports1, "CallHierarchyPrepareRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_callHierarchy_1.CallHierarchyPrepareRequest;
                    }
                });
                const protocol_semanticTokens_1 = __nested_webpack_require_477645__(2067);
                Object.defineProperty(exports1, "TokenFormat", {
                    enumerable: true,
                    get: function() {
                        return protocol_semanticTokens_1.TokenFormat;
                    }
                });
                Object.defineProperty(exports1, "SemanticTokensRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_semanticTokens_1.SemanticTokensRequest;
                    }
                });
                Object.defineProperty(exports1, "SemanticTokensDeltaRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_semanticTokens_1.SemanticTokensDeltaRequest;
                    }
                });
                Object.defineProperty(exports1, "SemanticTokensRangeRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_semanticTokens_1.SemanticTokensRangeRequest;
                    }
                });
                Object.defineProperty(exports1, "SemanticTokensRefreshRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_semanticTokens_1.SemanticTokensRefreshRequest;
                    }
                });
                Object.defineProperty(exports1, "SemanticTokensRegistrationType", {
                    enumerable: true,
                    get: function() {
                        return protocol_semanticTokens_1.SemanticTokensRegistrationType;
                    }
                });
                const protocol_showDocument_1 = __nested_webpack_require_477645__(4333);
                Object.defineProperty(exports1, "ShowDocumentRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_showDocument_1.ShowDocumentRequest;
                    }
                });
                const protocol_linkedEditingRange_1 = __nested_webpack_require_477645__(2249);
                Object.defineProperty(exports1, "LinkedEditingRangeRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_linkedEditingRange_1.LinkedEditingRangeRequest;
                    }
                });
                const protocol_fileOperations_1 = __nested_webpack_require_477645__(4781);
                Object.defineProperty(exports1, "FileOperationPatternKind", {
                    enumerable: true,
                    get: function() {
                        return protocol_fileOperations_1.FileOperationPatternKind;
                    }
                });
                Object.defineProperty(exports1, "DidCreateFilesNotification", {
                    enumerable: true,
                    get: function() {
                        return protocol_fileOperations_1.DidCreateFilesNotification;
                    }
                });
                Object.defineProperty(exports1, "WillCreateFilesRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_fileOperations_1.WillCreateFilesRequest;
                    }
                });
                Object.defineProperty(exports1, "DidRenameFilesNotification", {
                    enumerable: true,
                    get: function() {
                        return protocol_fileOperations_1.DidRenameFilesNotification;
                    }
                });
                Object.defineProperty(exports1, "WillRenameFilesRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_fileOperations_1.WillRenameFilesRequest;
                    }
                });
                Object.defineProperty(exports1, "DidDeleteFilesNotification", {
                    enumerable: true,
                    get: function() {
                        return protocol_fileOperations_1.DidDeleteFilesNotification;
                    }
                });
                Object.defineProperty(exports1, "WillDeleteFilesRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_fileOperations_1.WillDeleteFilesRequest;
                    }
                });
                const protocol_moniker_1 = __nested_webpack_require_477645__(7684);
                Object.defineProperty(exports1, "UniquenessLevel", {
                    enumerable: true,
                    get: function() {
                        return protocol_moniker_1.UniquenessLevel;
                    }
                });
                Object.defineProperty(exports1, "MonikerKind", {
                    enumerable: true,
                    get: function() {
                        return protocol_moniker_1.MonikerKind;
                    }
                });
                Object.defineProperty(exports1, "MonikerRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_moniker_1.MonikerRequest;
                    }
                });
                const protocol_typeHierarchy_1 = __nested_webpack_require_477645__(7062);
                Object.defineProperty(exports1, "TypeHierarchyPrepareRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_typeHierarchy_1.TypeHierarchyPrepareRequest;
                    }
                });
                Object.defineProperty(exports1, "TypeHierarchySubtypesRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_typeHierarchy_1.TypeHierarchySubtypesRequest;
                    }
                });
                Object.defineProperty(exports1, "TypeHierarchySupertypesRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_typeHierarchy_1.TypeHierarchySupertypesRequest;
                    }
                });
                const protocol_inlineValue_1 = __nested_webpack_require_477645__(3491);
                Object.defineProperty(exports1, "InlineValueRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_inlineValue_1.InlineValueRequest;
                    }
                });
                Object.defineProperty(exports1, "InlineValueRefreshRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_inlineValue_1.InlineValueRefreshRequest;
                    }
                });
                const protocol_inlayHint_1 = __nested_webpack_require_477645__(9383);
                Object.defineProperty(exports1, "InlayHintRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_inlayHint_1.InlayHintRequest;
                    }
                });
                Object.defineProperty(exports1, "InlayHintResolveRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_inlayHint_1.InlayHintResolveRequest;
                    }
                });
                Object.defineProperty(exports1, "InlayHintRefreshRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_inlayHint_1.InlayHintRefreshRequest;
                    }
                });
                const protocol_diagnostic_1 = __nested_webpack_require_477645__(1494);
                Object.defineProperty(exports1, "DiagnosticServerCancellationData", {
                    enumerable: true,
                    get: function() {
                        return protocol_diagnostic_1.DiagnosticServerCancellationData;
                    }
                });
                Object.defineProperty(exports1, "DocumentDiagnosticReportKind", {
                    enumerable: true,
                    get: function() {
                        return protocol_diagnostic_1.DocumentDiagnosticReportKind;
                    }
                });
                Object.defineProperty(exports1, "DocumentDiagnosticRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_diagnostic_1.DocumentDiagnosticRequest;
                    }
                });
                Object.defineProperty(exports1, "WorkspaceDiagnosticRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_diagnostic_1.WorkspaceDiagnosticRequest;
                    }
                });
                Object.defineProperty(exports1, "DiagnosticRefreshRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_diagnostic_1.DiagnosticRefreshRequest;
                    }
                });
                const protocol_notebook_1 = __nested_webpack_require_477645__(4792);
                Object.defineProperty(exports1, "NotebookCellKind", {
                    enumerable: true,
                    get: function() {
                        return protocol_notebook_1.NotebookCellKind;
                    }
                });
                Object.defineProperty(exports1, "ExecutionSummary", {
                    enumerable: true,
                    get: function() {
                        return protocol_notebook_1.ExecutionSummary;
                    }
                });
                Object.defineProperty(exports1, "NotebookCell", {
                    enumerable: true,
                    get: function() {
                        return protocol_notebook_1.NotebookCell;
                    }
                });
                Object.defineProperty(exports1, "NotebookDocument", {
                    enumerable: true,
                    get: function() {
                        return protocol_notebook_1.NotebookDocument;
                    }
                });
                Object.defineProperty(exports1, "NotebookDocumentSyncRegistrationType", {
                    enumerable: true,
                    get: function() {
                        return protocol_notebook_1.NotebookDocumentSyncRegistrationType;
                    }
                });
                Object.defineProperty(exports1, "DidOpenNotebookDocumentNotification", {
                    enumerable: true,
                    get: function() {
                        return protocol_notebook_1.DidOpenNotebookDocumentNotification;
                    }
                });
                Object.defineProperty(exports1, "NotebookCellArrayChange", {
                    enumerable: true,
                    get: function() {
                        return protocol_notebook_1.NotebookCellArrayChange;
                    }
                });
                Object.defineProperty(exports1, "DidChangeNotebookDocumentNotification", {
                    enumerable: true,
                    get: function() {
                        return protocol_notebook_1.DidChangeNotebookDocumentNotification;
                    }
                });
                Object.defineProperty(exports1, "DidSaveNotebookDocumentNotification", {
                    enumerable: true,
                    get: function() {
                        return protocol_notebook_1.DidSaveNotebookDocumentNotification;
                    }
                });
                Object.defineProperty(exports1, "DidCloseNotebookDocumentNotification", {
                    enumerable: true,
                    get: function() {
                        return protocol_notebook_1.DidCloseNotebookDocumentNotification;
                    }
                });
                // @ts-ignore: to avoid inlining LocationLink as dynamic import
                let __noDynamicImport;
                /**
 * The TextDocumentFilter namespace provides helper functions to work with
 * {@link TextDocumentFilter} literals.
 *
 * @since 3.17.0
 */ var TextDocumentFilter;
                (function(TextDocumentFilter) {
                    function is(value) {
                        const candidate = value;
                        return Is.string(candidate.language) || Is.string(candidate.scheme) || Is.string(candidate.pattern);
                    }
                    TextDocumentFilter.is = is;
                })(TextDocumentFilter = exports1.TextDocumentFilter || (exports1.TextDocumentFilter = {}));
                /**
 * The NotebookDocumentFilter namespace provides helper functions to work with
 * {@link NotebookDocumentFilter} literals.
 *
 * @since 3.17.0
 */ var NotebookDocumentFilter;
                (function(NotebookDocumentFilter) {
                    function is(value) {
                        const candidate = value;
                        return Is.objectLiteral(candidate) && (Is.string(candidate.notebookType) || Is.string(candidate.scheme) || Is.string(candidate.pattern));
                    }
                    NotebookDocumentFilter.is = is;
                })(NotebookDocumentFilter = exports1.NotebookDocumentFilter || (exports1.NotebookDocumentFilter = {}));
                /**
 * The NotebookCellTextDocumentFilter namespace provides helper functions to work with
 * {@link NotebookCellTextDocumentFilter} literals.
 *
 * @since 3.17.0
 */ var NotebookCellTextDocumentFilter;
                (function(NotebookCellTextDocumentFilter) {
                    function is(value) {
                        const candidate = value;
                        return Is.objectLiteral(candidate) && (Is.string(candidate.notebook) || NotebookDocumentFilter.is(candidate.notebook)) && (candidate.language === undefined || Is.string(candidate.language));
                    }
                    NotebookCellTextDocumentFilter.is = is;
                })(NotebookCellTextDocumentFilter = exports1.NotebookCellTextDocumentFilter || (exports1.NotebookCellTextDocumentFilter = {}));
                /**
 * The DocumentSelector namespace provides helper functions to work with
 * {@link DocumentSelector}s.
 */ var DocumentSelector;
                (function(DocumentSelector) {
                    function is(value) {
                        if (!Array.isArray(value)) {
                            return false;
                        }
                        for (let elem of value){
                            if (!Is.string(elem) && !TextDocumentFilter.is(elem) && !NotebookCellTextDocumentFilter.is(elem)) {
                                return false;
                            }
                        }
                        return true;
                    }
                    DocumentSelector.is = is;
                })(DocumentSelector = exports1.DocumentSelector || (exports1.DocumentSelector = {}));
                /**
 * The `client/registerCapability` request is sent from the server to the client to register a new capability
 * handler on the client side.
 */ var RegistrationRequest;
                (function(RegistrationRequest) {
                    RegistrationRequest.method = 'client/registerCapability';
                    RegistrationRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    RegistrationRequest.type = new messages_1.ProtocolRequestType(RegistrationRequest.method);
                })(RegistrationRequest = exports1.RegistrationRequest || (exports1.RegistrationRequest = {}));
                /**
 * The `client/unregisterCapability` request is sent from the server to the client to unregister a previously registered capability
 * handler on the client side.
 */ var UnregistrationRequest;
                (function(UnregistrationRequest) {
                    UnregistrationRequest.method = 'client/unregisterCapability';
                    UnregistrationRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    UnregistrationRequest.type = new messages_1.ProtocolRequestType(UnregistrationRequest.method);
                })(UnregistrationRequest = exports1.UnregistrationRequest || (exports1.UnregistrationRequest = {}));
                var ResourceOperationKind;
                (function(ResourceOperationKind) {
                    /**
     * Supports creating new files and folders.
     */ ResourceOperationKind.Create = 'create';
                    /**
     * Supports renaming existing files and folders.
     */ ResourceOperationKind.Rename = 'rename';
                    /**
     * Supports deleting existing files and folders.
     */ ResourceOperationKind.Delete = 'delete';
                })(ResourceOperationKind = exports1.ResourceOperationKind || (exports1.ResourceOperationKind = {}));
                var FailureHandlingKind;
                (function(FailureHandlingKind) {
                    /**
     * Applying the workspace change is simply aborted if one of the changes provided
     * fails. All operations executed before the failing operation stay executed.
     */ FailureHandlingKind.Abort = 'abort';
                    /**
     * All operations are executed transactional. That means they either all
     * succeed or no changes at all are applied to the workspace.
     */ FailureHandlingKind.Transactional = 'transactional';
                    /**
     * If the workspace edit contains only textual file changes they are executed transactional.
     * If resource changes (create, rename or delete file) are part of the change the failure
     * handling strategy is abort.
     */ FailureHandlingKind.TextOnlyTransactional = 'textOnlyTransactional';
                    /**
     * The client tries to undo the operations already executed. But there is no
     * guarantee that this is succeeding.
     */ FailureHandlingKind.Undo = 'undo';
                })(FailureHandlingKind = exports1.FailureHandlingKind || (exports1.FailureHandlingKind = {}));
                /**
 * A set of predefined position encoding kinds.
 *
 * @since 3.17.0
 */ var PositionEncodingKind;
                (function(PositionEncodingKind) {
                    /**
     * Character offsets count UTF-8 code units (e.g. bytes).
     */ PositionEncodingKind.UTF8 = 'utf-8';
                    /**
     * Character offsets count UTF-16 code units.
     *
     * This is the default and must always be supported
     * by servers
     */ PositionEncodingKind.UTF16 = 'utf-16';
                    /**
     * Character offsets count UTF-32 code units.
     *
     * Implementation note: these are the same as Unicode codepoints,
     * so this `PositionEncodingKind` may also be used for an
     * encoding-agnostic representation of character offsets.
     */ PositionEncodingKind.UTF32 = 'utf-32';
                })(PositionEncodingKind = exports1.PositionEncodingKind || (exports1.PositionEncodingKind = {}));
                /**
 * The StaticRegistrationOptions namespace provides helper functions to work with
 * {@link StaticRegistrationOptions} literals.
 */ var StaticRegistrationOptions;
                (function(StaticRegistrationOptions) {
                    function hasId(value) {
                        const candidate = value;
                        return candidate && Is.string(candidate.id) && candidate.id.length > 0;
                    }
                    StaticRegistrationOptions.hasId = hasId;
                })(StaticRegistrationOptions = exports1.StaticRegistrationOptions || (exports1.StaticRegistrationOptions = {}));
                /**
 * The TextDocumentRegistrationOptions namespace provides helper functions to work with
 * {@link TextDocumentRegistrationOptions} literals.
 */ var TextDocumentRegistrationOptions;
                (function(TextDocumentRegistrationOptions) {
                    function is(value) {
                        const candidate = value;
                        return candidate && (candidate.documentSelector === null || DocumentSelector.is(candidate.documentSelector));
                    }
                    TextDocumentRegistrationOptions.is = is;
                })(TextDocumentRegistrationOptions = exports1.TextDocumentRegistrationOptions || (exports1.TextDocumentRegistrationOptions = {}));
                /**
 * The WorkDoneProgressOptions namespace provides helper functions to work with
 * {@link WorkDoneProgressOptions} literals.
 */ var WorkDoneProgressOptions;
                (function(WorkDoneProgressOptions) {
                    function is(value) {
                        const candidate = value;
                        return Is.objectLiteral(candidate) && (candidate.workDoneProgress === undefined || Is.boolean(candidate.workDoneProgress));
                    }
                    WorkDoneProgressOptions.is = is;
                    function hasWorkDoneProgress(value) {
                        const candidate = value;
                        return candidate && Is.boolean(candidate.workDoneProgress);
                    }
                    WorkDoneProgressOptions.hasWorkDoneProgress = hasWorkDoneProgress;
                })(WorkDoneProgressOptions = exports1.WorkDoneProgressOptions || (exports1.WorkDoneProgressOptions = {}));
                /**
 * The initialize request is sent from the client to the server.
 * It is sent once as the request after starting up the server.
 * The requests parameter is of type {@link InitializeParams}
 * the response if of type {@link InitializeResult} of a Thenable that
 * resolves to such.
 */ var InitializeRequest;
                (function(InitializeRequest) {
                    InitializeRequest.method = 'initialize';
                    InitializeRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    InitializeRequest.type = new messages_1.ProtocolRequestType(InitializeRequest.method);
                })(InitializeRequest = exports1.InitializeRequest || (exports1.InitializeRequest = {}));
                /**
 * Known error codes for an `InitializeErrorCodes`;
 */ var InitializeErrorCodes;
                (function(InitializeErrorCodes) {
                    /**
     * If the protocol version provided by the client can't be handled by the server.
     *
     * @deprecated This initialize error got replaced by client capabilities. There is
     * no version handshake in version 3.0x
     */ InitializeErrorCodes.unknownProtocolVersion = 1;
                })(InitializeErrorCodes = exports1.InitializeErrorCodes || (exports1.InitializeErrorCodes = {}));
                /**
 * The initialized notification is sent from the client to the
 * server after the client is fully initialized and the server
 * is allowed to send requests from the server to the client.
 */ var InitializedNotification;
                (function(InitializedNotification) {
                    InitializedNotification.method = 'initialized';
                    InitializedNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    InitializedNotification.type = new messages_1.ProtocolNotificationType(InitializedNotification.method);
                })(InitializedNotification = exports1.InitializedNotification || (exports1.InitializedNotification = {}));
                //---- Shutdown Method ----
                /**
 * A shutdown request is sent from the client to the server.
 * It is sent once when the client decides to shutdown the
 * server. The only notification that is sent after a shutdown request
 * is the exit event.
 */ var ShutdownRequest;
                (function(ShutdownRequest) {
                    ShutdownRequest.method = 'shutdown';
                    ShutdownRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    ShutdownRequest.type = new messages_1.ProtocolRequestType0(ShutdownRequest.method);
                })(ShutdownRequest = exports1.ShutdownRequest || (exports1.ShutdownRequest = {}));
                //---- Exit Notification ----
                /**
 * The exit event is sent from the client to the server to
 * ask the server to exit its process.
 */ var ExitNotification;
                (function(ExitNotification) {
                    ExitNotification.method = 'exit';
                    ExitNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    ExitNotification.type = new messages_1.ProtocolNotificationType0(ExitNotification.method);
                })(ExitNotification = exports1.ExitNotification || (exports1.ExitNotification = {}));
                /**
 * The configuration change notification is sent from the client to the server
 * when the client's configuration has changed. The notification contains
 * the changed configuration as defined by the language client.
 */ var DidChangeConfigurationNotification;
                (function(DidChangeConfigurationNotification) {
                    DidChangeConfigurationNotification.method = 'workspace/didChangeConfiguration';
                    DidChangeConfigurationNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidChangeConfigurationNotification.type = new messages_1.ProtocolNotificationType(DidChangeConfigurationNotification.method);
                })(DidChangeConfigurationNotification = exports1.DidChangeConfigurationNotification || (exports1.DidChangeConfigurationNotification = {}));
                //---- Message show and log notifications ----
                /**
 * The message type
 */ var MessageType;
                (function(MessageType) {
                    /**
     * An error message.
     */ MessageType.Error = 1;
                    /**
     * A warning message.
     */ MessageType.Warning = 2;
                    /**
     * An information message.
     */ MessageType.Info = 3;
                    /**
     * A log message.
     */ MessageType.Log = 4;
                })(MessageType = exports1.MessageType || (exports1.MessageType = {}));
                /**
 * The show message notification is sent from a server to a client to ask
 * the client to display a particular message in the user interface.
 */ var ShowMessageNotification;
                (function(ShowMessageNotification) {
                    ShowMessageNotification.method = 'window/showMessage';
                    ShowMessageNotification.messageDirection = messages_1.MessageDirection.serverToClient;
                    ShowMessageNotification.type = new messages_1.ProtocolNotificationType(ShowMessageNotification.method);
                })(ShowMessageNotification = exports1.ShowMessageNotification || (exports1.ShowMessageNotification = {}));
                /**
 * The show message request is sent from the server to the client to show a message
 * and a set of options actions to the user.
 */ var ShowMessageRequest;
                (function(ShowMessageRequest) {
                    ShowMessageRequest.method = 'window/showMessageRequest';
                    ShowMessageRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    ShowMessageRequest.type = new messages_1.ProtocolRequestType(ShowMessageRequest.method);
                })(ShowMessageRequest = exports1.ShowMessageRequest || (exports1.ShowMessageRequest = {}));
                /**
 * The log message notification is sent from the server to the client to ask
 * the client to log a particular message.
 */ var LogMessageNotification;
                (function(LogMessageNotification) {
                    LogMessageNotification.method = 'window/logMessage';
                    LogMessageNotification.messageDirection = messages_1.MessageDirection.serverToClient;
                    LogMessageNotification.type = new messages_1.ProtocolNotificationType(LogMessageNotification.method);
                })(LogMessageNotification = exports1.LogMessageNotification || (exports1.LogMessageNotification = {}));
                //---- Telemetry notification
                /**
 * The telemetry event notification is sent from the server to the client to ask
 * the client to log telemetry data.
 */ var TelemetryEventNotification;
                (function(TelemetryEventNotification) {
                    TelemetryEventNotification.method = 'telemetry/event';
                    TelemetryEventNotification.messageDirection = messages_1.MessageDirection.serverToClient;
                    TelemetryEventNotification.type = new messages_1.ProtocolNotificationType(TelemetryEventNotification.method);
                })(TelemetryEventNotification = exports1.TelemetryEventNotification || (exports1.TelemetryEventNotification = {}));
                /**
 * Defines how the host (editor) should sync
 * document changes to the language server.
 */ var TextDocumentSyncKind;
                (function(TextDocumentSyncKind) {
                    /**
     * Documents should not be synced at all.
     */ TextDocumentSyncKind.None = 0;
                    /**
     * Documents are synced by always sending the full content
     * of the document.
     */ TextDocumentSyncKind.Full = 1;
                    /**
     * Documents are synced by sending the full content on open.
     * After that only incremental updates to the document are
     * send.
     */ TextDocumentSyncKind.Incremental = 2;
                })(TextDocumentSyncKind = exports1.TextDocumentSyncKind || (exports1.TextDocumentSyncKind = {}));
                /**
 * The document open notification is sent from the client to the server to signal
 * newly opened text documents. The document's truth is now managed by the client
 * and the server must not try to read the document's truth using the document's
 * uri. Open in this sense means it is managed by the client. It doesn't necessarily
 * mean that its content is presented in an editor. An open notification must not
 * be sent more than once without a corresponding close notification send before.
 * This means open and close notification must be balanced and the max open count
 * is one.
 */ var DidOpenTextDocumentNotification;
                (function(DidOpenTextDocumentNotification) {
                    DidOpenTextDocumentNotification.method = 'textDocument/didOpen';
                    DidOpenTextDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidOpenTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidOpenTextDocumentNotification.method);
                })(DidOpenTextDocumentNotification = exports1.DidOpenTextDocumentNotification || (exports1.DidOpenTextDocumentNotification = {}));
                var TextDocumentContentChangeEvent;
                (function(TextDocumentContentChangeEvent) {
                    /**
     * Checks whether the information describes a delta event.
     */ function isIncremental(event) {
                        let candidate = event;
                        return candidate !== undefined && candidate !== null && typeof candidate.text === 'string' && candidate.range !== undefined && (candidate.rangeLength === undefined || typeof candidate.rangeLength === 'number');
                    }
                    TextDocumentContentChangeEvent.isIncremental = isIncremental;
                    /**
     * Checks whether the information describes a full replacement event.
     */ function isFull(event) {
                        let candidate = event;
                        return candidate !== undefined && candidate !== null && typeof candidate.text === 'string' && candidate.range === undefined && candidate.rangeLength === undefined;
                    }
                    TextDocumentContentChangeEvent.isFull = isFull;
                })(TextDocumentContentChangeEvent = exports1.TextDocumentContentChangeEvent || (exports1.TextDocumentContentChangeEvent = {}));
                /**
 * The document change notification is sent from the client to the server to signal
 * changes to a text document.
 */ var DidChangeTextDocumentNotification;
                (function(DidChangeTextDocumentNotification) {
                    DidChangeTextDocumentNotification.method = 'textDocument/didChange';
                    DidChangeTextDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidChangeTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidChangeTextDocumentNotification.method);
                })(DidChangeTextDocumentNotification = exports1.DidChangeTextDocumentNotification || (exports1.DidChangeTextDocumentNotification = {}));
                /**
 * The document close notification is sent from the client to the server when
 * the document got closed in the client. The document's truth now exists where
 * the document's uri points to (e.g. if the document's uri is a file uri the
 * truth now exists on disk). As with the open notification the close notification
 * is about managing the document's content. Receiving a close notification
 * doesn't mean that the document was open in an editor before. A close
 * notification requires a previous open notification to be sent.
 */ var DidCloseTextDocumentNotification;
                (function(DidCloseTextDocumentNotification) {
                    DidCloseTextDocumentNotification.method = 'textDocument/didClose';
                    DidCloseTextDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidCloseTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidCloseTextDocumentNotification.method);
                })(DidCloseTextDocumentNotification = exports1.DidCloseTextDocumentNotification || (exports1.DidCloseTextDocumentNotification = {}));
                /**
 * The document save notification is sent from the client to the server when
 * the document got saved in the client.
 */ var DidSaveTextDocumentNotification;
                (function(DidSaveTextDocumentNotification) {
                    DidSaveTextDocumentNotification.method = 'textDocument/didSave';
                    DidSaveTextDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidSaveTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidSaveTextDocumentNotification.method);
                })(DidSaveTextDocumentNotification = exports1.DidSaveTextDocumentNotification || (exports1.DidSaveTextDocumentNotification = {}));
                /**
 * Represents reasons why a text document is saved.
 */ var TextDocumentSaveReason;
                (function(TextDocumentSaveReason) {
                    /**
     * Manually triggered, e.g. by the user pressing save, by starting debugging,
     * or by an API call.
     */ TextDocumentSaveReason.Manual = 1;
                    /**
     * Automatic after a delay.
     */ TextDocumentSaveReason.AfterDelay = 2;
                    /**
     * When the editor lost focus.
     */ TextDocumentSaveReason.FocusOut = 3;
                })(TextDocumentSaveReason = exports1.TextDocumentSaveReason || (exports1.TextDocumentSaveReason = {}));
                /**
 * A document will save notification is sent from the client to the server before
 * the document is actually saved.
 */ var WillSaveTextDocumentNotification;
                (function(WillSaveTextDocumentNotification) {
                    WillSaveTextDocumentNotification.method = 'textDocument/willSave';
                    WillSaveTextDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    WillSaveTextDocumentNotification.type = new messages_1.ProtocolNotificationType(WillSaveTextDocumentNotification.method);
                })(WillSaveTextDocumentNotification = exports1.WillSaveTextDocumentNotification || (exports1.WillSaveTextDocumentNotification = {}));
                /**
 * A document will save request is sent from the client to the server before
 * the document is actually saved. The request can return an array of TextEdits
 * which will be applied to the text document before it is saved. Please note that
 * clients might drop results if computing the text edits took too long or if a
 * server constantly fails on this request. This is done to keep the save fast and
 * reliable.
 */ var WillSaveTextDocumentWaitUntilRequest;
                (function(WillSaveTextDocumentWaitUntilRequest) {
                    WillSaveTextDocumentWaitUntilRequest.method = 'textDocument/willSaveWaitUntil';
                    WillSaveTextDocumentWaitUntilRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    WillSaveTextDocumentWaitUntilRequest.type = new messages_1.ProtocolRequestType(WillSaveTextDocumentWaitUntilRequest.method);
                })(WillSaveTextDocumentWaitUntilRequest = exports1.WillSaveTextDocumentWaitUntilRequest || (exports1.WillSaveTextDocumentWaitUntilRequest = {}));
                /**
 * The watched files notification is sent from the client to the server when
 * the client detects changes to file watched by the language client.
 */ var DidChangeWatchedFilesNotification;
                (function(DidChangeWatchedFilesNotification) {
                    DidChangeWatchedFilesNotification.method = 'workspace/didChangeWatchedFiles';
                    DidChangeWatchedFilesNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidChangeWatchedFilesNotification.type = new messages_1.ProtocolNotificationType(DidChangeWatchedFilesNotification.method);
                })(DidChangeWatchedFilesNotification = exports1.DidChangeWatchedFilesNotification || (exports1.DidChangeWatchedFilesNotification = {}));
                /**
 * The file event type
 */ var FileChangeType;
                (function(FileChangeType) {
                    /**
     * The file got created.
     */ FileChangeType.Created = 1;
                    /**
     * The file got changed.
     */ FileChangeType.Changed = 2;
                    /**
     * The file got deleted.
     */ FileChangeType.Deleted = 3;
                })(FileChangeType = exports1.FileChangeType || (exports1.FileChangeType = {}));
                var RelativePattern;
                (function(RelativePattern) {
                    function is(value) {
                        const candidate = value;
                        return Is.objectLiteral(candidate) && (vscode_languageserver_types_1.URI.is(candidate.baseUri) || vscode_languageserver_types_1.WorkspaceFolder.is(candidate.baseUri)) && Is.string(candidate.pattern);
                    }
                    RelativePattern.is = is;
                })(RelativePattern = exports1.RelativePattern || (exports1.RelativePattern = {}));
                var WatchKind;
                (function(WatchKind) {
                    /**
     * Interested in create events.
     */ WatchKind.Create = 1;
                    /**
     * Interested in change events
     */ WatchKind.Change = 2;
                    /**
     * Interested in delete events
     */ WatchKind.Delete = 4;
                })(WatchKind = exports1.WatchKind || (exports1.WatchKind = {}));
                /**
 * Diagnostics notification are sent from the server to the client to signal
 * results of validation runs.
 */ var PublishDiagnosticsNotification;
                (function(PublishDiagnosticsNotification) {
                    PublishDiagnosticsNotification.method = 'textDocument/publishDiagnostics';
                    PublishDiagnosticsNotification.messageDirection = messages_1.MessageDirection.serverToClient;
                    PublishDiagnosticsNotification.type = new messages_1.ProtocolNotificationType(PublishDiagnosticsNotification.method);
                })(PublishDiagnosticsNotification = exports1.PublishDiagnosticsNotification || (exports1.PublishDiagnosticsNotification = {}));
                /**
 * How a completion was triggered
 */ var CompletionTriggerKind;
                (function(CompletionTriggerKind) {
                    /**
     * Completion was triggered by typing an identifier (24x7 code
     * complete), manual invocation (e.g Ctrl+Space) or via API.
     */ CompletionTriggerKind.Invoked = 1;
                    /**
     * Completion was triggered by a trigger character specified by
     * the `triggerCharacters` properties of the `CompletionRegistrationOptions`.
     */ CompletionTriggerKind.TriggerCharacter = 2;
                    /**
     * Completion was re-triggered as current completion list is incomplete
     */ CompletionTriggerKind.TriggerForIncompleteCompletions = 3;
                })(CompletionTriggerKind = exports1.CompletionTriggerKind || (exports1.CompletionTriggerKind = {}));
                /**
 * Request to request completion at a given text document position. The request's
 * parameter is of type {@link TextDocumentPosition} the response
 * is of type {@link CompletionItem CompletionItem[]} or {@link CompletionList}
 * or a Thenable that resolves to such.
 *
 * The request can delay the computation of the {@link CompletionItem.detail `detail`}
 * and {@link CompletionItem.documentation `documentation`} properties to the `completionItem/resolve`
 * request. However, properties that are needed for the initial sorting and filtering, like `sortText`,
 * `filterText`, `insertText`, and `textEdit`, must not be changed during resolve.
 */ var CompletionRequest;
                (function(CompletionRequest) {
                    CompletionRequest.method = 'textDocument/completion';
                    CompletionRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    CompletionRequest.type = new messages_1.ProtocolRequestType(CompletionRequest.method);
                })(CompletionRequest = exports1.CompletionRequest || (exports1.CompletionRequest = {}));
                /**
 * Request to resolve additional information for a given completion item.The request's
 * parameter is of type {@link CompletionItem} the response
 * is of type {@link CompletionItem} or a Thenable that resolves to such.
 */ var CompletionResolveRequest;
                (function(CompletionResolveRequest) {
                    CompletionResolveRequest.method = 'completionItem/resolve';
                    CompletionResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    CompletionResolveRequest.type = new messages_1.ProtocolRequestType(CompletionResolveRequest.method);
                })(CompletionResolveRequest = exports1.CompletionResolveRequest || (exports1.CompletionResolveRequest = {}));
                /**
 * Request to request hover information at a given text document position. The request's
 * parameter is of type {@link TextDocumentPosition} the response is of
 * type {@link Hover} or a Thenable that resolves to such.
 */ var HoverRequest;
                (function(HoverRequest) {
                    HoverRequest.method = 'textDocument/hover';
                    HoverRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    HoverRequest.type = new messages_1.ProtocolRequestType(HoverRequest.method);
                })(HoverRequest = exports1.HoverRequest || (exports1.HoverRequest = {}));
                /**
 * How a signature help was triggered.
 *
 * @since 3.15.0
 */ var SignatureHelpTriggerKind;
                (function(SignatureHelpTriggerKind) {
                    /**
     * Signature help was invoked manually by the user or by a command.
     */ SignatureHelpTriggerKind.Invoked = 1;
                    /**
     * Signature help was triggered by a trigger character.
     */ SignatureHelpTriggerKind.TriggerCharacter = 2;
                    /**
     * Signature help was triggered by the cursor moving or by the document content changing.
     */ SignatureHelpTriggerKind.ContentChange = 3;
                })(SignatureHelpTriggerKind = exports1.SignatureHelpTriggerKind || (exports1.SignatureHelpTriggerKind = {}));
                var SignatureHelpRequest;
                (function(SignatureHelpRequest) {
                    SignatureHelpRequest.method = 'textDocument/signatureHelp';
                    SignatureHelpRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    SignatureHelpRequest.type = new messages_1.ProtocolRequestType(SignatureHelpRequest.method);
                })(SignatureHelpRequest = exports1.SignatureHelpRequest || (exports1.SignatureHelpRequest = {}));
                /**
 * A request to resolve the definition location of a symbol at a given text
 * document position. The request's parameter is of type [TextDocumentPosition]
 * (#TextDocumentPosition) the response is of either type {@link Definition}
 * or a typed array of {@link DefinitionLink} or a Thenable that resolves
 * to such.
 */ var DefinitionRequest;
                (function(DefinitionRequest) {
                    DefinitionRequest.method = 'textDocument/definition';
                    DefinitionRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    DefinitionRequest.type = new messages_1.ProtocolRequestType(DefinitionRequest.method);
                })(DefinitionRequest = exports1.DefinitionRequest || (exports1.DefinitionRequest = {}));
                /**
 * A request to resolve project-wide references for the symbol denoted
 * by the given text document position. The request's parameter is of
 * type {@link ReferenceParams} the response is of type
 * {@link Location Location[]} or a Thenable that resolves to such.
 */ var ReferencesRequest;
                (function(ReferencesRequest) {
                    ReferencesRequest.method = 'textDocument/references';
                    ReferencesRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    ReferencesRequest.type = new messages_1.ProtocolRequestType(ReferencesRequest.method);
                })(ReferencesRequest = exports1.ReferencesRequest || (exports1.ReferencesRequest = {}));
                /**
 * Request to resolve a {@link DocumentHighlight} for a given
 * text document position. The request's parameter is of type [TextDocumentPosition]
 * (#TextDocumentPosition) the request response is of type [DocumentHighlight[]]
 * (#DocumentHighlight) or a Thenable that resolves to such.
 */ var DocumentHighlightRequest;
                (function(DocumentHighlightRequest) {
                    DocumentHighlightRequest.method = 'textDocument/documentHighlight';
                    DocumentHighlightRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    DocumentHighlightRequest.type = new messages_1.ProtocolRequestType(DocumentHighlightRequest.method);
                })(DocumentHighlightRequest = exports1.DocumentHighlightRequest || (exports1.DocumentHighlightRequest = {}));
                /**
 * A request to list all symbols found in a given text document. The request's
 * parameter is of type {@link TextDocumentIdentifier} the
 * response is of type {@link SymbolInformation SymbolInformation[]} or a Thenable
 * that resolves to such.
 */ var DocumentSymbolRequest;
                (function(DocumentSymbolRequest) {
                    DocumentSymbolRequest.method = 'textDocument/documentSymbol';
                    DocumentSymbolRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    DocumentSymbolRequest.type = new messages_1.ProtocolRequestType(DocumentSymbolRequest.method);
                })(DocumentSymbolRequest = exports1.DocumentSymbolRequest || (exports1.DocumentSymbolRequest = {}));
                /**
 * A request to provide commands for the given text document and range.
 */ var CodeActionRequest;
                (function(CodeActionRequest) {
                    CodeActionRequest.method = 'textDocument/codeAction';
                    CodeActionRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    CodeActionRequest.type = new messages_1.ProtocolRequestType(CodeActionRequest.method);
                })(CodeActionRequest = exports1.CodeActionRequest || (exports1.CodeActionRequest = {}));
                /**
 * Request to resolve additional information for a given code action.The request's
 * parameter is of type {@link CodeAction} the response
 * is of type {@link CodeAction} or a Thenable that resolves to such.
 */ var CodeActionResolveRequest;
                (function(CodeActionResolveRequest) {
                    CodeActionResolveRequest.method = 'codeAction/resolve';
                    CodeActionResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    CodeActionResolveRequest.type = new messages_1.ProtocolRequestType(CodeActionResolveRequest.method);
                })(CodeActionResolveRequest = exports1.CodeActionResolveRequest || (exports1.CodeActionResolveRequest = {}));
                /**
 * A request to list project-wide symbols matching the query string given
 * by the {@link WorkspaceSymbolParams}. The response is
 * of type {@link SymbolInformation SymbolInformation[]} or a Thenable that
 * resolves to such.
 *
 * @since 3.17.0 - support for WorkspaceSymbol in the returned data. Clients
 *  need to advertise support for WorkspaceSymbols via the client capability
 *  `workspace.symbol.resolveSupport`.
 *
 */ var WorkspaceSymbolRequest;
                (function(WorkspaceSymbolRequest) {
                    WorkspaceSymbolRequest.method = 'workspace/symbol';
                    WorkspaceSymbolRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    WorkspaceSymbolRequest.type = new messages_1.ProtocolRequestType(WorkspaceSymbolRequest.method);
                })(WorkspaceSymbolRequest = exports1.WorkspaceSymbolRequest || (exports1.WorkspaceSymbolRequest = {}));
                /**
 * A request to resolve the range inside the workspace
 * symbol's location.
 *
 * @since 3.17.0
 */ var WorkspaceSymbolResolveRequest;
                (function(WorkspaceSymbolResolveRequest) {
                    WorkspaceSymbolResolveRequest.method = 'workspaceSymbol/resolve';
                    WorkspaceSymbolResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    WorkspaceSymbolResolveRequest.type = new messages_1.ProtocolRequestType(WorkspaceSymbolResolveRequest.method);
                })(WorkspaceSymbolResolveRequest = exports1.WorkspaceSymbolResolveRequest || (exports1.WorkspaceSymbolResolveRequest = {}));
                /**
 * A request to provide code lens for the given text document.
 */ var CodeLensRequest;
                (function(CodeLensRequest) {
                    CodeLensRequest.method = 'textDocument/codeLens';
                    CodeLensRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    CodeLensRequest.type = new messages_1.ProtocolRequestType(CodeLensRequest.method);
                })(CodeLensRequest = exports1.CodeLensRequest || (exports1.CodeLensRequest = {}));
                /**
 * A request to resolve a command for a given code lens.
 */ var CodeLensResolveRequest;
                (function(CodeLensResolveRequest) {
                    CodeLensResolveRequest.method = 'codeLens/resolve';
                    CodeLensResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    CodeLensResolveRequest.type = new messages_1.ProtocolRequestType(CodeLensResolveRequest.method);
                })(CodeLensResolveRequest = exports1.CodeLensResolveRequest || (exports1.CodeLensResolveRequest = {}));
                /**
 * A request to refresh all code actions
 *
 * @since 3.16.0
 */ var CodeLensRefreshRequest;
                (function(CodeLensRefreshRequest) {
                    CodeLensRefreshRequest.method = `workspace/codeLens/refresh`;
                    CodeLensRefreshRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    CodeLensRefreshRequest.type = new messages_1.ProtocolRequestType0(CodeLensRefreshRequest.method);
                })(CodeLensRefreshRequest = exports1.CodeLensRefreshRequest || (exports1.CodeLensRefreshRequest = {}));
                /**
 * A request to provide document links
 */ var DocumentLinkRequest;
                (function(DocumentLinkRequest) {
                    DocumentLinkRequest.method = 'textDocument/documentLink';
                    DocumentLinkRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    DocumentLinkRequest.type = new messages_1.ProtocolRequestType(DocumentLinkRequest.method);
                })(DocumentLinkRequest = exports1.DocumentLinkRequest || (exports1.DocumentLinkRequest = {}));
                /**
 * Request to resolve additional information for a given document link. The request's
 * parameter is of type {@link DocumentLink} the response
 * is of type {@link DocumentLink} or a Thenable that resolves to such.
 */ var DocumentLinkResolveRequest;
                (function(DocumentLinkResolveRequest) {
                    DocumentLinkResolveRequest.method = 'documentLink/resolve';
                    DocumentLinkResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    DocumentLinkResolveRequest.type = new messages_1.ProtocolRequestType(DocumentLinkResolveRequest.method);
                })(DocumentLinkResolveRequest = exports1.DocumentLinkResolveRequest || (exports1.DocumentLinkResolveRequest = {}));
                /**
 * A request to to format a whole document.
 */ var DocumentFormattingRequest;
                (function(DocumentFormattingRequest) {
                    DocumentFormattingRequest.method = 'textDocument/formatting';
                    DocumentFormattingRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    DocumentFormattingRequest.type = new messages_1.ProtocolRequestType(DocumentFormattingRequest.method);
                })(DocumentFormattingRequest = exports1.DocumentFormattingRequest || (exports1.DocumentFormattingRequest = {}));
                /**
 * A request to to format a range in a document.
 */ var DocumentRangeFormattingRequest;
                (function(DocumentRangeFormattingRequest) {
                    DocumentRangeFormattingRequest.method = 'textDocument/rangeFormatting';
                    DocumentRangeFormattingRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    DocumentRangeFormattingRequest.type = new messages_1.ProtocolRequestType(DocumentRangeFormattingRequest.method);
                })(DocumentRangeFormattingRequest = exports1.DocumentRangeFormattingRequest || (exports1.DocumentRangeFormattingRequest = {}));
                /**
 * A request to format a document on type.
 */ var DocumentOnTypeFormattingRequest;
                (function(DocumentOnTypeFormattingRequest) {
                    DocumentOnTypeFormattingRequest.method = 'textDocument/onTypeFormatting';
                    DocumentOnTypeFormattingRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    DocumentOnTypeFormattingRequest.type = new messages_1.ProtocolRequestType(DocumentOnTypeFormattingRequest.method);
                })(DocumentOnTypeFormattingRequest = exports1.DocumentOnTypeFormattingRequest || (exports1.DocumentOnTypeFormattingRequest = {}));
                //---- Rename ----------------------------------------------
                var PrepareSupportDefaultBehavior;
                (function(PrepareSupportDefaultBehavior) {
                    /**
     * The client's default behavior is to select the identifier
     * according the to language's syntax rule.
     */ PrepareSupportDefaultBehavior.Identifier = 1;
                })(PrepareSupportDefaultBehavior = exports1.PrepareSupportDefaultBehavior || (exports1.PrepareSupportDefaultBehavior = {}));
                /**
 * A request to rename a symbol.
 */ var RenameRequest;
                (function(RenameRequest) {
                    RenameRequest.method = 'textDocument/rename';
                    RenameRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    RenameRequest.type = new messages_1.ProtocolRequestType(RenameRequest.method);
                })(RenameRequest = exports1.RenameRequest || (exports1.RenameRequest = {}));
                /**
 * A request to test and perform the setup necessary for a rename.
 *
 * @since 3.16 - support for default behavior
 */ var PrepareRenameRequest;
                (function(PrepareRenameRequest) {
                    PrepareRenameRequest.method = 'textDocument/prepareRename';
                    PrepareRenameRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    PrepareRenameRequest.type = new messages_1.ProtocolRequestType(PrepareRenameRequest.method);
                })(PrepareRenameRequest = exports1.PrepareRenameRequest || (exports1.PrepareRenameRequest = {}));
                /**
 * A request send from the client to the server to execute a command. The request might return
 * a workspace edit which the client will apply to the workspace.
 */ var ExecuteCommandRequest;
                (function(ExecuteCommandRequest) {
                    ExecuteCommandRequest.method = 'workspace/executeCommand';
                    ExecuteCommandRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    ExecuteCommandRequest.type = new messages_1.ProtocolRequestType(ExecuteCommandRequest.method);
                })(ExecuteCommandRequest = exports1.ExecuteCommandRequest || (exports1.ExecuteCommandRequest = {}));
                /**
 * A request sent from the server to the client to modified certain resources.
 */ var ApplyWorkspaceEditRequest;
                (function(ApplyWorkspaceEditRequest) {
                    ApplyWorkspaceEditRequest.method = 'workspace/applyEdit';
                    ApplyWorkspaceEditRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    ApplyWorkspaceEditRequest.type = new messages_1.ProtocolRequestType('workspace/applyEdit');
                })(ApplyWorkspaceEditRequest = exports1.ApplyWorkspaceEditRequest || (exports1.ApplyWorkspaceEditRequest = {}));
            /***/ },
            /***/ 2249: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_546761__)=>{
                "use strict";
                /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.LinkedEditingRangeRequest = void 0;
                const messages_1 = __nested_webpack_require_546761__(8431);
                /**
 * A request to provide ranges that can be edited together.
 *
 * @since 3.16.0
 */ var LinkedEditingRangeRequest;
                (function(LinkedEditingRangeRequest) {
                    LinkedEditingRangeRequest.method = 'textDocument/linkedEditingRange';
                    LinkedEditingRangeRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    LinkedEditingRangeRequest.type = new messages_1.ProtocolRequestType(LinkedEditingRangeRequest.method);
                })(LinkedEditingRangeRequest = exports1.LinkedEditingRangeRequest || (exports1.LinkedEditingRangeRequest = {}));
            /***/ },
            /***/ 7684: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_548134__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.MonikerRequest = exports1.MonikerKind = exports1.UniquenessLevel = void 0;
                const messages_1 = __nested_webpack_require_548134__(8431);
                /**
 * Moniker uniqueness level to define scope of the moniker.
 *
 * @since 3.16.0
 */ var UniquenessLevel;
                (function(UniquenessLevel) {
                    /**
     * The moniker is only unique inside a document
     */ UniquenessLevel.document = 'document';
                    /**
     * The moniker is unique inside a project for which a dump got created
     */ UniquenessLevel.project = 'project';
                    /**
     * The moniker is unique inside the group to which a project belongs
     */ UniquenessLevel.group = 'group';
                    /**
     * The moniker is unique inside the moniker scheme.
     */ UniquenessLevel.scheme = 'scheme';
                    /**
     * The moniker is globally unique
     */ UniquenessLevel.global = 'global';
                })(UniquenessLevel = exports1.UniquenessLevel || (exports1.UniquenessLevel = {}));
                /**
 * The moniker kind.
 *
 * @since 3.16.0
 */ var MonikerKind;
                (function(MonikerKind) {
                    /**
     * The moniker represent a symbol that is imported into a project
     */ MonikerKind.$import = 'import';
                    /**
     * The moniker represents a symbol that is exported from a project
     */ MonikerKind.$export = 'export';
                    /**
     * The moniker represents a symbol that is local to a project (e.g. a local
     * variable of a function, a class not visible outside the project, ...)
     */ MonikerKind.local = 'local';
                })(MonikerKind = exports1.MonikerKind || (exports1.MonikerKind = {}));
                /**
 * A request to get the moniker of a symbol at a given text document position.
 * The request parameter is of type {@link TextDocumentPositionParams}.
 * The response is of type {@link Moniker Moniker[]} or `null`.
 */ var MonikerRequest;
                (function(MonikerRequest) {
                    MonikerRequest.method = 'textDocument/moniker';
                    MonikerRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    MonikerRequest.type = new messages_1.ProtocolRequestType(MonikerRequest.method);
                })(MonikerRequest = exports1.MonikerRequest || (exports1.MonikerRequest = {}));
            /***/ },
            /***/ 4792: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_551168__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.DidCloseNotebookDocumentNotification = exports1.DidSaveNotebookDocumentNotification = exports1.DidChangeNotebookDocumentNotification = exports1.NotebookCellArrayChange = exports1.DidOpenNotebookDocumentNotification = exports1.NotebookDocumentSyncRegistrationType = exports1.NotebookDocument = exports1.NotebookCell = exports1.ExecutionSummary = exports1.NotebookCellKind = void 0;
                const vscode_languageserver_types_1 = __nested_webpack_require_551168__(7717);
                const Is = __nested_webpack_require_551168__(8633);
                const messages_1 = __nested_webpack_require_551168__(8431);
                /**
 * A notebook cell kind.
 *
 * @since 3.17.0
 */ var NotebookCellKind;
                (function(NotebookCellKind) {
                    /**
     * A markup-cell is formatted source that is used for display.
     */ NotebookCellKind.Markup = 1;
                    /**
     * A code-cell is source code.
     */ NotebookCellKind.Code = 2;
                    function is(value) {
                        return value === 1 || value === 2;
                    }
                    NotebookCellKind.is = is;
                })(NotebookCellKind = exports1.NotebookCellKind || (exports1.NotebookCellKind = {}));
                var ExecutionSummary;
                (function(ExecutionSummary) {
                    function create(executionOrder, success) {
                        const result = {
                            executionOrder
                        };
                        if (success === true || success === false) {
                            result.success = success;
                        }
                        return result;
                    }
                    ExecutionSummary.create = create;
                    function is(value) {
                        const candidate = value;
                        return Is.objectLiteral(candidate) && vscode_languageserver_types_1.uinteger.is(candidate.executionOrder) && (candidate.success === undefined || Is.boolean(candidate.success));
                    }
                    ExecutionSummary.is = is;
                    function equals(one, other) {
                        if (one === other) {
                            return true;
                        }
                        if (one === null || one === undefined || other === null || other === undefined) {
                            return false;
                        }
                        return one.executionOrder === other.executionOrder && one.success === other.success;
                    }
                    ExecutionSummary.equals = equals;
                })(ExecutionSummary = exports1.ExecutionSummary || (exports1.ExecutionSummary = {}));
                var NotebookCell;
                (function(NotebookCell) {
                    function create(kind, document1) {
                        return {
                            kind,
                            document: document1
                        };
                    }
                    NotebookCell.create = create;
                    function is(value) {
                        const candidate = value;
                        return Is.objectLiteral(candidate) && NotebookCellKind.is(candidate.kind) && vscode_languageserver_types_1.DocumentUri.is(candidate.document) && (candidate.metadata === undefined || Is.objectLiteral(candidate.metadata));
                    }
                    NotebookCell.is = is;
                    function diff(one, two) {
                        const result = new Set();
                        if (one.document !== two.document) {
                            result.add('document');
                        }
                        if (one.kind !== two.kind) {
                            result.add('kind');
                        }
                        if (one.executionSummary !== two.executionSummary) {
                            result.add('executionSummary');
                        }
                        if ((one.metadata !== undefined || two.metadata !== undefined) && !equalsMetadata(one.metadata, two.metadata)) {
                            result.add('metadata');
                        }
                        if ((one.executionSummary !== undefined || two.executionSummary !== undefined) && !ExecutionSummary.equals(one.executionSummary, two.executionSummary)) {
                            result.add('executionSummary');
                        }
                        return result;
                    }
                    NotebookCell.diff = diff;
                    function equalsMetadata(one, other) {
                        if (one === other) {
                            return true;
                        }
                        if (one === null || one === undefined || other === null || other === undefined) {
                            return false;
                        }
                        if (typeof one !== typeof other) {
                            return false;
                        }
                        if (typeof one !== 'object') {
                            return false;
                        }
                        const oneArray = Array.isArray(one);
                        const otherArray = Array.isArray(other);
                        if (oneArray !== otherArray) {
                            return false;
                        }
                        if (oneArray && otherArray) {
                            if (one.length !== other.length) {
                                return false;
                            }
                            for(let i = 0; i < one.length; i++){
                                if (!equalsMetadata(one[i], other[i])) {
                                    return false;
                                }
                            }
                        }
                        if (Is.objectLiteral(one) && Is.objectLiteral(other)) {
                            const oneKeys = Object.keys(one);
                            const otherKeys = Object.keys(other);
                            if (oneKeys.length !== otherKeys.length) {
                                return false;
                            }
                            oneKeys.sort();
                            otherKeys.sort();
                            if (!equalsMetadata(oneKeys, otherKeys)) {
                                return false;
                            }
                            for(let i = 0; i < oneKeys.length; i++){
                                const prop = oneKeys[i];
                                if (!equalsMetadata(one[prop], other[prop])) {
                                    return false;
                                }
                            }
                        }
                        return true;
                    }
                })(NotebookCell = exports1.NotebookCell || (exports1.NotebookCell = {}));
                var NotebookDocument;
                (function(NotebookDocument) {
                    function create(uri, notebookType, version, cells) {
                        return {
                            uri,
                            notebookType,
                            version,
                            cells
                        };
                    }
                    NotebookDocument.create = create;
                    function is(value) {
                        const candidate = value;
                        return Is.objectLiteral(candidate) && Is.string(candidate.uri) && vscode_languageserver_types_1.integer.is(candidate.version) && Is.typedArray(candidate.cells, NotebookCell.is);
                    }
                    NotebookDocument.is = is;
                })(NotebookDocument = exports1.NotebookDocument || (exports1.NotebookDocument = {}));
                var NotebookDocumentSyncRegistrationType;
                (function(NotebookDocumentSyncRegistrationType) {
                    NotebookDocumentSyncRegistrationType.method = 'notebookDocument/sync';
                    NotebookDocumentSyncRegistrationType.messageDirection = messages_1.MessageDirection.clientToServer;
                    NotebookDocumentSyncRegistrationType.type = new messages_1.RegistrationType(NotebookDocumentSyncRegistrationType.method);
                })(NotebookDocumentSyncRegistrationType = exports1.NotebookDocumentSyncRegistrationType || (exports1.NotebookDocumentSyncRegistrationType = {}));
                /**
 * A notification sent when a notebook opens.
 *
 * @since 3.17.0
 */ var DidOpenNotebookDocumentNotification;
                (function(DidOpenNotebookDocumentNotification) {
                    DidOpenNotebookDocumentNotification.method = 'notebookDocument/didOpen';
                    DidOpenNotebookDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidOpenNotebookDocumentNotification.type = new messages_1.ProtocolNotificationType(DidOpenNotebookDocumentNotification.method);
                    DidOpenNotebookDocumentNotification.registrationMethod = NotebookDocumentSyncRegistrationType.method;
                })(DidOpenNotebookDocumentNotification = exports1.DidOpenNotebookDocumentNotification || (exports1.DidOpenNotebookDocumentNotification = {}));
                var NotebookCellArrayChange;
                (function(NotebookCellArrayChange) {
                    function is(value) {
                        const candidate = value;
                        return Is.objectLiteral(candidate) && vscode_languageserver_types_1.uinteger.is(candidate.start) && vscode_languageserver_types_1.uinteger.is(candidate.deleteCount) && (candidate.cells === undefined || Is.typedArray(candidate.cells, NotebookCell.is));
                    }
                    NotebookCellArrayChange.is = is;
                    function create(start, deleteCount, cells) {
                        const result = {
                            start,
                            deleteCount
                        };
                        if (cells !== undefined) {
                            result.cells = cells;
                        }
                        return result;
                    }
                    NotebookCellArrayChange.create = create;
                })(NotebookCellArrayChange = exports1.NotebookCellArrayChange || (exports1.NotebookCellArrayChange = {}));
                var DidChangeNotebookDocumentNotification;
                (function(DidChangeNotebookDocumentNotification) {
                    DidChangeNotebookDocumentNotification.method = 'notebookDocument/didChange';
                    DidChangeNotebookDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidChangeNotebookDocumentNotification.type = new messages_1.ProtocolNotificationType(DidChangeNotebookDocumentNotification.method);
                    DidChangeNotebookDocumentNotification.registrationMethod = NotebookDocumentSyncRegistrationType.method;
                })(DidChangeNotebookDocumentNotification = exports1.DidChangeNotebookDocumentNotification || (exports1.DidChangeNotebookDocumentNotification = {}));
                /**
 * A notification sent when a notebook document is saved.
 *
 * @since 3.17.0
 */ var DidSaveNotebookDocumentNotification;
                (function(DidSaveNotebookDocumentNotification) {
                    DidSaveNotebookDocumentNotification.method = 'notebookDocument/didSave';
                    DidSaveNotebookDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidSaveNotebookDocumentNotification.type = new messages_1.ProtocolNotificationType(DidSaveNotebookDocumentNotification.method);
                    DidSaveNotebookDocumentNotification.registrationMethod = NotebookDocumentSyncRegistrationType.method;
                })(DidSaveNotebookDocumentNotification = exports1.DidSaveNotebookDocumentNotification || (exports1.DidSaveNotebookDocumentNotification = {}));
                /**
 * A notification sent when a notebook closes.
 *
 * @since 3.17.0
 */ var DidCloseNotebookDocumentNotification;
                (function(DidCloseNotebookDocumentNotification) {
                    DidCloseNotebookDocumentNotification.method = 'notebookDocument/didClose';
                    DidCloseNotebookDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidCloseNotebookDocumentNotification.type = new messages_1.ProtocolNotificationType(DidCloseNotebookDocumentNotification.method);
                    DidCloseNotebookDocumentNotification.registrationMethod = NotebookDocumentSyncRegistrationType.method;
                })(DidCloseNotebookDocumentNotification = exports1.DidCloseNotebookDocumentNotification || (exports1.DidCloseNotebookDocumentNotification = {}));
            /***/ },
            /***/ 4166: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_564745__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.WorkDoneProgressCancelNotification = exports1.WorkDoneProgressCreateRequest = exports1.WorkDoneProgress = void 0;
                const vscode_jsonrpc_1 = __nested_webpack_require_564745__(9110);
                const messages_1 = __nested_webpack_require_564745__(8431);
                var WorkDoneProgress;
                (function(WorkDoneProgress) {
                    WorkDoneProgress.type = new vscode_jsonrpc_1.ProgressType();
                    function is(value) {
                        return value === WorkDoneProgress.type;
                    }
                    WorkDoneProgress.is = is;
                })(WorkDoneProgress = exports1.WorkDoneProgress || (exports1.WorkDoneProgress = {}));
                /**
 * The `window/workDoneProgress/create` request is sent from the server to the client to initiate progress
 * reporting from the server.
 */ var WorkDoneProgressCreateRequest;
                (function(WorkDoneProgressCreateRequest) {
                    WorkDoneProgressCreateRequest.method = 'window/workDoneProgress/create';
                    WorkDoneProgressCreateRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    WorkDoneProgressCreateRequest.type = new messages_1.ProtocolRequestType(WorkDoneProgressCreateRequest.method);
                })(WorkDoneProgressCreateRequest = exports1.WorkDoneProgressCreateRequest || (exports1.WorkDoneProgressCreateRequest = {}));
                /**
 * The `window/workDoneProgress/cancel` notification is sent from  the client to the server to cancel a progress
 * initiated on the server side.
 */ var WorkDoneProgressCancelNotification;
                (function(WorkDoneProgressCancelNotification) {
                    WorkDoneProgressCancelNotification.method = 'window/workDoneProgress/cancel';
                    WorkDoneProgressCancelNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    WorkDoneProgressCancelNotification.type = new messages_1.ProtocolNotificationType(WorkDoneProgressCancelNotification.method);
                })(WorkDoneProgressCancelNotification = exports1.WorkDoneProgressCancelNotification || (exports1.WorkDoneProgressCancelNotification = {}));
            /***/ },
            /***/ 1530: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_567586__)=>{
                "use strict";
                /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.SelectionRangeRequest = void 0;
                const messages_1 = __nested_webpack_require_567586__(8431);
                /**
 * A request to provide selection ranges in a document. The request's
 * parameter is of type {@link SelectionRangeParams}, the
 * response is of type {@link SelectionRange SelectionRange[]} or a Thenable
 * that resolves to such.
 */ var SelectionRangeRequest;
                (function(SelectionRangeRequest) {
                    SelectionRangeRequest.method = 'textDocument/selectionRange';
                    SelectionRangeRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    SelectionRangeRequest.type = new messages_1.ProtocolRequestType(SelectionRangeRequest.method);
                })(SelectionRangeRequest = exports1.SelectionRangeRequest || (exports1.SelectionRangeRequest = {}));
            /***/ },
            /***/ 2067: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_569066__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.SemanticTokensRefreshRequest = exports1.SemanticTokensRangeRequest = exports1.SemanticTokensDeltaRequest = exports1.SemanticTokensRequest = exports1.SemanticTokensRegistrationType = exports1.TokenFormat = void 0;
                const messages_1 = __nested_webpack_require_569066__(8431);
                //------- 'textDocument/semanticTokens' -----
                var TokenFormat;
                (function(TokenFormat) {
                    TokenFormat.Relative = 'relative';
                })(TokenFormat = exports1.TokenFormat || (exports1.TokenFormat = {}));
                var SemanticTokensRegistrationType;
                (function(SemanticTokensRegistrationType) {
                    SemanticTokensRegistrationType.method = 'textDocument/semanticTokens';
                    SemanticTokensRegistrationType.type = new messages_1.RegistrationType(SemanticTokensRegistrationType.method);
                })(SemanticTokensRegistrationType = exports1.SemanticTokensRegistrationType || (exports1.SemanticTokensRegistrationType = {}));
                /**
 * @since 3.16.0
 */ var SemanticTokensRequest;
                (function(SemanticTokensRequest) {
                    SemanticTokensRequest.method = 'textDocument/semanticTokens/full';
                    SemanticTokensRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    SemanticTokensRequest.type = new messages_1.ProtocolRequestType(SemanticTokensRequest.method);
                    SemanticTokensRequest.registrationMethod = SemanticTokensRegistrationType.method;
                })(SemanticTokensRequest = exports1.SemanticTokensRequest || (exports1.SemanticTokensRequest = {}));
                /**
 * @since 3.16.0
 */ var SemanticTokensDeltaRequest;
                (function(SemanticTokensDeltaRequest) {
                    SemanticTokensDeltaRequest.method = 'textDocument/semanticTokens/full/delta';
                    SemanticTokensDeltaRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    SemanticTokensDeltaRequest.type = new messages_1.ProtocolRequestType(SemanticTokensDeltaRequest.method);
                    SemanticTokensDeltaRequest.registrationMethod = SemanticTokensRegistrationType.method;
                })(SemanticTokensDeltaRequest = exports1.SemanticTokensDeltaRequest || (exports1.SemanticTokensDeltaRequest = {}));
                /**
 * @since 3.16.0
 */ var SemanticTokensRangeRequest;
                (function(SemanticTokensRangeRequest) {
                    SemanticTokensRangeRequest.method = 'textDocument/semanticTokens/range';
                    SemanticTokensRangeRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    SemanticTokensRangeRequest.type = new messages_1.ProtocolRequestType(SemanticTokensRangeRequest.method);
                    SemanticTokensRangeRequest.registrationMethod = SemanticTokensRegistrationType.method;
                })(SemanticTokensRangeRequest = exports1.SemanticTokensRangeRequest || (exports1.SemanticTokensRangeRequest = {}));
                /**
 * @since 3.16.0
 */ var SemanticTokensRefreshRequest;
                (function(SemanticTokensRefreshRequest) {
                    SemanticTokensRefreshRequest.method = `workspace/semanticTokens/refresh`;
                    SemanticTokensRefreshRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    SemanticTokensRefreshRequest.type = new messages_1.ProtocolRequestType0(SemanticTokensRefreshRequest.method);
                })(SemanticTokensRefreshRequest = exports1.SemanticTokensRefreshRequest || (exports1.SemanticTokensRefreshRequest = {}));
            /***/ },
            /***/ 4333: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_573377__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.ShowDocumentRequest = void 0;
                const messages_1 = __nested_webpack_require_573377__(8431);
                /**
 * A request to show a document. This request might open an
 * external program depending on the value of the URI to open.
 * For example a request to open `https://code.visualstudio.com/`
 * will very likely open the URI in a WEB browser.
 *
 * @since 3.16.0
*/ var ShowDocumentRequest;
                (function(ShowDocumentRequest) {
                    ShowDocumentRequest.method = 'window/showDocument';
                    ShowDocumentRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    ShowDocumentRequest.type = new messages_1.ProtocolRequestType(ShowDocumentRequest.method);
                })(ShowDocumentRequest = exports1.ShowDocumentRequest || (exports1.ShowDocumentRequest = {}));
            /***/ },
            /***/ 9264: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_574855__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.TypeDefinitionRequest = void 0;
                const messages_1 = __nested_webpack_require_574855__(8431);
                // @ts-ignore: to avoid inlining LocatioLink as dynamic import
                let __noDynamicImport;
                /**
 * A request to resolve the type definition locations of a symbol at a given text
 * document position. The request's parameter is of type [TextDocumentPositionParams]
 * (#TextDocumentPositionParams) the response is of type {@link Definition} or a
 * Thenable that resolves to such.
 */ var TypeDefinitionRequest;
                (function(TypeDefinitionRequest) {
                    TypeDefinitionRequest.method = 'textDocument/typeDefinition';
                    TypeDefinitionRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    TypeDefinitionRequest.type = new messages_1.ProtocolRequestType(TypeDefinitionRequest.method);
                })(TypeDefinitionRequest = exports1.TypeDefinitionRequest || (exports1.TypeDefinitionRequest = {}));
            /***/ },
            /***/ 7062: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_576504__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) TypeFox, Microsoft and others. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.TypeHierarchySubtypesRequest = exports1.TypeHierarchySupertypesRequest = exports1.TypeHierarchyPrepareRequest = void 0;
                const messages_1 = __nested_webpack_require_576504__(8431);
                /**
 * A request to result a `TypeHierarchyItem` in a document at a given position.
 * Can be used as an input to a subtypes or supertypes type hierarchy.
 *
 * @since 3.17.0
 */ var TypeHierarchyPrepareRequest;
                (function(TypeHierarchyPrepareRequest) {
                    TypeHierarchyPrepareRequest.method = 'textDocument/prepareTypeHierarchy';
                    TypeHierarchyPrepareRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    TypeHierarchyPrepareRequest.type = new messages_1.ProtocolRequestType(TypeHierarchyPrepareRequest.method);
                })(TypeHierarchyPrepareRequest = exports1.TypeHierarchyPrepareRequest || (exports1.TypeHierarchyPrepareRequest = {}));
                /**
 * A request to resolve the supertypes for a given `TypeHierarchyItem`.
 *
 * @since 3.17.0
 */ var TypeHierarchySupertypesRequest;
                (function(TypeHierarchySupertypesRequest) {
                    TypeHierarchySupertypesRequest.method = 'typeHierarchy/supertypes';
                    TypeHierarchySupertypesRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    TypeHierarchySupertypesRequest.type = new messages_1.ProtocolRequestType(TypeHierarchySupertypesRequest.method);
                })(TypeHierarchySupertypesRequest = exports1.TypeHierarchySupertypesRequest || (exports1.TypeHierarchySupertypesRequest = {}));
                /**
 * A request to resolve the subtypes for a given `TypeHierarchyItem`.
 *
 * @since 3.17.0
 */ var TypeHierarchySubtypesRequest;
                (function(TypeHierarchySubtypesRequest) {
                    TypeHierarchySubtypesRequest.method = 'typeHierarchy/subtypes';
                    TypeHierarchySubtypesRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    TypeHierarchySubtypesRequest.type = new messages_1.ProtocolRequestType(TypeHierarchySubtypesRequest.method);
                })(TypeHierarchySubtypesRequest = exports1.TypeHierarchySubtypesRequest || (exports1.TypeHierarchySubtypesRequest = {}));
            /***/ },
            /***/ 6860: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_579438__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.DidChangeWorkspaceFoldersNotification = exports1.WorkspaceFoldersRequest = void 0;
                const messages_1 = __nested_webpack_require_579438__(8431);
                /**
 * The `workspace/workspaceFolders` is sent from the server to the client to fetch the open workspace folders.
 */ var WorkspaceFoldersRequest;
                (function(WorkspaceFoldersRequest) {
                    WorkspaceFoldersRequest.method = 'workspace/workspaceFolders';
                    WorkspaceFoldersRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    WorkspaceFoldersRequest.type = new messages_1.ProtocolRequestType0(WorkspaceFoldersRequest.method);
                })(WorkspaceFoldersRequest = exports1.WorkspaceFoldersRequest || (exports1.WorkspaceFoldersRequest = {}));
                /**
 * The `workspace/didChangeWorkspaceFolders` notification is sent from the client to the server when the workspace
 * folder configuration changes.
 */ var DidChangeWorkspaceFoldersNotification;
                (function(DidChangeWorkspaceFoldersNotification) {
                    DidChangeWorkspaceFoldersNotification.method = 'workspace/didChangeWorkspaceFolders';
                    DidChangeWorkspaceFoldersNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidChangeWorkspaceFoldersNotification.type = new messages_1.ProtocolNotificationType(DidChangeWorkspaceFoldersNotification.method);
                })(DidChangeWorkspaceFoldersNotification = exports1.DidChangeWorkspaceFoldersNotification || (exports1.DidChangeWorkspaceFoldersNotification = {}));
            /***/ },
            /***/ 8633: /***/ (__unused_webpack_module, exports1)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.objectLiteral = exports1.typedArray = exports1.stringArray = exports1.array = exports1.func = exports1.error = exports1.number = exports1.string = exports1.boolean = void 0;
                function boolean(value) {
                    return value === true || value === false;
                }
                exports1.boolean = boolean;
                function string(value) {
                    return typeof value === 'string' || value instanceof String;
                }
                exports1.string = string;
                function number(value) {
                    return typeof value === 'number' || value instanceof Number;
                }
                exports1.number = number;
                function error(value) {
                    return value instanceof Error;
                }
                exports1.error = error;
                function func(value) {
                    return typeof value === 'function';
                }
                exports1.func = func;
                function array(value) {
                    return Array.isArray(value);
                }
                exports1.array = array;
                function stringArray(value) {
                    return array(value) && value.every((elem)=>string(elem));
                }
                exports1.stringArray = stringArray;
                function typedArray(value, check) {
                    return Array.isArray(value) && value.every(check);
                }
                exports1.typedArray = typedArray;
                function objectLiteral(value) {
                    // Strictly speaking class instances pass this check as well. Since the LSP
                    // doesn't use classes we ignore this for now. If we do we need to add something
                    // like this: `Object.getPrototypeOf(Object.getPrototypeOf(x)) === null`
                    return value !== null && typeof value === 'object';
                }
                exports1.objectLiteral = objectLiteral;
            /***/ },
            /***/ 7717: /***/ (__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_584333__)=>{
                "use strict";
                __nested_webpack_require_584333__.r(__nested_webpack_exports__);
                /* harmony export */ __nested_webpack_require_584333__.d(__nested_webpack_exports__, {
                    /* harmony export */ AnnotatedTextEdit: ()=>/* binding */ AnnotatedTextEdit,
                    /* harmony export */ ChangeAnnotation: ()=>/* binding */ ChangeAnnotation,
                    /* harmony export */ ChangeAnnotationIdentifier: ()=>/* binding */ ChangeAnnotationIdentifier,
                    /* harmony export */ CodeAction: ()=>/* binding */ CodeAction,
                    /* harmony export */ CodeActionContext: ()=>/* binding */ CodeActionContext,
                    /* harmony export */ CodeActionKind: ()=>/* binding */ CodeActionKind,
                    /* harmony export */ CodeActionTriggerKind: ()=>/* binding */ CodeActionTriggerKind,
                    /* harmony export */ CodeDescription: ()=>/* binding */ CodeDescription,
                    /* harmony export */ CodeLens: ()=>/* binding */ CodeLens,
                    /* harmony export */ Color: ()=>/* binding */ Color,
                    /* harmony export */ ColorInformation: ()=>/* binding */ ColorInformation,
                    /* harmony export */ ColorPresentation: ()=>/* binding */ ColorPresentation,
                    /* harmony export */ Command: ()=>/* binding */ Command,
                    /* harmony export */ CompletionItem: ()=>/* binding */ CompletionItem,
                    /* harmony export */ CompletionItemKind: ()=>/* binding */ CompletionItemKind,
                    /* harmony export */ CompletionItemLabelDetails: ()=>/* binding */ CompletionItemLabelDetails,
                    /* harmony export */ CompletionItemTag: ()=>/* binding */ CompletionItemTag,
                    /* harmony export */ CompletionList: ()=>/* binding */ CompletionList,
                    /* harmony export */ CreateFile: ()=>/* binding */ CreateFile,
                    /* harmony export */ DeleteFile: ()=>/* binding */ DeleteFile,
                    /* harmony export */ Diagnostic: ()=>/* binding */ Diagnostic,
                    /* harmony export */ DiagnosticRelatedInformation: ()=>/* binding */ DiagnosticRelatedInformation,
                    /* harmony export */ DiagnosticSeverity: ()=>/* binding */ DiagnosticSeverity,
                    /* harmony export */ DiagnosticTag: ()=>/* binding */ DiagnosticTag,
                    /* harmony export */ DocumentHighlight: ()=>/* binding */ DocumentHighlight,
                    /* harmony export */ DocumentHighlightKind: ()=>/* binding */ DocumentHighlightKind,
                    /* harmony export */ DocumentLink: ()=>/* binding */ DocumentLink,
                    /* harmony export */ DocumentSymbol: ()=>/* binding */ DocumentSymbol,
                    /* harmony export */ DocumentUri: ()=>/* binding */ DocumentUri,
                    /* harmony export */ EOL: ()=>/* binding */ EOL,
                    /* harmony export */ FoldingRange: ()=>/* binding */ FoldingRange,
                    /* harmony export */ FoldingRangeKind: ()=>/* binding */ FoldingRangeKind,
                    /* harmony export */ FormattingOptions: ()=>/* binding */ FormattingOptions,
                    /* harmony export */ Hover: ()=>/* binding */ Hover,
                    /* harmony export */ InlayHint: ()=>/* binding */ InlayHint,
                    /* harmony export */ InlayHintKind: ()=>/* binding */ InlayHintKind,
                    /* harmony export */ InlayHintLabelPart: ()=>/* binding */ InlayHintLabelPart,
                    /* harmony export */ InlineValueContext: ()=>/* binding */ InlineValueContext,
                    /* harmony export */ InlineValueEvaluatableExpression: ()=>/* binding */ InlineValueEvaluatableExpression,
                    /* harmony export */ InlineValueText: ()=>/* binding */ InlineValueText,
                    /* harmony export */ InlineValueVariableLookup: ()=>/* binding */ InlineValueVariableLookup,
                    /* harmony export */ InsertReplaceEdit: ()=>/* binding */ InsertReplaceEdit,
                    /* harmony export */ InsertTextFormat: ()=>/* binding */ InsertTextFormat,
                    /* harmony export */ InsertTextMode: ()=>/* binding */ InsertTextMode,
                    /* harmony export */ Location: ()=>/* binding */ Location,
                    /* harmony export */ LocationLink: ()=>/* binding */ LocationLink,
                    /* harmony export */ MarkedString: ()=>/* binding */ MarkedString,
                    /* harmony export */ MarkupContent: ()=>/* binding */ MarkupContent,
                    /* harmony export */ MarkupKind: ()=>/* binding */ MarkupKind,
                    /* harmony export */ OptionalVersionedTextDocumentIdentifier: ()=>/* binding */ OptionalVersionedTextDocumentIdentifier,
                    /* harmony export */ ParameterInformation: ()=>/* binding */ ParameterInformation,
                    /* harmony export */ Position: ()=>/* binding */ Position,
                    /* harmony export */ Range: ()=>/* binding */ Range,
                    /* harmony export */ RenameFile: ()=>/* binding */ RenameFile,
                    /* harmony export */ SelectionRange: ()=>/* binding */ SelectionRange,
                    /* harmony export */ SemanticTokenModifiers: ()=>/* binding */ SemanticTokenModifiers,
                    /* harmony export */ SemanticTokenTypes: ()=>/* binding */ SemanticTokenTypes,
                    /* harmony export */ SemanticTokens: ()=>/* binding */ SemanticTokens,
                    /* harmony export */ SignatureInformation: ()=>/* binding */ SignatureInformation,
                    /* harmony export */ SymbolInformation: ()=>/* binding */ SymbolInformation,
                    /* harmony export */ SymbolKind: ()=>/* binding */ SymbolKind,
                    /* harmony export */ SymbolTag: ()=>/* binding */ SymbolTag,
                    /* harmony export */ TextDocument: ()=>/* binding */ TextDocument,
                    /* harmony export */ TextDocumentEdit: ()=>/* binding */ TextDocumentEdit,
                    /* harmony export */ TextDocumentIdentifier: ()=>/* binding */ TextDocumentIdentifier,
                    /* harmony export */ TextDocumentItem: ()=>/* binding */ TextDocumentItem,
                    /* harmony export */ TextEdit: ()=>/* binding */ TextEdit,
                    /* harmony export */ URI: ()=>/* binding */ URI1,
                    /* harmony export */ VersionedTextDocumentIdentifier: ()=>/* binding */ VersionedTextDocumentIdentifier,
                    /* harmony export */ WorkspaceChange: ()=>/* binding */ WorkspaceChange,
                    /* harmony export */ WorkspaceEdit: ()=>/* binding */ WorkspaceEdit,
                    /* harmony export */ WorkspaceFolder: ()=>/* binding */ WorkspaceFolder,
                    /* harmony export */ WorkspaceSymbol: ()=>/* binding */ WorkspaceSymbol,
                    /* harmony export */ integer: ()=>/* binding */ integer,
                    /* harmony export */ uinteger: ()=>/* binding */ uinteger
                });
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ var DocumentUri;
                (function(DocumentUri) {
                    function is(value) {
                        return typeof value === 'string';
                    }
                    DocumentUri.is = is;
                })(DocumentUri || (DocumentUri = {}));
                var URI1;
                (function(URI1) {
                    function is(value) {
                        return typeof value === 'string';
                    }
                    URI1.is = is;
                })(URI1 || (URI1 = {}));
                var integer;
                (function(integer) {
                    integer.MIN_VALUE = -2147483648;
                    integer.MAX_VALUE = 2147483647;
                    function is(value) {
                        return typeof value === 'number' && integer.MIN_VALUE <= value && value <= integer.MAX_VALUE;
                    }
                    integer.is = is;
                })(integer || (integer = {}));
                var uinteger;
                (function(uinteger) {
                    uinteger.MIN_VALUE = 0;
                    uinteger.MAX_VALUE = 2147483647;
                    function is(value) {
                        return typeof value === 'number' && uinteger.MIN_VALUE <= value && value <= uinteger.MAX_VALUE;
                    }
                    uinteger.is = is;
                })(uinteger || (uinteger = {}));
                /**
 * The Position namespace provides helper functions to work with
 * {@link Position} literals.
 */ var Position;
                (function(Position) {
                    /**
     * Creates a new Position literal from the given line and character.
     * @param line The position's line.
     * @param character The position's character.
     */ function create(line, character) {
                        if (line === Number.MAX_VALUE) {
                            line = uinteger.MAX_VALUE;
                        }
                        if (character === Number.MAX_VALUE) {
                            character = uinteger.MAX_VALUE;
                        }
                        return {
                            line: line,
                            character: character
                        };
                    }
                    Position.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link Position} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && Is.uinteger(candidate.line) && Is.uinteger(candidate.character);
                    }
                    Position.is = is;
                })(Position || (Position = {}));
                /**
 * The Range namespace provides helper functions to work with
 * {@link Range} literals.
 */ var Range;
                (function(Range) {
                    function create(one, two, three, four) {
                        if (Is.uinteger(one) && Is.uinteger(two) && Is.uinteger(three) && Is.uinteger(four)) {
                            return {
                                start: Position.create(one, two),
                                end: Position.create(three, four)
                            };
                        } else if (Position.is(one) && Position.is(two)) {
                            return {
                                start: one,
                                end: two
                            };
                        } else {
                            throw new Error("Range#create called with invalid arguments[".concat(one, ", ").concat(two, ", ").concat(three, ", ").concat(four, "]"));
                        }
                    }
                    Range.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link Range} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && Position.is(candidate.start) && Position.is(candidate.end);
                    }
                    Range.is = is;
                })(Range || (Range = {}));
                /**
 * The Location namespace provides helper functions to work with
 * {@link Location} literals.
 */ var Location;
                (function(Location) {
                    /**
     * Creates a Location literal.
     * @param uri The location's uri.
     * @param range The location's range.
     */ function create(uri, range) {
                        return {
                            uri: uri,
                            range: range
                        };
                    }
                    Location.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link Location} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && Range.is(candidate.range) && (Is.string(candidate.uri) || Is.undefined(candidate.uri));
                    }
                    Location.is = is;
                })(Location || (Location = {}));
                /**
 * The LocationLink namespace provides helper functions to work with
 * {@link LocationLink} literals.
 */ var LocationLink;
                (function(LocationLink) {
                    /**
     * Creates a LocationLink literal.
     * @param targetUri The definition's uri.
     * @param targetRange The full range of the definition.
     * @param targetSelectionRange The span of the symbol definition at the target.
     * @param originSelectionRange The span of the symbol being defined in the originating source file.
     */ function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {
                        return {
                            targetUri: targetUri,
                            targetRange: targetRange,
                            targetSelectionRange: targetSelectionRange,
                            originSelectionRange: originSelectionRange
                        };
                    }
                    LocationLink.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link LocationLink} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && Range.is(candidate.targetRange) && Is.string(candidate.targetUri) && Range.is(candidate.targetSelectionRange) && (Range.is(candidate.originSelectionRange) || Is.undefined(candidate.originSelectionRange));
                    }
                    LocationLink.is = is;
                })(LocationLink || (LocationLink = {}));
                /**
 * The Color namespace provides helper functions to work with
 * {@link Color} literals.
 */ var Color;
                (function(Color) {
                    /**
     * Creates a new Color literal.
     */ function create(red, green, blue, alpha) {
                        return {
                            red: red,
                            green: green,
                            blue: blue,
                            alpha: alpha
                        };
                    }
                    Color.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link Color} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && Is.numberRange(candidate.red, 0, 1) && Is.numberRange(candidate.green, 0, 1) && Is.numberRange(candidate.blue, 0, 1) && Is.numberRange(candidate.alpha, 0, 1);
                    }
                    Color.is = is;
                })(Color || (Color = {}));
                /**
 * The ColorInformation namespace provides helper functions to work with
 * {@link ColorInformation} literals.
 */ var ColorInformation;
                (function(ColorInformation) {
                    /**
     * Creates a new ColorInformation literal.
     */ function create(range, color) {
                        return {
                            range: range,
                            color: color
                        };
                    }
                    ColorInformation.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link ColorInformation} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && Range.is(candidate.range) && Color.is(candidate.color);
                    }
                    ColorInformation.is = is;
                })(ColorInformation || (ColorInformation = {}));
                /**
 * The Color namespace provides helper functions to work with
 * {@link ColorPresentation} literals.
 */ var ColorPresentation;
                (function(ColorPresentation) {
                    /**
     * Creates a new ColorInformation literal.
     */ function create(label, textEdit, additionalTextEdits) {
                        return {
                            label: label,
                            textEdit: textEdit,
                            additionalTextEdits: additionalTextEdits
                        };
                    }
                    ColorPresentation.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link ColorInformation} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && Is.string(candidate.label) && (Is.undefined(candidate.textEdit) || TextEdit.is(candidate)) && (Is.undefined(candidate.additionalTextEdits) || Is.typedArray(candidate.additionalTextEdits, TextEdit.is));
                    }
                    ColorPresentation.is = is;
                })(ColorPresentation || (ColorPresentation = {}));
                /**
 * A set of predefined range kinds.
 */ var FoldingRangeKind;
                (function(FoldingRangeKind) {
                    /**
     * Folding range for a comment
     */ FoldingRangeKind.Comment = 'comment';
                    /**
     * Folding range for an import or include
     */ FoldingRangeKind.Imports = 'imports';
                    /**
     * Folding range for a region (e.g. `#region`)
     */ FoldingRangeKind.Region = 'region';
                })(FoldingRangeKind || (FoldingRangeKind = {}));
                /**
 * The folding range namespace provides helper functions to work with
 * {@link FoldingRange} literals.
 */ var FoldingRange;
                (function(FoldingRange) {
                    /**
     * Creates a new FoldingRange literal.
     */ function create(startLine, endLine, startCharacter, endCharacter, kind, collapsedText) {
                        var result = {
                            startLine: startLine,
                            endLine: endLine
                        };
                        if (Is.defined(startCharacter)) {
                            result.startCharacter = startCharacter;
                        }
                        if (Is.defined(endCharacter)) {
                            result.endCharacter = endCharacter;
                        }
                        if (Is.defined(kind)) {
                            result.kind = kind;
                        }
                        if (Is.defined(collapsedText)) {
                            result.collapsedText = collapsedText;
                        }
                        return result;
                    }
                    FoldingRange.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link FoldingRange} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && Is.uinteger(candidate.startLine) && Is.uinteger(candidate.startLine) && (Is.undefined(candidate.startCharacter) || Is.uinteger(candidate.startCharacter)) && (Is.undefined(candidate.endCharacter) || Is.uinteger(candidate.endCharacter)) && (Is.undefined(candidate.kind) || Is.string(candidate.kind));
                    }
                    FoldingRange.is = is;
                })(FoldingRange || (FoldingRange = {}));
                /**
 * The DiagnosticRelatedInformation namespace provides helper functions to work with
 * {@link DiagnosticRelatedInformation} literals.
 */ var DiagnosticRelatedInformation;
                (function(DiagnosticRelatedInformation) {
                    /**
     * Creates a new DiagnosticRelatedInformation literal.
     */ function create(location, message) {
                        return {
                            location: location,
                            message: message
                        };
                    }
                    DiagnosticRelatedInformation.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link DiagnosticRelatedInformation} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.defined(candidate) && Location.is(candidate.location) && Is.string(candidate.message);
                    }
                    DiagnosticRelatedInformation.is = is;
                })(DiagnosticRelatedInformation || (DiagnosticRelatedInformation = {}));
                /**
 * The diagnostic's severity.
 */ var DiagnosticSeverity;
                (function(DiagnosticSeverity) {
                    /**
     * Reports an error.
     */ DiagnosticSeverity.Error = 1;
                    /**
     * Reports a warning.
     */ DiagnosticSeverity.Warning = 2;
                    /**
     * Reports an information.
     */ DiagnosticSeverity.Information = 3;
                    /**
     * Reports a hint.
     */ DiagnosticSeverity.Hint = 4;
                })(DiagnosticSeverity || (DiagnosticSeverity = {}));
                /**
 * The diagnostic tags.
 *
 * @since 3.15.0
 */ var DiagnosticTag;
                (function(DiagnosticTag) {
                    /**
     * Unused or unnecessary code.
     *
     * Clients are allowed to render diagnostics with this tag faded out instead of having
     * an error squiggle.
     */ DiagnosticTag.Unnecessary = 1;
                    /**
     * Deprecated or obsolete code.
     *
     * Clients are allowed to rendered diagnostics with this tag strike through.
     */ DiagnosticTag.Deprecated = 2;
                })(DiagnosticTag || (DiagnosticTag = {}));
                /**
 * The CodeDescription namespace provides functions to deal with descriptions for diagnostic codes.
 *
 * @since 3.16.0
 */ var CodeDescription;
                (function(CodeDescription) {
                    function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && Is.string(candidate.href);
                    }
                    CodeDescription.is = is;
                })(CodeDescription || (CodeDescription = {}));
                /**
 * The Diagnostic namespace provides helper functions to work with
 * {@link Diagnostic} literals.
 */ var Diagnostic;
                (function(Diagnostic) {
                    /**
     * Creates a new Diagnostic literal.
     */ function create(range, message, severity, code, source, relatedInformation) {
                        var result = {
                            range: range,
                            message: message
                        };
                        if (Is.defined(severity)) {
                            result.severity = severity;
                        }
                        if (Is.defined(code)) {
                            result.code = code;
                        }
                        if (Is.defined(source)) {
                            result.source = source;
                        }
                        if (Is.defined(relatedInformation)) {
                            result.relatedInformation = relatedInformation;
                        }
                        return result;
                    }
                    Diagnostic.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link Diagnostic} interface.
     */ function is(value) {
                        var _a;
                        var candidate = value;
                        return Is.defined(candidate) && Range.is(candidate.range) && Is.string(candidate.message) && (Is.number(candidate.severity) || Is.undefined(candidate.severity)) && (Is.integer(candidate.code) || Is.string(candidate.code) || Is.undefined(candidate.code)) && (Is.undefined(candidate.codeDescription) || Is.string((_a = candidate.codeDescription) === null || _a === void 0 ? void 0 : _a.href)) && (Is.string(candidate.source) || Is.undefined(candidate.source)) && (Is.undefined(candidate.relatedInformation) || Is.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation.is));
                    }
                    Diagnostic.is = is;
                })(Diagnostic || (Diagnostic = {}));
                /**
 * The Command namespace provides helper functions to work with
 * {@link Command} literals.
 */ var Command;
                (function(Command) {
                    /**
     * Creates a new Command literal.
     */ function create(title, command) {
                        var args = [];
                        for(var _i = 2; _i < arguments.length; _i++){
                            args[_i - 2] = arguments[_i];
                        }
                        var result = {
                            title: title,
                            command: command
                        };
                        if (Is.defined(args) && args.length > 0) {
                            result.arguments = args;
                        }
                        return result;
                    }
                    Command.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link Command} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.defined(candidate) && Is.string(candidate.title) && Is.string(candidate.command);
                    }
                    Command.is = is;
                })(Command || (Command = {}));
                /**
 * The TextEdit namespace provides helper function to create replace,
 * insert and delete edits more easily.
 */ var TextEdit;
                (function(TextEdit) {
                    /**
     * Creates a replace text edit.
     * @param range The range of text to be replaced.
     * @param newText The new text.
     */ function replace(range, newText) {
                        return {
                            range: range,
                            newText: newText
                        };
                    }
                    TextEdit.replace = replace;
                    /**
     * Creates an insert text edit.
     * @param position The position to insert the text at.
     * @param newText The text to be inserted.
     */ function insert(position, newText) {
                        return {
                            range: {
                                start: position,
                                end: position
                            },
                            newText: newText
                        };
                    }
                    TextEdit.insert = insert;
                    /**
     * Creates a delete text edit.
     * @param range The range of text to be deleted.
     */ function del(range) {
                        return {
                            range: range,
                            newText: ''
                        };
                    }
                    TextEdit.del = del;
                    function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && Is.string(candidate.newText) && Range.is(candidate.range);
                    }
                    TextEdit.is = is;
                })(TextEdit || (TextEdit = {}));
                var ChangeAnnotation;
                (function(ChangeAnnotation) {
                    function create(label, needsConfirmation, description) {
                        var result = {
                            label: label
                        };
                        if (needsConfirmation !== undefined) {
                            result.needsConfirmation = needsConfirmation;
                        }
                        if (description !== undefined) {
                            result.description = description;
                        }
                        return result;
                    }
                    ChangeAnnotation.create = create;
                    function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && Is.string(candidate.label) && (Is.boolean(candidate.needsConfirmation) || candidate.needsConfirmation === undefined) && (Is.string(candidate.description) || candidate.description === undefined);
                    }
                    ChangeAnnotation.is = is;
                })(ChangeAnnotation || (ChangeAnnotation = {}));
                var ChangeAnnotationIdentifier;
                (function(ChangeAnnotationIdentifier) {
                    function is(value) {
                        var candidate = value;
                        return Is.string(candidate);
                    }
                    ChangeAnnotationIdentifier.is = is;
                })(ChangeAnnotationIdentifier || (ChangeAnnotationIdentifier = {}));
                var AnnotatedTextEdit;
                (function(AnnotatedTextEdit) {
                    /**
     * Creates an annotated replace text edit.
     *
     * @param range The range of text to be replaced.
     * @param newText The new text.
     * @param annotation The annotation.
     */ function replace(range, newText, annotation) {
                        return {
                            range: range,
                            newText: newText,
                            annotationId: annotation
                        };
                    }
                    AnnotatedTextEdit.replace = replace;
                    /**
     * Creates an annotated insert text edit.
     *
     * @param position The position to insert the text at.
     * @param newText The text to be inserted.
     * @param annotation The annotation.
     */ function insert(position, newText, annotation) {
                        return {
                            range: {
                                start: position,
                                end: position
                            },
                            newText: newText,
                            annotationId: annotation
                        };
                    }
                    AnnotatedTextEdit.insert = insert;
                    /**
     * Creates an annotated delete text edit.
     *
     * @param range The range of text to be deleted.
     * @param annotation The annotation.
     */ function del(range, annotation) {
                        return {
                            range: range,
                            newText: '',
                            annotationId: annotation
                        };
                    }
                    AnnotatedTextEdit.del = del;
                    function is(value) {
                        var candidate = value;
                        return TextEdit.is(candidate) && (ChangeAnnotation.is(candidate.annotationId) || ChangeAnnotationIdentifier.is(candidate.annotationId));
                    }
                    AnnotatedTextEdit.is = is;
                })(AnnotatedTextEdit || (AnnotatedTextEdit = {}));
                /**
 * The TextDocumentEdit namespace provides helper function to create
 * an edit that manipulates a text document.
 */ var TextDocumentEdit;
                (function(TextDocumentEdit) {
                    /**
     * Creates a new `TextDocumentEdit`
     */ function create(textDocument, edits) {
                        return {
                            textDocument: textDocument,
                            edits: edits
                        };
                    }
                    TextDocumentEdit.create = create;
                    function is(value) {
                        var candidate = value;
                        return Is.defined(candidate) && OptionalVersionedTextDocumentIdentifier.is(candidate.textDocument) && Array.isArray(candidate.edits);
                    }
                    TextDocumentEdit.is = is;
                })(TextDocumentEdit || (TextDocumentEdit = {}));
                var CreateFile;
                (function(CreateFile) {
                    function create(uri, options, annotation) {
                        var result = {
                            kind: 'create',
                            uri: uri
                        };
                        if (options !== undefined && (options.overwrite !== undefined || options.ignoreIfExists !== undefined)) {
                            result.options = options;
                        }
                        if (annotation !== undefined) {
                            result.annotationId = annotation;
                        }
                        return result;
                    }
                    CreateFile.create = create;
                    function is(value) {
                        var candidate = value;
                        return candidate && candidate.kind === 'create' && Is.string(candidate.uri) && (candidate.options === undefined || (candidate.options.overwrite === undefined || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === undefined || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));
                    }
                    CreateFile.is = is;
                })(CreateFile || (CreateFile = {}));
                var RenameFile;
                (function(RenameFile) {
                    function create(oldUri, newUri, options, annotation) {
                        var result = {
                            kind: 'rename',
                            oldUri: oldUri,
                            newUri: newUri
                        };
                        if (options !== undefined && (options.overwrite !== undefined || options.ignoreIfExists !== undefined)) {
                            result.options = options;
                        }
                        if (annotation !== undefined) {
                            result.annotationId = annotation;
                        }
                        return result;
                    }
                    RenameFile.create = create;
                    function is(value) {
                        var candidate = value;
                        return candidate && candidate.kind === 'rename' && Is.string(candidate.oldUri) && Is.string(candidate.newUri) && (candidate.options === undefined || (candidate.options.overwrite === undefined || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === undefined || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));
                    }
                    RenameFile.is = is;
                })(RenameFile || (RenameFile = {}));
                var DeleteFile;
                (function(DeleteFile) {
                    function create(uri, options, annotation) {
                        var result = {
                            kind: 'delete',
                            uri: uri
                        };
                        if (options !== undefined && (options.recursive !== undefined || options.ignoreIfNotExists !== undefined)) {
                            result.options = options;
                        }
                        if (annotation !== undefined) {
                            result.annotationId = annotation;
                        }
                        return result;
                    }
                    DeleteFile.create = create;
                    function is(value) {
                        var candidate = value;
                        return candidate && candidate.kind === 'delete' && Is.string(candidate.uri) && (candidate.options === undefined || (candidate.options.recursive === undefined || Is.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === undefined || Is.boolean(candidate.options.ignoreIfNotExists))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));
                    }
                    DeleteFile.is = is;
                })(DeleteFile || (DeleteFile = {}));
                var WorkspaceEdit;
                (function(WorkspaceEdit) {
                    function is(value) {
                        var candidate = value;
                        return candidate && (candidate.changes !== undefined || candidate.documentChanges !== undefined) && (candidate.documentChanges === undefined || candidate.documentChanges.every(function(change) {
                            if (Is.string(change.kind)) {
                                return CreateFile.is(change) || RenameFile.is(change) || DeleteFile.is(change);
                            } else {
                                return TextDocumentEdit.is(change);
                            }
                        }));
                    }
                    WorkspaceEdit.is = is;
                })(WorkspaceEdit || (WorkspaceEdit = {}));
                var TextEditChangeImpl = /** @class */ function() {
                    function TextEditChangeImpl(edits, changeAnnotations) {
                        this.edits = edits;
                        this.changeAnnotations = changeAnnotations;
                    }
                    TextEditChangeImpl.prototype.insert = function(position, newText, annotation) {
                        var edit;
                        var id;
                        if (annotation === undefined) {
                            edit = TextEdit.insert(position, newText);
                        } else if (ChangeAnnotationIdentifier.is(annotation)) {
                            id = annotation;
                            edit = AnnotatedTextEdit.insert(position, newText, annotation);
                        } else {
                            this.assertChangeAnnotations(this.changeAnnotations);
                            id = this.changeAnnotations.manage(annotation);
                            edit = AnnotatedTextEdit.insert(position, newText, id);
                        }
                        this.edits.push(edit);
                        if (id !== undefined) {
                            return id;
                        }
                    };
                    TextEditChangeImpl.prototype.replace = function(range, newText, annotation) {
                        var edit;
                        var id;
                        if (annotation === undefined) {
                            edit = TextEdit.replace(range, newText);
                        } else if (ChangeAnnotationIdentifier.is(annotation)) {
                            id = annotation;
                            edit = AnnotatedTextEdit.replace(range, newText, annotation);
                        } else {
                            this.assertChangeAnnotations(this.changeAnnotations);
                            id = this.changeAnnotations.manage(annotation);
                            edit = AnnotatedTextEdit.replace(range, newText, id);
                        }
                        this.edits.push(edit);
                        if (id !== undefined) {
                            return id;
                        }
                    };
                    TextEditChangeImpl.prototype.delete = function(range, annotation) {
                        var edit;
                        var id;
                        if (annotation === undefined) {
                            edit = TextEdit.del(range);
                        } else if (ChangeAnnotationIdentifier.is(annotation)) {
                            id = annotation;
                            edit = AnnotatedTextEdit.del(range, annotation);
                        } else {
                            this.assertChangeAnnotations(this.changeAnnotations);
                            id = this.changeAnnotations.manage(annotation);
                            edit = AnnotatedTextEdit.del(range, id);
                        }
                        this.edits.push(edit);
                        if (id !== undefined) {
                            return id;
                        }
                    };
                    TextEditChangeImpl.prototype.add = function(edit) {
                        this.edits.push(edit);
                    };
                    TextEditChangeImpl.prototype.all = function() {
                        return this.edits;
                    };
                    TextEditChangeImpl.prototype.clear = function() {
                        this.edits.splice(0, this.edits.length);
                    };
                    TextEditChangeImpl.prototype.assertChangeAnnotations = function(value) {
                        if (value === undefined) {
                            throw new Error("Text edit change is not configured to manage change annotations.");
                        }
                    };
                    return TextEditChangeImpl;
                }();
                /**
 * A helper class
 */ var ChangeAnnotations = /** @class */ function() {
                    function ChangeAnnotations(annotations) {
                        this._annotations = annotations === undefined ? Object.create(null) : annotations;
                        this._counter = 0;
                        this._size = 0;
                    }
                    ChangeAnnotations.prototype.all = function() {
                        return this._annotations;
                    };
                    Object.defineProperty(ChangeAnnotations.prototype, "size", {
                        get: function() {
                            return this._size;
                        },
                        enumerable: false,
                        configurable: true
                    });
                    ChangeAnnotations.prototype.manage = function(idOrAnnotation, annotation) {
                        var id;
                        if (ChangeAnnotationIdentifier.is(idOrAnnotation)) {
                            id = idOrAnnotation;
                        } else {
                            id = this.nextId();
                            annotation = idOrAnnotation;
                        }
                        if (this._annotations[id] !== undefined) {
                            throw new Error("Id ".concat(id, " is already in use."));
                        }
                        if (annotation === undefined) {
                            throw new Error("No annotation provided for id ".concat(id));
                        }
                        this._annotations[id] = annotation;
                        this._size++;
                        return id;
                    };
                    ChangeAnnotations.prototype.nextId = function() {
                        this._counter++;
                        return this._counter.toString();
                    };
                    return ChangeAnnotations;
                }();
                /**
 * A workspace change helps constructing changes to a workspace.
 */ var WorkspaceChange = /** @class */ function() {
                    function WorkspaceChange(workspaceEdit) {
                        var _this = this;
                        this._textEditChanges = Object.create(null);
                        if (workspaceEdit !== undefined) {
                            this._workspaceEdit = workspaceEdit;
                            if (workspaceEdit.documentChanges) {
                                this._changeAnnotations = new ChangeAnnotations(workspaceEdit.changeAnnotations);
                                workspaceEdit.changeAnnotations = this._changeAnnotations.all();
                                workspaceEdit.documentChanges.forEach(function(change) {
                                    if (TextDocumentEdit.is(change)) {
                                        var textEditChange = new TextEditChangeImpl(change.edits, _this._changeAnnotations);
                                        _this._textEditChanges[change.textDocument.uri] = textEditChange;
                                    }
                                });
                            } else if (workspaceEdit.changes) {
                                Object.keys(workspaceEdit.changes).forEach(function(key) {
                                    var textEditChange = new TextEditChangeImpl(workspaceEdit.changes[key]);
                                    _this._textEditChanges[key] = textEditChange;
                                });
                            }
                        } else {
                            this._workspaceEdit = {};
                        }
                    }
                    Object.defineProperty(WorkspaceChange.prototype, "edit", {
                        /**
         * Returns the underlying {@link WorkspaceEdit} literal
         * use to be returned from a workspace edit operation like rename.
         */ get: function() {
                            this.initDocumentChanges();
                            if (this._changeAnnotations !== undefined) {
                                if (this._changeAnnotations.size === 0) {
                                    this._workspaceEdit.changeAnnotations = undefined;
                                } else {
                                    this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
                                }
                            }
                            return this._workspaceEdit;
                        },
                        enumerable: false,
                        configurable: true
                    });
                    WorkspaceChange.prototype.getTextEditChange = function(key) {
                        if (OptionalVersionedTextDocumentIdentifier.is(key)) {
                            this.initDocumentChanges();
                            if (this._workspaceEdit.documentChanges === undefined) {
                                throw new Error('Workspace edit is not configured for document changes.');
                            }
                            var textDocument = {
                                uri: key.uri,
                                version: key.version
                            };
                            var result = this._textEditChanges[textDocument.uri];
                            if (!result) {
                                var edits = [];
                                var textDocumentEdit = {
                                    textDocument: textDocument,
                                    edits: edits
                                };
                                this._workspaceEdit.documentChanges.push(textDocumentEdit);
                                result = new TextEditChangeImpl(edits, this._changeAnnotations);
                                this._textEditChanges[textDocument.uri] = result;
                            }
                            return result;
                        } else {
                            this.initChanges();
                            if (this._workspaceEdit.changes === undefined) {
                                throw new Error('Workspace edit is not configured for normal text edit changes.');
                            }
                            var result = this._textEditChanges[key];
                            if (!result) {
                                var edits = [];
                                this._workspaceEdit.changes[key] = edits;
                                result = new TextEditChangeImpl(edits);
                                this._textEditChanges[key] = result;
                            }
                            return result;
                        }
                    };
                    WorkspaceChange.prototype.initDocumentChanges = function() {
                        if (this._workspaceEdit.documentChanges === undefined && this._workspaceEdit.changes === undefined) {
                            this._changeAnnotations = new ChangeAnnotations();
                            this._workspaceEdit.documentChanges = [];
                            this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
                        }
                    };
                    WorkspaceChange.prototype.initChanges = function() {
                        if (this._workspaceEdit.documentChanges === undefined && this._workspaceEdit.changes === undefined) {
                            this._workspaceEdit.changes = Object.create(null);
                        }
                    };
                    WorkspaceChange.prototype.createFile = function(uri, optionsOrAnnotation, options) {
                        this.initDocumentChanges();
                        if (this._workspaceEdit.documentChanges === undefined) {
                            throw new Error('Workspace edit is not configured for document changes.');
                        }
                        var annotation;
                        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
                            annotation = optionsOrAnnotation;
                        } else {
                            options = optionsOrAnnotation;
                        }
                        var operation;
                        var id;
                        if (annotation === undefined) {
                            operation = CreateFile.create(uri, options);
                        } else {
                            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
                            operation = CreateFile.create(uri, options, id);
                        }
                        this._workspaceEdit.documentChanges.push(operation);
                        if (id !== undefined) {
                            return id;
                        }
                    };
                    WorkspaceChange.prototype.renameFile = function(oldUri, newUri, optionsOrAnnotation, options) {
                        this.initDocumentChanges();
                        if (this._workspaceEdit.documentChanges === undefined) {
                            throw new Error('Workspace edit is not configured for document changes.');
                        }
                        var annotation;
                        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
                            annotation = optionsOrAnnotation;
                        } else {
                            options = optionsOrAnnotation;
                        }
                        var operation;
                        var id;
                        if (annotation === undefined) {
                            operation = RenameFile.create(oldUri, newUri, options);
                        } else {
                            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
                            operation = RenameFile.create(oldUri, newUri, options, id);
                        }
                        this._workspaceEdit.documentChanges.push(operation);
                        if (id !== undefined) {
                            return id;
                        }
                    };
                    WorkspaceChange.prototype.deleteFile = function(uri, optionsOrAnnotation, options) {
                        this.initDocumentChanges();
                        if (this._workspaceEdit.documentChanges === undefined) {
                            throw new Error('Workspace edit is not configured for document changes.');
                        }
                        var annotation;
                        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
                            annotation = optionsOrAnnotation;
                        } else {
                            options = optionsOrAnnotation;
                        }
                        var operation;
                        var id;
                        if (annotation === undefined) {
                            operation = DeleteFile.create(uri, options);
                        } else {
                            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
                            operation = DeleteFile.create(uri, options, id);
                        }
                        this._workspaceEdit.documentChanges.push(operation);
                        if (id !== undefined) {
                            return id;
                        }
                    };
                    return WorkspaceChange;
                }();
                /**
 * The TextDocumentIdentifier namespace provides helper functions to work with
 * {@link TextDocumentIdentifier} literals.
 */ var TextDocumentIdentifier;
                (function(TextDocumentIdentifier) {
                    /**
     * Creates a new TextDocumentIdentifier literal.
     * @param uri The document's uri.
     */ function create(uri) {
                        return {
                            uri: uri
                        };
                    }
                    TextDocumentIdentifier.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link TextDocumentIdentifier} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.defined(candidate) && Is.string(candidate.uri);
                    }
                    TextDocumentIdentifier.is = is;
                })(TextDocumentIdentifier || (TextDocumentIdentifier = {}));
                /**
 * The VersionedTextDocumentIdentifier namespace provides helper functions to work with
 * {@link VersionedTextDocumentIdentifier} literals.
 */ var VersionedTextDocumentIdentifier;
                (function(VersionedTextDocumentIdentifier) {
                    /**
     * Creates a new VersionedTextDocumentIdentifier literal.
     * @param uri The document's uri.
     * @param version The document's version.
     */ function create(uri, version) {
                        return {
                            uri: uri,
                            version: version
                        };
                    }
                    VersionedTextDocumentIdentifier.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link VersionedTextDocumentIdentifier} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.defined(candidate) && Is.string(candidate.uri) && Is.integer(candidate.version);
                    }
                    VersionedTextDocumentIdentifier.is = is;
                })(VersionedTextDocumentIdentifier || (VersionedTextDocumentIdentifier = {}));
                /**
 * The OptionalVersionedTextDocumentIdentifier namespace provides helper functions to work with
 * {@link OptionalVersionedTextDocumentIdentifier} literals.
 */ var OptionalVersionedTextDocumentIdentifier;
                (function(OptionalVersionedTextDocumentIdentifier) {
                    /**
     * Creates a new OptionalVersionedTextDocumentIdentifier literal.
     * @param uri The document's uri.
     * @param version The document's version.
     */ function create(uri, version) {
                        return {
                            uri: uri,
                            version: version
                        };
                    }
                    OptionalVersionedTextDocumentIdentifier.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link OptionalVersionedTextDocumentIdentifier} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.defined(candidate) && Is.string(candidate.uri) && (candidate.version === null || Is.integer(candidate.version));
                    }
                    OptionalVersionedTextDocumentIdentifier.is = is;
                })(OptionalVersionedTextDocumentIdentifier || (OptionalVersionedTextDocumentIdentifier = {}));
                /**
 * The TextDocumentItem namespace provides helper functions to work with
 * {@link TextDocumentItem} literals.
 */ var TextDocumentItem;
                (function(TextDocumentItem) {
                    /**
     * Creates a new TextDocumentItem literal.
     * @param uri The document's uri.
     * @param languageId The document's language identifier.
     * @param version The document's version number.
     * @param text The document's text.
     */ function create(uri, languageId, version, text) {
                        return {
                            uri: uri,
                            languageId: languageId,
                            version: version,
                            text: text
                        };
                    }
                    TextDocumentItem.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link TextDocumentItem} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.defined(candidate) && Is.string(candidate.uri) && Is.string(candidate.languageId) && Is.integer(candidate.version) && Is.string(candidate.text);
                    }
                    TextDocumentItem.is = is;
                })(TextDocumentItem || (TextDocumentItem = {}));
                /**
 * Describes the content type that a client supports in various
 * result literals like `Hover`, `ParameterInfo` or `CompletionItem`.
 *
 * Please note that `MarkupKinds` must not start with a `$`. This kinds
 * are reserved for internal usage.
 */ var MarkupKind;
                (function(MarkupKind) {
                    /**
     * Plain text is supported as a content format
     */ MarkupKind.PlainText = 'plaintext';
                    /**
     * Markdown is supported as a content format
     */ MarkupKind.Markdown = 'markdown';
                    /**
     * Checks whether the given value is a value of the {@link MarkupKind} type.
     */ function is(value) {
                        var candidate = value;
                        return candidate === MarkupKind.PlainText || candidate === MarkupKind.Markdown;
                    }
                    MarkupKind.is = is;
                })(MarkupKind || (MarkupKind = {}));
                var MarkupContent;
                (function(MarkupContent) {
                    /**
     * Checks whether the given value conforms to the {@link MarkupContent} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(value) && MarkupKind.is(candidate.kind) && Is.string(candidate.value);
                    }
                    MarkupContent.is = is;
                })(MarkupContent || (MarkupContent = {}));
                /**
 * The kind of a completion entry.
 */ var CompletionItemKind;
                (function(CompletionItemKind) {
                    CompletionItemKind.Text = 1;
                    CompletionItemKind.Method = 2;
                    CompletionItemKind.Function = 3;
                    CompletionItemKind.Constructor = 4;
                    CompletionItemKind.Field = 5;
                    CompletionItemKind.Variable = 6;
                    CompletionItemKind.Class = 7;
                    CompletionItemKind.Interface = 8;
                    CompletionItemKind.Module = 9;
                    CompletionItemKind.Property = 10;
                    CompletionItemKind.Unit = 11;
                    CompletionItemKind.Value = 12;
                    CompletionItemKind.Enum = 13;
                    CompletionItemKind.Keyword = 14;
                    CompletionItemKind.Snippet = 15;
                    CompletionItemKind.Color = 16;
                    CompletionItemKind.File = 17;
                    CompletionItemKind.Reference = 18;
                    CompletionItemKind.Folder = 19;
                    CompletionItemKind.EnumMember = 20;
                    CompletionItemKind.Constant = 21;
                    CompletionItemKind.Struct = 22;
                    CompletionItemKind.Event = 23;
                    CompletionItemKind.Operator = 24;
                    CompletionItemKind.TypeParameter = 25;
                })(CompletionItemKind || (CompletionItemKind = {}));
                /**
 * Defines whether the insert text in a completion item should be interpreted as
 * plain text or a snippet.
 */ var InsertTextFormat;
                (function(InsertTextFormat) {
                    /**
     * The primary text to be inserted is treated as a plain string.
     */ InsertTextFormat.PlainText = 1;
                    /**
     * The primary text to be inserted is treated as a snippet.
     *
     * A snippet can define tab stops and placeholders with `$1`, `$2`
     * and `${3:foo}`. `$0` defines the final tab stop, it defaults to
     * the end of the snippet. Placeholders with equal identifiers are linked,
     * that is typing in one will update others too.
     *
     * See also: https://microsoft.github.io/language-server-protocol/specifications/specification-current/#snippet_syntax
     */ InsertTextFormat.Snippet = 2;
                })(InsertTextFormat || (InsertTextFormat = {}));
                /**
 * Completion item tags are extra annotations that tweak the rendering of a completion
 * item.
 *
 * @since 3.15.0
 */ var CompletionItemTag;
                (function(CompletionItemTag) {
                    /**
     * Render a completion as obsolete, usually using a strike-out.
     */ CompletionItemTag.Deprecated = 1;
                })(CompletionItemTag || (CompletionItemTag = {}));
                /**
 * The InsertReplaceEdit namespace provides functions to deal with insert / replace edits.
 *
 * @since 3.16.0
 */ var InsertReplaceEdit;
                (function(InsertReplaceEdit) {
                    /**
     * Creates a new insert / replace edit
     */ function create(newText, insert, replace) {
                        return {
                            newText: newText,
                            insert: insert,
                            replace: replace
                        };
                    }
                    InsertReplaceEdit.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link InsertReplaceEdit} interface.
     */ function is(value) {
                        var candidate = value;
                        return candidate && Is.string(candidate.newText) && Range.is(candidate.insert) && Range.is(candidate.replace);
                    }
                    InsertReplaceEdit.is = is;
                })(InsertReplaceEdit || (InsertReplaceEdit = {}));
                /**
 * How whitespace and indentation is handled during completion
 * item insertion.
 *
 * @since 3.16.0
 */ var InsertTextMode;
                (function(InsertTextMode) {
                    /**
     * The insertion or replace strings is taken as it is. If the
     * value is multi line the lines below the cursor will be
     * inserted using the indentation defined in the string value.
     * The client will not apply any kind of adjustments to the
     * string.
     */ InsertTextMode.asIs = 1;
                    /**
     * The editor adjusts leading whitespace of new lines so that
     * they match the indentation up to the cursor of the line for
     * which the item is accepted.
     *
     * Consider a line like this: <2tabs><cursor><3tabs>foo. Accepting a
     * multi line completion item is indented using 2 tabs and all
     * following lines inserted will be indented using 2 tabs as well.
     */ InsertTextMode.adjustIndentation = 2;
                })(InsertTextMode || (InsertTextMode = {}));
                var CompletionItemLabelDetails;
                (function(CompletionItemLabelDetails) {
                    function is(value) {
                        var candidate = value;
                        return candidate && (Is.string(candidate.detail) || candidate.detail === undefined) && (Is.string(candidate.description) || candidate.description === undefined);
                    }
                    CompletionItemLabelDetails.is = is;
                })(CompletionItemLabelDetails || (CompletionItemLabelDetails = {}));
                /**
 * The CompletionItem namespace provides functions to deal with
 * completion items.
 */ var CompletionItem;
                (function(CompletionItem) {
                    /**
     * Create a completion item and seed it with a label.
     * @param label The completion item's label
     */ function create(label) {
                        return {
                            label: label
                        };
                    }
                    CompletionItem.create = create;
                })(CompletionItem || (CompletionItem = {}));
                /**
 * The CompletionList namespace provides functions to deal with
 * completion lists.
 */ var CompletionList;
                (function(CompletionList) {
                    /**
     * Creates a new completion list.
     *
     * @param items The completion items.
     * @param isIncomplete The list is not complete.
     */ function create(items, isIncomplete) {
                        return {
                            items: items ? items : [],
                            isIncomplete: !!isIncomplete
                        };
                    }
                    CompletionList.create = create;
                })(CompletionList || (CompletionList = {}));
                var MarkedString;
                (function(MarkedString) {
                    /**
     * Creates a marked string from plain text.
     *
     * @param plainText The plain text.
     */ function fromPlainText(plainText) {
                        return plainText.replace(/[\\`*_{}[\]()#+\-.!]/g, '\\$&'); // escape markdown syntax tokens: http://daringfireball.net/projects/markdown/syntax#backslash
                    }
                    MarkedString.fromPlainText = fromPlainText;
                    /**
     * Checks whether the given value conforms to the {@link MarkedString} type.
     */ function is(value) {
                        var candidate = value;
                        return Is.string(candidate) || Is.objectLiteral(candidate) && Is.string(candidate.language) && Is.string(candidate.value);
                    }
                    MarkedString.is = is;
                })(MarkedString || (MarkedString = {}));
                var Hover;
                (function(Hover) {
                    /**
     * Checks whether the given value conforms to the {@link Hover} interface.
     */ function is(value) {
                        var candidate = value;
                        return !!candidate && Is.objectLiteral(candidate) && (MarkupContent.is(candidate.contents) || MarkedString.is(candidate.contents) || Is.typedArray(candidate.contents, MarkedString.is)) && (value.range === undefined || Range.is(value.range));
                    }
                    Hover.is = is;
                })(Hover || (Hover = {}));
                /**
 * The ParameterInformation namespace provides helper functions to work with
 * {@link ParameterInformation} literals.
 */ var ParameterInformation;
                (function(ParameterInformation) {
                    /**
     * Creates a new parameter information literal.
     *
     * @param label A label string.
     * @param documentation A doc string.
     */ function create(label, documentation) {
                        return documentation ? {
                            label: label,
                            documentation: documentation
                        } : {
                            label: label
                        };
                    }
                    ParameterInformation.create = create;
                })(ParameterInformation || (ParameterInformation = {}));
                /**
 * The SignatureInformation namespace provides helper functions to work with
 * {@link SignatureInformation} literals.
 */ var SignatureInformation;
                (function(SignatureInformation) {
                    function create(label, documentation) {
                        var parameters = [];
                        for(var _i = 2; _i < arguments.length; _i++){
                            parameters[_i - 2] = arguments[_i];
                        }
                        var result = {
                            label: label
                        };
                        if (Is.defined(documentation)) {
                            result.documentation = documentation;
                        }
                        if (Is.defined(parameters)) {
                            result.parameters = parameters;
                        } else {
                            result.parameters = [];
                        }
                        return result;
                    }
                    SignatureInformation.create = create;
                })(SignatureInformation || (SignatureInformation = {}));
                /**
 * A document highlight kind.
 */ var DocumentHighlightKind;
                (function(DocumentHighlightKind) {
                    /**
     * A textual occurrence.
     */ DocumentHighlightKind.Text = 1;
                    /**
     * Read-access of a symbol, like reading a variable.
     */ DocumentHighlightKind.Read = 2;
                    /**
     * Write-access of a symbol, like writing to a variable.
     */ DocumentHighlightKind.Write = 3;
                })(DocumentHighlightKind || (DocumentHighlightKind = {}));
                /**
 * DocumentHighlight namespace to provide helper functions to work with
 * {@link DocumentHighlight} literals.
 */ var DocumentHighlight;
                (function(DocumentHighlight) {
                    /**
     * Create a DocumentHighlight object.
     * @param range The range the highlight applies to.
     * @param kind The highlight kind
     */ function create(range, kind) {
                        var result = {
                            range: range
                        };
                        if (Is.number(kind)) {
                            result.kind = kind;
                        }
                        return result;
                    }
                    DocumentHighlight.create = create;
                })(DocumentHighlight || (DocumentHighlight = {}));
                /**
 * A symbol kind.
 */ var SymbolKind;
                (function(SymbolKind) {
                    SymbolKind.File = 1;
                    SymbolKind.Module = 2;
                    SymbolKind.Namespace = 3;
                    SymbolKind.Package = 4;
                    SymbolKind.Class = 5;
                    SymbolKind.Method = 6;
                    SymbolKind.Property = 7;
                    SymbolKind.Field = 8;
                    SymbolKind.Constructor = 9;
                    SymbolKind.Enum = 10;
                    SymbolKind.Interface = 11;
                    SymbolKind.Function = 12;
                    SymbolKind.Variable = 13;
                    SymbolKind.Constant = 14;
                    SymbolKind.String = 15;
                    SymbolKind.Number = 16;
                    SymbolKind.Boolean = 17;
                    SymbolKind.Array = 18;
                    SymbolKind.Object = 19;
                    SymbolKind.Key = 20;
                    SymbolKind.Null = 21;
                    SymbolKind.EnumMember = 22;
                    SymbolKind.Struct = 23;
                    SymbolKind.Event = 24;
                    SymbolKind.Operator = 25;
                    SymbolKind.TypeParameter = 26;
                })(SymbolKind || (SymbolKind = {}));
                /**
 * Symbol tags are extra annotations that tweak the rendering of a symbol.
 *
 * @since 3.16
 */ var SymbolTag;
                (function(SymbolTag) {
                    /**
     * Render a symbol as obsolete, usually using a strike-out.
     */ SymbolTag.Deprecated = 1;
                })(SymbolTag || (SymbolTag = {}));
                var SymbolInformation;
                (function(SymbolInformation) {
                    /**
     * Creates a new symbol information literal.
     *
     * @param name The name of the symbol.
     * @param kind The kind of the symbol.
     * @param range The range of the location of the symbol.
     * @param uri The resource of the location of symbol.
     * @param containerName The name of the symbol containing the symbol.
     */ function create(name, kind, range, uri, containerName) {
                        var result = {
                            name: name,
                            kind: kind,
                            location: {
                                uri: uri,
                                range: range
                            }
                        };
                        if (containerName) {
                            result.containerName = containerName;
                        }
                        return result;
                    }
                    SymbolInformation.create = create;
                })(SymbolInformation || (SymbolInformation = {}));
                var WorkspaceSymbol;
                (function(WorkspaceSymbol) {
                    /**
     * Create a new workspace symbol.
     *
     * @param name The name of the symbol.
     * @param kind The kind of the symbol.
     * @param uri The resource of the location of the symbol.
     * @param range An options range of the location.
     * @returns A WorkspaceSymbol.
     */ function create(name, kind, uri, range) {
                        return range !== undefined ? {
                            name: name,
                            kind: kind,
                            location: {
                                uri: uri,
                                range: range
                            }
                        } : {
                            name: name,
                            kind: kind,
                            location: {
                                uri: uri
                            }
                        };
                    }
                    WorkspaceSymbol.create = create;
                })(WorkspaceSymbol || (WorkspaceSymbol = {}));
                var DocumentSymbol;
                (function(DocumentSymbol) {
                    /**
     * Creates a new symbol information literal.
     *
     * @param name The name of the symbol.
     * @param detail The detail of the symbol.
     * @param kind The kind of the symbol.
     * @param range The range of the symbol.
     * @param selectionRange The selectionRange of the symbol.
     * @param children Children of the symbol.
     */ function create(name, detail, kind, range, selectionRange, children) {
                        var result = {
                            name: name,
                            detail: detail,
                            kind: kind,
                            range: range,
                            selectionRange: selectionRange
                        };
                        if (children !== undefined) {
                            result.children = children;
                        }
                        return result;
                    }
                    DocumentSymbol.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link DocumentSymbol} interface.
     */ function is(value) {
                        var candidate = value;
                        return candidate && Is.string(candidate.name) && Is.number(candidate.kind) && Range.is(candidate.range) && Range.is(candidate.selectionRange) && (candidate.detail === undefined || Is.string(candidate.detail)) && (candidate.deprecated === undefined || Is.boolean(candidate.deprecated)) && (candidate.children === undefined || Array.isArray(candidate.children)) && (candidate.tags === undefined || Array.isArray(candidate.tags));
                    }
                    DocumentSymbol.is = is;
                })(DocumentSymbol || (DocumentSymbol = {}));
                /**
 * A set of predefined code action kinds
 */ var CodeActionKind;
                (function(CodeActionKind) {
                    /**
     * Empty kind.
     */ CodeActionKind.Empty = '';
                    /**
     * Base kind for quickfix actions: 'quickfix'
     */ CodeActionKind.QuickFix = 'quickfix';
                    /**
     * Base kind for refactoring actions: 'refactor'
     */ CodeActionKind.Refactor = 'refactor';
                    /**
     * Base kind for refactoring extraction actions: 'refactor.extract'
     *
     * Example extract actions:
     *
     * - Extract method
     * - Extract function
     * - Extract variable
     * - Extract interface from class
     * - ...
     */ CodeActionKind.RefactorExtract = 'refactor.extract';
                    /**
     * Base kind for refactoring inline actions: 'refactor.inline'
     *
     * Example inline actions:
     *
     * - Inline function
     * - Inline variable
     * - Inline constant
     * - ...
     */ CodeActionKind.RefactorInline = 'refactor.inline';
                    /**
     * Base kind for refactoring rewrite actions: 'refactor.rewrite'
     *
     * Example rewrite actions:
     *
     * - Convert JavaScript function to class
     * - Add or remove parameter
     * - Encapsulate field
     * - Make method static
     * - Move method to base class
     * - ...
     */ CodeActionKind.RefactorRewrite = 'refactor.rewrite';
                    /**
     * Base kind for source actions: `source`
     *
     * Source code actions apply to the entire file.
     */ CodeActionKind.Source = 'source';
                    /**
     * Base kind for an organize imports source action: `source.organizeImports`
     */ CodeActionKind.SourceOrganizeImports = 'source.organizeImports';
                    /**
     * Base kind for auto-fix source actions: `source.fixAll`.
     *
     * Fix all actions automatically fix errors that have a clear fix that do not require user input.
     * They should not suppress errors or perform unsafe fixes such as generating new types or classes.
     *
     * @since 3.15.0
     */ CodeActionKind.SourceFixAll = 'source.fixAll';
                })(CodeActionKind || (CodeActionKind = {}));
                /**
 * The reason why code actions were requested.
 *
 * @since 3.17.0
 */ var CodeActionTriggerKind;
                (function(CodeActionTriggerKind) {
                    /**
     * Code actions were explicitly requested by the user or by an extension.
     */ CodeActionTriggerKind.Invoked = 1;
                    /**
     * Code actions were requested automatically.
     *
     * This typically happens when current selection in a file changes, but can
     * also be triggered when file content changes.
     */ CodeActionTriggerKind.Automatic = 2;
                })(CodeActionTriggerKind || (CodeActionTriggerKind = {}));
                /**
 * The CodeActionContext namespace provides helper functions to work with
 * {@link CodeActionContext} literals.
 */ var CodeActionContext;
                (function(CodeActionContext) {
                    /**
     * Creates a new CodeActionContext literal.
     */ function create(diagnostics, only, triggerKind) {
                        var result = {
                            diagnostics: diagnostics
                        };
                        if (only !== undefined && only !== null) {
                            result.only = only;
                        }
                        if (triggerKind !== undefined && triggerKind !== null) {
                            result.triggerKind = triggerKind;
                        }
                        return result;
                    }
                    CodeActionContext.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link CodeActionContext} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.defined(candidate) && Is.typedArray(candidate.diagnostics, Diagnostic.is) && (candidate.only === undefined || Is.typedArray(candidate.only, Is.string)) && (candidate.triggerKind === undefined || candidate.triggerKind === CodeActionTriggerKind.Invoked || candidate.triggerKind === CodeActionTriggerKind.Automatic);
                    }
                    CodeActionContext.is = is;
                })(CodeActionContext || (CodeActionContext = {}));
                var CodeAction;
                (function(CodeAction) {
                    function create(title, kindOrCommandOrEdit, kind) {
                        var result = {
                            title: title
                        };
                        var checkKind = true;
                        if (typeof kindOrCommandOrEdit === 'string') {
                            checkKind = false;
                            result.kind = kindOrCommandOrEdit;
                        } else if (Command.is(kindOrCommandOrEdit)) {
                            result.command = kindOrCommandOrEdit;
                        } else {
                            result.edit = kindOrCommandOrEdit;
                        }
                        if (checkKind && kind !== undefined) {
                            result.kind = kind;
                        }
                        return result;
                    }
                    CodeAction.create = create;
                    function is(value) {
                        var candidate = value;
                        return candidate && Is.string(candidate.title) && (candidate.diagnostics === undefined || Is.typedArray(candidate.diagnostics, Diagnostic.is)) && (candidate.kind === undefined || Is.string(candidate.kind)) && (candidate.edit !== undefined || candidate.command !== undefined) && (candidate.command === undefined || Command.is(candidate.command)) && (candidate.isPreferred === undefined || Is.boolean(candidate.isPreferred)) && (candidate.edit === undefined || WorkspaceEdit.is(candidate.edit));
                    }
                    CodeAction.is = is;
                })(CodeAction || (CodeAction = {}));
                /**
 * The CodeLens namespace provides helper functions to work with
 * {@link CodeLens} literals.
 */ var CodeLens;
                (function(CodeLens) {
                    /**
     * Creates a new CodeLens literal.
     */ function create(range, data) {
                        var result = {
                            range: range
                        };
                        if (Is.defined(data)) {
                            result.data = data;
                        }
                        return result;
                    }
                    CodeLens.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link CodeLens} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.command) || Command.is(candidate.command));
                    }
                    CodeLens.is = is;
                })(CodeLens || (CodeLens = {}));
                /**
 * The FormattingOptions namespace provides helper functions to work with
 * {@link FormattingOptions} literals.
 */ var FormattingOptions;
                (function(FormattingOptions) {
                    /**
     * Creates a new FormattingOptions literal.
     */ function create(tabSize, insertSpaces) {
                        return {
                            tabSize: tabSize,
                            insertSpaces: insertSpaces
                        };
                    }
                    FormattingOptions.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link FormattingOptions} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.defined(candidate) && Is.uinteger(candidate.tabSize) && Is.boolean(candidate.insertSpaces);
                    }
                    FormattingOptions.is = is;
                })(FormattingOptions || (FormattingOptions = {}));
                /**
 * The DocumentLink namespace provides helper functions to work with
 * {@link DocumentLink} literals.
 */ var DocumentLink;
                (function(DocumentLink) {
                    /**
     * Creates a new DocumentLink literal.
     */ function create(range, target, data) {
                        return {
                            range: range,
                            target: target,
                            data: data
                        };
                    }
                    DocumentLink.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link DocumentLink} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.target) || Is.string(candidate.target));
                    }
                    DocumentLink.is = is;
                })(DocumentLink || (DocumentLink = {}));
                /**
 * The SelectionRange namespace provides helper function to work with
 * SelectionRange literals.
 */ var SelectionRange;
                (function(SelectionRange) {
                    /**
     * Creates a new SelectionRange
     * @param range the range.
     * @param parent an optional parent.
     */ function create(range, parent) {
                        return {
                            range: range,
                            parent: parent
                        };
                    }
                    SelectionRange.create = create;
                    function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && Range.is(candidate.range) && (candidate.parent === undefined || SelectionRange.is(candidate.parent));
                    }
                    SelectionRange.is = is;
                })(SelectionRange || (SelectionRange = {}));
                /**
 * A set of predefined token types. This set is not fixed
 * an clients can specify additional token types via the
 * corresponding client capabilities.
 *
 * @since 3.16.0
 */ var SemanticTokenTypes;
                (function(SemanticTokenTypes) {
                    SemanticTokenTypes["namespace"] = "namespace";
                    /**
     * Represents a generic type. Acts as a fallback for types which can't be mapped to
     * a specific type like class or enum.
     */ SemanticTokenTypes["type"] = "type";
                    SemanticTokenTypes["class"] = "class";
                    SemanticTokenTypes["enum"] = "enum";
                    SemanticTokenTypes["interface"] = "interface";
                    SemanticTokenTypes["struct"] = "struct";
                    SemanticTokenTypes["typeParameter"] = "typeParameter";
                    SemanticTokenTypes["parameter"] = "parameter";
                    SemanticTokenTypes["variable"] = "variable";
                    SemanticTokenTypes["property"] = "property";
                    SemanticTokenTypes["enumMember"] = "enumMember";
                    SemanticTokenTypes["event"] = "event";
                    SemanticTokenTypes["function"] = "function";
                    SemanticTokenTypes["method"] = "method";
                    SemanticTokenTypes["macro"] = "macro";
                    SemanticTokenTypes["keyword"] = "keyword";
                    SemanticTokenTypes["modifier"] = "modifier";
                    SemanticTokenTypes["comment"] = "comment";
                    SemanticTokenTypes["string"] = "string";
                    SemanticTokenTypes["number"] = "number";
                    SemanticTokenTypes["regexp"] = "regexp";
                    SemanticTokenTypes["operator"] = "operator";
                    /**
     * @since 3.17.0
     */ SemanticTokenTypes["decorator"] = "decorator";
                })(SemanticTokenTypes || (SemanticTokenTypes = {}));
                /**
 * A set of predefined token modifiers. This set is not fixed
 * an clients can specify additional token types via the
 * corresponding client capabilities.
 *
 * @since 3.16.0
 */ var SemanticTokenModifiers;
                (function(SemanticTokenModifiers) {
                    SemanticTokenModifiers["declaration"] = "declaration";
                    SemanticTokenModifiers["definition"] = "definition";
                    SemanticTokenModifiers["readonly"] = "readonly";
                    SemanticTokenModifiers["static"] = "static";
                    SemanticTokenModifiers["deprecated"] = "deprecated";
                    SemanticTokenModifiers["abstract"] = "abstract";
                    SemanticTokenModifiers["async"] = "async";
                    SemanticTokenModifiers["modification"] = "modification";
                    SemanticTokenModifiers["documentation"] = "documentation";
                    SemanticTokenModifiers["defaultLibrary"] = "defaultLibrary";
                })(SemanticTokenModifiers || (SemanticTokenModifiers = {}));
                /**
 * @since 3.16.0
 */ var SemanticTokens;
                (function(SemanticTokens) {
                    function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && (candidate.resultId === undefined || typeof candidate.resultId === 'string') && Array.isArray(candidate.data) && (candidate.data.length === 0 || typeof candidate.data[0] === 'number');
                    }
                    SemanticTokens.is = is;
                })(SemanticTokens || (SemanticTokens = {}));
                /**
 * The InlineValueText namespace provides functions to deal with InlineValueTexts.
 *
 * @since 3.17.0
 */ var InlineValueText;
                (function(InlineValueText) {
                    /**
     * Creates a new InlineValueText literal.
     */ function create(range, text) {
                        return {
                            range: range,
                            text: text
                        };
                    }
                    InlineValueText.create = create;
                    function is(value) {
                        var candidate = value;
                        return candidate !== undefined && candidate !== null && Range.is(candidate.range) && Is.string(candidate.text);
                    }
                    InlineValueText.is = is;
                })(InlineValueText || (InlineValueText = {}));
                /**
 * The InlineValueVariableLookup namespace provides functions to deal with InlineValueVariableLookups.
 *
 * @since 3.17.0
 */ var InlineValueVariableLookup;
                (function(InlineValueVariableLookup) {
                    /**
     * Creates a new InlineValueText literal.
     */ function create(range, variableName, caseSensitiveLookup) {
                        return {
                            range: range,
                            variableName: variableName,
                            caseSensitiveLookup: caseSensitiveLookup
                        };
                    }
                    InlineValueVariableLookup.create = create;
                    function is(value) {
                        var candidate = value;
                        return candidate !== undefined && candidate !== null && Range.is(candidate.range) && Is.boolean(candidate.caseSensitiveLookup) && (Is.string(candidate.variableName) || candidate.variableName === undefined);
                    }
                    InlineValueVariableLookup.is = is;
                })(InlineValueVariableLookup || (InlineValueVariableLookup = {}));
                /**
 * The InlineValueEvaluatableExpression namespace provides functions to deal with InlineValueEvaluatableExpression.
 *
 * @since 3.17.0
 */ var InlineValueEvaluatableExpression;
                (function(InlineValueEvaluatableExpression) {
                    /**
     * Creates a new InlineValueEvaluatableExpression literal.
     */ function create(range, expression) {
                        return {
                            range: range,
                            expression: expression
                        };
                    }
                    InlineValueEvaluatableExpression.create = create;
                    function is(value) {
                        var candidate = value;
                        return candidate !== undefined && candidate !== null && Range.is(candidate.range) && (Is.string(candidate.expression) || candidate.expression === undefined);
                    }
                    InlineValueEvaluatableExpression.is = is;
                })(InlineValueEvaluatableExpression || (InlineValueEvaluatableExpression = {}));
                /**
 * The InlineValueContext namespace provides helper functions to work with
 * {@link InlineValueContext} literals.
 *
 * @since 3.17.0
 */ var InlineValueContext;
                (function(InlineValueContext) {
                    /**
     * Creates a new InlineValueContext literal.
     */ function create(frameId, stoppedLocation) {
                        return {
                            frameId: frameId,
                            stoppedLocation: stoppedLocation
                        };
                    }
                    InlineValueContext.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link InlineValueContext} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.defined(candidate) && Range.is(value.stoppedLocation);
                    }
                    InlineValueContext.is = is;
                })(InlineValueContext || (InlineValueContext = {}));
                /**
 * Inlay hint kinds.
 *
 * @since 3.17.0
 */ var InlayHintKind;
                (function(InlayHintKind) {
                    /**
     * An inlay hint that for a type annotation.
     */ InlayHintKind.Type = 1;
                    /**
     * An inlay hint that is for a parameter.
     */ InlayHintKind.Parameter = 2;
                    function is(value) {
                        return value === 1 || value === 2;
                    }
                    InlayHintKind.is = is;
                })(InlayHintKind || (InlayHintKind = {}));
                var InlayHintLabelPart;
                (function(InlayHintLabelPart) {
                    function create(value) {
                        return {
                            value: value
                        };
                    }
                    InlayHintLabelPart.create = create;
                    function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && (candidate.tooltip === undefined || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip)) && (candidate.location === undefined || Location.is(candidate.location)) && (candidate.command === undefined || Command.is(candidate.command));
                    }
                    InlayHintLabelPart.is = is;
                })(InlayHintLabelPart || (InlayHintLabelPart = {}));
                var InlayHint;
                (function(InlayHint) {
                    function create(position, label, kind) {
                        var result = {
                            position: position,
                            label: label
                        };
                        if (kind !== undefined) {
                            result.kind = kind;
                        }
                        return result;
                    }
                    InlayHint.create = create;
                    function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && Position.is(candidate.position) && (Is.string(candidate.label) || Is.typedArray(candidate.label, InlayHintLabelPart.is)) && (candidate.kind === undefined || InlayHintKind.is(candidate.kind)) && candidate.textEdits === undefined || Is.typedArray(candidate.textEdits, TextEdit.is) && (candidate.tooltip === undefined || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip)) && (candidate.paddingLeft === undefined || Is.boolean(candidate.paddingLeft)) && (candidate.paddingRight === undefined || Is.boolean(candidate.paddingRight));
                    }
                    InlayHint.is = is;
                })(InlayHint || (InlayHint = {}));
                var WorkspaceFolder;
                (function(WorkspaceFolder) {
                    function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && URI1.is(candidate.uri) && Is.string(candidate.name);
                    }
                    WorkspaceFolder.is = is;
                })(WorkspaceFolder || (WorkspaceFolder = {}));
                var EOL = [
                    '\n',
                    '\r\n',
                    '\r'
                ];
                /**
 * @deprecated Use the text document from the new vscode-languageserver-textdocument package.
 */ var TextDocument;
                (function(TextDocument) {
                    /**
     * Creates a new ITextDocument literal from the given uri and content.
     * @param uri The document's uri.
     * @param languageId The document's language Id.
     * @param version The document's version.
     * @param content The document's content.
     */ function create(uri, languageId, version, content) {
                        return new FullTextDocument(uri, languageId, version, content);
                    }
                    TextDocument.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link ITextDocument} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.defined(candidate) && Is.string(candidate.uri) && (Is.undefined(candidate.languageId) || Is.string(candidate.languageId)) && Is.uinteger(candidate.lineCount) && Is.func(candidate.getText) && Is.func(candidate.positionAt) && Is.func(candidate.offsetAt) ? true : false;
                    }
                    TextDocument.is = is;
                    function applyEdits(document1, edits) {
                        var text = document1.getText();
                        var sortedEdits = mergeSort(edits, function(a, b) {
                            var diff = a.range.start.line - b.range.start.line;
                            if (diff === 0) {
                                return a.range.start.character - b.range.start.character;
                            }
                            return diff;
                        });
                        var lastModifiedOffset = text.length;
                        for(var i = sortedEdits.length - 1; i >= 0; i--){
                            var e = sortedEdits[i];
                            var startOffset = document1.offsetAt(e.range.start);
                            var endOffset = document1.offsetAt(e.range.end);
                            if (endOffset <= lastModifiedOffset) {
                                text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);
                            } else {
                                throw new Error('Overlapping edit');
                            }
                            lastModifiedOffset = startOffset;
                        }
                        return text;
                    }
                    TextDocument.applyEdits = applyEdits;
                    function mergeSort(data, compare) {
                        if (data.length <= 1) {
                            // sorted
                            return data;
                        }
                        var p = data.length / 2 | 0;
                        var left = data.slice(0, p);
                        var right = data.slice(p);
                        mergeSort(left, compare);
                        mergeSort(right, compare);
                        var leftIdx = 0;
                        var rightIdx = 0;
                        var i = 0;
                        while(leftIdx < left.length && rightIdx < right.length){
                            var ret = compare(left[leftIdx], right[rightIdx]);
                            if (ret <= 0) {
                                // smaller_equal -> take left to preserve order
                                data[i++] = left[leftIdx++];
                            } else {
                                // greater -> take right
                                data[i++] = right[rightIdx++];
                            }
                        }
                        while(leftIdx < left.length){
                            data[i++] = left[leftIdx++];
                        }
                        while(rightIdx < right.length){
                            data[i++] = right[rightIdx++];
                        }
                        return data;
                    }
                })(TextDocument || (TextDocument = {}));
                /**
 * @deprecated Use the text document from the new vscode-languageserver-textdocument package.
 */ var FullTextDocument = /** @class */ function() {
                    function FullTextDocument(uri, languageId, version, content) {
                        this._uri = uri;
                        this._languageId = languageId;
                        this._version = version;
                        this._content = content;
                        this._lineOffsets = undefined;
                    }
                    Object.defineProperty(FullTextDocument.prototype, "uri", {
                        get: function() {
                            return this._uri;
                        },
                        enumerable: false,
                        configurable: true
                    });
                    Object.defineProperty(FullTextDocument.prototype, "languageId", {
                        get: function() {
                            return this._languageId;
                        },
                        enumerable: false,
                        configurable: true
                    });
                    Object.defineProperty(FullTextDocument.prototype, "version", {
                        get: function() {
                            return this._version;
                        },
                        enumerable: false,
                        configurable: true
                    });
                    FullTextDocument.prototype.getText = function(range) {
                        if (range) {
                            var start = this.offsetAt(range.start);
                            var end = this.offsetAt(range.end);
                            return this._content.substring(start, end);
                        }
                        return this._content;
                    };
                    FullTextDocument.prototype.update = function(event, version) {
                        this._content = event.text;
                        this._version = version;
                        this._lineOffsets = undefined;
                    };
                    FullTextDocument.prototype.getLineOffsets = function() {
                        if (this._lineOffsets === undefined) {
                            var lineOffsets = [];
                            var text = this._content;
                            var isLineStart = true;
                            for(var i = 0; i < text.length; i++){
                                if (isLineStart) {
                                    lineOffsets.push(i);
                                    isLineStart = false;
                                }
                                var ch = text.charAt(i);
                                isLineStart = ch === '\r' || ch === '\n';
                                if (ch === '\r' && i + 1 < text.length && text.charAt(i + 1) === '\n') {
                                    i++;
                                }
                            }
                            if (isLineStart && text.length > 0) {
                                lineOffsets.push(text.length);
                            }
                            this._lineOffsets = lineOffsets;
                        }
                        return this._lineOffsets;
                    };
                    FullTextDocument.prototype.positionAt = function(offset) {
                        offset = Math.max(Math.min(offset, this._content.length), 0);
                        var lineOffsets = this.getLineOffsets();
                        var low = 0, high = lineOffsets.length;
                        if (high === 0) {
                            return Position.create(0, offset);
                        }
                        while(low < high){
                            var mid = Math.floor((low + high) / 2);
                            if (lineOffsets[mid] > offset) {
                                high = mid;
                            } else {
                                low = mid + 1;
                            }
                        }
                        // low is the least x for which the line offset is larger than the current offset
                        // or array.length if no line offset is larger than the current offset
                        var line = low - 1;
                        return Position.create(line, offset - lineOffsets[line]);
                    };
                    FullTextDocument.prototype.offsetAt = function(position) {
                        var lineOffsets = this.getLineOffsets();
                        if (position.line >= lineOffsets.length) {
                            return this._content.length;
                        } else if (position.line < 0) {
                            return 0;
                        }
                        var lineOffset = lineOffsets[position.line];
                        var nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;
                        return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
                    };
                    Object.defineProperty(FullTextDocument.prototype, "lineCount", {
                        get: function() {
                            return this.getLineOffsets().length;
                        },
                        enumerable: false,
                        configurable: true
                    });
                    return FullTextDocument;
                }();
                var Is;
                (function(Is) {
                    var toString = Object.prototype.toString;
                    function defined(value) {
                        return typeof value !== 'undefined';
                    }
                    Is.defined = defined;
                    function undefined1(value) {
                        return typeof value === 'undefined';
                    }
                    Is.undefined = undefined1;
                    function boolean(value) {
                        return value === true || value === false;
                    }
                    Is.boolean = boolean;
                    function string(value) {
                        return toString.call(value) === '[object String]';
                    }
                    Is.string = string;
                    function number(value) {
                        return toString.call(value) === '[object Number]';
                    }
                    Is.number = number;
                    function numberRange(value, min, max) {
                        return toString.call(value) === '[object Number]' && min <= value && value <= max;
                    }
                    Is.numberRange = numberRange;
                    function integer(value) {
                        return toString.call(value) === '[object Number]' && -2147483648 <= value && value <= 2147483647;
                    }
                    Is.integer = integer;
                    function uinteger(value) {
                        return toString.call(value) === '[object Number]' && 0 <= value && value <= 2147483647;
                    }
                    Is.uinteger = uinteger;
                    function func(value) {
                        return toString.call(value) === '[object Function]';
                    }
                    Is.func = func;
                    function objectLiteral(value) {
                        // Strictly speaking class instances pass this check as well. Since the LSP
                        // doesn't use classes we ignore this for now. If we do we need to add something
                        // like this: `Object.getPrototypeOf(Object.getPrototypeOf(x)) === null`
                        return value !== null && typeof value === 'object';
                    }
                    Is.objectLiteral = objectLiteral;
                    function typedArray(value, check) {
                        return Array.isArray(value) && value.every(check);
                    }
                    Is.typedArray = typedArray;
                })(Is || (Is = {}));
            /***/ },
            /***/ 4879: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_695390__) {
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
                    if (k2 === undefined) k2 = k;
                    var desc = Object.getOwnPropertyDescriptor(m, k);
                    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
                        desc = {
                            enumerable: true,
                            get: function() {
                                return m[k];
                            }
                        };
                    }
                    Object.defineProperty(o, k2, desc);
                } : function(o, m, k, k2) {
                    if (k2 === undefined) k2 = k;
                    o[k2] = m[k];
                });
                var __exportStar = this && this.__exportStar || function(m, exports1) {
                    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
                };
                Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.createMessageConnection = exports1.BrowserMessageWriter = exports1.BrowserMessageReader = void 0;
                const ril_1 = __nested_webpack_require_695390__(8927);
                // Install the browser runtime abstract.
                ril_1.default.install();
                const api_1 = __nested_webpack_require_695390__(8969);
                __exportStar(__nested_webpack_require_695390__(8969), exports1);
                class BrowserMessageReader extends api_1.AbstractMessageReader {
                    listen(callback) {
                        return this._onData.event(callback);
                    }
                    constructor(context){
                        super();
                        this._onData = new api_1.Emitter();
                        this._messageListener = (event)=>{
                            this._onData.fire(event.data);
                        };
                        context.addEventListener('error', (event)=>this.fireError(event));
                        context.onmessage = this._messageListener;
                    }
                }
                exports1.BrowserMessageReader = BrowserMessageReader;
                class BrowserMessageWriter extends api_1.AbstractMessageWriter {
                    write(msg) {
                        try {
                            this.context.postMessage(msg);
                            return Promise.resolve();
                        } catch (error) {
                            this.handleError(error, msg);
                            return Promise.reject(error);
                        }
                    }
                    handleError(error, msg) {
                        this.errorCount++;
                        this.fireError(error, msg, this.errorCount);
                    }
                    end() {}
                    constructor(context){
                        super();
                        this.context = context;
                        this.errorCount = 0;
                        context.addEventListener('error', (event)=>this.fireError(event));
                    }
                }
                exports1.BrowserMessageWriter = BrowserMessageWriter;
                function createMessageConnection(reader, writer, logger, options) {
                    if (logger === undefined) {
                        logger = api_1.NullLogger;
                    }
                    if (api_1.ConnectionStrategy.is(options)) {
                        options = {
                            connectionStrategy: options
                        };
                    }
                    return (0, api_1.createMessageConnection)(reader, writer, logger, options);
                }
                exports1.createMessageConnection = createMessageConnection;
            //# sourceMappingURL=main.js.map
            /***/ },
            /***/ 8927: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_699874__)=>{
                "use strict";
                /* provided dependency */ var console = __nested_webpack_require_699874__(4364);
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                const ral_1 = __nested_webpack_require_699874__(4254);
                const disposable_1 = __nested_webpack_require_699874__(7963);
                const events_1 = __nested_webpack_require_699874__(6780);
                const messageBuffer_1 = __nested_webpack_require_699874__(2180);
                class MessageBuffer extends messageBuffer_1.AbstractMessageBuffer {
                    emptyBuffer() {
                        return MessageBuffer.emptyBuffer;
                    }
                    fromString(value, _encoding) {
                        return new TextEncoder().encode(value);
                    }
                    toString(value, encoding) {
                        if (encoding === 'ascii') {
                            return this.asciiDecoder.decode(value);
                        } else {
                            return new TextDecoder(encoding).decode(value);
                        }
                    }
                    asNative(buffer, length) {
                        if (length === undefined) {
                            return buffer;
                        } else {
                            return buffer.slice(0, length);
                        }
                    }
                    allocNative(length) {
                        return new Uint8Array(length);
                    }
                    constructor(encoding = 'utf-8'){
                        super(encoding);
                        this.asciiDecoder = new TextDecoder('ascii');
                    }
                }
                MessageBuffer.emptyBuffer = new Uint8Array(0);
                class ReadableStreamWrapper {
                    onClose(listener) {
                        this.socket.addEventListener('close', listener);
                        return disposable_1.Disposable.create(()=>this.socket.removeEventListener('close', listener));
                    }
                    onError(listener) {
                        this.socket.addEventListener('error', listener);
                        return disposable_1.Disposable.create(()=>this.socket.removeEventListener('error', listener));
                    }
                    onEnd(listener) {
                        this.socket.addEventListener('end', listener);
                        return disposable_1.Disposable.create(()=>this.socket.removeEventListener('end', listener));
                    }
                    onData(listener) {
                        return this._onData.event(listener);
                    }
                    constructor(socket){
                        this.socket = socket;
                        this._onData = new events_1.Emitter();
                        this._messageListener = (event)=>{
                            const blob = event.data;
                            blob.arrayBuffer().then((buffer)=>{
                                this._onData.fire(new Uint8Array(buffer));
                            }, ()=>{
                                (0, ral_1.default)().console.error(`Converting blob to array buffer failed.`);
                            });
                        };
                        this.socket.addEventListener('message', this._messageListener);
                    }
                }
                class WritableStreamWrapper {
                    onClose(listener) {
                        this.socket.addEventListener('close', listener);
                        return disposable_1.Disposable.create(()=>this.socket.removeEventListener('close', listener));
                    }
                    onError(listener) {
                        this.socket.addEventListener('error', listener);
                        return disposable_1.Disposable.create(()=>this.socket.removeEventListener('error', listener));
                    }
                    onEnd(listener) {
                        this.socket.addEventListener('end', listener);
                        return disposable_1.Disposable.create(()=>this.socket.removeEventListener('end', listener));
                    }
                    write(data, encoding) {
                        if (typeof data === 'string') {
                            if (encoding !== undefined && encoding !== 'utf-8') {
                                throw new Error(`In a Browser environments only utf-8 text encoding is supported. But got encoding: ${encoding}`);
                            }
                            this.socket.send(data);
                        } else {
                            this.socket.send(data);
                        }
                        return Promise.resolve();
                    }
                    end() {
                        this.socket.close();
                    }
                    constructor(socket){
                        this.socket = socket;
                    }
                }
                const _textEncoder = new TextEncoder();
                const _ril = Object.freeze({
                    messageBuffer: Object.freeze({
                        create: (encoding)=>new MessageBuffer(encoding)
                    }),
                    applicationJson: Object.freeze({
                        encoder: Object.freeze({
                            name: 'application/json',
                            encode: (msg, options)=>{
                                if (options.charset !== 'utf-8') {
                                    throw new Error(`In a Browser environments only utf-8 text encoding is supported. But got encoding: ${options.charset}`);
                                }
                                return Promise.resolve(_textEncoder.encode(JSON.stringify(msg, undefined, 0)));
                            }
                        }),
                        decoder: Object.freeze({
                            name: 'application/json',
                            decode: (buffer, options)=>{
                                if (!(buffer instanceof Uint8Array)) {
                                    throw new Error(`In a Browser environments only Uint8Arrays are supported.`);
                                }
                                return Promise.resolve(JSON.parse(new TextDecoder(options.charset).decode(buffer)));
                            }
                        })
                    }),
                    stream: Object.freeze({
                        asReadableStream: (socket)=>new ReadableStreamWrapper(socket),
                        asWritableStream: (socket)=>new WritableStreamWrapper(socket)
                    }),
                    console: console,
                    timer: Object.freeze({
                        setTimeout (callback, ms, ...args) {
                            const handle = setTimeout(callback, ms, ...args);
                            return {
                                dispose: ()=>clearTimeout(handle)
                            };
                        },
                        setImmediate (callback, ...args) {
                            const handle = setTimeout(callback, 0, ...args);
                            return {
                                dispose: ()=>clearTimeout(handle)
                            };
                        },
                        setInterval (callback, ms, ...args) {
                            const handle = setInterval(callback, ms, ...args);
                            return {
                                dispose: ()=>clearInterval(handle)
                            };
                        }
                    })
                });
                function RIL() {
                    return _ril;
                }
                (function(RIL) {
                    function install() {
                        ral_1.default.install(_ril);
                    }
                    RIL.install = install;
                })(RIL || (RIL = {}));
                exports1["default"] = RIL;
            //# sourceMappingURL=ril.js.map
            /***/ },
            /***/ 8969: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_708551__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ /// <reference path="../../typings/thenable.d.ts" />
                Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.TraceFormat = exports1.TraceValues = exports1.Trace = exports1.ProgressType = exports1.ProgressToken = exports1.createMessageConnection = exports1.NullLogger = exports1.ConnectionOptions = exports1.ConnectionStrategy = exports1.WriteableStreamMessageWriter = exports1.AbstractMessageWriter = exports1.MessageWriter = exports1.ReadableStreamMessageReader = exports1.AbstractMessageReader = exports1.MessageReader = exports1.CancellationToken = exports1.CancellationTokenSource = exports1.Emitter = exports1.Event = exports1.Disposable = exports1.LRUCache = exports1.Touch = exports1.LinkedMap = exports1.ParameterStructures = exports1.NotificationType9 = exports1.NotificationType8 = exports1.NotificationType7 = exports1.NotificationType6 = exports1.NotificationType5 = exports1.NotificationType4 = exports1.NotificationType3 = exports1.NotificationType2 = exports1.NotificationType1 = exports1.NotificationType0 = exports1.NotificationType = exports1.ErrorCodes = exports1.ResponseError = exports1.RequestType9 = exports1.RequestType8 = exports1.RequestType7 = exports1.RequestType6 = exports1.RequestType5 = exports1.RequestType4 = exports1.RequestType3 = exports1.RequestType2 = exports1.RequestType1 = exports1.RequestType0 = exports1.RequestType = exports1.Message = exports1.RAL = void 0;
                exports1.CancellationStrategy = exports1.CancellationSenderStrategy = exports1.CancellationReceiverStrategy = exports1.ConnectionError = exports1.ConnectionErrors = exports1.LogTraceNotification = exports1.SetTraceNotification = void 0;
                const messages_1 = __nested_webpack_require_708551__(4313);
                Object.defineProperty(exports1, "Message", {
                    enumerable: true,
                    get: function() {
                        return messages_1.Message;
                    }
                });
                Object.defineProperty(exports1, "RequestType", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType;
                    }
                });
                Object.defineProperty(exports1, "RequestType0", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType0;
                    }
                });
                Object.defineProperty(exports1, "RequestType1", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType1;
                    }
                });
                Object.defineProperty(exports1, "RequestType2", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType2;
                    }
                });
                Object.defineProperty(exports1, "RequestType3", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType3;
                    }
                });
                Object.defineProperty(exports1, "RequestType4", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType4;
                    }
                });
                Object.defineProperty(exports1, "RequestType5", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType5;
                    }
                });
                Object.defineProperty(exports1, "RequestType6", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType6;
                    }
                });
                Object.defineProperty(exports1, "RequestType7", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType7;
                    }
                });
                Object.defineProperty(exports1, "RequestType8", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType8;
                    }
                });
                Object.defineProperty(exports1, "RequestType9", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType9;
                    }
                });
                Object.defineProperty(exports1, "ResponseError", {
                    enumerable: true,
                    get: function() {
                        return messages_1.ResponseError;
                    }
                });
                Object.defineProperty(exports1, "ErrorCodes", {
                    enumerable: true,
                    get: function() {
                        return messages_1.ErrorCodes;
                    }
                });
                Object.defineProperty(exports1, "NotificationType", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType;
                    }
                });
                Object.defineProperty(exports1, "NotificationType0", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType0;
                    }
                });
                Object.defineProperty(exports1, "NotificationType1", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType1;
                    }
                });
                Object.defineProperty(exports1, "NotificationType2", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType2;
                    }
                });
                Object.defineProperty(exports1, "NotificationType3", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType3;
                    }
                });
                Object.defineProperty(exports1, "NotificationType4", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType4;
                    }
                });
                Object.defineProperty(exports1, "NotificationType5", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType5;
                    }
                });
                Object.defineProperty(exports1, "NotificationType6", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType6;
                    }
                });
                Object.defineProperty(exports1, "NotificationType7", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType7;
                    }
                });
                Object.defineProperty(exports1, "NotificationType8", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType8;
                    }
                });
                Object.defineProperty(exports1, "NotificationType9", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType9;
                    }
                });
                Object.defineProperty(exports1, "ParameterStructures", {
                    enumerable: true,
                    get: function() {
                        return messages_1.ParameterStructures;
                    }
                });
                const linkedMap_1 = __nested_webpack_require_708551__(6176);
                Object.defineProperty(exports1, "LinkedMap", {
                    enumerable: true,
                    get: function() {
                        return linkedMap_1.LinkedMap;
                    }
                });
                Object.defineProperty(exports1, "LRUCache", {
                    enumerable: true,
                    get: function() {
                        return linkedMap_1.LRUCache;
                    }
                });
                Object.defineProperty(exports1, "Touch", {
                    enumerable: true,
                    get: function() {
                        return linkedMap_1.Touch;
                    }
                });
                const disposable_1 = __nested_webpack_require_708551__(7963);
                Object.defineProperty(exports1, "Disposable", {
                    enumerable: true,
                    get: function() {
                        return disposable_1.Disposable;
                    }
                });
                const events_1 = __nested_webpack_require_708551__(6780);
                Object.defineProperty(exports1, "Event", {
                    enumerable: true,
                    get: function() {
                        return events_1.Event;
                    }
                });
                Object.defineProperty(exports1, "Emitter", {
                    enumerable: true,
                    get: function() {
                        return events_1.Emitter;
                    }
                });
                const cancellation_1 = __nested_webpack_require_708551__(3106);
                Object.defineProperty(exports1, "CancellationTokenSource", {
                    enumerable: true,
                    get: function() {
                        return cancellation_1.CancellationTokenSource;
                    }
                });
                Object.defineProperty(exports1, "CancellationToken", {
                    enumerable: true,
                    get: function() {
                        return cancellation_1.CancellationToken;
                    }
                });
                const messageReader_1 = __nested_webpack_require_708551__(9813);
                Object.defineProperty(exports1, "MessageReader", {
                    enumerable: true,
                    get: function() {
                        return messageReader_1.MessageReader;
                    }
                });
                Object.defineProperty(exports1, "AbstractMessageReader", {
                    enumerable: true,
                    get: function() {
                        return messageReader_1.AbstractMessageReader;
                    }
                });
                Object.defineProperty(exports1, "ReadableStreamMessageReader", {
                    enumerable: true,
                    get: function() {
                        return messageReader_1.ReadableStreamMessageReader;
                    }
                });
                const messageWriter_1 = __nested_webpack_require_708551__(7745);
                Object.defineProperty(exports1, "MessageWriter", {
                    enumerable: true,
                    get: function() {
                        return messageWriter_1.MessageWriter;
                    }
                });
                Object.defineProperty(exports1, "AbstractMessageWriter", {
                    enumerable: true,
                    get: function() {
                        return messageWriter_1.AbstractMessageWriter;
                    }
                });
                Object.defineProperty(exports1, "WriteableStreamMessageWriter", {
                    enumerable: true,
                    get: function() {
                        return messageWriter_1.WriteableStreamMessageWriter;
                    }
                });
                const connection_1 = __nested_webpack_require_708551__(4630);
                Object.defineProperty(exports1, "ConnectionStrategy", {
                    enumerable: true,
                    get: function() {
                        return connection_1.ConnectionStrategy;
                    }
                });
                Object.defineProperty(exports1, "ConnectionOptions", {
                    enumerable: true,
                    get: function() {
                        return connection_1.ConnectionOptions;
                    }
                });
                Object.defineProperty(exports1, "NullLogger", {
                    enumerable: true,
                    get: function() {
                        return connection_1.NullLogger;
                    }
                });
                Object.defineProperty(exports1, "createMessageConnection", {
                    enumerable: true,
                    get: function() {
                        return connection_1.createMessageConnection;
                    }
                });
                Object.defineProperty(exports1, "ProgressToken", {
                    enumerable: true,
                    get: function() {
                        return connection_1.ProgressToken;
                    }
                });
                Object.defineProperty(exports1, "ProgressType", {
                    enumerable: true,
                    get: function() {
                        return connection_1.ProgressType;
                    }
                });
                Object.defineProperty(exports1, "Trace", {
                    enumerable: true,
                    get: function() {
                        return connection_1.Trace;
                    }
                });
                Object.defineProperty(exports1, "TraceValues", {
                    enumerable: true,
                    get: function() {
                        return connection_1.TraceValues;
                    }
                });
                Object.defineProperty(exports1, "TraceFormat", {
                    enumerable: true,
                    get: function() {
                        return connection_1.TraceFormat;
                    }
                });
                Object.defineProperty(exports1, "SetTraceNotification", {
                    enumerable: true,
                    get: function() {
                        return connection_1.SetTraceNotification;
                    }
                });
                Object.defineProperty(exports1, "LogTraceNotification", {
                    enumerable: true,
                    get: function() {
                        return connection_1.LogTraceNotification;
                    }
                });
                Object.defineProperty(exports1, "ConnectionErrors", {
                    enumerable: true,
                    get: function() {
                        return connection_1.ConnectionErrors;
                    }
                });
                Object.defineProperty(exports1, "ConnectionError", {
                    enumerable: true,
                    get: function() {
                        return connection_1.ConnectionError;
                    }
                });
                Object.defineProperty(exports1, "CancellationReceiverStrategy", {
                    enumerable: true,
                    get: function() {
                        return connection_1.CancellationReceiverStrategy;
                    }
                });
                Object.defineProperty(exports1, "CancellationSenderStrategy", {
                    enumerable: true,
                    get: function() {
                        return connection_1.CancellationSenderStrategy;
                    }
                });
                Object.defineProperty(exports1, "CancellationStrategy", {
                    enumerable: true,
                    get: function() {
                        return connection_1.CancellationStrategy;
                    }
                });
                const ral_1 = __nested_webpack_require_708551__(4254);
                exports1.RAL = ral_1.default;
            //# sourceMappingURL=api.js.map
            /***/ },
            /***/ 3106: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_725303__)=>{
                "use strict";
                /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.CancellationTokenSource = exports1.CancellationToken = void 0;
                const ral_1 = __nested_webpack_require_725303__(4254);
                const Is = __nested_webpack_require_725303__(6145);
                const events_1 = __nested_webpack_require_725303__(6780);
                var CancellationToken;
                (function(CancellationToken) {
                    CancellationToken.None = Object.freeze({
                        isCancellationRequested: false,
                        onCancellationRequested: events_1.Event.None
                    });
                    CancellationToken.Cancelled = Object.freeze({
                        isCancellationRequested: true,
                        onCancellationRequested: events_1.Event.None
                    });
                    function is(value) {
                        const candidate = value;
                        return candidate && (candidate === CancellationToken.None || candidate === CancellationToken.Cancelled || Is.boolean(candidate.isCancellationRequested) && !!candidate.onCancellationRequested);
                    }
                    CancellationToken.is = is;
                })(CancellationToken = exports1.CancellationToken || (exports1.CancellationToken = {}));
                const shortcutEvent = Object.freeze(function(callback, context) {
                    const handle = (0, ral_1.default)().timer.setTimeout(callback.bind(context), 0);
                    return {
                        dispose () {
                            handle.dispose();
                        }
                    };
                });
                class MutableToken {
                    cancel() {
                        if (!this._isCancelled) {
                            this._isCancelled = true;
                            if (this._emitter) {
                                this._emitter.fire(undefined);
                                this.dispose();
                            }
                        }
                    }
                    get isCancellationRequested() {
                        return this._isCancelled;
                    }
                    get onCancellationRequested() {
                        if (this._isCancelled) {
                            return shortcutEvent;
                        }
                        if (!this._emitter) {
                            this._emitter = new events_1.Emitter();
                        }
                        return this._emitter.event;
                    }
                    dispose() {
                        if (this._emitter) {
                            this._emitter.dispose();
                            this._emitter = undefined;
                        }
                    }
                    constructor(){
                        this._isCancelled = false;
                    }
                }
                class CancellationTokenSource {
                    get token() {
                        if (!this._token) {
                            // be lazy and create the token only when
                            // actually needed
                            this._token = new MutableToken();
                        }
                        return this._token;
                    }
                    cancel() {
                        if (!this._token) {
                            // save an object by returning the default
                            // cancelled token when cancellation happens
                            // before someone asks for the token
                            this._token = CancellationToken.Cancelled;
                        } else {
                            this._token.cancel();
                        }
                    }
                    dispose() {
                        if (!this._token) {
                            // ensure to initialize with an empty token if we had none
                            this._token = CancellationToken.None;
                        } else if (this._token instanceof MutableToken) {
                            // actually dispose
                            this._token.dispose();
                        }
                    }
                }
                exports1.CancellationTokenSource = CancellationTokenSource;
            //# sourceMappingURL=cancellation.js.map
            /***/ },
            /***/ 4630: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_730290__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.createMessageConnection = exports1.ConnectionOptions = exports1.CancellationStrategy = exports1.CancellationSenderStrategy = exports1.CancellationReceiverStrategy = exports1.ConnectionStrategy = exports1.ConnectionError = exports1.ConnectionErrors = exports1.LogTraceNotification = exports1.SetTraceNotification = exports1.TraceFormat = exports1.TraceValues = exports1.Trace = exports1.NullLogger = exports1.ProgressType = exports1.ProgressToken = void 0;
                const ral_1 = __nested_webpack_require_730290__(4254);
                const Is = __nested_webpack_require_730290__(6145);
                const messages_1 = __nested_webpack_require_730290__(4313);
                const linkedMap_1 = __nested_webpack_require_730290__(6176);
                const events_1 = __nested_webpack_require_730290__(6780);
                const cancellation_1 = __nested_webpack_require_730290__(3106);
                var CancelNotification;
                (function(CancelNotification) {
                    CancelNotification.type = new messages_1.NotificationType('$/cancelRequest');
                })(CancelNotification || (CancelNotification = {}));
                var ProgressToken;
                (function(ProgressToken) {
                    function is(value) {
                        return typeof value === 'string' || typeof value === 'number';
                    }
                    ProgressToken.is = is;
                })(ProgressToken = exports1.ProgressToken || (exports1.ProgressToken = {}));
                var ProgressNotification;
                (function(ProgressNotification) {
                    ProgressNotification.type = new messages_1.NotificationType('$/progress');
                })(ProgressNotification || (ProgressNotification = {}));
                class ProgressType {
                    constructor(){}
                }
                exports1.ProgressType = ProgressType;
                var StarRequestHandler;
                (function(StarRequestHandler) {
                    function is(value) {
                        return Is.func(value);
                    }
                    StarRequestHandler.is = is;
                })(StarRequestHandler || (StarRequestHandler = {}));
                exports1.NullLogger = Object.freeze({
                    error: ()=>{},
                    warn: ()=>{},
                    info: ()=>{},
                    log: ()=>{}
                });
                var Trace;
                (function(Trace) {
                    Trace[Trace["Off"] = 0] = "Off";
                    Trace[Trace["Messages"] = 1] = "Messages";
                    Trace[Trace["Compact"] = 2] = "Compact";
                    Trace[Trace["Verbose"] = 3] = "Verbose";
                })(Trace = exports1.Trace || (exports1.Trace = {}));
                var TraceValues;
                (function(TraceValues) {
                    /**
     * Turn tracing off.
     */ TraceValues.Off = 'off';
                    /**
     * Trace messages only.
     */ TraceValues.Messages = 'messages';
                    /**
     * Compact message tracing.
     */ TraceValues.Compact = 'compact';
                    /**
     * Verbose message tracing.
     */ TraceValues.Verbose = 'verbose';
                })(TraceValues = exports1.TraceValues || (exports1.TraceValues = {}));
                (function(Trace) {
                    function fromString(value) {
                        if (!Is.string(value)) {
                            return Trace.Off;
                        }
                        value = value.toLowerCase();
                        switch(value){
                            case 'off':
                                return Trace.Off;
                            case 'messages':
                                return Trace.Messages;
                            case 'compact':
                                return Trace.Compact;
                            case 'verbose':
                                return Trace.Verbose;
                            default:
                                return Trace.Off;
                        }
                    }
                    Trace.fromString = fromString;
                    function toString(value) {
                        switch(value){
                            case Trace.Off:
                                return 'off';
                            case Trace.Messages:
                                return 'messages';
                            case Trace.Compact:
                                return 'compact';
                            case Trace.Verbose:
                                return 'verbose';
                            default:
                                return 'off';
                        }
                    }
                    Trace.toString = toString;
                })(Trace = exports1.Trace || (exports1.Trace = {}));
                var TraceFormat;
                (function(TraceFormat) {
                    TraceFormat["Text"] = "text";
                    TraceFormat["JSON"] = "json";
                })(TraceFormat = exports1.TraceFormat || (exports1.TraceFormat = {}));
                (function(TraceFormat) {
                    function fromString(value) {
                        if (!Is.string(value)) {
                            return TraceFormat.Text;
                        }
                        value = value.toLowerCase();
                        if (value === 'json') {
                            return TraceFormat.JSON;
                        } else {
                            return TraceFormat.Text;
                        }
                    }
                    TraceFormat.fromString = fromString;
                })(TraceFormat = exports1.TraceFormat || (exports1.TraceFormat = {}));
                var SetTraceNotification;
                (function(SetTraceNotification) {
                    SetTraceNotification.type = new messages_1.NotificationType('$/setTrace');
                })(SetTraceNotification = exports1.SetTraceNotification || (exports1.SetTraceNotification = {}));
                var LogTraceNotification;
                (function(LogTraceNotification) {
                    LogTraceNotification.type = new messages_1.NotificationType('$/logTrace');
                })(LogTraceNotification = exports1.LogTraceNotification || (exports1.LogTraceNotification = {}));
                var ConnectionErrors;
                (function(ConnectionErrors) {
                    /**
     * The connection is closed.
     */ ConnectionErrors[ConnectionErrors["Closed"] = 1] = "Closed";
                    /**
     * The connection got disposed.
     */ ConnectionErrors[ConnectionErrors["Disposed"] = 2] = "Disposed";
                    /**
     * The connection is already in listening mode.
     */ ConnectionErrors[ConnectionErrors["AlreadyListening"] = 3] = "AlreadyListening";
                })(ConnectionErrors = exports1.ConnectionErrors || (exports1.ConnectionErrors = {}));
                class ConnectionError extends Error {
                    constructor(code, message){
                        super(message);
                        this.code = code;
                        Object.setPrototypeOf(this, ConnectionError.prototype);
                    }
                }
                exports1.ConnectionError = ConnectionError;
                var ConnectionStrategy;
                (function(ConnectionStrategy) {
                    function is(value) {
                        const candidate = value;
                        return candidate && Is.func(candidate.cancelUndispatched);
                    }
                    ConnectionStrategy.is = is;
                })(ConnectionStrategy = exports1.ConnectionStrategy || (exports1.ConnectionStrategy = {}));
                var CancellationReceiverStrategy;
                (function(CancellationReceiverStrategy) {
                    CancellationReceiverStrategy.Message = Object.freeze({
                        createCancellationTokenSource (_) {
                            return new cancellation_1.CancellationTokenSource();
                        }
                    });
                    function is(value) {
                        const candidate = value;
                        return candidate && Is.func(candidate.createCancellationTokenSource);
                    }
                    CancellationReceiverStrategy.is = is;
                })(CancellationReceiverStrategy = exports1.CancellationReceiverStrategy || (exports1.CancellationReceiverStrategy = {}));
                var CancellationSenderStrategy;
                (function(CancellationSenderStrategy) {
                    CancellationSenderStrategy.Message = Object.freeze({
                        sendCancellation (conn, id) {
                            return conn.sendNotification(CancelNotification.type, {
                                id
                            });
                        },
                        cleanup (_) {}
                    });
                    function is(value) {
                        const candidate = value;
                        return candidate && Is.func(candidate.sendCancellation) && Is.func(candidate.cleanup);
                    }
                    CancellationSenderStrategy.is = is;
                })(CancellationSenderStrategy = exports1.CancellationSenderStrategy || (exports1.CancellationSenderStrategy = {}));
                var CancellationStrategy;
                (function(CancellationStrategy) {
                    CancellationStrategy.Message = Object.freeze({
                        receiver: CancellationReceiverStrategy.Message,
                        sender: CancellationSenderStrategy.Message
                    });
                    function is(value) {
                        const candidate = value;
                        return candidate && CancellationReceiverStrategy.is(candidate.receiver) && CancellationSenderStrategy.is(candidate.sender);
                    }
                    CancellationStrategy.is = is;
                })(CancellationStrategy = exports1.CancellationStrategy || (exports1.CancellationStrategy = {}));
                var ConnectionOptions;
                (function(ConnectionOptions) {
                    function is(value) {
                        const candidate = value;
                        return candidate && (CancellationStrategy.is(candidate.cancellationStrategy) || ConnectionStrategy.is(candidate.connectionStrategy));
                    }
                    ConnectionOptions.is = is;
                })(ConnectionOptions = exports1.ConnectionOptions || (exports1.ConnectionOptions = {}));
                var ConnectionState;
                (function(ConnectionState) {
                    ConnectionState[ConnectionState["New"] = 1] = "New";
                    ConnectionState[ConnectionState["Listening"] = 2] = "Listening";
                    ConnectionState[ConnectionState["Closed"] = 3] = "Closed";
                    ConnectionState[ConnectionState["Disposed"] = 4] = "Disposed";
                })(ConnectionState || (ConnectionState = {}));
                function createMessageConnection(messageReader, messageWriter, _logger, options) {
                    const logger = _logger !== undefined ? _logger : exports1.NullLogger;
                    let sequenceNumber = 0;
                    let notificationSequenceNumber = 0;
                    let unknownResponseSequenceNumber = 0;
                    const version = '2.0';
                    let starRequestHandler = undefined;
                    const requestHandlers = new Map();
                    let starNotificationHandler = undefined;
                    const notificationHandlers = new Map();
                    const progressHandlers = new Map();
                    let timer;
                    let messageQueue = new linkedMap_1.LinkedMap();
                    let responsePromises = new Map();
                    let knownCanceledRequests = new Set();
                    let requestTokens = new Map();
                    let trace = Trace.Off;
                    let traceFormat = TraceFormat.Text;
                    let tracer;
                    let state = ConnectionState.New;
                    const errorEmitter = new events_1.Emitter();
                    const closeEmitter = new events_1.Emitter();
                    const unhandledNotificationEmitter = new events_1.Emitter();
                    const unhandledProgressEmitter = new events_1.Emitter();
                    const disposeEmitter = new events_1.Emitter();
                    const cancellationStrategy = options && options.cancellationStrategy ? options.cancellationStrategy : CancellationStrategy.Message;
                    function createRequestQueueKey(id) {
                        if (id === null) {
                            throw new Error(`Can't send requests with id null since the response can't be correlated.`);
                        }
                        return 'req-' + id.toString();
                    }
                    function createResponseQueueKey(id) {
                        if (id === null) {
                            return 'res-unknown-' + (++unknownResponseSequenceNumber).toString();
                        } else {
                            return 'res-' + id.toString();
                        }
                    }
                    function createNotificationQueueKey() {
                        return 'not-' + (++notificationSequenceNumber).toString();
                    }
                    function addMessageToQueue(queue, message) {
                        if (messages_1.Message.isRequest(message)) {
                            queue.set(createRequestQueueKey(message.id), message);
                        } else if (messages_1.Message.isResponse(message)) {
                            queue.set(createResponseQueueKey(message.id), message);
                        } else {
                            queue.set(createNotificationQueueKey(), message);
                        }
                    }
                    function cancelUndispatched(_message) {
                        return undefined;
                    }
                    function isListening() {
                        return state === ConnectionState.Listening;
                    }
                    function isClosed() {
                        return state === ConnectionState.Closed;
                    }
                    function isDisposed() {
                        return state === ConnectionState.Disposed;
                    }
                    function closeHandler() {
                        if (state === ConnectionState.New || state === ConnectionState.Listening) {
                            state = ConnectionState.Closed;
                            closeEmitter.fire(undefined);
                        }
                    // If the connection is disposed don't sent close events.
                    }
                    function readErrorHandler(error) {
                        errorEmitter.fire([
                            error,
                            undefined,
                            undefined
                        ]);
                    }
                    function writeErrorHandler(data) {
                        errorEmitter.fire(data);
                    }
                    messageReader.onClose(closeHandler);
                    messageReader.onError(readErrorHandler);
                    messageWriter.onClose(closeHandler);
                    messageWriter.onError(writeErrorHandler);
                    function triggerMessageQueue() {
                        if (timer || messageQueue.size === 0) {
                            return;
                        }
                        timer = (0, ral_1.default)().timer.setImmediate(()=>{
                            timer = undefined;
                            processMessageQueue();
                        });
                    }
                    function processMessageQueue() {
                        if (messageQueue.size === 0) {
                            return;
                        }
                        const message = messageQueue.shift();
                        try {
                            if (messages_1.Message.isRequest(message)) {
                                handleRequest(message);
                            } else if (messages_1.Message.isNotification(message)) {
                                handleNotification(message);
                            } else if (messages_1.Message.isResponse(message)) {
                                handleResponse(message);
                            } else {
                                handleInvalidMessage(message);
                            }
                        } finally{
                            triggerMessageQueue();
                        }
                    }
                    const callback = (message)=>{
                        try {
                            // We have received a cancellation message. Check if the message is still in the queue
                            // and cancel it if allowed to do so.
                            if (messages_1.Message.isNotification(message) && message.method === CancelNotification.type.method) {
                                const cancelId = message.params.id;
                                const key = createRequestQueueKey(cancelId);
                                const toCancel = messageQueue.get(key);
                                if (messages_1.Message.isRequest(toCancel)) {
                                    var _options;
                                    const strategy = (_options = options) === null || _options === void 0 ? void 0 : _options.connectionStrategy;
                                    const response = strategy && strategy.cancelUndispatched ? strategy.cancelUndispatched(toCancel, cancelUndispatched) : cancelUndispatched(toCancel);
                                    if (response && (response.error !== undefined || response.result !== undefined)) {
                                        messageQueue.delete(key);
                                        requestTokens.delete(cancelId);
                                        response.id = toCancel.id;
                                        traceSendingResponse(response, message.method, Date.now());
                                        messageWriter.write(response).catch(()=>logger.error(`Sending response for canceled message failed.`));
                                        return;
                                    }
                                }
                                const cancellationToken = requestTokens.get(cancelId);
                                // The request is already running. Cancel the token
                                if (cancellationToken !== undefined) {
                                    cancellationToken.cancel();
                                    traceReceivedNotification(message);
                                    return;
                                } else {
                                    // Remember the cancel but still queue the message to
                                    // clean up state in process message.
                                    knownCanceledRequests.add(cancelId);
                                }
                            }
                            addMessageToQueue(messageQueue, message);
                        } finally{
                            triggerMessageQueue();
                        }
                    };
                    function handleRequest(requestMessage) {
                        if (isDisposed()) {
                            // we return here silently since we fired an event when the
                            // connection got disposed.
                            return;
                        }
                        function reply(resultOrError, method, startTime) {
                            const message = {
                                jsonrpc: version,
                                id: requestMessage.id
                            };
                            if (resultOrError instanceof messages_1.ResponseError) {
                                message.error = resultOrError.toJson();
                            } else {
                                message.result = resultOrError === undefined ? null : resultOrError;
                            }
                            traceSendingResponse(message, method, startTime);
                            messageWriter.write(message).catch(()=>logger.error(`Sending response failed.`));
                        }
                        function replyError(error, method, startTime) {
                            const message = {
                                jsonrpc: version,
                                id: requestMessage.id,
                                error: error.toJson()
                            };
                            traceSendingResponse(message, method, startTime);
                            messageWriter.write(message).catch(()=>logger.error(`Sending response failed.`));
                        }
                        function replySuccess(result, method, startTime) {
                            // The JSON RPC defines that a response must either have a result or an error
                            // So we can't treat undefined as a valid response result.
                            if (result === undefined) {
                                result = null;
                            }
                            const message = {
                                jsonrpc: version,
                                id: requestMessage.id,
                                result: result
                            };
                            traceSendingResponse(message, method, startTime);
                            messageWriter.write(message).catch(()=>logger.error(`Sending response failed.`));
                        }
                        traceReceivedRequest(requestMessage);
                        const element = requestHandlers.get(requestMessage.method);
                        let type;
                        let requestHandler;
                        if (element) {
                            type = element.type;
                            requestHandler = element.handler;
                        }
                        const startTime = Date.now();
                        if (requestHandler || starRequestHandler) {
                            var _requestMessage_id;
                            const tokenKey = (_requestMessage_id = requestMessage.id) !== null && _requestMessage_id !== void 0 ? _requestMessage_id : String(Date.now()); //
                            const cancellationSource = cancellationStrategy.receiver.createCancellationTokenSource(tokenKey);
                            if (requestMessage.id !== null && knownCanceledRequests.has(requestMessage.id)) {
                                cancellationSource.cancel();
                            }
                            if (requestMessage.id !== null) {
                                requestTokens.set(tokenKey, cancellationSource);
                            }
                            try {
                                let handlerResult;
                                if (requestHandler) {
                                    if (requestMessage.params === undefined) {
                                        if (type !== undefined && type.numberOfParams !== 0) {
                                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines ${type.numberOfParams} params but received none.`), requestMessage.method, startTime);
                                            return;
                                        }
                                        handlerResult = requestHandler(cancellationSource.token);
                                    } else if (Array.isArray(requestMessage.params)) {
                                        if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byName) {
                                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by name but received parameters by position`), requestMessage.method, startTime);
                                            return;
                                        }
                                        handlerResult = requestHandler(...requestMessage.params, cancellationSource.token);
                                    } else {
                                        if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by position but received parameters by name`), requestMessage.method, startTime);
                                            return;
                                        }
                                        handlerResult = requestHandler(requestMessage.params, cancellationSource.token);
                                    }
                                } else if (starRequestHandler) {
                                    handlerResult = starRequestHandler(requestMessage.method, requestMessage.params, cancellationSource.token);
                                }
                                const promise = handlerResult;
                                if (!handlerResult) {
                                    requestTokens.delete(tokenKey);
                                    replySuccess(handlerResult, requestMessage.method, startTime);
                                } else if (promise.then) {
                                    promise.then((resultOrError)=>{
                                        requestTokens.delete(tokenKey);
                                        reply(resultOrError, requestMessage.method, startTime);
                                    }, (error)=>{
                                        requestTokens.delete(tokenKey);
                                        if (error instanceof messages_1.ResponseError) {
                                            replyError(error, requestMessage.method, startTime);
                                        } else if (error && Is.string(error.message)) {
                                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
                                        } else {
                                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
                                        }
                                    });
                                } else {
                                    requestTokens.delete(tokenKey);
                                    reply(handlerResult, requestMessage.method, startTime);
                                }
                            } catch (error) {
                                requestTokens.delete(tokenKey);
                                if (error instanceof messages_1.ResponseError) {
                                    reply(error, requestMessage.method, startTime);
                                } else if (error && Is.string(error.message)) {
                                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
                                } else {
                                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
                                }
                            }
                        } else {
                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.MethodNotFound, `Unhandled method ${requestMessage.method}`), requestMessage.method, startTime);
                        }
                    }
                    function handleResponse(responseMessage) {
                        if (isDisposed()) {
                            // See handle request.
                            return;
                        }
                        if (responseMessage.id === null) {
                            if (responseMessage.error) {
                                logger.error(`Received response message without id: Error is: \n${JSON.stringify(responseMessage.error, undefined, 4)}`);
                            } else {
                                logger.error(`Received response message without id. No further error information provided.`);
                            }
                        } else {
                            const key = responseMessage.id;
                            const responsePromise = responsePromises.get(key);
                            traceReceivedResponse(responseMessage, responsePromise);
                            if (responsePromise !== undefined) {
                                responsePromises.delete(key);
                                try {
                                    if (responseMessage.error) {
                                        const error = responseMessage.error;
                                        responsePromise.reject(new messages_1.ResponseError(error.code, error.message, error.data));
                                    } else if (responseMessage.result !== undefined) {
                                        responsePromise.resolve(responseMessage.result);
                                    } else {
                                        throw new Error('Should never happen.');
                                    }
                                } catch (error) {
                                    if (error.message) {
                                        logger.error(`Response handler '${responsePromise.method}' failed with message: ${error.message}`);
                                    } else {
                                        logger.error(`Response handler '${responsePromise.method}' failed unexpectedly.`);
                                    }
                                }
                            }
                        }
                    }
                    function handleNotification(message) {
                        if (isDisposed()) {
                            // See handle request.
                            return;
                        }
                        let type = undefined;
                        let notificationHandler;
                        if (message.method === CancelNotification.type.method) {
                            const cancelId = message.params.id;
                            knownCanceledRequests.delete(cancelId);
                            traceReceivedNotification(message);
                            return;
                        } else {
                            const element = notificationHandlers.get(message.method);
                            if (element) {
                                notificationHandler = element.handler;
                                type = element.type;
                            }
                        }
                        if (notificationHandler || starNotificationHandler) {
                            try {
                                traceReceivedNotification(message);
                                if (notificationHandler) {
                                    if (message.params === undefined) {
                                        if (type !== undefined) {
                                            if (type.numberOfParams !== 0 && type.parameterStructures !== messages_1.ParameterStructures.byName) {
                                                logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received none.`);
                                            }
                                        }
                                        notificationHandler();
                                    } else if (Array.isArray(message.params)) {
                                        // There are JSON-RPC libraries that send progress message as positional params although
                                        // specified as named. So convert them if this is the case.
                                        const params = message.params;
                                        if (message.method === ProgressNotification.type.method && params.length === 2 && ProgressToken.is(params[0])) {
                                            notificationHandler({
                                                token: params[0],
                                                value: params[1]
                                            });
                                        } else {
                                            if (type !== undefined) {
                                                if (type.parameterStructures === messages_1.ParameterStructures.byName) {
                                                    logger.error(`Notification ${message.method} defines parameters by name but received parameters by position`);
                                                }
                                                if (type.numberOfParams !== message.params.length) {
                                                    logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received ${params.length} arguments`);
                                                }
                                            }
                                            notificationHandler(...params);
                                        }
                                    } else {
                                        if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                                            logger.error(`Notification ${message.method} defines parameters by position but received parameters by name`);
                                        }
                                        notificationHandler(message.params);
                                    }
                                } else if (starNotificationHandler) {
                                    starNotificationHandler(message.method, message.params);
                                }
                            } catch (error) {
                                if (error.message) {
                                    logger.error(`Notification handler '${message.method}' failed with message: ${error.message}`);
                                } else {
                                    logger.error(`Notification handler '${message.method}' failed unexpectedly.`);
                                }
                            }
                        } else {
                            unhandledNotificationEmitter.fire(message);
                        }
                    }
                    function handleInvalidMessage(message) {
                        if (!message) {
                            logger.error('Received empty message.');
                            return;
                        }
                        logger.error(`Received message which is neither a response nor a notification message:\n${JSON.stringify(message, null, 4)}`);
                        // Test whether we find an id to reject the promise
                        const responseMessage = message;
                        if (Is.string(responseMessage.id) || Is.number(responseMessage.id)) {
                            const key = responseMessage.id;
                            const responseHandler = responsePromises.get(key);
                            if (responseHandler) {
                                responseHandler.reject(new Error('The received response has neither a result nor an error property.'));
                            }
                        }
                    }
                    function stringifyTrace(params) {
                        if (params === undefined || params === null) {
                            return undefined;
                        }
                        switch(trace){
                            case Trace.Verbose:
                                return JSON.stringify(params, null, 4);
                            case Trace.Compact:
                                return JSON.stringify(params);
                            default:
                                return undefined;
                        }
                    }
                    function traceSendingRequest(message) {
                        if (trace === Trace.Off || !tracer) {
                            return;
                        }
                        if (traceFormat === TraceFormat.Text) {
                            let data = undefined;
                            if ((trace === Trace.Verbose || trace === Trace.Compact) && message.params) {
                                data = `Params: ${stringifyTrace(message.params)}\n\n`;
                            }
                            tracer.log(`Sending request '${message.method} - (${message.id})'.`, data);
                        } else {
                            logLSPMessage('send-request', message);
                        }
                    }
                    function traceSendingNotification(message) {
                        if (trace === Trace.Off || !tracer) {
                            return;
                        }
                        if (traceFormat === TraceFormat.Text) {
                            let data = undefined;
                            if (trace === Trace.Verbose || trace === Trace.Compact) {
                                if (message.params) {
                                    data = `Params: ${stringifyTrace(message.params)}\n\n`;
                                } else {
                                    data = 'No parameters provided.\n\n';
                                }
                            }
                            tracer.log(`Sending notification '${message.method}'.`, data);
                        } else {
                            logLSPMessage('send-notification', message);
                        }
                    }
                    function traceSendingResponse(message, method, startTime) {
                        if (trace === Trace.Off || !tracer) {
                            return;
                        }
                        if (traceFormat === TraceFormat.Text) {
                            let data = undefined;
                            if (trace === Trace.Verbose || trace === Trace.Compact) {
                                if (message.error && message.error.data) {
                                    data = `Error data: ${stringifyTrace(message.error.data)}\n\n`;
                                } else {
                                    if (message.result) {
                                        data = `Result: ${stringifyTrace(message.result)}\n\n`;
                                    } else if (message.error === undefined) {
                                        data = 'No result returned.\n\n';
                                    }
                                }
                            }
                            tracer.log(`Sending response '${method} - (${message.id})'. Processing request took ${Date.now() - startTime}ms`, data);
                        } else {
                            logLSPMessage('send-response', message);
                        }
                    }
                    function traceReceivedRequest(message) {
                        if (trace === Trace.Off || !tracer) {
                            return;
                        }
                        if (traceFormat === TraceFormat.Text) {
                            let data = undefined;
                            if ((trace === Trace.Verbose || trace === Trace.Compact) && message.params) {
                                data = `Params: ${stringifyTrace(message.params)}\n\n`;
                            }
                            tracer.log(`Received request '${message.method} - (${message.id})'.`, data);
                        } else {
                            logLSPMessage('receive-request', message);
                        }
                    }
                    function traceReceivedNotification(message) {
                        if (trace === Trace.Off || !tracer || message.method === LogTraceNotification.type.method) {
                            return;
                        }
                        if (traceFormat === TraceFormat.Text) {
                            let data = undefined;
                            if (trace === Trace.Verbose || trace === Trace.Compact) {
                                if (message.params) {
                                    data = `Params: ${stringifyTrace(message.params)}\n\n`;
                                } else {
                                    data = 'No parameters provided.\n\n';
                                }
                            }
                            tracer.log(`Received notification '${message.method}'.`, data);
                        } else {
                            logLSPMessage('receive-notification', message);
                        }
                    }
                    function traceReceivedResponse(message, responsePromise) {
                        if (trace === Trace.Off || !tracer) {
                            return;
                        }
                        if (traceFormat === TraceFormat.Text) {
                            let data = undefined;
                            if (trace === Trace.Verbose || trace === Trace.Compact) {
                                if (message.error && message.error.data) {
                                    data = `Error data: ${stringifyTrace(message.error.data)}\n\n`;
                                } else {
                                    if (message.result) {
                                        data = `Result: ${stringifyTrace(message.result)}\n\n`;
                                    } else if (message.error === undefined) {
                                        data = 'No result returned.\n\n';
                                    }
                                }
                            }
                            if (responsePromise) {
                                const error = message.error ? ` Request failed: ${message.error.message} (${message.error.code}).` : '';
                                tracer.log(`Received response '${responsePromise.method} - (${message.id})' in ${Date.now() - responsePromise.timerStart}ms.${error}`, data);
                            } else {
                                tracer.log(`Received response ${message.id} without active response promise.`, data);
                            }
                        } else {
                            logLSPMessage('receive-response', message);
                        }
                    }
                    function logLSPMessage(type, message) {
                        if (!tracer || trace === Trace.Off) {
                            return;
                        }
                        const lspMessage = {
                            isLSPMessage: true,
                            type,
                            message,
                            timestamp: Date.now()
                        };
                        tracer.log(lspMessage);
                    }
                    function throwIfClosedOrDisposed() {
                        if (isClosed()) {
                            throw new ConnectionError(ConnectionErrors.Closed, 'Connection is closed.');
                        }
                        if (isDisposed()) {
                            throw new ConnectionError(ConnectionErrors.Disposed, 'Connection is disposed.');
                        }
                    }
                    function throwIfListening() {
                        if (isListening()) {
                            throw new ConnectionError(ConnectionErrors.AlreadyListening, 'Connection is already listening');
                        }
                    }
                    function throwIfNotListening() {
                        if (!isListening()) {
                            throw new Error('Call listen() first.');
                        }
                    }
                    function undefinedToNull(param) {
                        if (param === undefined) {
                            return null;
                        } else {
                            return param;
                        }
                    }
                    function nullToUndefined(param) {
                        if (param === null) {
                            return undefined;
                        } else {
                            return param;
                        }
                    }
                    function isNamedParam(param) {
                        return param !== undefined && param !== null && !Array.isArray(param) && typeof param === 'object';
                    }
                    function computeSingleParam(parameterStructures, param) {
                        switch(parameterStructures){
                            case messages_1.ParameterStructures.auto:
                                if (isNamedParam(param)) {
                                    return nullToUndefined(param);
                                } else {
                                    return [
                                        undefinedToNull(param)
                                    ];
                                }
                            case messages_1.ParameterStructures.byName:
                                if (!isNamedParam(param)) {
                                    throw new Error(`Received parameters by name but param is not an object literal.`);
                                }
                                return nullToUndefined(param);
                            case messages_1.ParameterStructures.byPosition:
                                return [
                                    undefinedToNull(param)
                                ];
                            default:
                                throw new Error(`Unknown parameter structure ${parameterStructures.toString()}`);
                        }
                    }
                    function computeMessageParams(type, params) {
                        let result;
                        const numberOfParams = type.numberOfParams;
                        switch(numberOfParams){
                            case 0:
                                result = undefined;
                                break;
                            case 1:
                                result = computeSingleParam(type.parameterStructures, params[0]);
                                break;
                            default:
                                result = [];
                                for(let i = 0; i < params.length && i < numberOfParams; i++){
                                    result.push(undefinedToNull(params[i]));
                                }
                                if (params.length < numberOfParams) {
                                    for(let i = params.length; i < numberOfParams; i++){
                                        result.push(null);
                                    }
                                }
                                break;
                        }
                        return result;
                    }
                    const connection = {
                        sendNotification: (type, ...args)=>{
                            throwIfClosedOrDisposed();
                            let method;
                            let messageParams;
                            if (Is.string(type)) {
                                method = type;
                                const first = args[0];
                                let paramStart = 0;
                                let parameterStructures = messages_1.ParameterStructures.auto;
                                if (messages_1.ParameterStructures.is(first)) {
                                    paramStart = 1;
                                    parameterStructures = first;
                                }
                                let paramEnd = args.length;
                                const numberOfParams = paramEnd - paramStart;
                                switch(numberOfParams){
                                    case 0:
                                        messageParams = undefined;
                                        break;
                                    case 1:
                                        messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                                        break;
                                    default:
                                        if (parameterStructures === messages_1.ParameterStructures.byName) {
                                            throw new Error(`Received ${numberOfParams} parameters for 'by Name' notification parameter structure.`);
                                        }
                                        messageParams = args.slice(paramStart, paramEnd).map((value)=>undefinedToNull(value));
                                        break;
                                }
                            } else {
                                const params = args;
                                method = type.method;
                                messageParams = computeMessageParams(type, params);
                            }
                            const notificationMessage = {
                                jsonrpc: version,
                                method: method,
                                params: messageParams
                            };
                            traceSendingNotification(notificationMessage);
                            return messageWriter.write(notificationMessage).catch(()=>logger.error(`Sending notification failed.`));
                        },
                        onNotification: (type, handler)=>{
                            throwIfClosedOrDisposed();
                            let method;
                            if (Is.func(type)) {
                                starNotificationHandler = type;
                            } else if (handler) {
                                if (Is.string(type)) {
                                    method = type;
                                    notificationHandlers.set(type, {
                                        type: undefined,
                                        handler
                                    });
                                } else {
                                    method = type.method;
                                    notificationHandlers.set(type.method, {
                                        type,
                                        handler
                                    });
                                }
                            }
                            return {
                                dispose: ()=>{
                                    if (method !== undefined) {
                                        notificationHandlers.delete(method);
                                    } else {
                                        starNotificationHandler = undefined;
                                    }
                                }
                            };
                        },
                        onProgress: (_type, token, handler)=>{
                            if (progressHandlers.has(token)) {
                                throw new Error(`Progress handler for token ${token} already registered`);
                            }
                            progressHandlers.set(token, handler);
                            return {
                                dispose: ()=>{
                                    progressHandlers.delete(token);
                                }
                            };
                        },
                        sendProgress: (_type, token, value)=>{
                            return connection.sendNotification(ProgressNotification.type, {
                                token,
                                value
                            });
                        },
                        onUnhandledProgress: unhandledProgressEmitter.event,
                        sendRequest: (type, ...args)=>{
                            throwIfClosedOrDisposed();
                            throwIfNotListening();
                            let method;
                            let messageParams;
                            let token = undefined;
                            if (Is.string(type)) {
                                method = type;
                                const first = args[0];
                                const last = args[args.length - 1];
                                let paramStart = 0;
                                let parameterStructures = messages_1.ParameterStructures.auto;
                                if (messages_1.ParameterStructures.is(first)) {
                                    paramStart = 1;
                                    parameterStructures = first;
                                }
                                let paramEnd = args.length;
                                if (cancellation_1.CancellationToken.is(last)) {
                                    paramEnd = paramEnd - 1;
                                    token = last;
                                }
                                const numberOfParams = paramEnd - paramStart;
                                switch(numberOfParams){
                                    case 0:
                                        messageParams = undefined;
                                        break;
                                    case 1:
                                        messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                                        break;
                                    default:
                                        if (parameterStructures === messages_1.ParameterStructures.byName) {
                                            throw new Error(`Received ${numberOfParams} parameters for 'by Name' request parameter structure.`);
                                        }
                                        messageParams = args.slice(paramStart, paramEnd).map((value)=>undefinedToNull(value));
                                        break;
                                }
                            } else {
                                const params = args;
                                method = type.method;
                                messageParams = computeMessageParams(type, params);
                                const numberOfParams = type.numberOfParams;
                                token = cancellation_1.CancellationToken.is(params[numberOfParams]) ? params[numberOfParams] : undefined;
                            }
                            const id = sequenceNumber++;
                            let disposable;
                            if (token) {
                                disposable = token.onCancellationRequested(()=>{
                                    const p = cancellationStrategy.sender.sendCancellation(connection, id);
                                    if (p === undefined) {
                                        logger.log(`Received no promise from cancellation strategy when cancelling id ${id}`);
                                        return Promise.resolve();
                                    } else {
                                        return p.catch(()=>{
                                            logger.log(`Sending cancellation messages for id ${id} failed`);
                                        });
                                    }
                                });
                            }
                            const result = new Promise((resolve, reject)=>{
                                const requestMessage = {
                                    jsonrpc: version,
                                    id: id,
                                    method: method,
                                    params: messageParams
                                };
                                const resolveWithCleanup = (r)=>{
                                    var _disposable;
                                    resolve(r);
                                    cancellationStrategy.sender.cleanup(id);
                                    (_disposable = disposable) === null || _disposable === void 0 ? void 0 : _disposable.dispose();
                                };
                                const rejectWithCleanup = (r)=>{
                                    var _disposable;
                                    reject(r);
                                    cancellationStrategy.sender.cleanup(id);
                                    (_disposable = disposable) === null || _disposable === void 0 ? void 0 : _disposable.dispose();
                                };
                                let responsePromise = {
                                    method: method,
                                    timerStart: Date.now(),
                                    resolve: resolveWithCleanup,
                                    reject: rejectWithCleanup
                                };
                                traceSendingRequest(requestMessage);
                                try {
                                    messageWriter.write(requestMessage).catch(()=>logger.error(`Sending request failed.`));
                                } catch (e) {
                                    // Writing the message failed. So we need to reject the promise.
                                    responsePromise.reject(new messages_1.ResponseError(messages_1.ErrorCodes.MessageWriteError, e.message ? e.message : 'Unknown reason'));
                                    responsePromise = null;
                                }
                                if (responsePromise) {
                                    responsePromises.set(id, responsePromise);
                                }
                            });
                            return result;
                        },
                        onRequest: (type, handler)=>{
                            throwIfClosedOrDisposed();
                            let method = null;
                            if (StarRequestHandler.is(type)) {
                                method = undefined;
                                starRequestHandler = type;
                            } else if (Is.string(type)) {
                                method = null;
                                if (handler !== undefined) {
                                    method = type;
                                    requestHandlers.set(type, {
                                        handler: handler,
                                        type: undefined
                                    });
                                }
                            } else {
                                if (handler !== undefined) {
                                    method = type.method;
                                    requestHandlers.set(type.method, {
                                        type,
                                        handler
                                    });
                                }
                            }
                            return {
                                dispose: ()=>{
                                    if (method === null) {
                                        return;
                                    }
                                    if (method !== undefined) {
                                        requestHandlers.delete(method);
                                    } else {
                                        starRequestHandler = undefined;
                                    }
                                }
                            };
                        },
                        hasPendingResponse: ()=>{
                            return responsePromises.size > 0;
                        },
                        trace: async (_value, _tracer, sendNotificationOrTraceOptions)=>{
                            let _sendNotification = false;
                            let _traceFormat = TraceFormat.Text;
                            if (sendNotificationOrTraceOptions !== undefined) {
                                if (Is.boolean(sendNotificationOrTraceOptions)) {
                                    _sendNotification = sendNotificationOrTraceOptions;
                                } else {
                                    _sendNotification = sendNotificationOrTraceOptions.sendNotification || false;
                                    _traceFormat = sendNotificationOrTraceOptions.traceFormat || TraceFormat.Text;
                                }
                            }
                            trace = _value;
                            traceFormat = _traceFormat;
                            if (trace === Trace.Off) {
                                tracer = undefined;
                            } else {
                                tracer = _tracer;
                            }
                            if (_sendNotification && !isClosed() && !isDisposed()) {
                                await connection.sendNotification(SetTraceNotification.type, {
                                    value: Trace.toString(_value)
                                });
                            }
                        },
                        onError: errorEmitter.event,
                        onClose: closeEmitter.event,
                        onUnhandledNotification: unhandledNotificationEmitter.event,
                        onDispose: disposeEmitter.event,
                        end: ()=>{
                            messageWriter.end();
                        },
                        dispose: ()=>{
                            if (isDisposed()) {
                                return;
                            }
                            state = ConnectionState.Disposed;
                            disposeEmitter.fire(undefined);
                            const error = new messages_1.ResponseError(messages_1.ErrorCodes.PendingResponseRejected, 'Pending response rejected since connection got disposed');
                            for (const promise of responsePromises.values()){
                                promise.reject(error);
                            }
                            responsePromises = new Map();
                            requestTokens = new Map();
                            knownCanceledRequests = new Set();
                            messageQueue = new linkedMap_1.LinkedMap();
                            // Test for backwards compatibility
                            if (Is.func(messageWriter.dispose)) {
                                messageWriter.dispose();
                            }
                            if (Is.func(messageReader.dispose)) {
                                messageReader.dispose();
                            }
                        },
                        listen: ()=>{
                            throwIfClosedOrDisposed();
                            throwIfListening();
                            state = ConnectionState.Listening;
                            messageReader.listen(callback);
                        },
                        inspect: ()=>{
                            // eslint-disable-next-line no-console
                            (0, ral_1.default)().console.log('inspect');
                        }
                    };
                    connection.onNotification(LogTraceNotification.type, (params)=>{
                        if (trace === Trace.Off || !tracer) {
                            return;
                        }
                        const verbose = trace === Trace.Verbose || trace === Trace.Compact;
                        tracer.log(params.message, verbose ? params.verbose : undefined);
                    });
                    connection.onNotification(ProgressNotification.type, (params)=>{
                        const handler = progressHandlers.get(params.token);
                        if (handler) {
                            handler(params.value);
                        } else {
                            unhandledProgressEmitter.fire(params);
                        }
                    });
                    return connection;
                }
                exports1.createMessageConnection = createMessageConnection;
            //# sourceMappingURL=connection.js.map
            /***/ },
            /***/ 7963: /***/ (__unused_webpack_module, exports1)=>{
                "use strict";
                /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.Disposable = void 0;
                var Disposable;
                (function(Disposable) {
                    function create(func) {
                        return {
                            dispose: func
                        };
                    }
                    Disposable.create = create;
                })(Disposable = exports1.Disposable || (exports1.Disposable = {}));
            //# sourceMappingURL=disposable.js.map
            /***/ },
            /***/ 6780: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_798550__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.Emitter = exports1.Event = void 0;
                const ral_1 = __nested_webpack_require_798550__(4254);
                var Event1;
                (function(Event1) {
                    const _disposable = {
                        dispose () {}
                    };
                    Event1.None = function() {
                        return _disposable;
                    };
                })(Event1 = exports1.Event || (exports1.Event = {}));
                class CallbackList {
                    add(callback, context = null, bucket) {
                        if (!this._callbacks) {
                            this._callbacks = [];
                            this._contexts = [];
                        }
                        this._callbacks.push(callback);
                        this._contexts.push(context);
                        if (Array.isArray(bucket)) {
                            bucket.push({
                                dispose: ()=>this.remove(callback, context)
                            });
                        }
                    }
                    remove(callback, context = null) {
                        if (!this._callbacks) {
                            return;
                        }
                        let foundCallbackWithDifferentContext = false;
                        for(let i = 0, len = this._callbacks.length; i < len; i++){
                            if (this._callbacks[i] === callback) {
                                if (this._contexts[i] === context) {
                                    // callback & context match => remove it
                                    this._callbacks.splice(i, 1);
                                    this._contexts.splice(i, 1);
                                    return;
                                } else {
                                    foundCallbackWithDifferentContext = true;
                                }
                            }
                        }
                        if (foundCallbackWithDifferentContext) {
                            throw new Error('When adding a listener with a context, you should remove it with the same context');
                        }
                    }
                    invoke(...args) {
                        if (!this._callbacks) {
                            return [];
                        }
                        const ret = [], callbacks = this._callbacks.slice(0), contexts = this._contexts.slice(0);
                        for(let i = 0, len = callbacks.length; i < len; i++){
                            try {
                                ret.push(callbacks[i].apply(contexts[i], args));
                            } catch (e) {
                                // eslint-disable-next-line no-console
                                (0, ral_1.default)().console.error(e);
                            }
                        }
                        return ret;
                    }
                    isEmpty() {
                        return !this._callbacks || this._callbacks.length === 0;
                    }
                    dispose() {
                        this._callbacks = undefined;
                        this._contexts = undefined;
                    }
                }
                class Emitter {
                    /**
     * For the public to allow to subscribe
     * to events from this Emitter
     */ get event() {
                        if (!this._event) {
                            this._event = (listener, thisArgs, disposables)=>{
                                if (!this._callbacks) {
                                    this._callbacks = new CallbackList();
                                }
                                if (this._options && this._options.onFirstListenerAdd && this._callbacks.isEmpty()) {
                                    this._options.onFirstListenerAdd(this);
                                }
                                this._callbacks.add(listener, thisArgs);
                                const result = {
                                    dispose: ()=>{
                                        if (!this._callbacks) {
                                            // disposable is disposed after emitter is disposed.
                                            return;
                                        }
                                        this._callbacks.remove(listener, thisArgs);
                                        result.dispose = Emitter._noop;
                                        if (this._options && this._options.onLastListenerRemove && this._callbacks.isEmpty()) {
                                            this._options.onLastListenerRemove(this);
                                        }
                                    }
                                };
                                if (Array.isArray(disposables)) {
                                    disposables.push(result);
                                }
                                return result;
                            };
                        }
                        return this._event;
                    }
                    /**
     * To be kept private to fire an event to
     * subscribers
     */ fire(event) {
                        if (this._callbacks) {
                            this._callbacks.invoke.call(this._callbacks, event);
                        }
                    }
                    dispose() {
                        if (this._callbacks) {
                            this._callbacks.dispose();
                            this._callbacks = undefined;
                        }
                    }
                    constructor(_options){
                        this._options = _options;
                    }
                }
                exports1.Emitter = Emitter;
                Emitter._noop = function() {};
            //# sourceMappingURL=events.js.map
            /***/ },
            /***/ 6145: /***/ (__unused_webpack_module, exports1)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.stringArray = exports1.array = exports1.func = exports1.error = exports1.number = exports1.string = exports1.boolean = void 0;
                function boolean(value) {
                    return value === true || value === false;
                }
                exports1.boolean = boolean;
                function string(value) {
                    return typeof value === 'string' || value instanceof String;
                }
                exports1.string = string;
                function number(value) {
                    return typeof value === 'number' || value instanceof Number;
                }
                exports1.number = number;
                function error(value) {
                    return value instanceof Error;
                }
                exports1.error = error;
                function func(value) {
                    return typeof value === 'function';
                }
                exports1.func = func;
                function array(value) {
                    return Array.isArray(value);
                }
                exports1.array = array;
                function stringArray(value) {
                    return array(value) && value.every((elem)=>string(elem));
                }
                exports1.stringArray = stringArray;
            //# sourceMappingURL=is.js.map
            /***/ },
            /***/ 6176: /***/ (__unused_webpack_module, exports1)=>{
                "use strict";
                /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ var _a;
                Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.LRUCache = exports1.LinkedMap = exports1.Touch = void 0;
                var Touch;
                (function(Touch) {
                    Touch.None = 0;
                    Touch.First = 1;
                    Touch.AsOld = Touch.First;
                    Touch.Last = 2;
                    Touch.AsNew = Touch.Last;
                })(Touch = exports1.Touch || (exports1.Touch = {}));
                class LinkedMap {
                    clear() {
                        this._map.clear();
                        this._head = undefined;
                        this._tail = undefined;
                        this._size = 0;
                        this._state++;
                    }
                    isEmpty() {
                        return !this._head && !this._tail;
                    }
                    get size() {
                        return this._size;
                    }
                    get first() {
                        var _this__head;
                        return (_this__head = this._head) === null || _this__head === void 0 ? void 0 : _this__head.value;
                    }
                    get last() {
                        var _this__tail;
                        return (_this__tail = this._tail) === null || _this__tail === void 0 ? void 0 : _this__tail.value;
                    }
                    has(key) {
                        return this._map.has(key);
                    }
                    get(key, touch = Touch.None) {
                        const item = this._map.get(key);
                        if (!item) {
                            return undefined;
                        }
                        if (touch !== Touch.None) {
                            this.touch(item, touch);
                        }
                        return item.value;
                    }
                    set(key, value, touch = Touch.None) {
                        let item = this._map.get(key);
                        if (item) {
                            item.value = value;
                            if (touch !== Touch.None) {
                                this.touch(item, touch);
                            }
                        } else {
                            item = {
                                key,
                                value,
                                next: undefined,
                                previous: undefined
                            };
                            switch(touch){
                                case Touch.None:
                                    this.addItemLast(item);
                                    break;
                                case Touch.First:
                                    this.addItemFirst(item);
                                    break;
                                case Touch.Last:
                                    this.addItemLast(item);
                                    break;
                                default:
                                    this.addItemLast(item);
                                    break;
                            }
                            this._map.set(key, item);
                            this._size++;
                        }
                        return this;
                    }
                    delete(key) {
                        return !!this.remove(key);
                    }
                    remove(key) {
                        const item = this._map.get(key);
                        if (!item) {
                            return undefined;
                        }
                        this._map.delete(key);
                        this.removeItem(item);
                        this._size--;
                        return item.value;
                    }
                    shift() {
                        if (!this._head && !this._tail) {
                            return undefined;
                        }
                        if (!this._head || !this._tail) {
                            throw new Error('Invalid list');
                        }
                        const item = this._head;
                        this._map.delete(item.key);
                        this.removeItem(item);
                        this._size--;
                        return item.value;
                    }
                    forEach(callbackfn, thisArg) {
                        const state = this._state;
                        let current = this._head;
                        while(current){
                            if (thisArg) {
                                callbackfn.bind(thisArg)(current.value, current.key, this);
                            } else {
                                callbackfn(current.value, current.key, this);
                            }
                            if (this._state !== state) {
                                throw new Error(`LinkedMap got modified during iteration.`);
                            }
                            current = current.next;
                        }
                    }
                    keys() {
                        const state = this._state;
                        let current = this._head;
                        const iterator = {
                            [Symbol.iterator]: ()=>{
                                return iterator;
                            },
                            next: ()=>{
                                if (this._state !== state) {
                                    throw new Error(`LinkedMap got modified during iteration.`);
                                }
                                if (current) {
                                    const result = {
                                        value: current.key,
                                        done: false
                                    };
                                    current = current.next;
                                    return result;
                                } else {
                                    return {
                                        value: undefined,
                                        done: true
                                    };
                                }
                            }
                        };
                        return iterator;
                    }
                    values() {
                        const state = this._state;
                        let current = this._head;
                        const iterator = {
                            [Symbol.iterator]: ()=>{
                                return iterator;
                            },
                            next: ()=>{
                                if (this._state !== state) {
                                    throw new Error(`LinkedMap got modified during iteration.`);
                                }
                                if (current) {
                                    const result = {
                                        value: current.value,
                                        done: false
                                    };
                                    current = current.next;
                                    return result;
                                } else {
                                    return {
                                        value: undefined,
                                        done: true
                                    };
                                }
                            }
                        };
                        return iterator;
                    }
                    entries() {
                        const state = this._state;
                        let current = this._head;
                        const iterator = {
                            [Symbol.iterator]: ()=>{
                                return iterator;
                            },
                            next: ()=>{
                                if (this._state !== state) {
                                    throw new Error(`LinkedMap got modified during iteration.`);
                                }
                                if (current) {
                                    const result = {
                                        value: [
                                            current.key,
                                            current.value
                                        ],
                                        done: false
                                    };
                                    current = current.next;
                                    return result;
                                } else {
                                    return {
                                        value: undefined,
                                        done: true
                                    };
                                }
                            }
                        };
                        return iterator;
                    }
                    [(_a = Symbol.toStringTag, Symbol.iterator)]() {
                        return this.entries();
                    }
                    trimOld(newSize) {
                        if (newSize >= this.size) {
                            return;
                        }
                        if (newSize === 0) {
                            this.clear();
                            return;
                        }
                        let current = this._head;
                        let currentSize = this.size;
                        while(current && currentSize > newSize){
                            this._map.delete(current.key);
                            current = current.next;
                            currentSize--;
                        }
                        this._head = current;
                        this._size = currentSize;
                        if (current) {
                            current.previous = undefined;
                        }
                        this._state++;
                    }
                    addItemFirst(item) {
                        // First time Insert
                        if (!this._head && !this._tail) {
                            this._tail = item;
                        } else if (!this._head) {
                            throw new Error('Invalid list');
                        } else {
                            item.next = this._head;
                            this._head.previous = item;
                        }
                        this._head = item;
                        this._state++;
                    }
                    addItemLast(item) {
                        // First time Insert
                        if (!this._head && !this._tail) {
                            this._head = item;
                        } else if (!this._tail) {
                            throw new Error('Invalid list');
                        } else {
                            item.previous = this._tail;
                            this._tail.next = item;
                        }
                        this._tail = item;
                        this._state++;
                    }
                    removeItem(item) {
                        if (item === this._head && item === this._tail) {
                            this._head = undefined;
                            this._tail = undefined;
                        } else if (item === this._head) {
                            // This can only happened if size === 1 which is handle
                            // by the case above.
                            if (!item.next) {
                                throw new Error('Invalid list');
                            }
                            item.next.previous = undefined;
                            this._head = item.next;
                        } else if (item === this._tail) {
                            // This can only happened if size === 1 which is handle
                            // by the case above.
                            if (!item.previous) {
                                throw new Error('Invalid list');
                            }
                            item.previous.next = undefined;
                            this._tail = item.previous;
                        } else {
                            const next = item.next;
                            const previous = item.previous;
                            if (!next || !previous) {
                                throw new Error('Invalid list');
                            }
                            next.previous = previous;
                            previous.next = next;
                        }
                        item.next = undefined;
                        item.previous = undefined;
                        this._state++;
                    }
                    touch(item, touch) {
                        if (!this._head || !this._tail) {
                            throw new Error('Invalid list');
                        }
                        if (touch !== Touch.First && touch !== Touch.Last) {
                            return;
                        }
                        if (touch === Touch.First) {
                            if (item === this._head) {
                                return;
                            }
                            const next = item.next;
                            const previous = item.previous;
                            // Unlink the item
                            if (item === this._tail) {
                                // previous must be defined since item was not head but is tail
                                // So there are more than on item in the map
                                previous.next = undefined;
                                this._tail = previous;
                            } else {
                                // Both next and previous are not undefined since item was neither head nor tail.
                                next.previous = previous;
                                previous.next = next;
                            }
                            // Insert the node at head
                            item.previous = undefined;
                            item.next = this._head;
                            this._head.previous = item;
                            this._head = item;
                            this._state++;
                        } else if (touch === Touch.Last) {
                            if (item === this._tail) {
                                return;
                            }
                            const next = item.next;
                            const previous = item.previous;
                            // Unlink the item.
                            if (item === this._head) {
                                // next must be defined since item was not tail but is head
                                // So there are more than on item in the map
                                next.previous = undefined;
                                this._head = next;
                            } else {
                                // Both next and previous are not undefined since item was neither head nor tail.
                                next.previous = previous;
                                previous.next = next;
                            }
                            item.next = undefined;
                            item.previous = this._tail;
                            this._tail.next = item;
                            this._tail = item;
                            this._state++;
                        }
                    }
                    toJSON() {
                        const data = [];
                        this.forEach((value, key)=>{
                            data.push([
                                key,
                                value
                            ]);
                        });
                        return data;
                    }
                    fromJSON(data) {
                        this.clear();
                        for (const [key, value] of data){
                            this.set(key, value);
                        }
                    }
                    constructor(){
                        this[_a] = 'LinkedMap';
                        this._map = new Map();
                        this._head = undefined;
                        this._tail = undefined;
                        this._size = 0;
                        this._state = 0;
                    }
                }
                exports1.LinkedMap = LinkedMap;
                class LRUCache extends LinkedMap {
                    get limit() {
                        return this._limit;
                    }
                    set limit(limit) {
                        this._limit = limit;
                        this.checkTrim();
                    }
                    get ratio() {
                        return this._ratio;
                    }
                    set ratio(ratio) {
                        this._ratio = Math.min(Math.max(0, ratio), 1);
                        this.checkTrim();
                    }
                    get(key, touch = Touch.AsNew) {
                        return super.get(key, touch);
                    }
                    peek(key) {
                        return super.get(key, Touch.None);
                    }
                    set(key, value) {
                        super.set(key, value, Touch.Last);
                        this.checkTrim();
                        return this;
                    }
                    checkTrim() {
                        if (this.size > this._limit) {
                            this.trimOld(Math.round(this._limit * this._ratio));
                        }
                    }
                    constructor(limit, ratio = 1){
                        super();
                        this._limit = limit;
                        this._ratio = Math.min(Math.max(0, ratio), 1);
                    }
                }
                exports1.LRUCache = LRUCache;
            //# sourceMappingURL=linkedMap.js.map
            /***/ },
            /***/ 2180: /***/ (__unused_webpack_module, exports1)=>{
                "use strict";
                /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.AbstractMessageBuffer = void 0;
                const CR = 13;
                const LF = 10;
                const CRLF = '\r\n';
                class AbstractMessageBuffer {
                    get encoding() {
                        return this._encoding;
                    }
                    append(chunk) {
                        const toAppend = typeof chunk === 'string' ? this.fromString(chunk, this._encoding) : chunk;
                        this._chunks.push(toAppend);
                        this._totalLength += toAppend.byteLength;
                    }
                    tryReadHeaders() {
                        if (this._chunks.length === 0) {
                            return undefined;
                        }
                        let state = 0;
                        let chunkIndex = 0;
                        let offset = 0;
                        let chunkBytesRead = 0;
                        row: while(chunkIndex < this._chunks.length){
                            const chunk = this._chunks[chunkIndex];
                            offset = 0;
                            column: while(offset < chunk.length){
                                const value = chunk[offset];
                                switch(value){
                                    case CR:
                                        switch(state){
                                            case 0:
                                                state = 1;
                                                break;
                                            case 2:
                                                state = 3;
                                                break;
                                            default:
                                                state = 0;
                                        }
                                        break;
                                    case LF:
                                        switch(state){
                                            case 1:
                                                state = 2;
                                                break;
                                            case 3:
                                                state = 4;
                                                offset++;
                                                break row;
                                            default:
                                                state = 0;
                                        }
                                        break;
                                    default:
                                        state = 0;
                                }
                                offset++;
                            }
                            chunkBytesRead += chunk.byteLength;
                            chunkIndex++;
                        }
                        if (state !== 4) {
                            return undefined;
                        }
                        // The buffer contains the two CRLF at the end. So we will
                        // have two empty lines after the split at the end as well.
                        const buffer = this._read(chunkBytesRead + offset);
                        const result = new Map();
                        const headers = this.toString(buffer, 'ascii').split(CRLF);
                        if (headers.length < 2) {
                            return result;
                        }
                        for(let i = 0; i < headers.length - 2; i++){
                            const header = headers[i];
                            const index = header.indexOf(':');
                            if (index === -1) {
                                throw new Error('Message header must separate key and value using :');
                            }
                            const key = header.substr(0, index);
                            const value = header.substr(index + 1).trim();
                            result.set(key, value);
                        }
                        return result;
                    }
                    tryReadBody(length) {
                        if (this._totalLength < length) {
                            return undefined;
                        }
                        return this._read(length);
                    }
                    get numberOfBytes() {
                        return this._totalLength;
                    }
                    _read(byteCount) {
                        if (byteCount === 0) {
                            return this.emptyBuffer();
                        }
                        if (byteCount > this._totalLength) {
                            throw new Error(`Cannot read so many bytes!`);
                        }
                        if (this._chunks[0].byteLength === byteCount) {
                            // super fast path, precisely first chunk must be returned
                            const chunk = this._chunks[0];
                            this._chunks.shift();
                            this._totalLength -= byteCount;
                            return this.asNative(chunk);
                        }
                        if (this._chunks[0].byteLength > byteCount) {
                            // fast path, the reading is entirely within the first chunk
                            const chunk = this._chunks[0];
                            const result = this.asNative(chunk, byteCount);
                            this._chunks[0] = chunk.slice(byteCount);
                            this._totalLength -= byteCount;
                            return result;
                        }
                        const result = this.allocNative(byteCount);
                        let resultOffset = 0;
                        let chunkIndex = 0;
                        while(byteCount > 0){
                            const chunk = this._chunks[chunkIndex];
                            if (chunk.byteLength > byteCount) {
                                // this chunk will survive
                                const chunkPart = chunk.slice(0, byteCount);
                                result.set(chunkPart, resultOffset);
                                resultOffset += byteCount;
                                this._chunks[chunkIndex] = chunk.slice(byteCount);
                                this._totalLength -= byteCount;
                                byteCount -= byteCount;
                            } else {
                                // this chunk will be entirely read
                                result.set(chunk, resultOffset);
                                resultOffset += chunk.byteLength;
                                this._chunks.shift();
                                this._totalLength -= chunk.byteLength;
                                byteCount -= chunk.byteLength;
                            }
                        }
                        return result;
                    }
                    constructor(encoding = 'utf-8'){
                        this._encoding = encoding;
                        this._chunks = [];
                        this._totalLength = 0;
                    }
                }
                exports1.AbstractMessageBuffer = AbstractMessageBuffer;
            //# sourceMappingURL=messageBuffer.js.map
            /***/ },
            /***/ 9813: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_834384__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.ReadableStreamMessageReader = exports1.AbstractMessageReader = exports1.MessageReader = void 0;
                const ral_1 = __nested_webpack_require_834384__(4254);
                const Is = __nested_webpack_require_834384__(6145);
                const events_1 = __nested_webpack_require_834384__(6780);
                var MessageReader;
                (function(MessageReader) {
                    function is(value) {
                        let candidate = value;
                        return candidate && Is.func(candidate.listen) && Is.func(candidate.dispose) && Is.func(candidate.onError) && Is.func(candidate.onClose) && Is.func(candidate.onPartialMessage);
                    }
                    MessageReader.is = is;
                })(MessageReader = exports1.MessageReader || (exports1.MessageReader = {}));
                class AbstractMessageReader {
                    dispose() {
                        this.errorEmitter.dispose();
                        this.closeEmitter.dispose();
                    }
                    get onError() {
                        return this.errorEmitter.event;
                    }
                    fireError(error) {
                        this.errorEmitter.fire(this.asError(error));
                    }
                    get onClose() {
                        return this.closeEmitter.event;
                    }
                    fireClose() {
                        this.closeEmitter.fire(undefined);
                    }
                    get onPartialMessage() {
                        return this.partialMessageEmitter.event;
                    }
                    firePartialMessage(info) {
                        this.partialMessageEmitter.fire(info);
                    }
                    asError(error) {
                        if (error instanceof Error) {
                            return error;
                        } else {
                            return new Error(`Reader received error. Reason: ${Is.string(error.message) ? error.message : 'unknown'}`);
                        }
                    }
                    constructor(){
                        this.errorEmitter = new events_1.Emitter();
                        this.closeEmitter = new events_1.Emitter();
                        this.partialMessageEmitter = new events_1.Emitter();
                    }
                }
                exports1.AbstractMessageReader = AbstractMessageReader;
                var ResolvedMessageReaderOptions;
                (function(ResolvedMessageReaderOptions) {
                    function fromOptions(options) {
                        let charset;
                        let result;
                        let contentDecoder;
                        const contentDecoders = new Map();
                        let contentTypeDecoder;
                        const contentTypeDecoders = new Map();
                        if (options === undefined || typeof options === 'string') {
                            charset = options !== null && options !== void 0 ? options : 'utf-8';
                        } else {
                            var _options_charset;
                            charset = (_options_charset = options.charset) !== null && _options_charset !== void 0 ? _options_charset : 'utf-8';
                            if (options.contentDecoder !== undefined) {
                                contentDecoder = options.contentDecoder;
                                contentDecoders.set(contentDecoder.name, contentDecoder);
                            }
                            if (options.contentDecoders !== undefined) {
                                for (const decoder of options.contentDecoders){
                                    contentDecoders.set(decoder.name, decoder);
                                }
                            }
                            if (options.contentTypeDecoder !== undefined) {
                                contentTypeDecoder = options.contentTypeDecoder;
                                contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
                            }
                            if (options.contentTypeDecoders !== undefined) {
                                for (const decoder of options.contentTypeDecoders){
                                    contentTypeDecoders.set(decoder.name, decoder);
                                }
                            }
                        }
                        if (contentTypeDecoder === undefined) {
                            contentTypeDecoder = (0, ral_1.default)().applicationJson.decoder;
                            contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
                        }
                        return {
                            charset,
                            contentDecoder,
                            contentDecoders,
                            contentTypeDecoder,
                            contentTypeDecoders
                        };
                    }
                    ResolvedMessageReaderOptions.fromOptions = fromOptions;
                })(ResolvedMessageReaderOptions || (ResolvedMessageReaderOptions = {}));
                class ReadableStreamMessageReader extends AbstractMessageReader {
                    set partialMessageTimeout(timeout) {
                        this._partialMessageTimeout = timeout;
                    }
                    get partialMessageTimeout() {
                        return this._partialMessageTimeout;
                    }
                    listen(callback) {
                        this.nextMessageLength = -1;
                        this.messageToken = 0;
                        this.partialMessageTimer = undefined;
                        this.callback = callback;
                        const result = this.readable.onData((data)=>{
                            this.onData(data);
                        });
                        this.readable.onError((error)=>this.fireError(error));
                        this.readable.onClose(()=>this.fireClose());
                        return result;
                    }
                    onData(data) {
                        this.buffer.append(data);
                        while(true){
                            if (this.nextMessageLength === -1) {
                                const headers = this.buffer.tryReadHeaders();
                                if (!headers) {
                                    return;
                                }
                                const contentLength = headers.get('Content-Length');
                                if (!contentLength) {
                                    throw new Error('Header must provide a Content-Length property.');
                                }
                                const length = parseInt(contentLength);
                                if (isNaN(length)) {
                                    throw new Error('Content-Length value must be a number.');
                                }
                                this.nextMessageLength = length;
                            }
                            const body = this.buffer.tryReadBody(this.nextMessageLength);
                            if (body === undefined) {
                                /** We haven't received the full message yet. */ this.setPartialMessageTimer();
                                return;
                            }
                            this.clearPartialMessageTimer();
                            this.nextMessageLength = -1;
                            let p;
                            if (this.options.contentDecoder !== undefined) {
                                p = this.options.contentDecoder.decode(body);
                            } else {
                                p = Promise.resolve(body);
                            }
                            p.then((value)=>{
                                this.options.contentTypeDecoder.decode(value, this.options).then((msg)=>{
                                    this.callback(msg);
                                }, (error)=>{
                                    this.fireError(error);
                                });
                            }, (error)=>{
                                this.fireError(error);
                            });
                        }
                    }
                    clearPartialMessageTimer() {
                        if (this.partialMessageTimer) {
                            this.partialMessageTimer.dispose();
                            this.partialMessageTimer = undefined;
                        }
                    }
                    setPartialMessageTimer() {
                        this.clearPartialMessageTimer();
                        if (this._partialMessageTimeout <= 0) {
                            return;
                        }
                        this.partialMessageTimer = (0, ral_1.default)().timer.setTimeout((token, timeout)=>{
                            this.partialMessageTimer = undefined;
                            if (token === this.messageToken) {
                                this.firePartialMessage({
                                    messageToken: token,
                                    waitingTime: timeout
                                });
                                this.setPartialMessageTimer();
                            }
                        }, this._partialMessageTimeout, this.messageToken, this._partialMessageTimeout);
                    }
                    constructor(readable, options){
                        super();
                        this.readable = readable;
                        this.options = ResolvedMessageReaderOptions.fromOptions(options);
                        this.buffer = (0, ral_1.default)().messageBuffer.create(this.options.charset);
                        this._partialMessageTimeout = 10000;
                        this.nextMessageLength = -1;
                        this.messageToken = 0;
                    }
                }
                exports1.ReadableStreamMessageReader = ReadableStreamMessageReader;
            //# sourceMappingURL=messageReader.js.map
            /***/ },
            /***/ 7745: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_845364__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.WriteableStreamMessageWriter = exports1.AbstractMessageWriter = exports1.MessageWriter = void 0;
                const ral_1 = __nested_webpack_require_845364__(4254);
                const Is = __nested_webpack_require_845364__(6145);
                const semaphore_1 = __nested_webpack_require_845364__(9931);
                const events_1 = __nested_webpack_require_845364__(6780);
                const ContentLength = 'Content-Length: ';
                const CRLF = '\r\n';
                var MessageWriter;
                (function(MessageWriter) {
                    function is(value) {
                        let candidate = value;
                        return candidate && Is.func(candidate.dispose) && Is.func(candidate.onClose) && Is.func(candidate.onError) && Is.func(candidate.write);
                    }
                    MessageWriter.is = is;
                })(MessageWriter = exports1.MessageWriter || (exports1.MessageWriter = {}));
                class AbstractMessageWriter {
                    dispose() {
                        this.errorEmitter.dispose();
                        this.closeEmitter.dispose();
                    }
                    get onError() {
                        return this.errorEmitter.event;
                    }
                    fireError(error, message, count) {
                        this.errorEmitter.fire([
                            this.asError(error),
                            message,
                            count
                        ]);
                    }
                    get onClose() {
                        return this.closeEmitter.event;
                    }
                    fireClose() {
                        this.closeEmitter.fire(undefined);
                    }
                    asError(error) {
                        if (error instanceof Error) {
                            return error;
                        } else {
                            return new Error(`Writer received error. Reason: ${Is.string(error.message) ? error.message : 'unknown'}`);
                        }
                    }
                    constructor(){
                        this.errorEmitter = new events_1.Emitter();
                        this.closeEmitter = new events_1.Emitter();
                    }
                }
                exports1.AbstractMessageWriter = AbstractMessageWriter;
                var ResolvedMessageWriterOptions;
                (function(ResolvedMessageWriterOptions) {
                    function fromOptions(options) {
                        if (options === undefined || typeof options === 'string') {
                            return {
                                charset: options !== null && options !== void 0 ? options : 'utf-8',
                                contentTypeEncoder: (0, ral_1.default)().applicationJson.encoder
                            };
                        } else {
                            var _options_charset, _options_contentTypeEncoder;
                            return {
                                charset: (_options_charset = options.charset) !== null && _options_charset !== void 0 ? _options_charset : 'utf-8',
                                contentEncoder: options.contentEncoder,
                                contentTypeEncoder: (_options_contentTypeEncoder = options.contentTypeEncoder) !== null && _options_contentTypeEncoder !== void 0 ? _options_contentTypeEncoder : (0, ral_1.default)().applicationJson.encoder
                            };
                        }
                    }
                    ResolvedMessageWriterOptions.fromOptions = fromOptions;
                })(ResolvedMessageWriterOptions || (ResolvedMessageWriterOptions = {}));
                class WriteableStreamMessageWriter extends AbstractMessageWriter {
                    async write(msg) {
                        return this.writeSemaphore.lock(async ()=>{
                            const payload = this.options.contentTypeEncoder.encode(msg, this.options).then((buffer)=>{
                                if (this.options.contentEncoder !== undefined) {
                                    return this.options.contentEncoder.encode(buffer);
                                } else {
                                    return buffer;
                                }
                            });
                            return payload.then((buffer)=>{
                                const headers = [];
                                headers.push(ContentLength, buffer.byteLength.toString(), CRLF);
                                headers.push(CRLF);
                                return this.doWrite(msg, headers, buffer);
                            }, (error)=>{
                                this.fireError(error);
                                throw error;
                            });
                        });
                    }
                    async doWrite(msg, headers, data) {
                        try {
                            await this.writable.write(headers.join(''), 'ascii');
                            return this.writable.write(data);
                        } catch (error) {
                            this.handleError(error, msg);
                            return Promise.reject(error);
                        }
                    }
                    handleError(error, msg) {
                        this.errorCount++;
                        this.fireError(error, msg, this.errorCount);
                    }
                    end() {
                        this.writable.end();
                    }
                    constructor(writable, options){
                        super();
                        this.writable = writable;
                        this.options = ResolvedMessageWriterOptions.fromOptions(options);
                        this.errorCount = 0;
                        this.writeSemaphore = new semaphore_1.Semaphore(1);
                        this.writable.onError((error)=>this.fireError(error));
                        this.writable.onClose(()=>this.fireClose());
                    }
                }
                exports1.WriteableStreamMessageWriter = WriteableStreamMessageWriter;
            //# sourceMappingURL=messageWriter.js.map
            /***/ },
            /***/ 4313: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_852304__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.Message = exports1.NotificationType9 = exports1.NotificationType8 = exports1.NotificationType7 = exports1.NotificationType6 = exports1.NotificationType5 = exports1.NotificationType4 = exports1.NotificationType3 = exports1.NotificationType2 = exports1.NotificationType1 = exports1.NotificationType0 = exports1.NotificationType = exports1.RequestType9 = exports1.RequestType8 = exports1.RequestType7 = exports1.RequestType6 = exports1.RequestType5 = exports1.RequestType4 = exports1.RequestType3 = exports1.RequestType2 = exports1.RequestType1 = exports1.RequestType = exports1.RequestType0 = exports1.AbstractMessageSignature = exports1.ParameterStructures = exports1.ResponseError = exports1.ErrorCodes = void 0;
                const is = __nested_webpack_require_852304__(6145);
                /**
 * Predefined error codes.
 */ var ErrorCodes;
                (function(ErrorCodes) {
                    // Defined by JSON RPC
                    ErrorCodes.ParseError = -32700;
                    ErrorCodes.InvalidRequest = -32600;
                    ErrorCodes.MethodNotFound = -32601;
                    ErrorCodes.InvalidParams = -32602;
                    ErrorCodes.InternalError = -32603;
                    /**
     * This is the start range of JSON RPC reserved error codes.
     * It doesn't denote a real error code. No application error codes should
     * be defined between the start and end range. For backwards
     * compatibility the `ServerNotInitialized` and the `UnknownErrorCode`
     * are left in the range.
     *
     * @since 3.16.0
    */ ErrorCodes.jsonrpcReservedErrorRangeStart = -32099;
                    /** @deprecated use  jsonrpcReservedErrorRangeStart */ ErrorCodes.serverErrorStart = -32099;
                    /**
     * An error occurred when write a message to the transport layer.
     */ ErrorCodes.MessageWriteError = -32099;
                    /**
     * An error occurred when reading a message from the transport layer.
     */ ErrorCodes.MessageReadError = -32098;
                    /**
     * The connection got disposed or lost and all pending responses got
     * rejected.
     */ ErrorCodes.PendingResponseRejected = -32097;
                    /**
     * The connection is inactive and a use of it failed.
     */ ErrorCodes.ConnectionInactive = -32096;
                    /**
     * Error code indicating that a server received a notification or
     * request before the server has received the `initialize` request.
     */ ErrorCodes.ServerNotInitialized = -32002;
                    ErrorCodes.UnknownErrorCode = -32001;
                    /**
     * This is the end range of JSON RPC reserved error codes.
     * It doesn't denote a real error code.
     *
     * @since 3.16.0
    */ ErrorCodes.jsonrpcReservedErrorRangeEnd = -32000;
                    /** @deprecated use  jsonrpcReservedErrorRangeEnd */ ErrorCodes.serverErrorEnd = -32000;
                })(ErrorCodes = exports1.ErrorCodes || (exports1.ErrorCodes = {}));
                /**
 * An error object return in a response in case a request
 * has failed.
 */ class ResponseError extends Error {
                    toJson() {
                        const result = {
                            code: this.code,
                            message: this.message
                        };
                        if (this.data !== undefined) {
                            result.data = this.data;
                        }
                        return result;
                    }
                    constructor(code, message, data){
                        super(message);
                        this.code = is.number(code) ? code : ErrorCodes.UnknownErrorCode;
                        this.data = data;
                        Object.setPrototypeOf(this, ResponseError.prototype);
                    }
                }
                exports1.ResponseError = ResponseError;
                class ParameterStructures {
                    static is(value) {
                        return value === ParameterStructures.auto || value === ParameterStructures.byName || value === ParameterStructures.byPosition;
                    }
                    toString() {
                        return this.kind;
                    }
                    constructor(kind){
                        this.kind = kind;
                    }
                }
                exports1.ParameterStructures = ParameterStructures;
                /**
 * The parameter structure is automatically inferred on the number of parameters
 * and the parameter type in case of a single param.
 */ ParameterStructures.auto = new ParameterStructures('auto');
                /**
 * Forces `byPosition` parameter structure. This is useful if you have a single
 * parameter which has a literal type.
 */ ParameterStructures.byPosition = new ParameterStructures('byPosition');
                /**
 * Forces `byName` parameter structure. This is only useful when having a single
 * parameter. The library will report errors if used with a different number of
 * parameters.
 */ ParameterStructures.byName = new ParameterStructures('byName');
                /**
 * An abstract implementation of a MessageType.
 */ class AbstractMessageSignature {
                    get parameterStructures() {
                        return ParameterStructures.auto;
                    }
                    constructor(method, numberOfParams){
                        this.method = method;
                        this.numberOfParams = numberOfParams;
                    }
                }
                exports1.AbstractMessageSignature = AbstractMessageSignature;
                /**
 * Classes to type request response pairs
 */ class RequestType0 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 0);
                    }
                }
                exports1.RequestType0 = RequestType0;
                class RequestType extends AbstractMessageSignature {
                    get parameterStructures() {
                        return this._parameterStructures;
                    }
                    constructor(method, _parameterStructures = ParameterStructures.auto){
                        super(method, 1);
                        this._parameterStructures = _parameterStructures;
                    }
                }
                exports1.RequestType = RequestType;
                class RequestType1 extends AbstractMessageSignature {
                    get parameterStructures() {
                        return this._parameterStructures;
                    }
                    constructor(method, _parameterStructures = ParameterStructures.auto){
                        super(method, 1);
                        this._parameterStructures = _parameterStructures;
                    }
                }
                exports1.RequestType1 = RequestType1;
                class RequestType2 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 2);
                    }
                }
                exports1.RequestType2 = RequestType2;
                class RequestType3 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 3);
                    }
                }
                exports1.RequestType3 = RequestType3;
                class RequestType4 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 4);
                    }
                }
                exports1.RequestType4 = RequestType4;
                class RequestType5 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 5);
                    }
                }
                exports1.RequestType5 = RequestType5;
                class RequestType6 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 6);
                    }
                }
                exports1.RequestType6 = RequestType6;
                class RequestType7 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 7);
                    }
                }
                exports1.RequestType7 = RequestType7;
                class RequestType8 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 8);
                    }
                }
                exports1.RequestType8 = RequestType8;
                class RequestType9 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 9);
                    }
                }
                exports1.RequestType9 = RequestType9;
                class NotificationType extends AbstractMessageSignature {
                    get parameterStructures() {
                        return this._parameterStructures;
                    }
                    constructor(method, _parameterStructures = ParameterStructures.auto){
                        super(method, 1);
                        this._parameterStructures = _parameterStructures;
                    }
                }
                exports1.NotificationType = NotificationType;
                class NotificationType0 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 0);
                    }
                }
                exports1.NotificationType0 = NotificationType0;
                class NotificationType1 extends AbstractMessageSignature {
                    get parameterStructures() {
                        return this._parameterStructures;
                    }
                    constructor(method, _parameterStructures = ParameterStructures.auto){
                        super(method, 1);
                        this._parameterStructures = _parameterStructures;
                    }
                }
                exports1.NotificationType1 = NotificationType1;
                class NotificationType2 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 2);
                    }
                }
                exports1.NotificationType2 = NotificationType2;
                class NotificationType3 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 3);
                    }
                }
                exports1.NotificationType3 = NotificationType3;
                class NotificationType4 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 4);
                    }
                }
                exports1.NotificationType4 = NotificationType4;
                class NotificationType5 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 5);
                    }
                }
                exports1.NotificationType5 = NotificationType5;
                class NotificationType6 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 6);
                    }
                }
                exports1.NotificationType6 = NotificationType6;
                class NotificationType7 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 7);
                    }
                }
                exports1.NotificationType7 = NotificationType7;
                class NotificationType8 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 8);
                    }
                }
                exports1.NotificationType8 = NotificationType8;
                class NotificationType9 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 9);
                    }
                }
                exports1.NotificationType9 = NotificationType9;
                var Message;
                (function(Message) {
                    /**
     * Tests if the given message is a request message
     */ function isRequest(message) {
                        const candidate = message;
                        return candidate && is.string(candidate.method) && (is.string(candidate.id) || is.number(candidate.id));
                    }
                    Message.isRequest = isRequest;
                    /**
     * Tests if the given message is a notification message
     */ function isNotification(message) {
                        const candidate = message;
                        return candidate && is.string(candidate.method) && message.id === void 0;
                    }
                    Message.isNotification = isNotification;
                    /**
     * Tests if the given message is a response message
     */ function isResponse(message) {
                        const candidate = message;
                        return candidate && (candidate.result !== void 0 || !!candidate.error) && (is.string(candidate.id) || is.number(candidate.id) || candidate.id === null);
                    }
                    Message.isResponse = isResponse;
                })(Message = exports1.Message || (exports1.Message = {}));
            //# sourceMappingURL=messages.js.map
            /***/ },
            /***/ 4254: /***/ (__unused_webpack_module, exports1)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                let _ral;
                function RAL() {
                    if (_ral === undefined) {
                        throw new Error(`No runtime abstraction layer installed`);
                    }
                    return _ral;
                }
                (function(RAL) {
                    function install(ral) {
                        if (ral === undefined) {
                            throw new Error(`No runtime abstraction layer provided`);
                        }
                        _ral = ral;
                    }
                    RAL.install = install;
                })(RAL || (RAL = {}));
                exports1["default"] = RAL;
            //# sourceMappingURL=ral.js.map
            /***/ },
            /***/ 9931: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_867905__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.Semaphore = void 0;
                const ral_1 = __nested_webpack_require_867905__(4254);
                class Semaphore {
                    lock(thunk) {
                        return new Promise((resolve, reject)=>{
                            this._waiting.push({
                                thunk,
                                resolve,
                                reject
                            });
                            this.runNext();
                        });
                    }
                    get active() {
                        return this._active;
                    }
                    runNext() {
                        if (this._waiting.length === 0 || this._active === this._capacity) {
                            return;
                        }
                        (0, ral_1.default)().timer.setImmediate(()=>this.doRunNext());
                    }
                    doRunNext() {
                        if (this._waiting.length === 0 || this._active === this._capacity) {
                            return;
                        }
                        const next = this._waiting.shift();
                        this._active++;
                        if (this._active > this._capacity) {
                            throw new Error(`To many thunks active`);
                        }
                        try {
                            const result = next.thunk();
                            if (result instanceof Promise) {
                                result.then((value)=>{
                                    this._active--;
                                    next.resolve(value);
                                    this.runNext();
                                }, (err)=>{
                                    this._active--;
                                    next.reject(err);
                                    this.runNext();
                                });
                            } else {
                                this._active--;
                                next.resolve(result);
                                this.runNext();
                            }
                        } catch (err) {
                            this._active--;
                            next.reject(err);
                            this.runNext();
                        }
                    }
                    constructor(capacity = 1){
                        if (capacity <= 0) {
                            throw new Error('Capacity must be greater than 0');
                        }
                        this._capacity = capacity;
                        this._active = 0;
                        this._waiting = [];
                    }
                }
                exports1.Semaphore = Semaphore;
            //# sourceMappingURL=semaphore.js.map
            /***/ },
            /***/ 2730: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_871398__)=>{
                "use strict";
                var forEach = __nested_webpack_require_871398__(705);
                var availableTypedArrays = __nested_webpack_require_871398__(4834);
                var callBind = __nested_webpack_require_871398__(8498);
                var callBound = __nested_webpack_require_871398__(9818);
                var gOPD = __nested_webpack_require_871398__(9336);
                var $toString = callBound('Object.prototype.toString');
                var hasToStringTag = __nested_webpack_require_871398__(1913)();
                var g = typeof globalThis === 'undefined' ? __nested_webpack_require_871398__.g : globalThis;
                var typedArrays = availableTypedArrays();
                var $slice = callBound('String.prototype.slice');
                var getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');
                var $indexOf = callBound('Array.prototype.indexOf', true) || function indexOf(array, value) {
                    for(var i = 0; i < array.length; i += 1){
                        if (array[i] === value) {
                            return i;
                        }
                    }
                    return -1;
                };
                var cache = {
                    __proto__: null
                };
                if (hasToStringTag && gOPD && getPrototypeOf) {
                    forEach(typedArrays, function(typedArray) {
                        var arr = new g[typedArray]();
                        if (Symbol.toStringTag in arr) {
                            var proto = getPrototypeOf(arr);
                            var descriptor = gOPD(proto, Symbol.toStringTag);
                            if (!descriptor) {
                                var superProto = getPrototypeOf(proto);
                                descriptor = gOPD(superProto, Symbol.toStringTag);
                            }
                            cache['$' + typedArray] = callBind(descriptor.get);
                        }
                    });
                } else {
                    forEach(typedArrays, function(typedArray) {
                        var arr = new g[typedArray]();
                        cache['$' + typedArray] = callBind(arr.slice);
                    });
                }
                var tryTypedArrays = function tryAllTypedArrays(value) {
                    var found = false;
                    forEach(cache, function(getter, typedArray) {
                        if (!found) {
                            try {
                                if ('$' + getter(value) === typedArray) {
                                    found = $slice(typedArray, 1);
                                }
                            } catch (e) {}
                        }
                    });
                    return found;
                };
                var trySlices = function tryAllSlices(value) {
                    var found = false;
                    forEach(cache, function(getter, name) {
                        if (!found) {
                            try {
                                getter(value);
                                found = $slice(name, 1);
                            } catch (e) {}
                        }
                    });
                    return found;
                };
                module1.exports = function whichTypedArray(value) {
                    if (!value || typeof value !== 'object') {
                        return false;
                    }
                    if (!hasToStringTag) {
                        var tag = $slice($toString(value), 8, -1);
                        if ($indexOf(typedArrays, tag) > -1) {
                            return tag;
                        }
                        if (tag !== 'Object') {
                            return false;
                        }
                        // node < 0.6 hits here on real Typed Arrays
                        return trySlices(value);
                    }
                    if (!gOPD) {
                        return null;
                    } // unknown engine
                    return tryTypedArrays(value);
                };
            /***/ },
            /***/ 4834: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_875645__)=>{
                "use strict";
                var possibleNames = [
                    'BigInt64Array',
                    'BigUint64Array',
                    'Float32Array',
                    'Float64Array',
                    'Int16Array',
                    'Int32Array',
                    'Int8Array',
                    'Uint16Array',
                    'Uint32Array',
                    'Uint8Array',
                    'Uint8ClampedArray'
                ];
                var g = typeof globalThis === 'undefined' ? __nested_webpack_require_875645__.g : globalThis;
                module1.exports = function availableTypedArrays() {
                    var out = [];
                    for(var i = 0; i < possibleNames.length; i++){
                        if (typeof g[possibleNames[i]] === 'function') {
                            out[out.length] = possibleNames[i];
                        }
                    }
                    return out;
                };
            /***/ },
            /***/ 8041: /***/ (__unused_webpack___webpack_module__, __nested_webpack_exports__, __nested_webpack_require_876759__)=>{
                "use strict";
                /* harmony export */ __nested_webpack_require_876759__.d(__nested_webpack_exports__, {
                    /* harmony export */ V: ()=>/* binding */ TextDocument
                });
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ class FullTextDocument {
                    get uri() {
                        return this._uri;
                    }
                    get languageId() {
                        return this._languageId;
                    }
                    get version() {
                        return this._version;
                    }
                    getText(range) {
                        if (range) {
                            const start = this.offsetAt(range.start);
                            const end = this.offsetAt(range.end);
                            return this._content.substring(start, end);
                        }
                        return this._content;
                    }
                    update(changes, version) {
                        for (const change of changes){
                            if (FullTextDocument.isIncremental(change)) {
                                // makes sure start is before end
                                const range = getWellformedRange(change.range);
                                // update content
                                const startOffset = this.offsetAt(range.start);
                                const endOffset = this.offsetAt(range.end);
                                this._content = this._content.substring(0, startOffset) + change.text + this._content.substring(endOffset, this._content.length);
                                // update the offsets
                                const startLine = Math.max(range.start.line, 0);
                                const endLine = Math.max(range.end.line, 0);
                                let lineOffsets = this._lineOffsets;
                                const addedLineOffsets = computeLineOffsets(change.text, false, startOffset);
                                if (endLine - startLine === addedLineOffsets.length) {
                                    for(let i = 0, len = addedLineOffsets.length; i < len; i++){
                                        lineOffsets[i + startLine + 1] = addedLineOffsets[i];
                                    }
                                } else {
                                    if (addedLineOffsets.length < 10000) {
                                        lineOffsets.splice(startLine + 1, endLine - startLine, ...addedLineOffsets);
                                    } else {
                                        this._lineOffsets = lineOffsets = lineOffsets.slice(0, startLine + 1).concat(addedLineOffsets, lineOffsets.slice(endLine + 1));
                                    }
                                }
                                const diff = change.text.length - (endOffset - startOffset);
                                if (diff !== 0) {
                                    for(let i = startLine + 1 + addedLineOffsets.length, len = lineOffsets.length; i < len; i++){
                                        lineOffsets[i] = lineOffsets[i] + diff;
                                    }
                                }
                            } else if (FullTextDocument.isFull(change)) {
                                this._content = change.text;
                                this._lineOffsets = undefined;
                            } else {
                                throw new Error('Unknown change event received');
                            }
                        }
                        this._version = version;
                    }
                    getLineOffsets() {
                        if (this._lineOffsets === undefined) {
                            this._lineOffsets = computeLineOffsets(this._content, true);
                        }
                        return this._lineOffsets;
                    }
                    positionAt(offset) {
                        offset = Math.max(Math.min(offset, this._content.length), 0);
                        const lineOffsets = this.getLineOffsets();
                        let low = 0, high = lineOffsets.length;
                        if (high === 0) {
                            return {
                                line: 0,
                                character: offset
                            };
                        }
                        while(low < high){
                            const mid = Math.floor((low + high) / 2);
                            if (lineOffsets[mid] > offset) {
                                high = mid;
                            } else {
                                low = mid + 1;
                            }
                        }
                        // low is the least x for which the line offset is larger than the current offset
                        // or array.length if no line offset is larger than the current offset
                        const line = low - 1;
                        offset = this.ensureBeforeEOL(offset, lineOffsets[line]);
                        return {
                            line,
                            character: offset - lineOffsets[line]
                        };
                    }
                    offsetAt(position) {
                        const lineOffsets = this.getLineOffsets();
                        if (position.line >= lineOffsets.length) {
                            return this._content.length;
                        } else if (position.line < 0) {
                            return 0;
                        }
                        const lineOffset = lineOffsets[position.line];
                        if (position.character <= 0) {
                            return lineOffset;
                        }
                        const nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;
                        const offset = Math.min(lineOffset + position.character, nextLineOffset);
                        return this.ensureBeforeEOL(offset, lineOffset);
                    }
                    ensureBeforeEOL(offset, lineOffset) {
                        while(offset > lineOffset && isEOL(this._content.charCodeAt(offset - 1))){
                            offset--;
                        }
                        return offset;
                    }
                    get lineCount() {
                        return this.getLineOffsets().length;
                    }
                    static isIncremental(event) {
                        const candidate = event;
                        return candidate !== undefined && candidate !== null && typeof candidate.text === 'string' && candidate.range !== undefined && (candidate.rangeLength === undefined || typeof candidate.rangeLength === 'number');
                    }
                    static isFull(event) {
                        const candidate = event;
                        return candidate !== undefined && candidate !== null && typeof candidate.text === 'string' && candidate.range === undefined && candidate.rangeLength === undefined;
                    }
                    constructor(uri, languageId, version, content){
                        this._uri = uri;
                        this._languageId = languageId;
                        this._version = version;
                        this._content = content;
                        this._lineOffsets = undefined;
                    }
                }
                var TextDocument;
                (function(TextDocument) {
                    /**
     * Creates a new text document.
     *
     * @param uri The document's uri.
     * @param languageId  The document's language Id.
     * @param version The document's initial version number.
     * @param content The document's content.
     */ function create(uri, languageId, version, content) {
                        return new FullTextDocument(uri, languageId, version, content);
                    }
                    TextDocument.create = create;
                    /**
     * Updates a TextDocument by modifying its content.
     *
     * @param document the document to update. Only documents created by TextDocument.create are valid inputs.
     * @param changes the changes to apply to the document.
     * @param version the changes version for the document.
     * @returns The updated TextDocument. Note: That's the same document instance passed in as first parameter.
     *
     */ function update(document1, changes, version) {
                        if (document1 instanceof FullTextDocument) {
                            document1.update(changes, version);
                            return document1;
                        } else {
                            throw new Error('TextDocument.update: document must be created by TextDocument.create');
                        }
                    }
                    TextDocument.update = update;
                    function applyEdits(document1, edits) {
                        const text = document1.getText();
                        const sortedEdits = mergeSort(edits.map(getWellformedEdit), (a, b)=>{
                            const diff = a.range.start.line - b.range.start.line;
                            if (diff === 0) {
                                return a.range.start.character - b.range.start.character;
                            }
                            return diff;
                        });
                        let lastModifiedOffset = 0;
                        const spans = [];
                        for (const e of sortedEdits){
                            const startOffset = document1.offsetAt(e.range.start);
                            if (startOffset < lastModifiedOffset) {
                                throw new Error('Overlapping edit');
                            } else if (startOffset > lastModifiedOffset) {
                                spans.push(text.substring(lastModifiedOffset, startOffset));
                            }
                            if (e.newText.length) {
                                spans.push(e.newText);
                            }
                            lastModifiedOffset = document1.offsetAt(e.range.end);
                        }
                        spans.push(text.substr(lastModifiedOffset));
                        return spans.join('');
                    }
                    TextDocument.applyEdits = applyEdits;
                })(TextDocument || (TextDocument = {}));
                function mergeSort(data, compare) {
                    if (data.length <= 1) {
                        // sorted
                        return data;
                    }
                    const p = data.length / 2 | 0;
                    const left = data.slice(0, p);
                    const right = data.slice(p);
                    mergeSort(left, compare);
                    mergeSort(right, compare);
                    let leftIdx = 0;
                    let rightIdx = 0;
                    let i = 0;
                    while(leftIdx < left.length && rightIdx < right.length){
                        const ret = compare(left[leftIdx], right[rightIdx]);
                        if (ret <= 0) {
                            // smaller_equal -> take left to preserve order
                            data[i++] = left[leftIdx++];
                        } else {
                            // greater -> take right
                            data[i++] = right[rightIdx++];
                        }
                    }
                    while(leftIdx < left.length){
                        data[i++] = left[leftIdx++];
                    }
                    while(rightIdx < right.length){
                        data[i++] = right[rightIdx++];
                    }
                    return data;
                }
                function computeLineOffsets(text, isAtLineStart, textOffset = 0) {
                    const result = isAtLineStart ? [
                        textOffset
                    ] : [];
                    for(let i = 0; i < text.length; i++){
                        const ch = text.charCodeAt(i);
                        if (isEOL(ch)) {
                            if (ch === 13 /* CharCode.CarriageReturn */  && i + 1 < text.length && text.charCodeAt(i + 1) === 10 /* CharCode.LineFeed */ ) {
                                i++;
                            }
                            result.push(textOffset + i + 1);
                        }
                    }
                    return result;
                }
                function isEOL(char) {
                    return char === 13 /* CharCode.CarriageReturn */  || char === 10 /* CharCode.LineFeed */ ;
                }
                function getWellformedRange(range) {
                    const start = range.start;
                    const end = range.end;
                    if (start.line > end.line || start.line === end.line && start.character > end.character) {
                        return {
                            start: end,
                            end: start
                        };
                    }
                    return range;
                }
                function getWellformedEdit(textEdit) {
                    const range = getWellformedRange(textEdit.range);
                    if (range !== textEdit.range) {
                        return {
                            newText: textEdit.newText,
                            range
                        };
                    }
                    return textEdit;
                }
            /***/ }
        };
        /************************************************************************/ /******/ // The module cache
        /******/ var __webpack_module_cache__ = {};
        /******/ /******/ // The require function
        /******/ function __nested_webpack_require_891277__(moduleId) {
            /******/ // Check if module is in cache
            /******/ var cachedModule = __webpack_module_cache__[moduleId];
            /******/ if (cachedModule !== undefined) {
                /******/ return cachedModule.exports;
            /******/ }
            /******/ // Create a new module (and put it into the cache)
            /******/ var module1 = __webpack_module_cache__[moduleId] = {
                /******/ // no module.id needed
                /******/ // no module.loaded needed
                /******/ exports: {}
            };
            /******/ /******/ // Execute the module function
            /******/ __webpack_modules__[moduleId].call(module1.exports, module1, module1.exports, __nested_webpack_require_891277__);
            /******/ /******/ // Return the exports of the module
            /******/ return module1.exports;
        /******/ }
        /******/ /************************************************************************/ /******/ /* webpack/runtime/compat get default export */ /******/ (()=>{
            /******/ // getDefaultExport function for compatibility with non-harmony modules
            /******/ __nested_webpack_require_891277__.n = (module1)=>{
                /******/ var getter = module1 && module1.__esModule ? /******/ ()=>module1['default'] : /******/ ()=>module1;
                /******/ __nested_webpack_require_891277__.d(getter, {
                    a: getter
                });
                /******/ return getter;
            /******/ };
        /******/ })();
        /******/ /******/ /* webpack/runtime/define property getters */ /******/ (()=>{
            /******/ // define getter functions for harmony exports
            /******/ __nested_webpack_require_891277__.d = (exports1, definition)=>{
                /******/ for(var key in definition){
                    /******/ if (__nested_webpack_require_891277__.o(definition, key) && !__nested_webpack_require_891277__.o(exports1, key)) {
                        /******/ Object.defineProperty(exports1, key, {
                            enumerable: true,
                            get: definition[key]
                        });
                    /******/ }
                /******/ }
            /******/ };
        /******/ })();
        /******/ /******/ /* webpack/runtime/global */ /******/ (()=>{
            /******/ __nested_webpack_require_891277__.g = function() {
                /******/ if (typeof globalThis === 'object') return globalThis;
                /******/ try {
                    /******/ return this || new Function('return this')();
                /******/ } catch (e) {
                    /******/ if (typeof window === 'object') return window;
                /******/ }
            /******/ }();
        /******/ })();
        /******/ /******/ /* webpack/runtime/hasOwnProperty shorthand */ /******/ (()=>{
            /******/ __nested_webpack_require_891277__.o = (obj, prop)=>Object.prototype.hasOwnProperty.call(obj, prop);
        /******/ })();
        /******/ /******/ /* webpack/runtime/make namespace object */ /******/ (()=>{
            /******/ // define __esModule on exports
            /******/ __nested_webpack_require_891277__.r = (exports1)=>{
                /******/ if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
                    /******/ Object.defineProperty(exports1, Symbol.toStringTag, {
                        value: 'Module'
                    });
                /******/ }
                /******/ Object.defineProperty(exports1, '__esModule', {
                    value: true
                });
            /******/ };
        /******/ })();
        /******/ /************************************************************************/ var __nested_webpack_exports__ = {};
        // This entry need to be wrapped in an IIFE because it need to be in strict mode.
        (()=>{
            "use strict";
            // ESM COMPAT FLAG
            __nested_webpack_require_891277__.r(__nested_webpack_exports__);
            // EXPORTS
            __nested_webpack_require_891277__.d(__nested_webpack_exports__, {
                LanguageClient: ()=>/* binding */ LanguageClient
            });
            // EXTERNAL MODULE: ../../node_modules/vscode-ws-jsonrpc/node_modules/vscode-jsonrpc/lib/browser/main.js
            var main = __nested_webpack_require_891277__(4879);
            // EXTERNAL MODULE: ../../node_modules/vscode-ws-jsonrpc/node_modules/vscode-jsonrpc/lib/common/messages.js
            var messages = __nested_webpack_require_891277__(4313);
            ; // CONCATENATED MODULE: ../../node_modules/vscode-ws-jsonrpc/lib/disposable.js
            /* --------------------------------------------------------------------------------------------
 * Copyright (c) 2018-2022 TypeFox GmbH (http://www.typefox.io). All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ class DisposableCollection {
                dispose() {
                    while(this.disposables.length !== 0){
                        this.disposables.pop().dispose();
                    }
                }
                push(disposable) {
                    const disposables = this.disposables;
                    disposables.push(disposable);
                    return {
                        dispose () {
                            const index = disposables.indexOf(disposable);
                            if (index !== -1) {
                                disposables.splice(index, 1);
                            }
                        }
                    };
                }
                constructor(){
                    _define_property(this, "disposables", []);
                }
            }
            //# sourceMappingURL=disposable.js.map
            // EXTERNAL MODULE: ../../node_modules/vscode-ws-jsonrpc/node_modules/vscode-jsonrpc/lib/common/messageReader.js
            var messageReader = __nested_webpack_require_891277__(9813);
            ; // CONCATENATED MODULE: ../../node_modules/vscode-ws-jsonrpc/lib/socket/reader.js
            /* --------------------------------------------------------------------------------------------
 * Copyright (c) 2018-2022 TypeFox GmbH (http://www.typefox.io). All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ class WebSocketMessageReader extends messageReader.AbstractMessageReader {
                listen(callback) {
                    if (this.state === 'initial') {
                        this.state = 'listening';
                        this.callback = callback;
                        while(this.events.length !== 0){
                            const event = this.events.pop();
                            if (event.message) {
                                this.readMessage(event.message);
                            } else if (event.error) {
                                this.fireError(event.error);
                            } else {
                                this.fireClose();
                            }
                        }
                    }
                    return {
                        dispose: ()=>{
                            if (this.callback === callback) {
                                this.callback = undefined;
                            }
                        }
                    };
                }
                readMessage(message) {
                    if (this.state === 'initial') {
                        this.events.splice(0, 0, {
                            message
                        });
                    } else if (this.state === 'listening') {
                        try {
                            const data = JSON.parse(message);
                            this.callback(data);
                        } catch (err) {
                            const error = {
                                name: '' + 400,
                                message: `Error during message parsing, reason = ${typeof err === 'object' ? err.message : 'unknown'}`
                            };
                            this.fireError(error);
                        }
                    }
                }
                fireError(error) {
                    if (this.state === 'initial') {
                        this.events.splice(0, 0, {
                            error
                        });
                    } else if (this.state === 'listening') {
                        super.fireError(error);
                    }
                }
                fireClose() {
                    if (this.state === 'initial') {
                        this.events.splice(0, 0, {});
                    } else if (this.state === 'listening') {
                        super.fireClose();
                    }
                    this.state = 'closed';
                }
                constructor(socket){
                    super();
                    _define_property(this, "socket", void 0);
                    _define_property(this, "state", 'initial');
                    _define_property(this, "callback", void 0);
                    _define_property(this, "events", []);
                    this.socket = socket;
                    this.socket.onMessage((message)=>this.readMessage(message));
                    this.socket.onError((error)=>this.fireError(error));
                    this.socket.onClose((code, reason)=>{
                        if (code !== 1000) {
                            const error = {
                                name: '' + code,
                                message: `Error during socket reconnect: code = ${code}, reason = ${reason}`
                            };
                            this.fireError(error);
                        }
                        this.fireClose();
                    });
                }
            }
            //# sourceMappingURL=reader.js.map
            // EXTERNAL MODULE: ../../node_modules/vscode-ws-jsonrpc/node_modules/vscode-jsonrpc/lib/common/messageWriter.js
            var messageWriter = __nested_webpack_require_891277__(7745);
            ; // CONCATENATED MODULE: ../../node_modules/vscode-ws-jsonrpc/lib/socket/writer.js
            /* --------------------------------------------------------------------------------------------
 * Copyright (c) 2018-2022 TypeFox GmbH (http://www.typefox.io). All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ class WebSocketMessageWriter extends messageWriter.AbstractMessageWriter {
                end() {}
                async write(msg) {
                    try {
                        const content = JSON.stringify(msg);
                        this.socket.send(content);
                    } catch (e) {
                        this.errorCount++;
                        this.fireError(e, msg, this.errorCount);
                    }
                }
                constructor(socket){
                    super();
                    _define_property(this, "socket", void 0);
                    _define_property(this, "errorCount", 0);
                    this.socket = socket;
                }
            }
            //# sourceMappingURL=writer.js.map
            ; // CONCATENATED MODULE: ../../node_modules/vscode-ws-jsonrpc/lib/socket/connection.js
            /* --------------------------------------------------------------------------------------------
 * Copyright (c) 2018-2022 TypeFox GmbH (http://www.typefox.io). All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ function createWebSocketConnection(socket, logger) {
                const messageReader = new WebSocketMessageReader(socket);
                const messageWriter = new WebSocketMessageWriter(socket);
                const connection = (0, main.createMessageConnection)(messageReader, messageWriter, logger);
                connection.onClose(()=>connection.dispose());
                return connection;
            }
            //# sourceMappingURL=connection.js.map
            ; // CONCATENATED MODULE: ../../node_modules/vscode-ws-jsonrpc/lib/socket/index.js
            /* --------------------------------------------------------------------------------------------
 * Copyright (c) 2018-2022 TypeFox GmbH (http://www.typefox.io). All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ //# sourceMappingURL=index.js.map
            ; // CONCATENATED MODULE: ../../node_modules/vscode-ws-jsonrpc/lib/logger.js
            /* provided dependency */ var console = __nested_webpack_require_891277__(4364);
            class ConsoleLogger {
                error(message) {
                    console.error(message);
                }
                warn(message) {
                    console.warn(message);
                }
                info(message) {
                    console.info(message);
                }
                log(message) {
                    console.log(message);
                }
                debug(message) {
                    console.debug(message);
                }
            }
            //# sourceMappingURL=logger.js.map
            ; // CONCATENATED MODULE: ../../node_modules/vscode-ws-jsonrpc/lib/connection.js
            /* --------------------------------------------------------------------------------------------
 * Copyright (c) 2018-2022 TypeFox GmbH (http://www.typefox.io). All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ function listen(options) {
                const { webSocket, onConnection } = options;
                const logger = options.logger || new ConsoleLogger();
                webSocket.onopen = ()=>{
                    const socket = toSocket(webSocket);
                    const connection = createWebSocketConnection(socket, logger);
                    onConnection(connection);
                };
            }
            function toSocket(webSocket) {
                return {
                    send: (content)=>webSocket.send(content),
                    onMessage: (cb)=>{
                        webSocket.onmessage = (event)=>cb(event.data);
                    },
                    onError: (cb)=>{
                        webSocket.onerror = (event)=>{
                            if ('message' in event) {
                                cb(event.message);
                            }
                        };
                    },
                    onClose: (cb)=>{
                        webSocket.onclose = (event)=>cb(event.code, event.reason);
                    },
                    dispose: ()=>webSocket.close()
                };
            }
            //# sourceMappingURL=connection.js.map
            ; // CONCATENATED MODULE: ../../node_modules/vscode-ws-jsonrpc/lib/index.js
            /* --------------------------------------------------------------------------------------------
 * Copyright (c) 2018-2022 TypeFox GmbH (http://www.typefox.io). All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ //# sourceMappingURL=index.js.map
            // EXTERNAL MODULE: ../../node_modules/vscode-languageserver-protocol/lib/browser/main.js
            var browser_main = __nested_webpack_require_891277__(5501);
            // EXTERNAL MODULE: ../../node_modules/vscode-languageserver-protocol/browser.js
            var browser = __nested_webpack_require_891277__(8713);
            // EXTERNAL MODULE: ./src/services/base-service.ts
            var base_service = __nested_webpack_require_891277__(2125);
            ; // CONCATENATED MODULE: ./src/message-types.ts
            function _define_property1(obj, key, value) {
                if (key in obj) {
                    Object.defineProperty(obj, key, {
                        value: value,
                        enumerable: true,
                        configurable: true,
                        writable: true
                    });
                } else {
                    obj[key] = value;
                }
                return obj;
            }
            class BaseMessage {
                constructor(documentIdentifier, callbackId){
                    _define_property1(this, "sessionId", void 0);
                    _define_property1(this, "documentUri", void 0);
                    _define_property1(this, "version", void 0);
                    _define_property1(this, "callbackId", void 0);
                    this.sessionId = documentIdentifier.sessionId;
                    this.documentUri = documentIdentifier.documentUri;
                    this.callbackId = callbackId;
                }
            }
            class InitMessage extends BaseMessage {
                constructor(documentIdentifier, callbackId, value, version, mode, options){
                    super(documentIdentifier, callbackId);
                    _define_property1(this, "type", MessageType.init);
                    _define_property1(this, "mode", void 0);
                    _define_property1(this, "options", void 0);
                    _define_property1(this, "value", void 0);
                    _define_property1(this, "version", void 0);
                    this.version = version;
                    this.options = options;
                    this.mode = mode;
                    this.value = value;
                }
            }
            class FormatMessage extends BaseMessage {
                constructor(documentIdentifier, callbackId, value, format){
                    super(documentIdentifier, callbackId);
                    _define_property1(this, "type", MessageType.format);
                    _define_property1(this, "value", void 0);
                    _define_property1(this, "format", void 0);
                    this.value = value;
                    this.format = format;
                }
            }
            class CompleteMessage extends BaseMessage {
                constructor(documentIdentifier, callbackId, value){
                    super(documentIdentifier, callbackId);
                    _define_property1(this, "type", MessageType.complete);
                    _define_property1(this, "value", void 0);
                    this.value = value;
                }
            }
            class ResolveCompletionMessage extends BaseMessage {
                constructor(documentIdentifier, callbackId, value){
                    super(documentIdentifier, callbackId);
                    _define_property1(this, "type", MessageType.resolveCompletion);
                    _define_property1(this, "value", void 0);
                    this.value = value;
                }
            }
            class HoverMessage extends BaseMessage {
                constructor(documentIdentifier, callbackId, value){
                    super(documentIdentifier, callbackId);
                    _define_property1(this, "type", MessageType.hover);
                    _define_property1(this, "value", void 0);
                    this.value = value;
                }
            }
            class ValidateMessage extends BaseMessage {
                constructor(documentIdentifier, callbackId){
                    super(documentIdentifier, callbackId);
                    _define_property1(this, "type", MessageType.validate);
                }
            }
            class ChangeMessage extends BaseMessage {
                constructor(documentIdentifier, callbackId, value, version){
                    super(documentIdentifier, callbackId);
                    _define_property1(this, "type", MessageType.change);
                    _define_property1(this, "value", void 0);
                    _define_property1(this, "version", void 0);
                    this.value = value;
                    this.version = version;
                }
            }
            class DeltasMessage extends BaseMessage {
                constructor(documentIdentifier, callbackId, value, version){
                    super(documentIdentifier, callbackId);
                    _define_property1(this, "type", MessageType.applyDelta);
                    _define_property1(this, "value", void 0);
                    _define_property1(this, "version", void 0);
                    this.value = value;
                    this.version = version;
                }
            }
            class ChangeModeMessage extends BaseMessage {
                constructor(documentIdentifier, callbackId, value, version, mode){
                    super(documentIdentifier, callbackId);
                    _define_property1(this, "type", MessageType.changeMode);
                    _define_property1(this, "mode", void 0);
                    _define_property1(this, "value", void 0);
                    _define_property1(this, "version", void 0);
                    this.value = value;
                    this.mode = mode;
                    this.version = version;
                }
            }
            class ChangeOptionsMessage extends BaseMessage {
                constructor(documentIdentifier, callbackId, options, merge = false){
                    super(documentIdentifier, callbackId);
                    _define_property1(this, "type", MessageType.changeOptions);
                    _define_property1(this, "options", void 0);
                    _define_property1(this, "merge", void 0);
                    this.options = options;
                    this.merge = merge;
                }
            }
            class CloseDocumentMessage extends BaseMessage {
                constructor(documentIdentifier, callbackId){
                    super(documentIdentifier, callbackId);
                    _define_property1(this, "type", MessageType.closeDocument);
                }
            }
            class CloseConnectionMessage {
                constructor(callbackId){
                    _define_property1(this, "type", MessageType.closeConnection);
                    _define_property1(this, "callbackId", void 0);
                    this.callbackId = callbackId;
                }
            }
            class GlobalOptionsMessage {
                constructor(serviceName, options, merge){
                    _define_property1(this, "type", MessageType.globalOptions);
                    _define_property1(this, "serviceName", void 0);
                    _define_property1(this, "options", void 0);
                    _define_property1(this, "merge", void 0);
                    this.serviceName = serviceName;
                    this.options = options;
                    this.merge = merge;
                }
            }
            class ConfigureFeaturesMessage {
                constructor(serviceName, options){
                    _define_property1(this, "type", MessageType.configureFeatures);
                    _define_property1(this, "serviceName", void 0);
                    _define_property1(this, "options", void 0);
                    this.serviceName = serviceName;
                    this.options = options;
                }
            }
            class SignatureHelpMessage extends BaseMessage {
                constructor(documentIdentifier, callbackId, value){
                    super(documentIdentifier, callbackId);
                    _define_property1(this, "type", MessageType.signatureHelp);
                    _define_property1(this, "value", void 0);
                    this.value = value;
                }
            }
            class DocumentHighlightMessage extends BaseMessage {
                constructor(documentIdentifier, callbackId, value){
                    super(documentIdentifier, callbackId);
                    _define_property1(this, "type", MessageType.documentHighlight);
                    _define_property1(this, "value", void 0);
                    this.value = value;
                }
            }
            class GetSemanticTokensMessage extends BaseMessage {
                constructor(documentIdentifier, callbackId, value){
                    super(documentIdentifier, callbackId);
                    _define_property1(this, "type", MessageType.getSemanticTokens);
                    _define_property1(this, "value", void 0);
                    this.value = value;
                }
            }
            class GetCodeActionsMessage extends BaseMessage {
                constructor(documentIdentifier, callbackId, value, context){
                    super(documentIdentifier, callbackId);
                    _define_property1(this, "type", MessageType.getCodeActions);
                    _define_property1(this, "value", void 0);
                    _define_property1(this, "context", void 0);
                    this.value = value;
                    this.context = context;
                }
            }
            class SetWorkspaceMessage {
                constructor(value){
                    _define_property1(this, "type", MessageType.setWorkspace);
                    _define_property1(this, "value", void 0);
                    this.value = value;
                }
            }
            class ExecuteCommandMessage {
                constructor(serviceName, callbackId, command, args){
                    _define_property1(this, "callbackId", void 0);
                    _define_property1(this, "serviceName", void 0);
                    _define_property1(this, "type", MessageType.executeCommand);
                    _define_property1(this, "value", void 0);
                    _define_property1(this, "args", void 0);
                    this.serviceName = serviceName;
                    this.callbackId = callbackId;
                    this.value = command;
                    this.args = args;
                }
            }
            class AppliedEditMessage {
                constructor(value, serviceName, callbackId){
                    _define_property1(this, "callbackId", void 0);
                    _define_property1(this, "serviceName", void 0);
                    _define_property1(this, "type", MessageType.appliedEdit);
                    _define_property1(this, "value", void 0);
                    this.serviceName = serviceName;
                    this.callbackId = callbackId;
                    this.value = value;
                }
            }
            var MessageType;
            (function(MessageType) {
                MessageType[MessageType["init"] = 0] = "init";
                MessageType[MessageType["format"] = 1] = "format";
                MessageType[MessageType["complete"] = 2] = "complete";
                MessageType[MessageType["resolveCompletion"] = 3] = "resolveCompletion";
                MessageType[MessageType["change"] = 4] = "change";
                MessageType[MessageType["hover"] = 5] = "hover";
                MessageType[MessageType["validate"] = 6] = "validate";
                MessageType[MessageType["applyDelta"] = 7] = "applyDelta";
                MessageType[MessageType["changeMode"] = 8] = "changeMode";
                MessageType[MessageType["changeOptions"] = 9] = "changeOptions";
                MessageType[MessageType["closeDocument"] = 10] = "closeDocument";
                MessageType[MessageType["globalOptions"] = 11] = "globalOptions";
                MessageType[MessageType["configureFeatures"] = 12] = "configureFeatures";
                MessageType[MessageType["signatureHelp"] = 13] = "signatureHelp";
                MessageType[MessageType["documentHighlight"] = 14] = "documentHighlight";
                MessageType[MessageType["closeConnection"] = 15] = "closeConnection";
                MessageType[MessageType["capabilitiesChange"] = 16] = "capabilitiesChange";
                MessageType[MessageType["getSemanticTokens"] = 17] = "getSemanticTokens";
                MessageType[MessageType["getCodeActions"] = 18] = "getCodeActions";
                MessageType[MessageType["executeCommand"] = 19] = "executeCommand";
                MessageType[MessageType["applyEdit"] = 20] = "applyEdit";
                MessageType[MessageType["appliedEdit"] = 21] = "appliedEdit";
                MessageType[MessageType["setWorkspace"] = 22] = "setWorkspace";
            })(MessageType || (MessageType = {}));
            ; // CONCATENATED MODULE: ../../node_modules/vscode-uri/lib/esm/index.mjs
            /* provided dependency */ var process = __nested_webpack_require_891277__(9907);
            var LIB;
            (()=>{
                "use strict";
                var t = {
                    470: (t)=>{
                        function e(t) {
                            if ("string" != typeof t) throw new TypeError("Path must be a string. Received " + JSON.stringify(t));
                        }
                        function r(t, e) {
                            for(var r, n = "", i = 0, o = -1, s = 0, h = 0; h <= t.length; ++h){
                                if (h < t.length) r = t.charCodeAt(h);
                                else {
                                    if (47 === r) break;
                                    r = 47;
                                }
                                if (47 === r) {
                                    if (o === h - 1 || 1 === s) ;
                                    else if (o !== h - 1 && 2 === s) {
                                        if (n.length < 2 || 2 !== i || 46 !== n.charCodeAt(n.length - 1) || 46 !== n.charCodeAt(n.length - 2)) {
                                            if (n.length > 2) {
                                                var a = n.lastIndexOf("/");
                                                if (a !== n.length - 1) {
                                                    -1 === a ? (n = "", i = 0) : i = (n = n.slice(0, a)).length - 1 - n.lastIndexOf("/"), o = h, s = 0;
                                                    continue;
                                                }
                                            } else if (2 === n.length || 1 === n.length) {
                                                n = "", i = 0, o = h, s = 0;
                                                continue;
                                            }
                                        }
                                        e && (n.length > 0 ? n += "/.." : n = "..", i = 2);
                                    } else n.length > 0 ? n += "/" + t.slice(o + 1, h) : n = t.slice(o + 1, h), i = h - o - 1;
                                    o = h, s = 0;
                                } else 46 === r && -1 !== s ? ++s : s = -1;
                            }
                            return n;
                        }
                        var n = {
                            resolve: function() {
                                for(var t, n = "", i = !1, o = arguments.length - 1; o >= -1 && !i; o--){
                                    var s;
                                    o >= 0 ? s = arguments[o] : (void 0 === t && (t = process.cwd()), s = t), e(s), 0 !== s.length && (n = s + "/" + n, i = 47 === s.charCodeAt(0));
                                }
                                return n = r(n, !i), i ? n.length > 0 ? "/" + n : "/" : n.length > 0 ? n : ".";
                            },
                            normalize: function(t) {
                                if (e(t), 0 === t.length) return ".";
                                var n = 47 === t.charCodeAt(0), i = 47 === t.charCodeAt(t.length - 1);
                                return 0 !== (t = r(t, !n)).length || n || (t = "."), t.length > 0 && i && (t += "/"), n ? "/" + t : t;
                            },
                            isAbsolute: function(t) {
                                return e(t), t.length > 0 && 47 === t.charCodeAt(0);
                            },
                            join: function() {
                                if (0 === arguments.length) return ".";
                                for(var t, r = 0; r < arguments.length; ++r){
                                    var i = arguments[r];
                                    e(i), i.length > 0 && (void 0 === t ? t = i : t += "/" + i);
                                }
                                return void 0 === t ? "." : n.normalize(t);
                            },
                            relative: function(t, r) {
                                if (e(t), e(r), t === r) return "";
                                if ((t = n.resolve(t)) === (r = n.resolve(r))) return "";
                                for(var i = 1; i < t.length && 47 === t.charCodeAt(i); ++i);
                                for(var o = t.length, s = o - i, h = 1; h < r.length && 47 === r.charCodeAt(h); ++h);
                                for(var a = r.length - h, c = s < a ? s : a, f = -1, u = 0; u <= c; ++u){
                                    if (u === c) {
                                        if (a > c) {
                                            if (47 === r.charCodeAt(h + u)) return r.slice(h + u + 1);
                                            if (0 === u) return r.slice(h + u);
                                        } else s > c && (47 === t.charCodeAt(i + u) ? f = u : 0 === u && (f = 0));
                                        break;
                                    }
                                    var l = t.charCodeAt(i + u);
                                    if (l !== r.charCodeAt(h + u)) break;
                                    47 === l && (f = u);
                                }
                                var g = "";
                                for(u = i + f + 1; u <= o; ++u)u !== o && 47 !== t.charCodeAt(u) || (0 === g.length ? g += ".." : g += "/..");
                                return g.length > 0 ? g + r.slice(h + f) : (h += f, 47 === r.charCodeAt(h) && ++h, r.slice(h));
                            },
                            _makeLong: function(t) {
                                return t;
                            },
                            dirname: function(t) {
                                if (e(t), 0 === t.length) return ".";
                                for(var r = t.charCodeAt(0), n = 47 === r, i = -1, o = !0, s = t.length - 1; s >= 1; --s)if (47 === (r = t.charCodeAt(s))) {
                                    if (!o) {
                                        i = s;
                                        break;
                                    }
                                } else o = !1;
                                return -1 === i ? n ? "/" : "." : n && 1 === i ? "//" : t.slice(0, i);
                            },
                            basename: function(t, r) {
                                if (void 0 !== r && "string" != typeof r) throw new TypeError('"ext" argument must be a string');
                                e(t);
                                var n, i = 0, o = -1, s = !0;
                                if (void 0 !== r && r.length > 0 && r.length <= t.length) {
                                    if (r.length === t.length && r === t) return "";
                                    var h = r.length - 1, a = -1;
                                    for(n = t.length - 1; n >= 0; --n){
                                        var c = t.charCodeAt(n);
                                        if (47 === c) {
                                            if (!s) {
                                                i = n + 1;
                                                break;
                                            }
                                        } else -1 === a && (s = !1, a = n + 1), h >= 0 && (c === r.charCodeAt(h) ? -1 == --h && (o = n) : (h = -1, o = a));
                                    }
                                    return i === o ? o = a : -1 === o && (o = t.length), t.slice(i, o);
                                }
                                for(n = t.length - 1; n >= 0; --n)if (47 === t.charCodeAt(n)) {
                                    if (!s) {
                                        i = n + 1;
                                        break;
                                    }
                                } else -1 === o && (s = !1, o = n + 1);
                                return -1 === o ? "" : t.slice(i, o);
                            },
                            extname: function(t) {
                                e(t);
                                for(var r = -1, n = 0, i = -1, o = !0, s = 0, h = t.length - 1; h >= 0; --h){
                                    var a = t.charCodeAt(h);
                                    if (47 !== a) -1 === i && (o = !1, i = h + 1), 46 === a ? -1 === r ? r = h : 1 !== s && (s = 1) : -1 !== r && (s = -1);
                                    else if (!o) {
                                        n = h + 1;
                                        break;
                                    }
                                }
                                return -1 === r || -1 === i || 0 === s || 1 === s && r === i - 1 && r === n + 1 ? "" : t.slice(r, i);
                            },
                            format: function(t) {
                                if (null === t || "object" != typeof t) throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof t);
                                return function(t, e) {
                                    var r = e.dir || e.root, n = e.base || (e.name || "") + (e.ext || "");
                                    return r ? r === e.root ? r + n : r + "/" + n : n;
                                }(0, t);
                            },
                            parse: function(t) {
                                e(t);
                                var r = {
                                    root: "",
                                    dir: "",
                                    base: "",
                                    ext: "",
                                    name: ""
                                };
                                if (0 === t.length) return r;
                                var n, i = t.charCodeAt(0), o = 47 === i;
                                o ? (r.root = "/", n = 1) : n = 0;
                                for(var s = -1, h = 0, a = -1, c = !0, f = t.length - 1, u = 0; f >= n; --f)if (47 !== (i = t.charCodeAt(f))) -1 === a && (c = !1, a = f + 1), 46 === i ? -1 === s ? s = f : 1 !== u && (u = 1) : -1 !== s && (u = -1);
                                else if (!c) {
                                    h = f + 1;
                                    break;
                                }
                                return -1 === s || -1 === a || 0 === u || 1 === u && s === a - 1 && s === h + 1 ? -1 !== a && (r.base = r.name = 0 === h && o ? t.slice(1, a) : t.slice(h, a)) : (0 === h && o ? (r.name = t.slice(1, s), r.base = t.slice(1, a)) : (r.name = t.slice(h, s), r.base = t.slice(h, a)), r.ext = t.slice(s, a)), h > 0 ? r.dir = t.slice(0, h - 1) : o && (r.dir = "/"), r;
                            },
                            sep: "/",
                            delimiter: ":",
                            win32: null,
                            posix: null
                        };
                        n.posix = n, t.exports = n;
                    }
                }, e = {};
                function r(n) {
                    var i = e[n];
                    if (void 0 !== i) return i.exports;
                    var o = e[n] = {
                        exports: {}
                    };
                    return t[n](o, o.exports, r), o.exports;
                }
                r.d = (t, e)=>{
                    for(var n in e)r.o(e, n) && !r.o(t, n) && Object.defineProperty(t, n, {
                        enumerable: !0,
                        get: e[n]
                    });
                }, r.o = (t, e)=>Object.prototype.hasOwnProperty.call(t, e), r.r = (t)=>{
                    "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {
                        value: "Module"
                    }), Object.defineProperty(t, "__esModule", {
                        value: !0
                    });
                };
                var n = {};
                (()=>{
                    let t;
                    if (r.r(n), r.d(n, {
                        URI: ()=>f,
                        Utils: ()=>P
                    }), "object" == typeof process) t = "win32" === process.platform;
                    else if ("object" == typeof navigator) {
                        let e = navigator.userAgent;
                        t = e.indexOf("Windows") >= 0;
                    }
                    const e = /^\w[\w\d+.-]*$/, i = /^\//, o = /^\/\//;
                    function s(t, r) {
                        if (!t.scheme && r) throw new Error(`[UriError]: Scheme is missing: {scheme: "", authority: "${t.authority}", path: "${t.path}", query: "${t.query}", fragment: "${t.fragment}"}`);
                        if (t.scheme && !e.test(t.scheme)) throw new Error("[UriError]: Scheme contains illegal characters.");
                        if (t.path) {
                            if (t.authority) {
                                if (!i.test(t.path)) throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character');
                            } else if (o.test(t.path)) throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")');
                        }
                    }
                    const h = "", a = "/", c = /^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;
                    class f {
                        static isUri(t) {
                            return t instanceof f || !!t && "string" == typeof t.authority && "string" == typeof t.fragment && "string" == typeof t.path && "string" == typeof t.query && "string" == typeof t.scheme && "string" == typeof t.fsPath && "function" == typeof t.with && "function" == typeof t.toString;
                        }
                        get fsPath() {
                            return m(this, !1);
                        }
                        with(t) {
                            if (!t) return this;
                            let { scheme: e, authority: r, path: n, query: i, fragment: o } = t;
                            return void 0 === e ? e = this.scheme : null === e && (e = h), void 0 === r ? r = this.authority : null === r && (r = h), void 0 === n ? n = this.path : null === n && (n = h), void 0 === i ? i = this.query : null === i && (i = h), void 0 === o ? o = this.fragment : null === o && (o = h), e === this.scheme && r === this.authority && n === this.path && i === this.query && o === this.fragment ? this : new l(e, r, n, i, o);
                        }
                        static parse(t, e = !1) {
                            const r = c.exec(t);
                            return r ? new l(r[2] || h, C(r[4] || h), C(r[5] || h), C(r[7] || h), C(r[9] || h), e) : new l(h, h, h, h, h);
                        }
                        static file(e) {
                            let r = h;
                            if (t && (e = e.replace(/\\/g, a)), e[0] === a && e[1] === a) {
                                const t = e.indexOf(a, 2);
                                -1 === t ? (r = e.substring(2), e = a) : (r = e.substring(2, t), e = e.substring(t) || a);
                            }
                            return new l("file", r, e, h, h);
                        }
                        static from(t) {
                            const e = new l(t.scheme, t.authority, t.path, t.query, t.fragment);
                            return s(e, !0), e;
                        }
                        toString(t = !1) {
                            return y(this, t);
                        }
                        toJSON() {
                            return this;
                        }
                        static revive(t) {
                            if (t) {
                                if (t instanceof f) return t;
                                {
                                    const e = new l(t);
                                    return e._formatted = t.external, e._fsPath = t._sep === u ? t.fsPath : null, e;
                                }
                            }
                            return t;
                        }
                        constructor(t, e, r, n, i, o = !1){
                            _define_property(this, "scheme", void 0);
                            _define_property(this, "authority", void 0);
                            _define_property(this, "path", void 0);
                            _define_property(this, "query", void 0);
                            _define_property(this, "fragment", void 0);
                            "object" == typeof t ? (this.scheme = t.scheme || h, this.authority = t.authority || h, this.path = t.path || h, this.query = t.query || h, this.fragment = t.fragment || h) : (this.scheme = function(t, e) {
                                return t || e ? t : "file";
                            }(t, o), this.authority = e || h, this.path = function(t, e) {
                                switch(t){
                                    case "https":
                                    case "http":
                                    case "file":
                                        e ? e[0] !== a && (e = a + e) : e = a;
                                }
                                return e;
                            }(this.scheme, r || h), this.query = n || h, this.fragment = i || h, s(this, o));
                        }
                    }
                    const u = t ? 1 : void 0;
                    class l extends f {
                        get fsPath() {
                            return this._fsPath || (this._fsPath = m(this, !1)), this._fsPath;
                        }
                        toString(t = !1) {
                            return t ? y(this, !0) : (this._formatted || (this._formatted = y(this, !1)), this._formatted);
                        }
                        toJSON() {
                            const t = {
                                $mid: 1
                            };
                            return this._fsPath && (t.fsPath = this._fsPath, t._sep = u), this._formatted && (t.external = this._formatted), this.path && (t.path = this.path), this.scheme && (t.scheme = this.scheme), this.authority && (t.authority = this.authority), this.query && (t.query = this.query), this.fragment && (t.fragment = this.fragment), t;
                        }
                        constructor(...args){
                            super(...args);
                            _define_property(this, "_formatted", null);
                            _define_property(this, "_fsPath", null);
                        }
                    }
                    const g = {
                        58: "%3A",
                        47: "%2F",
                        63: "%3F",
                        35: "%23",
                        91: "%5B",
                        93: "%5D",
                        64: "%40",
                        33: "%21",
                        36: "%24",
                        38: "%26",
                        39: "%27",
                        40: "%28",
                        41: "%29",
                        42: "%2A",
                        43: "%2B",
                        44: "%2C",
                        59: "%3B",
                        61: "%3D",
                        32: "%20"
                    };
                    function d(t, e, r) {
                        let n, i = -1;
                        for(let o = 0; o < t.length; o++){
                            const s = t.charCodeAt(o);
                            if (s >= 97 && s <= 122 || s >= 65 && s <= 90 || s >= 48 && s <= 57 || 45 === s || 46 === s || 95 === s || 126 === s || e && 47 === s || r && 91 === s || r && 93 === s || r && 58 === s) -1 !== i && (n += encodeURIComponent(t.substring(i, o)), i = -1), void 0 !== n && (n += t.charAt(o));
                            else {
                                void 0 === n && (n = t.substr(0, o));
                                const e = g[s];
                                void 0 !== e ? (-1 !== i && (n += encodeURIComponent(t.substring(i, o)), i = -1), n += e) : -1 === i && (i = o);
                            }
                        }
                        return -1 !== i && (n += encodeURIComponent(t.substring(i))), void 0 !== n ? n : t;
                    }
                    function p(t) {
                        let e;
                        for(let r = 0; r < t.length; r++){
                            const n = t.charCodeAt(r);
                            35 === n || 63 === n ? (void 0 === e && (e = t.substr(0, r)), e += g[n]) : void 0 !== e && (e += t[r]);
                        }
                        return void 0 !== e ? e : t;
                    }
                    function m(e, r) {
                        let n;
                        return n = e.authority && e.path.length > 1 && "file" === e.scheme ? `//${e.authority}${e.path}` : 47 === e.path.charCodeAt(0) && (e.path.charCodeAt(1) >= 65 && e.path.charCodeAt(1) <= 90 || e.path.charCodeAt(1) >= 97 && e.path.charCodeAt(1) <= 122) && 58 === e.path.charCodeAt(2) ? r ? e.path.substr(1) : e.path[1].toLowerCase() + e.path.substr(2) : e.path, t && (n = n.replace(/\//g, "\\")), n;
                    }
                    function y(t, e) {
                        const r = e ? p : d;
                        let n = "", { scheme: i, authority: o, path: s, query: h, fragment: c } = t;
                        if (i && (n += i, n += ":"), (o || "file" === i) && (n += a, n += a), o) {
                            let t = o.indexOf("@");
                            if (-1 !== t) {
                                const e = o.substr(0, t);
                                o = o.substr(t + 1), t = e.lastIndexOf(":"), -1 === t ? n += r(e, !1, !1) : (n += r(e.substr(0, t), !1, !1), n += ":", n += r(e.substr(t + 1), !1, !0)), n += "@";
                            }
                            o = o.toLowerCase(), t = o.lastIndexOf(":"), -1 === t ? n += r(o, !1, !0) : (n += r(o.substr(0, t), !1, !0), n += o.substr(t));
                        }
                        if (s) {
                            if (s.length >= 3 && 47 === s.charCodeAt(0) && 58 === s.charCodeAt(2)) {
                                const t = s.charCodeAt(1);
                                t >= 65 && t <= 90 && (s = `/${String.fromCharCode(t + 32)}:${s.substr(3)}`);
                            } else if (s.length >= 2 && 58 === s.charCodeAt(1)) {
                                const t = s.charCodeAt(0);
                                t >= 65 && t <= 90 && (s = `${String.fromCharCode(t + 32)}:${s.substr(2)}`);
                            }
                            n += r(s, !0, !1);
                        }
                        return h && (n += "?", n += r(h, !1, !1)), c && (n += "#", n += e ? c : d(c, !1, !1)), n;
                    }
                    function v(t) {
                        try {
                            return decodeURIComponent(t);
                        } catch  {
                            return t.length > 3 ? t.substr(0, 3) + v(t.substr(3)) : t;
                        }
                    }
                    const b = /(%[0-9A-Za-z][0-9A-Za-z])+/g;
                    function C(t) {
                        return t.match(b) ? t.replace(b, (t)=>v(t)) : t;
                    }
                    var A = r(470);
                    const w = A.posix || A, x = "/";
                    var P;
                    !function(t) {
                        t.joinPath = function(t, ...e) {
                            return t.with({
                                path: w.join(t.path, ...e)
                            });
                        }, t.resolvePath = function(t, ...e) {
                            let r = t.path, n = !1;
                            r[0] !== x && (r = x + r, n = !0);
                            let i = w.resolve(r, ...e);
                            return n && i[0] === x && !t.authority && (i = i.substring(1)), t.with({
                                path: i
                            });
                        }, t.dirname = function(t) {
                            if (0 === t.path.length || t.path === x) return t;
                            let e = w.dirname(t.path);
                            return 1 === e.length && 46 === e.charCodeAt(0) && (e = ""), t.with({
                                path: e
                            });
                        }, t.basename = function(t) {
                            return w.basename(t.path);
                        }, t.extname = function(t) {
                            return w.extname(t.path);
                        };
                    }(P || (P = {}));
                })(), LIB = n;
            })();
            const { URI: language_client_URI, Utils } = LIB;
            //# sourceMappingURL=index.mjs.map
            ; // CONCATENATED MODULE: ./src/services/language-client.ts
            /* provided dependency */ var language_client_console = __nested_webpack_require_891277__(4364);
            function language_client_define_property(obj, key, value) {
                if (key in obj) {
                    Object.defineProperty(obj, key, {
                        value: value,
                        enumerable: true,
                        configurable: true,
                        writable: true
                    });
                } else {
                    obj[key] = value;
                }
                return obj;
            }
            class LanguageClient extends base_service.BaseService {
                $connect() {
                    switch(this.serverData.type){
                        case "webworker":
                            if ('worker' in this.serverData) {
                                this.$connectWorker(this.serverData.worker, this.serverData.initializationOptions);
                            } else {
                                throw new Error("No worker provided");
                            }
                            break;
                        case "socket":
                            if ('socket' in this.serverData) {
                                this.socket = this.serverData.socket;
                                this.$connectSocket(this.serverData.initializationOptions);
                            } else {
                                throw new Error("No socketUrl provided");
                            }
                            break;
                        default:
                            throw new Error("Unknown server type: " + this.serverData.type);
                    }
                }
                $connectSocket(initializationOptions) {
                    listen({
                        webSocket: this.socket,
                        onConnection: (connection)=>{
                            this.$initConnection(connection, initializationOptions);
                        }
                    });
                    if (this.socket.readyState === WebSocket.OPEN) this.socket.dispatchEvent(new Event('open'));
                }
                $connectWorker(worker, initializationOptions) {
                    const connection = (0, browser.createProtocolConnection)(new browser.BrowserMessageReader(worker), new browser.BrowserMessageWriter(worker));
                    this.$initConnection(connection, initializationOptions);
                }
                $initConnection(connection, initializationOptions) {
                    connection.listen();
                    this.isConnected = true;
                    this.connection = connection;
                    this.sendInitialize(initializationOptions);
                    this.connection.onNotification('textDocument/publishDiagnostics', (result)=>{
                        let postMessage = {
                            "type": MessageType.validate,
                            "documentUri": result.uri,
                            "value": result.diagnostics
                        };
                        this.ctx.postMessage(postMessage);
                    });
                    this.connection.onNotification('window/showMessage', (params)=>{
                        this.showLog(params);
                    });
                    this.connection.onNotification('window/logMessage', (params)=>{
                        this.showLog(params);
                    });
                    this.connection.onNotification('$/logTrace', (params)=>{
                        this.showTrace(params);
                    });
                    this.connection.onRequest('window/showMessageRequest', (params)=>{
                        this.showLog(params);
                    });
                    this.connection.onRequest('workspace/configuration', (params)=>{
                        language_client_console.log(params);
                    });
                    this.connection.onRequest('client/registerCapability', (params)=>{
                        language_client_console.log(params);
                    });
                    this.connection.onRequest('workspace/applyEdit', async (params)=>{
                        return new Promise((resolve, reject)=>{
                            const callbackId = this.callbackId++;
                            this.callbacks[callbackId] = (result)=>{
                                if (result.applied) {
                                    resolve(result);
                                } else {
                                    reject(new Error(result.failureReason));
                                }
                            };
                            let postMessage = {
                                "type": MessageType.applyEdit,
                                "serviceName": this.serviceName,
                                "value": params.edit,
                                "callbackId": callbackId
                            };
                            this.ctx.postMessage(postMessage);
                        });
                    });
                    this.connection.onError((e)=>{
                        throw e;
                    });
                    this.connection.onClose(()=>{
                        this.isConnected = false;
                    });
                }
                async $reconnect() {
                    Object.values(this.documents).forEach((document1)=>this.removeDocument(document1));
                    await this.dispose();
                    this.$connect();
                }
                sendAppliedResult(result, callbackId) {
                    if (!this.isConnected || !this.callbacks[callbackId]) {
                        return;
                    }
                    this.callbacks[callbackId](result);
                }
                showLog(params) {
                    switch(params.type){
                        case 1:
                            language_client_console.error(params.message);
                            break;
                        case 2:
                            language_client_console.warn(params.message);
                            break;
                        case 3:
                            language_client_console.info(params.message);
                            break;
                        case 4:
                        default:
                            language_client_console.log(params.message);
                            break;
                    }
                }
                showTrace(params) {
                    language_client_console.log(params.message);
                    if (params.verbose) {
                        language_client_console.log(params.verbose);
                    }
                }
                addDocument(document1) {
                    super.addDocument(document1);
                    const textDocumentMessage = {
                        textDocument: document1
                    };
                    this.enqueueIfNotConnected(()=>this.connection.sendNotification('textDocument/didOpen', textDocumentMessage));
                }
                enqueueIfNotConnected(callback) {
                    if (!this.isConnected || !this.isInitialized) {
                        this.requestsQueue.push(callback);
                    } else {
                        callback();
                    }
                }
                removeDocument(document1) {
                    super.removeDocument(document1);
                    this.enqueueIfNotConnected(()=>this.connection.sendNotification('textDocument/didClose', {
                            textDocument: {
                                uri: document1.uri
                            }
                        }));
                }
                async dispose() {
                    var _this_connection;
                    (_this_connection = this.connection) === null || _this_connection === void 0 ? void 0 : _this_connection.dispose();
                }
                async closeConnection() {
                    if (!this.connection) return;
                    await this.dispose();
                    await this.connection.sendRequest("shutdown");
                    await this.connection.sendNotification('exit');
                    if (this.socket) this.socket.close();
                    this.isConnected = false;
                }
                sendInitialize(initializationOptions) {
                    if (!this.isConnected) return;
                    const message = {
                        capabilities: this.clientCapabilities,
                        initializationOptions: initializationOptions,
                        processId: null,
                        rootUri: null
                    };
                    if (this.workspaceUri) {
                        message.workspaceFolders = [
                            this.workspaceFolder
                        ];
                    }
                    this.connection.sendRequest("initialize", message).then((params)=>{
                        this.isInitialized = true;
                        this.serviceCapabilities = params.capabilities;
                        const serviceName = this.serviceName;
                        Object.keys(this.documents).forEach((documentUri)=>{
                            const postMessage = {
                                "type": MessageType.capabilitiesChange,
                                "value": {
                                    [serviceName]: this.serviceCapabilities
                                },
                                documentUri: documentUri
                            };
                            this.ctx.postMessage(postMessage);
                        });
                        this.connection.sendNotification('initialized', {}).then(()=>{
                            this.connection.sendNotification('workspace/didChangeConfiguration', {
                                settings: {}
                            });
                            this.requestsQueue.forEach((requestCallback)=>requestCallback());
                            this.requestsQueue = [];
                        });
                    });
                }
                applyDeltas(identifier, deltas) {
                    var _this_serviceCapabilities, _this_serviceCapabilities1;
                    super.applyDeltas(identifier, deltas);
                    if (!this.isConnected || !this.serviceCapabilities) {
                        return;
                    }
                    if (((_this_serviceCapabilities = this.serviceCapabilities) === null || _this_serviceCapabilities === void 0 ? void 0 : _this_serviceCapabilities.textDocumentSync) === browser_main.TextDocumentSyncKind.None) {
                        return;
                    }
                    if (((_this_serviceCapabilities1 = this.serviceCapabilities) === null || _this_serviceCapabilities1 === void 0 ? void 0 : _this_serviceCapabilities1.textDocumentSync) !== browser_main.TextDocumentSyncKind.Incremental) {
                        return this.setValue(identifier, this.getDocument(identifier.uri).getText());
                    }
                    const textDocumentChange = {
                        textDocument: {
                            uri: identifier.uri,
                            version: identifier.version
                        },
                        contentChanges: deltas
                    };
                    this.connection.sendNotification('textDocument/didChange', textDocumentChange);
                }
                setValue(identifier, value) {
                    var _this_serviceCapabilities;
                    super.setValue(identifier, value);
                    if (!this.isConnected) {
                        return;
                    }
                    if (((_this_serviceCapabilities = this.serviceCapabilities) === null || _this_serviceCapabilities === void 0 ? void 0 : _this_serviceCapabilities.textDocumentSync) === browser_main.TextDocumentSyncKind.None) {
                        return;
                    }
                    const textDocumentChange = {
                        textDocument: {
                            uri: identifier.uri,
                            version: identifier.version
                        },
                        contentChanges: [
                            {
                                text: value
                            }
                        ]
                    };
                    this.connection.sendNotification('textDocument/didChange', textDocumentChange);
                }
                async doHover(document1, position) {
                    var _this_serviceCapabilities;
                    if (!this.isInitialized) {
                        return null;
                    }
                    if (!((_this_serviceCapabilities = this.serviceCapabilities) === null || _this_serviceCapabilities === void 0 ? void 0 : _this_serviceCapabilities.hoverProvider)) {
                        return null;
                    }
                    let options = {
                        textDocument: {
                            uri: document1.uri
                        },
                        position: position
                    };
                    return this.connection.sendRequest('textDocument/hover', options);
                }
                async doComplete(document1, position) {
                    var _this_serviceCapabilities;
                    if (!this.isInitialized) {
                        return null;
                    }
                    if (!((_this_serviceCapabilities = this.serviceCapabilities) === null || _this_serviceCapabilities === void 0 ? void 0 : _this_serviceCapabilities.completionProvider)) {
                        return null;
                    }
                    let options = {
                        textDocument: {
                            uri: document1.uri
                        },
                        position: position
                    };
                    return this.connection.sendRequest('textDocument/completion', options);
                }
                async doResolve(item) {
                    var _this_serviceCapabilities_completionProvider, _this_serviceCapabilities;
                    if (!this.isInitialized) return null;
                    if (!((_this_serviceCapabilities = this.serviceCapabilities) === null || _this_serviceCapabilities === void 0 ? void 0 : (_this_serviceCapabilities_completionProvider = _this_serviceCapabilities.completionProvider) === null || _this_serviceCapabilities_completionProvider === void 0 ? void 0 : _this_serviceCapabilities_completionProvider.resolveProvider)) return null;
                    return this.connection.sendRequest('completionItem/resolve', item["item"]);
                }
                async doValidation(document1) {
                    //TODO: textDocument/diagnostic capability
                    return [];
                }
                async format(document1, range, format) {
                    if (!this.isInitialized) {
                        return [];
                    }
                    if (!(this.serviceCapabilities && (this.serviceCapabilities.documentRangeFormattingProvider || this.serviceCapabilities.documentFormattingProvider))) {
                        return [];
                    }
                    if (!this.serviceCapabilities.documentRangeFormattingProvider) {
                        let options = {
                            textDocument: {
                                uri: document1.uri
                            },
                            options: format
                        };
                        return this.connection.sendRequest('textDocument/formatting', options);
                    } else {
                        let options = {
                            textDocument: {
                                uri: document1.uri
                            },
                            options: format,
                            range: range
                        };
                        return this.connection.sendRequest('textDocument/rangeFormatting', options);
                    }
                }
                setGlobalOptions(options) {
                    super.setGlobalOptions(options);
                    const configChanges = {
                        settings: options
                    };
                    this.enqueueIfNotConnected(()=>this.connection.sendNotification('workspace/didChangeConfiguration', configChanges));
                }
                setWorkspace(workspaceUri) {
                    var _this_serviceCapabilities_workspace_workspaceFolders, _this_serviceCapabilities_workspace, _this_serviceCapabilities;
                    super.setWorkspace(workspaceUri);
                    if (!((_this_serviceCapabilities = this.serviceCapabilities) === null || _this_serviceCapabilities === void 0 ? void 0 : (_this_serviceCapabilities_workspace = _this_serviceCapabilities.workspace) === null || _this_serviceCapabilities_workspace === void 0 ? void 0 : (_this_serviceCapabilities_workspace_workspaceFolders = _this_serviceCapabilities_workspace.workspaceFolders) === null || _this_serviceCapabilities_workspace_workspaceFolders === void 0 ? void 0 : _this_serviceCapabilities_workspace_workspaceFolders.changeNotifications)) {
                        return this.$reconnect();
                    }
                    const message = {
                        added: [
                            this.workspaceFolder
                        ],
                        removed: []
                    };
                    return this.connection.sendRequest('workspace/didChangeWorkspaceFolders', message);
                }
                get workspaceFolder() {
                    let workspaceUri = this.workspaceUri;
                    return {
                        uri: language_client_URI.file(workspaceUri).toString(),
                        name: workspaceUri.split("/").pop()
                    };
                }
                async findDocumentHighlights(document1, position) {
                    var _this_serviceCapabilities;
                    if (!this.isInitialized) return [];
                    if (!((_this_serviceCapabilities = this.serviceCapabilities) === null || _this_serviceCapabilities === void 0 ? void 0 : _this_serviceCapabilities.documentHighlightProvider)) return [];
                    let options = {
                        textDocument: {
                            uri: document1.uri
                        },
                        position: position
                    };
                    return this.connection.sendRequest('textDocument/documentHighlight', options);
                }
                async provideSignatureHelp(document1, position) {
                    var _this_serviceCapabilities;
                    if (!this.isInitialized) return null;
                    if (!((_this_serviceCapabilities = this.serviceCapabilities) === null || _this_serviceCapabilities === void 0 ? void 0 : _this_serviceCapabilities.signatureHelpProvider)) return null;
                    let options = {
                        textDocument: {
                            uri: document1.uri
                        },
                        position: position
                    };
                    return this.connection.sendRequest('textDocument/signatureHelp', options);
                }
                async getSemanticTokens(document1, range) {
                    var _this_serviceCapabilities;
                    if (!this.isInitialized) return null;
                    if (!((_this_serviceCapabilities = this.serviceCapabilities) === null || _this_serviceCapabilities === void 0 ? void 0 : _this_serviceCapabilities.semanticTokensProvider)) return null;
                    if (!this.serviceCapabilities.semanticTokensProvider.range) {
                        let options = {
                            textDocument: {
                                uri: document1.uri
                            }
                        };
                        return this.connection.sendRequest('textDocument/semanticTokens/full', options);
                    } else {
                        let options = {
                            textDocument: {
                                uri: document1.uri
                            },
                            range: range
                        };
                        return this.connection.sendRequest('textDocument/semanticTokens/range', options);
                    }
                }
                async getCodeActions(document1, range, context) {
                    var _this_serviceCapabilities;
                    if (!this.isInitialized) return null;
                    if (!((_this_serviceCapabilities = this.serviceCapabilities) === null || _this_serviceCapabilities === void 0 ? void 0 : _this_serviceCapabilities.codeActionProvider)) return null;
                    let options = {
                        textDocument: {
                            uri: document1.uri
                        },
                        range: range,
                        context: context
                    };
                    return this.connection.sendRequest('textDocument/codeAction', options);
                }
                executeCommand(command, args) {
                    var _this_serviceCapabilities, _this_serviceCapabilities1;
                    if (!this.isInitialized) return Promise.resolve(null);
                    if (!((_this_serviceCapabilities = this.serviceCapabilities) === null || _this_serviceCapabilities === void 0 ? void 0 : _this_serviceCapabilities.executeCommandProvider) || !((_this_serviceCapabilities1 = this.serviceCapabilities) === null || _this_serviceCapabilities1 === void 0 ? void 0 : _this_serviceCapabilities1.executeCommandProvider.commands.includes(command))) return Promise.resolve(null);
                    let options = {
                        command,
                        arguments: args
                    };
                    return this.connection.sendRequest('workspace/executeCommand', options);
                }
                constructor(serverData, ctx, workspaceUri){
                    super(serverData.modes, workspaceUri);
                    language_client_define_property(this, "$service", void 0);
                    language_client_define_property(this, "isConnected", false);
                    language_client_define_property(this, "isInitialized", false);
                    language_client_define_property(this, "socket", void 0);
                    language_client_define_property(this, "connection", void 0);
                    language_client_define_property(this, "requestsQueue", []);
                    language_client_define_property(this, "callbackId", 0);
                    language_client_define_property(this, "callbacks", {});
                    language_client_define_property(this, "serverData", void 0);
                    language_client_define_property(this, "ctx", void 0);
                    this.ctx = ctx;
                    this.serverData = serverData;
                    this.$connect();
                }
            }
        })();
        /******/ return __nested_webpack_exports__;
    /******/ })();
});


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0FBQztvQkFDcERBLGdDQUFnQyxJQUFJLEVBQUUsY0FBYyxLQUFLO29CQUN6REEsZ0NBQWdDLElBQUksRUFBRSxPQUFPLEtBQUs7b0JBQ2xELElBQUksQ0FBQy92RCxHQUFHLEdBQUdBO29CQUNYLElBQUksQ0FBQ2l3RCxVQUFVLEdBQUdBO29CQUNsQixJQUFJLENBQUNELFFBQVE7Z0JBQ2pCO1lBQ0o7UUFFQTtRQUVBLE1BQU0sR0FBSSxPQUFPL3lDLDBCQUFtQkE7SUFDcEMsTUFBTSxHQUFHO0FBRVQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hY2UtbGludGVycy1yb290Ly4vcGFja2FnZXMvYWNlLWxpbnRlcnMvYnVpbGQvbGFuZ3VhZ2UtY2xpZW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5KTtcblx0ZWxzZSB7XG5cdFx0dmFyIGEgPSBmYWN0b3J5KCk7XG5cdFx0Zm9yKHZhciBpIGluIGEpICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgPyBleHBvcnRzIDogcm9vdClbaV0gPSBhW2ldO1xuXHR9XG59KSh0aGlzLCAoKSA9PiB7XG5yZXR1cm4gLyoqKioqKi8gKCgpID0+IHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX21vZHVsZXNfXyA9ICh7XG5cbi8qKiovIDYwOTM6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogcHJvdmlkZWQgZGVwZW5kZW5jeSAqLyB2YXIgcHJvY2VzcyA9IF9fd2VicGFja19yZXF1aXJlX18oOTkwNyk7XG4vKiBwcm92aWRlZCBkZXBlbmRlbmN5ICovIHZhciBjb25zb2xlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MzY0KTtcbi8vIEN1cnJlbnRseSBpbiBzeW5jIHdpdGggTm9kZS5qcyBsaWIvYXNzZXJ0LmpzXG4vLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvY29tbWl0LzJhNTFhZTQyNGE1MTNlYzlhNmFhMzQ2NmJhYTBjYzFkNTVkZDRmM2Jcbi8vIE9yaWdpbmFsbHkgZnJvbSBuYXJ3aGFsLmpzIChodHRwOi8vbmFyd2hhbGpzLm9yZylcbi8vIENvcHlyaWdodCAoYykgMjAwOSBUaG9tYXMgUm9iaW5zb24gPDI4MG5vcnRoLmNvbT5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSAnU29mdHdhcmUnKSwgdG9cbi8vIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlXG4vLyByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Jcbi8vIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgJ0FTIElTJywgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4vLyBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OXG4vLyBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgX3JlcXVpcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzNDIpLFxuICAgIF9yZXF1aXJlJGNvZGVzID0gX3JlcXVpcmUuY29kZXMsXG4gICAgRVJSX0FNQklHVU9VU19BUkdVTUVOVCA9IF9yZXF1aXJlJGNvZGVzLkVSUl9BTUJJR1VPVVNfQVJHVU1FTlQsXG4gICAgRVJSX0lOVkFMSURfQVJHX1RZUEUgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfSU5WQUxJRF9BUkdfVFlQRSxcbiAgICBFUlJfSU5WQUxJRF9BUkdfVkFMVUUgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfSU5WQUxJRF9BUkdfVkFMVUUsXG4gICAgRVJSX0lOVkFMSURfUkVUVVJOX1ZBTFVFID0gX3JlcXVpcmUkY29kZXMuRVJSX0lOVkFMSURfUkVUVVJOX1ZBTFVFLFxuICAgIEVSUl9NSVNTSU5HX0FSR1MgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfTUlTU0lOR19BUkdTO1xuXG52YXIgQXNzZXJ0aW9uRXJyb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk4MDEpO1xuXG52YXIgX3JlcXVpcmUyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2ODI3KSxcbiAgICBpbnNwZWN0ID0gX3JlcXVpcmUyLmluc3BlY3Q7XG5cbnZhciBfcmVxdWlyZSR0eXBlcyA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDY4MjcpLnR5cGVzKSxcbiAgICBpc1Byb21pc2UgPSBfcmVxdWlyZSR0eXBlcy5pc1Byb21pc2UsXG4gICAgaXNSZWdFeHAgPSBfcmVxdWlyZSR0eXBlcy5pc1JlZ0V4cDtcblxudmFyIG9iamVjdEFzc2lnbiA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduIDogKF9fd2VicGFja19yZXF1aXJlX18oMzA0NikuYXNzaWduKTtcbnZhciBvYmplY3RJcyA9IE9iamVjdC5pcyA/IE9iamVjdC5pcyA6IF9fd2VicGFja19yZXF1aXJlX18oNTk2OCk7XG52YXIgZXJyb3JDYWNoZSA9IG5ldyBNYXAoKTtcbnZhciBpc0RlZXBFcXVhbDtcbnZhciBpc0RlZXBTdHJpY3RFcXVhbDtcbnZhciBwYXJzZUV4cHJlc3Npb25BdDtcbnZhciBmaW5kTm9kZUFyb3VuZDtcbnZhciBkZWNvZGVyO1xuXG5mdW5jdGlvbiBsYXp5TG9hZENvbXBhcmlzb24oKSB7XG4gIHZhciBjb21wYXJpc29uID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NjU2KTtcblxuICBpc0RlZXBFcXVhbCA9IGNvbXBhcmlzb24uaXNEZWVwRXF1YWw7XG4gIGlzRGVlcFN0cmljdEVxdWFsID0gY29tcGFyaXNvbi5pc0RlZXBTdHJpY3RFcXVhbDtcbn0gLy8gRXNjYXBlIGNvbnRyb2wgY2hhcmFjdGVycyBidXQgbm90IFxcbiBhbmQgXFx0IHRvIGtlZXAgdGhlIGxpbmUgYnJlYWtzIGFuZFxuLy8gaW5kZW50YXRpb24gaW50YWN0LlxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRyb2wtcmVnZXhcblxuXG52YXIgZXNjYXBlU2VxdWVuY2VzUmVnRXhwID0gL1tcXHgwMC1cXHgwOFxceDBiXFx4MGNcXHgwZS1cXHgxZl0vZztcbnZhciBtZXRhID0gKC8qIHVudXNlZCBwdXJlIGV4cHJlc3Npb24gb3Igc3VwZXIgKi8gbnVsbCAmJiAoW1wiXFxcXHUwMDAwXCIsIFwiXFxcXHUwMDAxXCIsIFwiXFxcXHUwMDAyXCIsIFwiXFxcXHUwMDAzXCIsIFwiXFxcXHUwMDA0XCIsIFwiXFxcXHUwMDA1XCIsIFwiXFxcXHUwMDA2XCIsIFwiXFxcXHUwMDA3XCIsICdcXFxcYicsICcnLCAnJywgXCJcXFxcdTAwMGJcIiwgJ1xcXFxmJywgJycsIFwiXFxcXHUwMDBlXCIsIFwiXFxcXHUwMDBmXCIsIFwiXFxcXHUwMDEwXCIsIFwiXFxcXHUwMDExXCIsIFwiXFxcXHUwMDEyXCIsIFwiXFxcXHUwMDEzXCIsIFwiXFxcXHUwMDE0XCIsIFwiXFxcXHUwMDE1XCIsIFwiXFxcXHUwMDE2XCIsIFwiXFxcXHUwMDE3XCIsIFwiXFxcXHUwMDE4XCIsIFwiXFxcXHUwMDE5XCIsIFwiXFxcXHUwMDFhXCIsIFwiXFxcXHUwMDFiXCIsIFwiXFxcXHUwMDFjXCIsIFwiXFxcXHUwMDFkXCIsIFwiXFxcXHUwMDFlXCIsIFwiXFxcXHUwMDFmXCJdKSk7XG5cbnZhciBlc2NhcGVGbiA9IGZ1bmN0aW9uIGVzY2FwZUZuKHN0cikge1xuICByZXR1cm4gbWV0YVtzdHIuY2hhckNvZGVBdCgwKV07XG59O1xuXG52YXIgd2FybmVkID0gZmFsc2U7IC8vIFRoZSBhc3NlcnQgbW9kdWxlIHByb3ZpZGVzIGZ1bmN0aW9ucyB0aGF0IHRocm93XG4vLyBBc3NlcnRpb25FcnJvcidzIHdoZW4gcGFydGljdWxhciBjb25kaXRpb25zIGFyZSBub3QgbWV0LiBUaGVcbi8vIGFzc2VydCBtb2R1bGUgbXVzdCBjb25mb3JtIHRvIHRoZSBmb2xsb3dpbmcgaW50ZXJmYWNlLlxuXG52YXIgYXNzZXJ0ID0gbW9kdWxlLmV4cG9ydHMgPSBvaztcbnZhciBOT19FWENFUFRJT05fU0VOVElORUwgPSB7fTsgLy8gQWxsIG9mIHRoZSBmb2xsb3dpbmcgZnVuY3Rpb25zIG11c3QgdGhyb3cgYW4gQXNzZXJ0aW9uRXJyb3Jcbi8vIHdoZW4gYSBjb3JyZXNwb25kaW5nIGNvbmRpdGlvbiBpcyBub3QgbWV0LCB3aXRoIGEgbWVzc2FnZSB0aGF0XG4vLyBtYXkgYmUgdW5kZWZpbmVkIGlmIG5vdCBwcm92aWRlZC4gQWxsIGFzc2VydGlvbiBtZXRob2RzIHByb3ZpZGVcbi8vIGJvdGggdGhlIGFjdHVhbCBhbmQgZXhwZWN0ZWQgdmFsdWVzIHRvIHRoZSBhc3NlcnRpb24gZXJyb3IgZm9yXG4vLyBkaXNwbGF5IHB1cnBvc2VzLlxuXG5mdW5jdGlvbiBpbm5lckZhaWwob2JqKSB7XG4gIGlmIChvYmoubWVzc2FnZSBpbnN0YW5jZW9mIEVycm9yKSB0aHJvdyBvYmoubWVzc2FnZTtcbiAgdGhyb3cgbmV3IEFzc2VydGlvbkVycm9yKG9iaik7XG59XG5cbmZ1bmN0aW9uIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgb3BlcmF0b3IsIHN0YWNrU3RhcnRGbikge1xuICB2YXIgYXJnc0xlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHZhciBpbnRlcm5hbE1lc3NhZ2U7XG5cbiAgaWYgKGFyZ3NMZW4gPT09IDApIHtcbiAgICBpbnRlcm5hbE1lc3NhZ2UgPSAnRmFpbGVkJztcbiAgfSBlbHNlIGlmIChhcmdzTGVuID09PSAxKSB7XG4gICAgbWVzc2FnZSA9IGFjdHVhbDtcbiAgICBhY3R1YWwgPSB1bmRlZmluZWQ7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHdhcm5lZCA9PT0gZmFsc2UpIHtcbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgICB2YXIgd2FybiA9IHByb2Nlc3MuZW1pdFdhcm5pbmcgPyBwcm9jZXNzLmVtaXRXYXJuaW5nIDogY29uc29sZS53YXJuLmJpbmQoY29uc29sZSk7XG4gICAgICB3YXJuKCdhc3NlcnQuZmFpbCgpIHdpdGggbW9yZSB0aGFuIG9uZSBhcmd1bWVudCBpcyBkZXByZWNhdGVkLiAnICsgJ1BsZWFzZSB1c2UgYXNzZXJ0LnN0cmljdEVxdWFsKCkgaW5zdGVhZCBvciBvbmx5IHBhc3MgYSBtZXNzYWdlLicsICdEZXByZWNhdGlvbldhcm5pbmcnLCAnREVQMDA5NCcpO1xuICAgIH1cblxuICAgIGlmIChhcmdzTGVuID09PSAyKSBvcGVyYXRvciA9ICchPSc7XG4gIH1cblxuICBpZiAobWVzc2FnZSBpbnN0YW5jZW9mIEVycm9yKSB0aHJvdyBtZXNzYWdlO1xuICB2YXIgZXJyQXJncyA9IHtcbiAgICBhY3R1YWw6IGFjdHVhbCxcbiAgICBleHBlY3RlZDogZXhwZWN0ZWQsXG4gICAgb3BlcmF0b3I6IG9wZXJhdG9yID09PSB1bmRlZmluZWQgPyAnZmFpbCcgOiBvcGVyYXRvcixcbiAgICBzdGFja1N0YXJ0Rm46IHN0YWNrU3RhcnRGbiB8fCBmYWlsXG4gIH07XG5cbiAgaWYgKG1lc3NhZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgIGVyckFyZ3MubWVzc2FnZSA9IG1lc3NhZ2U7XG4gIH1cblxuICB2YXIgZXJyID0gbmV3IEFzc2VydGlvbkVycm9yKGVyckFyZ3MpO1xuXG4gIGlmIChpbnRlcm5hbE1lc3NhZ2UpIHtcbiAgICBlcnIubWVzc2FnZSA9IGludGVybmFsTWVzc2FnZTtcbiAgICBlcnIuZ2VuZXJhdGVkTWVzc2FnZSA9IHRydWU7XG4gIH1cblxuICB0aHJvdyBlcnI7XG59XG5cbmFzc2VydC5mYWlsID0gZmFpbDsgLy8gVGhlIEFzc2VydGlvbkVycm9yIGlzIGRlZmluZWQgaW4gaW50ZXJuYWwvZXJyb3IuXG5cbmFzc2VydC5Bc3NlcnRpb25FcnJvciA9IEFzc2VydGlvbkVycm9yO1xuXG5mdW5jdGlvbiBpbm5lck9rKGZuLCBhcmdMZW4sIHZhbHVlLCBtZXNzYWdlKSB7XG4gIGlmICghdmFsdWUpIHtcbiAgICB2YXIgZ2VuZXJhdGVkTWVzc2FnZSA9IGZhbHNlO1xuXG4gICAgaWYgKGFyZ0xlbiA9PT0gMCkge1xuICAgICAgZ2VuZXJhdGVkTWVzc2FnZSA9IHRydWU7XG4gICAgICBtZXNzYWdlID0gJ05vIHZhbHVlIGFyZ3VtZW50IHBhc3NlZCB0byBgYXNzZXJ0Lm9rKClgJztcbiAgICB9IGVsc2UgaWYgKG1lc3NhZ2UgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgdGhyb3cgbWVzc2FnZTtcbiAgICB9XG5cbiAgICB2YXIgZXJyID0gbmV3IEFzc2VydGlvbkVycm9yKHtcbiAgICAgIGFjdHVhbDogdmFsdWUsXG4gICAgICBleHBlY3RlZDogdHJ1ZSxcbiAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICBvcGVyYXRvcjogJz09JyxcbiAgICAgIHN0YWNrU3RhcnRGbjogZm5cbiAgICB9KTtcbiAgICBlcnIuZ2VuZXJhdGVkTWVzc2FnZSA9IGdlbmVyYXRlZE1lc3NhZ2U7XG4gICAgdGhyb3cgZXJyO1xuICB9XG59IC8vIFB1cmUgYXNzZXJ0aW9uIHRlc3RzIHdoZXRoZXIgYSB2YWx1ZSBpcyB0cnV0aHksIGFzIGRldGVybWluZWRcbi8vIGJ5ICEhdmFsdWUuXG5cblxuZnVuY3Rpb24gb2soKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICBpbm5lck9rLmFwcGx5KHZvaWQgMCwgW29rLCBhcmdzLmxlbmd0aF0uY29uY2F0KGFyZ3MpKTtcbn1cblxuYXNzZXJ0Lm9rID0gb2s7IC8vIFRoZSBlcXVhbGl0eSBhc3NlcnRpb24gdGVzdHMgc2hhbGxvdywgY29lcmNpdmUgZXF1YWxpdHkgd2l0aCA9PS5cblxuLyogZXNsaW50LWRpc2FibGUgbm8tcmVzdHJpY3RlZC1wcm9wZXJ0aWVzICovXG5cbmFzc2VydC5lcXVhbCA9IGZ1bmN0aW9uIGVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgdGhyb3cgbmV3IEVSUl9NSVNTSU5HX0FSR1MoJ2FjdHVhbCcsICdleHBlY3RlZCcpO1xuICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcblxuXG4gIGlmIChhY3R1YWwgIT0gZXhwZWN0ZWQpIHtcbiAgICBpbm5lckZhaWwoe1xuICAgICAgYWN0dWFsOiBhY3R1YWwsXG4gICAgICBleHBlY3RlZDogZXhwZWN0ZWQsXG4gICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgb3BlcmF0b3I6ICc9PScsXG4gICAgICBzdGFja1N0YXJ0Rm46IGVxdWFsXG4gICAgfSk7XG4gIH1cbn07IC8vIFRoZSBub24tZXF1YWxpdHkgYXNzZXJ0aW9uIHRlc3RzIGZvciB3aGV0aGVyIHR3byBvYmplY3RzIGFyZSBub3Rcbi8vIGVxdWFsIHdpdGggIT0uXG5cblxuYXNzZXJ0Lm5vdEVxdWFsID0gZnVuY3Rpb24gbm90RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgRVJSX01JU1NJTkdfQVJHUygnYWN0dWFsJywgJ2V4cGVjdGVkJyk7XG4gIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuXG5cbiAgaWYgKGFjdHVhbCA9PSBleHBlY3RlZCkge1xuICAgIGlubmVyRmFpbCh7XG4gICAgICBhY3R1YWw6IGFjdHVhbCxcbiAgICAgIGV4cGVjdGVkOiBleHBlY3RlZCxcbiAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICBvcGVyYXRvcjogJyE9JyxcbiAgICAgIHN0YWNrU3RhcnRGbjogbm90RXF1YWxcbiAgICB9KTtcbiAgfVxufTsgLy8gVGhlIGVxdWl2YWxlbmNlIGFzc2VydGlvbiB0ZXN0cyBhIGRlZXAgZXF1YWxpdHkgcmVsYXRpb24uXG5cblxuYXNzZXJ0LmRlZXBFcXVhbCA9IGZ1bmN0aW9uIGRlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgIHRocm93IG5ldyBFUlJfTUlTU0lOR19BUkdTKCdhY3R1YWwnLCAnZXhwZWN0ZWQnKTtcbiAgfVxuXG4gIGlmIChpc0RlZXBFcXVhbCA9PT0gdW5kZWZpbmVkKSBsYXp5TG9hZENvbXBhcmlzb24oKTtcblxuICBpZiAoIWlzRGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQpKSB7XG4gICAgaW5uZXJGYWlsKHtcbiAgICAgIGFjdHVhbDogYWN0dWFsLFxuICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgIG9wZXJhdG9yOiAnZGVlcEVxdWFsJyxcbiAgICAgIHN0YWNrU3RhcnRGbjogZGVlcEVxdWFsXG4gICAgfSk7XG4gIH1cbn07IC8vIFRoZSBub24tZXF1aXZhbGVuY2UgYXNzZXJ0aW9uIHRlc3RzIGZvciBhbnkgZGVlcCBpbmVxdWFsaXR5LlxuXG5cbmFzc2VydC5ub3REZWVwRXF1YWwgPSBmdW5jdGlvbiBub3REZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgRVJSX01JU1NJTkdfQVJHUygnYWN0dWFsJywgJ2V4cGVjdGVkJyk7XG4gIH1cblxuICBpZiAoaXNEZWVwRXF1YWwgPT09IHVuZGVmaW5lZCkgbGF6eUxvYWRDb21wYXJpc29uKCk7XG5cbiAgaWYgKGlzRGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQpKSB7XG4gICAgaW5uZXJGYWlsKHtcbiAgICAgIGFjdHVhbDogYWN0dWFsLFxuICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgIG9wZXJhdG9yOiAnbm90RGVlcEVxdWFsJyxcbiAgICAgIHN0YWNrU3RhcnRGbjogbm90RGVlcEVxdWFsXG4gICAgfSk7XG4gIH1cbn07XG4vKiBlc2xpbnQtZW5hYmxlICovXG5cblxuYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbCA9IGZ1bmN0aW9uIGRlZXBTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgIHRocm93IG5ldyBFUlJfTUlTU0lOR19BUkdTKCdhY3R1YWwnLCAnZXhwZWN0ZWQnKTtcbiAgfVxuXG4gIGlmIChpc0RlZXBFcXVhbCA9PT0gdW5kZWZpbmVkKSBsYXp5TG9hZENvbXBhcmlzb24oKTtcblxuICBpZiAoIWlzRGVlcFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQpKSB7XG4gICAgaW5uZXJGYWlsKHtcbiAgICAgIGFjdHVhbDogYWN0dWFsLFxuICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgIG9wZXJhdG9yOiAnZGVlcFN0cmljdEVxdWFsJyxcbiAgICAgIHN0YWNrU3RhcnRGbjogZGVlcFN0cmljdEVxdWFsXG4gICAgfSk7XG4gIH1cbn07XG5cbmFzc2VydC5ub3REZWVwU3RyaWN0RXF1YWwgPSBub3REZWVwU3RyaWN0RXF1YWw7XG5cbmZ1bmN0aW9uIG5vdERlZXBTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgIHRocm93IG5ldyBFUlJfTUlTU0lOR19BUkdTKCdhY3R1YWwnLCAnZXhwZWN0ZWQnKTtcbiAgfVxuXG4gIGlmIChpc0RlZXBFcXVhbCA9PT0gdW5kZWZpbmVkKSBsYXp5TG9hZENvbXBhcmlzb24oKTtcblxuICBpZiAoaXNEZWVwU3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCkpIHtcbiAgICBpbm5lckZhaWwoe1xuICAgICAgYWN0dWFsOiBhY3R1YWwsXG4gICAgICBleHBlY3RlZDogZXhwZWN0ZWQsXG4gICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgb3BlcmF0b3I6ICdub3REZWVwU3RyaWN0RXF1YWwnLFxuICAgICAgc3RhY2tTdGFydEZuOiBub3REZWVwU3RyaWN0RXF1YWxcbiAgICB9KTtcbiAgfVxufVxuXG5hc3NlcnQuc3RyaWN0RXF1YWwgPSBmdW5jdGlvbiBzdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgIHRocm93IG5ldyBFUlJfTUlTU0lOR19BUkdTKCdhY3R1YWwnLCAnZXhwZWN0ZWQnKTtcbiAgfVxuXG4gIGlmICghb2JqZWN0SXMoYWN0dWFsLCBleHBlY3RlZCkpIHtcbiAgICBpbm5lckZhaWwoe1xuICAgICAgYWN0dWFsOiBhY3R1YWwsXG4gICAgICBleHBlY3RlZDogZXhwZWN0ZWQsXG4gICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgb3BlcmF0b3I6ICdzdHJpY3RFcXVhbCcsXG4gICAgICBzdGFja1N0YXJ0Rm46IHN0cmljdEVxdWFsXG4gICAgfSk7XG4gIH1cbn07XG5cbmFzc2VydC5ub3RTdHJpY3RFcXVhbCA9IGZ1bmN0aW9uIG5vdFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgdGhyb3cgbmV3IEVSUl9NSVNTSU5HX0FSR1MoJ2FjdHVhbCcsICdleHBlY3RlZCcpO1xuICB9XG5cbiAgaWYgKG9iamVjdElzKGFjdHVhbCwgZXhwZWN0ZWQpKSB7XG4gICAgaW5uZXJGYWlsKHtcbiAgICAgIGFjdHVhbDogYWN0dWFsLFxuICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgIG9wZXJhdG9yOiAnbm90U3RyaWN0RXF1YWwnLFxuICAgICAgc3RhY2tTdGFydEZuOiBub3RTdHJpY3RFcXVhbFxuICAgIH0pO1xuICB9XG59O1xuXG52YXIgQ29tcGFyaXNvbiA9IGZ1bmN0aW9uIENvbXBhcmlzb24ob2JqLCBrZXlzLCBhY3R1YWwpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29tcGFyaXNvbik7XG5cbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICBpZiAoa2V5IGluIG9iaikge1xuICAgICAgaWYgKGFjdHVhbCAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBhY3R1YWxba2V5XSA9PT0gJ3N0cmluZycgJiYgaXNSZWdFeHAob2JqW2tleV0pICYmIG9ialtrZXldLnRlc3QoYWN0dWFsW2tleV0pKSB7XG4gICAgICAgIF90aGlzW2tleV0gPSBhY3R1YWxba2V5XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF90aGlzW2tleV0gPSBvYmpba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufTtcblxuZnVuY3Rpb24gY29tcGFyZUV4Y2VwdGlvbktleShhY3R1YWwsIGV4cGVjdGVkLCBrZXksIG1lc3NhZ2UsIGtleXMsIGZuKSB7XG4gIGlmICghKGtleSBpbiBhY3R1YWwpIHx8ICFpc0RlZXBTdHJpY3RFcXVhbChhY3R1YWxba2V5XSwgZXhwZWN0ZWRba2V5XSkpIHtcbiAgICBpZiAoIW1lc3NhZ2UpIHtcbiAgICAgIC8vIENyZWF0ZSBwbGFjZWhvbGRlciBvYmplY3RzIHRvIGNyZWF0ZSBhIG5pY2Ugb3V0cHV0LlxuICAgICAgdmFyIGEgPSBuZXcgQ29tcGFyaXNvbihhY3R1YWwsIGtleXMpO1xuICAgICAgdmFyIGIgPSBuZXcgQ29tcGFyaXNvbihleHBlY3RlZCwga2V5cywgYWN0dWFsKTtcbiAgICAgIHZhciBlcnIgPSBuZXcgQXNzZXJ0aW9uRXJyb3Ioe1xuICAgICAgICBhY3R1YWw6IGEsXG4gICAgICAgIGV4cGVjdGVkOiBiLFxuICAgICAgICBvcGVyYXRvcjogJ2RlZXBTdHJpY3RFcXVhbCcsXG4gICAgICAgIHN0YWNrU3RhcnRGbjogZm5cbiAgICAgIH0pO1xuICAgICAgZXJyLmFjdHVhbCA9IGFjdHVhbDtcbiAgICAgIGVyci5leHBlY3RlZCA9IGV4cGVjdGVkO1xuICAgICAgZXJyLm9wZXJhdG9yID0gZm4ubmFtZTtcbiAgICAgIHRocm93IGVycjtcbiAgICB9XG5cbiAgICBpbm5lckZhaWwoe1xuICAgICAgYWN0dWFsOiBhY3R1YWwsXG4gICAgICBleHBlY3RlZDogZXhwZWN0ZWQsXG4gICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgb3BlcmF0b3I6IGZuLm5hbWUsXG4gICAgICBzdGFja1N0YXJ0Rm46IGZuXG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZXhwZWN0ZWRFeGNlcHRpb24oYWN0dWFsLCBleHBlY3RlZCwgbXNnLCBmbikge1xuICBpZiAodHlwZW9mIGV4cGVjdGVkICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKGlzUmVnRXhwKGV4cGVjdGVkKSkgcmV0dXJuIGV4cGVjdGVkLnRlc3QoYWN0dWFsKTsgLy8gYXNzZXJ0LmRvZXNOb3RUaHJvdyBkb2VzIG5vdCBhY2NlcHQgb2JqZWN0cy5cblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoJ2V4cGVjdGVkJywgWydGdW5jdGlvbicsICdSZWdFeHAnXSwgZXhwZWN0ZWQpO1xuICAgIH0gLy8gSGFuZGxlIHByaW1pdGl2ZXMgcHJvcGVybHkuXG5cblxuICAgIGlmIChfdHlwZW9mKGFjdHVhbCkgIT09ICdvYmplY3QnIHx8IGFjdHVhbCA9PT0gbnVsbCkge1xuICAgICAgdmFyIGVyciA9IG5ldyBBc3NlcnRpb25FcnJvcih7XG4gICAgICAgIGFjdHVhbDogYWN0dWFsLFxuICAgICAgICBleHBlY3RlZDogZXhwZWN0ZWQsXG4gICAgICAgIG1lc3NhZ2U6IG1zZyxcbiAgICAgICAgb3BlcmF0b3I6ICdkZWVwU3RyaWN0RXF1YWwnLFxuICAgICAgICBzdGFja1N0YXJ0Rm46IGZuXG4gICAgICB9KTtcbiAgICAgIGVyci5vcGVyYXRvciA9IGZuLm5hbWU7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuXG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhleHBlY3RlZCk7IC8vIFNwZWNpYWwgaGFuZGxlIGVycm9ycyB0byBtYWtlIHN1cmUgdGhlIG5hbWUgYW5kIHRoZSBtZXNzYWdlIGFyZSBjb21wYXJlZFxuICAgIC8vIGFzIHdlbGwuXG5cbiAgICBpZiAoZXhwZWN0ZWQgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAga2V5cy5wdXNoKCduYW1lJywgJ21lc3NhZ2UnKTtcbiAgICB9IGVsc2UgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1ZBTFVFKCdlcnJvcicsIGV4cGVjdGVkLCAnbWF5IG5vdCBiZSBhbiBlbXB0eSBvYmplY3QnKTtcbiAgICB9XG5cbiAgICBpZiAoaXNEZWVwRXF1YWwgPT09IHVuZGVmaW5lZCkgbGF6eUxvYWRDb21wYXJpc29uKCk7XG4gICAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIGlmICh0eXBlb2YgYWN0dWFsW2tleV0gPT09ICdzdHJpbmcnICYmIGlzUmVnRXhwKGV4cGVjdGVkW2tleV0pICYmIGV4cGVjdGVkW2tleV0udGVzdChhY3R1YWxba2V5XSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb21wYXJlRXhjZXB0aW9uS2V5KGFjdHVhbCwgZXhwZWN0ZWQsIGtleSwgbXNnLCBrZXlzLCBmbik7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gR3VhcmQgaW5zdGFuY2VvZiBhZ2FpbnN0IGFycm93IGZ1bmN0aW9ucyBhcyB0aGV5IGRvbid0IGhhdmUgYSBwcm90b3R5cGUuXG5cblxuICBpZiAoZXhwZWN0ZWQucHJvdG90eXBlICE9PSB1bmRlZmluZWQgJiYgYWN0dWFsIGluc3RhbmNlb2YgZXhwZWN0ZWQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChFcnJvci5pc1Byb3RvdHlwZU9mKGV4cGVjdGVkKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBleHBlY3RlZC5jYWxsKHt9LCBhY3R1YWwpID09PSB0cnVlO1xufVxuXG5mdW5jdGlvbiBnZXRBY3R1YWwoZm4pIHtcbiAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRSgnZm4nLCAnRnVuY3Rpb24nLCBmbik7XG4gIH1cblxuICB0cnkge1xuICAgIGZuKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZTtcbiAgfVxuXG4gIHJldHVybiBOT19FWENFUFRJT05fU0VOVElORUw7XG59XG5cbmZ1bmN0aW9uIGNoZWNrSXNQcm9taXNlKG9iaikge1xuICAvLyBBY2NlcHQgbmF0aXZlIEVTNiBwcm9taXNlcyBhbmQgcHJvbWlzZXMgdGhhdCBhcmUgaW1wbGVtZW50ZWQgaW4gYSBzaW1pbGFyXG4gIC8vIHdheS4gRG8gbm90IGFjY2VwdCB0aGVuYWJsZXMgdGhhdCB1c2UgYSBmdW5jdGlvbiBhcyBgb2JqYCBhbmQgdGhhdCBoYXZlIG5vXG4gIC8vIGBjYXRjaGAgaGFuZGxlci5cbiAgLy8gVE9ETzogdGhlbmFibGVzIGFyZSBjaGVja2VkIHVwIHVudGlsIHRoZXkgaGF2ZSB0aGUgY29ycmVjdCBtZXRob2RzLFxuICAvLyBidXQgYWNjb3JkaW5nIHRvIGRvY3VtZW50YXRpb24sIHRoZSBgdGhlbmAgbWV0aG9kIHNob3VsZCByZWNlaXZlXG4gIC8vIHRoZSBgZnVsZmlsbGAgYW5kIGByZWplY3RgIGFyZ3VtZW50cyBhcyB3ZWxsIG9yIGl0IG1heSBiZSBuZXZlciByZXNvbHZlZC5cbiAgcmV0dXJuIGlzUHJvbWlzZShvYmopIHx8IG9iaiAhPT0gbnVsbCAmJiBfdHlwZW9mKG9iaikgPT09ICdvYmplY3QnICYmIHR5cGVvZiBvYmoudGhlbiA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygb2JqLmNhdGNoID09PSAnZnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiB3YWl0Rm9yQWN0dWFsKHByb21pc2VGbikge1xuICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJlc3VsdFByb21pc2U7XG5cbiAgICBpZiAodHlwZW9mIHByb21pc2VGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gUmV0dXJuIGEgcmVqZWN0ZWQgcHJvbWlzZSBpZiBgcHJvbWlzZUZuYCB0aHJvd3Mgc3luY2hyb25vdXNseS5cbiAgICAgIHJlc3VsdFByb21pc2UgPSBwcm9taXNlRm4oKTsgLy8gRmFpbCBpbiBjYXNlIG5vIHByb21pc2UgaXMgcmV0dXJuZWQuXG5cbiAgICAgIGlmICghY2hlY2tJc1Byb21pc2UocmVzdWx0UHJvbWlzZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX1JFVFVSTl9WQUxVRSgnaW5zdGFuY2Ugb2YgUHJvbWlzZScsICdwcm9taXNlRm4nLCByZXN1bHRQcm9taXNlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNoZWNrSXNQcm9taXNlKHByb21pc2VGbikpIHtcbiAgICAgIHJlc3VsdFByb21pc2UgPSBwcm9taXNlRm47XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRSgncHJvbWlzZUZuJywgWydGdW5jdGlvbicsICdQcm9taXNlJ10sIHByb21pc2VGbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHJlc3VsdFByb21pc2U7XG4gICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gTk9fRVhDRVBUSU9OX1NFTlRJTkVMO1xuICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICByZXR1cm4gZTtcbiAgICB9KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGV4cGVjdHNFcnJvcihzdGFja1N0YXJ0Rm4sIGFjdHVhbCwgZXJyb3IsIG1lc3NhZ2UpIHtcbiAgaWYgKHR5cGVvZiBlcnJvciA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gNCkge1xuICAgICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKCdlcnJvcicsIFsnT2JqZWN0JywgJ0Vycm9yJywgJ0Z1bmN0aW9uJywgJ1JlZ0V4cCddLCBlcnJvcik7XG4gICAgfVxuXG4gICAgaWYgKF90eXBlb2YoYWN0dWFsKSA9PT0gJ29iamVjdCcgJiYgYWN0dWFsICE9PSBudWxsKSB7XG4gICAgICBpZiAoYWN0dWFsLm1lc3NhZ2UgPT09IGVycm9yKSB7XG4gICAgICAgIHRocm93IG5ldyBFUlJfQU1CSUdVT1VTX0FSR1VNRU5UKCdlcnJvci9tZXNzYWdlJywgXCJUaGUgZXJyb3IgbWVzc2FnZSBcXFwiXCIuY29uY2F0KGFjdHVhbC5tZXNzYWdlLCBcIlxcXCIgaXMgaWRlbnRpY2FsIHRvIHRoZSBtZXNzYWdlLlwiKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChhY3R1YWwgPT09IGVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRVJSX0FNQklHVU9VU19BUkdVTUVOVCgnZXJyb3IvbWVzc2FnZScsIFwiVGhlIGVycm9yIFxcXCJcIi5jb25jYXQoYWN0dWFsLCBcIlxcXCIgaXMgaWRlbnRpY2FsIHRvIHRoZSBtZXNzYWdlLlwiKSk7XG4gICAgfVxuXG4gICAgbWVzc2FnZSA9IGVycm9yO1xuICAgIGVycm9yID0gdW5kZWZpbmVkO1xuICB9IGVsc2UgaWYgKGVycm9yICE9IG51bGwgJiYgX3R5cGVvZihlcnJvcikgIT09ICdvYmplY3QnICYmIHR5cGVvZiBlcnJvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRSgnZXJyb3InLCBbJ09iamVjdCcsICdFcnJvcicsICdGdW5jdGlvbicsICdSZWdFeHAnXSwgZXJyb3IpO1xuICB9XG5cbiAgaWYgKGFjdHVhbCA9PT0gTk9fRVhDRVBUSU9OX1NFTlRJTkVMKSB7XG4gICAgdmFyIGRldGFpbHMgPSAnJztcblxuICAgIGlmIChlcnJvciAmJiBlcnJvci5uYW1lKSB7XG4gICAgICBkZXRhaWxzICs9IFwiIChcIi5jb25jYXQoZXJyb3IubmFtZSwgXCIpXCIpO1xuICAgIH1cblxuICAgIGRldGFpbHMgKz0gbWVzc2FnZSA/IFwiOiBcIi5jb25jYXQobWVzc2FnZSkgOiAnLic7XG4gICAgdmFyIGZuVHlwZSA9IHN0YWNrU3RhcnRGbi5uYW1lID09PSAncmVqZWN0cycgPyAncmVqZWN0aW9uJyA6ICdleGNlcHRpb24nO1xuICAgIGlubmVyRmFpbCh7XG4gICAgICBhY3R1YWw6IHVuZGVmaW5lZCxcbiAgICAgIGV4cGVjdGVkOiBlcnJvcixcbiAgICAgIG9wZXJhdG9yOiBzdGFja1N0YXJ0Rm4ubmFtZSxcbiAgICAgIG1lc3NhZ2U6IFwiTWlzc2luZyBleHBlY3RlZCBcIi5jb25jYXQoZm5UeXBlKS5jb25jYXQoZGV0YWlscyksXG4gICAgICBzdGFja1N0YXJ0Rm46IHN0YWNrU3RhcnRGblxuICAgIH0pO1xuICB9XG5cbiAgaWYgKGVycm9yICYmICFleHBlY3RlZEV4Y2VwdGlvbihhY3R1YWwsIGVycm9yLCBtZXNzYWdlLCBzdGFja1N0YXJ0Rm4pKSB7XG4gICAgdGhyb3cgYWN0dWFsO1xuICB9XG59XG5cbmZ1bmN0aW9uIGV4cGVjdHNOb0Vycm9yKHN0YWNrU3RhcnRGbiwgYWN0dWFsLCBlcnJvciwgbWVzc2FnZSkge1xuICBpZiAoYWN0dWFsID09PSBOT19FWENFUFRJT05fU0VOVElORUwpIHJldHVybjtcblxuICBpZiAodHlwZW9mIGVycm9yID09PSAnc3RyaW5nJykge1xuICAgIG1lc3NhZ2UgPSBlcnJvcjtcbiAgICBlcnJvciA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmICghZXJyb3IgfHwgZXhwZWN0ZWRFeGNlcHRpb24oYWN0dWFsLCBlcnJvcikpIHtcbiAgICB2YXIgZGV0YWlscyA9IG1lc3NhZ2UgPyBcIjogXCIuY29uY2F0KG1lc3NhZ2UpIDogJy4nO1xuICAgIHZhciBmblR5cGUgPSBzdGFja1N0YXJ0Rm4ubmFtZSA9PT0gJ2RvZXNOb3RSZWplY3QnID8gJ3JlamVjdGlvbicgOiAnZXhjZXB0aW9uJztcbiAgICBpbm5lckZhaWwoe1xuICAgICAgYWN0dWFsOiBhY3R1YWwsXG4gICAgICBleHBlY3RlZDogZXJyb3IsXG4gICAgICBvcGVyYXRvcjogc3RhY2tTdGFydEZuLm5hbWUsXG4gICAgICBtZXNzYWdlOiBcIkdvdCB1bndhbnRlZCBcIi5jb25jYXQoZm5UeXBlKS5jb25jYXQoZGV0YWlscywgXCJcXG5cIikgKyBcIkFjdHVhbCBtZXNzYWdlOiBcXFwiXCIuY29uY2F0KGFjdHVhbCAmJiBhY3R1YWwubWVzc2FnZSwgXCJcXFwiXCIpLFxuICAgICAgc3RhY2tTdGFydEZuOiBzdGFja1N0YXJ0Rm5cbiAgICB9KTtcbiAgfVxuXG4gIHRocm93IGFjdHVhbDtcbn1cblxuYXNzZXJ0LnRocm93cyA9IGZ1bmN0aW9uIHRocm93cyhwcm9taXNlRm4pIHtcbiAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLCBfa2V5MiA9IDE7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICB9XG5cbiAgZXhwZWN0c0Vycm9yLmFwcGx5KHZvaWQgMCwgW3Rocm93cywgZ2V0QWN0dWFsKHByb21pc2VGbildLmNvbmNhdChhcmdzKSk7XG59O1xuXG5hc3NlcnQucmVqZWN0cyA9IGZ1bmN0aW9uIHJlamVjdHMocHJvbWlzZUZuKSB7XG4gIGZvciAodmFyIF9sZW4zID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMyA+IDEgPyBfbGVuMyAtIDEgOiAwKSwgX2tleTMgPSAxOyBfa2V5MyA8IF9sZW4zOyBfa2V5MysrKSB7XG4gICAgYXJnc1tfa2V5MyAtIDFdID0gYXJndW1lbnRzW19rZXkzXTtcbiAgfVxuXG4gIHJldHVybiB3YWl0Rm9yQWN0dWFsKHByb21pc2VGbikudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgcmV0dXJuIGV4cGVjdHNFcnJvci5hcHBseSh2b2lkIDAsIFtyZWplY3RzLCByZXN1bHRdLmNvbmNhdChhcmdzKSk7XG4gIH0pO1xufTtcblxuYXNzZXJ0LmRvZXNOb3RUaHJvdyA9IGZ1bmN0aW9uIGRvZXNOb3RUaHJvdyhmbikge1xuICBmb3IgKHZhciBfbGVuNCA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjQgPiAxID8gX2xlbjQgLSAxIDogMCksIF9rZXk0ID0gMTsgX2tleTQgPCBfbGVuNDsgX2tleTQrKykge1xuICAgIGFyZ3NbX2tleTQgLSAxXSA9IGFyZ3VtZW50c1tfa2V5NF07XG4gIH1cblxuICBleHBlY3RzTm9FcnJvci5hcHBseSh2b2lkIDAsIFtkb2VzTm90VGhyb3csIGdldEFjdHVhbChmbildLmNvbmNhdChhcmdzKSk7XG59O1xuXG5hc3NlcnQuZG9lc05vdFJlamVjdCA9IGZ1bmN0aW9uIGRvZXNOb3RSZWplY3QoZm4pIHtcbiAgZm9yICh2YXIgX2xlbjUgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW41ID4gMSA/IF9sZW41IC0gMSA6IDApLCBfa2V5NSA9IDE7IF9rZXk1IDwgX2xlbjU7IF9rZXk1KyspIHtcbiAgICBhcmdzW19rZXk1IC0gMV0gPSBhcmd1bWVudHNbX2tleTVdO1xuICB9XG5cbiAgcmV0dXJuIHdhaXRGb3JBY3R1YWwoZm4pLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgIHJldHVybiBleHBlY3RzTm9FcnJvci5hcHBseSh2b2lkIDAsIFtkb2VzTm90UmVqZWN0LCByZXN1bHRdLmNvbmNhdChhcmdzKSk7XG4gIH0pO1xufTtcblxuYXNzZXJ0LmlmRXJyb3IgPSBmdW5jdGlvbiBpZkVycm9yKGVycikge1xuICBpZiAoZXJyICE9PSBudWxsICYmIGVyciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIG1lc3NhZ2UgPSAnaWZFcnJvciBnb3QgdW53YW50ZWQgZXhjZXB0aW9uOiAnO1xuXG4gICAgaWYgKF90eXBlb2YoZXJyKSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGVyci5tZXNzYWdlID09PSAnc3RyaW5nJykge1xuICAgICAgaWYgKGVyci5tZXNzYWdlLmxlbmd0aCA9PT0gMCAmJiBlcnIuY29uc3RydWN0b3IpIHtcbiAgICAgICAgbWVzc2FnZSArPSBlcnIuY29uc3RydWN0b3IubmFtZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1lc3NhZ2UgKz0gZXJyLm1lc3NhZ2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG1lc3NhZ2UgKz0gaW5zcGVjdChlcnIpO1xuICAgIH1cblxuICAgIHZhciBuZXdFcnIgPSBuZXcgQXNzZXJ0aW9uRXJyb3Ioe1xuICAgICAgYWN0dWFsOiBlcnIsXG4gICAgICBleHBlY3RlZDogbnVsbCxcbiAgICAgIG9wZXJhdG9yOiAnaWZFcnJvcicsXG4gICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgc3RhY2tTdGFydEZuOiBpZkVycm9yXG4gICAgfSk7IC8vIE1ha2Ugc3VyZSB3ZSBhY3R1YWxseSBoYXZlIGEgc3RhY2sgdHJhY2UhXG5cbiAgICB2YXIgb3JpZ1N0YWNrID0gZXJyLnN0YWNrO1xuXG4gICAgaWYgKHR5cGVvZiBvcmlnU3RhY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBUaGlzIHdpbGwgcmVtb3ZlIGFueSBkdXBsaWNhdGVkIGZyYW1lcyBmcm9tIHRoZSBlcnJvciBmcmFtZXMgdGFrZW5cbiAgICAgIC8vIGZyb20gd2l0aGluIGBpZkVycm9yYCBhbmQgYWRkIHRoZSBvcmlnaW5hbCBlcnJvciBmcmFtZXMgdG8gdGhlIG5ld2x5XG4gICAgICAvLyBjcmVhdGVkIG9uZXMuXG4gICAgICB2YXIgdG1wMiA9IG9yaWdTdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICB0bXAyLnNoaWZ0KCk7IC8vIEZpbHRlciBhbGwgZnJhbWVzIGV4aXN0aW5nIGluIGVyci5zdGFjay5cblxuICAgICAgdmFyIHRtcDEgPSBuZXdFcnIuc3RhY2suc3BsaXQoJ1xcbicpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRtcDIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gRmluZCB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiB0aGUgZnJhbWUuXG4gICAgICAgIHZhciBwb3MgPSB0bXAxLmluZGV4T2YodG1wMltpXSk7XG5cbiAgICAgICAgaWYgKHBvcyAhPT0gLTEpIHtcbiAgICAgICAgICAvLyBPbmx5IGtlZXAgbmV3IGZyYW1lcy5cbiAgICAgICAgICB0bXAxID0gdG1wMS5zbGljZSgwLCBwb3MpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG5ld0Vyci5zdGFjayA9IFwiXCIuY29uY2F0KHRtcDEuam9pbignXFxuJyksIFwiXFxuXCIpLmNvbmNhdCh0bXAyLmpvaW4oJ1xcbicpKTtcbiAgICB9XG5cbiAgICB0aHJvdyBuZXdFcnI7XG4gIH1cbn07IC8vIEV4cG9zZSBhIHN0cmljdCBvbmx5IHZhcmlhbnQgb2YgYXNzZXJ0XG5cblxuZnVuY3Rpb24gc3RyaWN0KCkge1xuICBmb3IgKHZhciBfbGVuNiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjYpLCBfa2V5NiA9IDA7IF9rZXk2IDwgX2xlbjY7IF9rZXk2KyspIHtcbiAgICBhcmdzW19rZXk2XSA9IGFyZ3VtZW50c1tfa2V5Nl07XG4gIH1cblxuICBpbm5lck9rLmFwcGx5KHZvaWQgMCwgW3N0cmljdCwgYXJncy5sZW5ndGhdLmNvbmNhdChhcmdzKSk7XG59XG5cbmFzc2VydC5zdHJpY3QgPSBvYmplY3RBc3NpZ24oc3RyaWN0LCBhc3NlcnQsIHtcbiAgZXF1YWw6IGFzc2VydC5zdHJpY3RFcXVhbCxcbiAgZGVlcEVxdWFsOiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsLFxuICBub3RFcXVhbDogYXNzZXJ0Lm5vdFN0cmljdEVxdWFsLFxuICBub3REZWVwRXF1YWw6IGFzc2VydC5ub3REZWVwU3RyaWN0RXF1YWxcbn0pO1xuYXNzZXJ0LnN0cmljdC5zdHJpY3QgPSBhc3NlcnQuc3RyaWN0O1xuXG4vKioqLyB9KSxcblxuLyoqKi8gOTgwMTpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBwcm92aWRlZCBkZXBlbmRlbmN5ICovIHZhciBwcm9jZXNzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5OTA3KTtcbi8vIEN1cnJlbnRseSBpbiBzeW5jIHdpdGggTm9kZS5qcyBsaWIvaW50ZXJuYWwvYXNzZXJ0L2Fzc2VydGlvbl9lcnJvci5qc1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2NvbW1pdC8wODE3ODQwZjc3NTAzMjE2OWRkZDcwYzg1YWMwNTlmMThmZmNjODFjXG5cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IHZhciBvd25LZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTsgaWYgKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSAnZnVuY3Rpb24nKSB7IG93bktleXMgPSBvd25LZXlzLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSkuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBzeW0pLmVudW1lcmFibGU7IH0pKTsgfSBvd25LZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpIHsgdmFyIF9jYWNoZSA9IHR5cGVvZiBNYXAgPT09IFwiZnVuY3Rpb25cIiA/IG5ldyBNYXAoKSA6IHVuZGVmaW5lZDsgX3dyYXBOYXRpdmVTdXBlciA9IGZ1bmN0aW9uIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpIHsgaWYgKENsYXNzID09PSBudWxsIHx8ICFfaXNOYXRpdmVGdW5jdGlvbihDbGFzcykpIHJldHVybiBDbGFzczsgaWYgKHR5cGVvZiBDbGFzcyAhPT0gXCJmdW5jdGlvblwiKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBpZiAodHlwZW9mIF9jYWNoZSAhPT0gXCJ1bmRlZmluZWRcIikgeyBpZiAoX2NhY2hlLmhhcyhDbGFzcykpIHJldHVybiBfY2FjaGUuZ2V0KENsYXNzKTsgX2NhY2hlLnNldChDbGFzcywgV3JhcHBlcik7IH0gZnVuY3Rpb24gV3JhcHBlcigpIHsgcmV0dXJuIF9jb25zdHJ1Y3QoQ2xhc3MsIGFyZ3VtZW50cywgX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yKTsgfSBXcmFwcGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBXcmFwcGVyLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyByZXR1cm4gX3NldFByb3RvdHlwZU9mKFdyYXBwZXIsIENsYXNzKTsgfTsgcmV0dXJuIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIGlzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFJlZmxlY3QuY29uc3RydWN0KERhdGUsIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG5mdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHsgaWYgKGlzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpKSB7IF9jb25zdHJ1Y3QgPSBSZWZsZWN0LmNvbnN0cnVjdDsgfSBlbHNlIHsgX2NvbnN0cnVjdCA9IGZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykgeyB2YXIgYSA9IFtudWxsXTsgYS5wdXNoLmFwcGx5KGEsIGFyZ3MpOyB2YXIgQ29uc3RydWN0b3IgPSBGdW5jdGlvbi5iaW5kLmFwcGx5KFBhcmVudCwgYSk7IHZhciBpbnN0YW5jZSA9IG5ldyBDb25zdHJ1Y3RvcigpOyBpZiAoQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihpbnN0YW5jZSwgQ2xhc3MucHJvdG90eXBlKTsgcmV0dXJuIGluc3RhbmNlOyB9OyB9IHJldHVybiBfY29uc3RydWN0LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlRnVuY3Rpb24oZm4pIHsgcmV0dXJuIEZ1bmN0aW9uLnRvU3RyaW5nLmNhbGwoZm4pLmluZGV4T2YoXCJbbmF0aXZlIGNvZGVdXCIpICE9PSAtMTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbnZhciBfcmVxdWlyZSA9IF9fd2VicGFja19yZXF1aXJlX18oNjgyNyksXG4gICAgaW5zcGVjdCA9IF9yZXF1aXJlLmluc3BlY3Q7XG5cbnZhciBfcmVxdWlyZTIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzNDIpLFxuICAgIEVSUl9JTlZBTElEX0FSR19UWVBFID0gX3JlcXVpcmUyLmNvZGVzLkVSUl9JTlZBTElEX0FSR19UWVBFOyAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvZW5kc1dpdGhcblxuXG5mdW5jdGlvbiBlbmRzV2l0aChzdHIsIHNlYXJjaCwgdGhpc19sZW4pIHtcbiAgaWYgKHRoaXNfbGVuID09PSB1bmRlZmluZWQgfHwgdGhpc19sZW4gPiBzdHIubGVuZ3RoKSB7XG4gICAgdGhpc19sZW4gPSBzdHIubGVuZ3RoO1xuICB9XG5cbiAgcmV0dXJuIHN0ci5zdWJzdHJpbmcodGhpc19sZW4gLSBzZWFyY2gubGVuZ3RoLCB0aGlzX2xlbikgPT09IHNlYXJjaDtcbn0gLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL3JlcGVhdFxuXG5cbmZ1bmN0aW9uIHJlcGVhdChzdHIsIGNvdW50KSB7XG4gIGNvdW50ID0gTWF0aC5mbG9vcihjb3VudCk7XG4gIGlmIChzdHIubGVuZ3RoID09IDAgfHwgY291bnQgPT0gMCkgcmV0dXJuICcnO1xuICB2YXIgbWF4Q291bnQgPSBzdHIubGVuZ3RoICogY291bnQ7XG4gIGNvdW50ID0gTWF0aC5mbG9vcihNYXRoLmxvZyhjb3VudCkgLyBNYXRoLmxvZygyKSk7XG5cbiAgd2hpbGUgKGNvdW50KSB7XG4gICAgc3RyICs9IHN0cjtcbiAgICBjb3VudC0tO1xuICB9XG5cbiAgc3RyICs9IHN0ci5zdWJzdHJpbmcoMCwgbWF4Q291bnQgLSBzdHIubGVuZ3RoKTtcbiAgcmV0dXJuIHN0cjtcbn1cblxudmFyIGJsdWUgPSAnJztcbnZhciBncmVlbiA9ICcnO1xudmFyIHJlZCA9ICcnO1xudmFyIHdoaXRlID0gJyc7XG52YXIga1JlYWRhYmxlT3BlcmF0b3IgPSB7XG4gIGRlZXBTdHJpY3RFcXVhbDogJ0V4cGVjdGVkIHZhbHVlcyB0byBiZSBzdHJpY3RseSBkZWVwLWVxdWFsOicsXG4gIHN0cmljdEVxdWFsOiAnRXhwZWN0ZWQgdmFsdWVzIHRvIGJlIHN0cmljdGx5IGVxdWFsOicsXG4gIHN0cmljdEVxdWFsT2JqZWN0OiAnRXhwZWN0ZWQgXCJhY3R1YWxcIiB0byBiZSByZWZlcmVuY2UtZXF1YWwgdG8gXCJleHBlY3RlZFwiOicsXG4gIGRlZXBFcXVhbDogJ0V4cGVjdGVkIHZhbHVlcyB0byBiZSBsb29zZWx5IGRlZXAtZXF1YWw6JyxcbiAgZXF1YWw6ICdFeHBlY3RlZCB2YWx1ZXMgdG8gYmUgbG9vc2VseSBlcXVhbDonLFxuICBub3REZWVwU3RyaWN0RXF1YWw6ICdFeHBlY3RlZCBcImFjdHVhbFwiIG5vdCB0byBiZSBzdHJpY3RseSBkZWVwLWVxdWFsIHRvOicsXG4gIG5vdFN0cmljdEVxdWFsOiAnRXhwZWN0ZWQgXCJhY3R1YWxcIiB0byBiZSBzdHJpY3RseSB1bmVxdWFsIHRvOicsXG4gIG5vdFN0cmljdEVxdWFsT2JqZWN0OiAnRXhwZWN0ZWQgXCJhY3R1YWxcIiBub3QgdG8gYmUgcmVmZXJlbmNlLWVxdWFsIHRvIFwiZXhwZWN0ZWRcIjonLFxuICBub3REZWVwRXF1YWw6ICdFeHBlY3RlZCBcImFjdHVhbFwiIG5vdCB0byBiZSBsb29zZWx5IGRlZXAtZXF1YWwgdG86JyxcbiAgbm90RXF1YWw6ICdFeHBlY3RlZCBcImFjdHVhbFwiIHRvIGJlIGxvb3NlbHkgdW5lcXVhbCB0bzonLFxuICBub3RJZGVudGljYWw6ICdWYWx1ZXMgaWRlbnRpY2FsIGJ1dCBub3QgcmVmZXJlbmNlLWVxdWFsOidcbn07IC8vIENvbXBhcmluZyBzaG9ydCBwcmltaXRpdmVzIHNob3VsZCBqdXN0IHNob3cgPT09IC8gIT09IGluc3RlYWQgb2YgdXNpbmcgdGhlXG4vLyBkaWZmLlxuXG52YXIga01heFNob3J0TGVuZ3RoID0gMTA7XG5cbmZ1bmN0aW9uIGNvcHlFcnJvcihzb3VyY2UpIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICB2YXIgdGFyZ2V0ID0gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2Yoc291cmNlKSk7XG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsICdtZXNzYWdlJywge1xuICAgIHZhbHVlOiBzb3VyY2UubWVzc2FnZVxuICB9KTtcbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gaW5zcGVjdFZhbHVlKHZhbCkge1xuICAvLyBUaGUgdXRpbC5pbnNwZWN0IGRlZmF1bHQgdmFsdWVzIGNvdWxkIGJlIGNoYW5nZWQuIFRoaXMgbWFrZXMgc3VyZSB0aGVcbiAgLy8gZXJyb3IgbWVzc2FnZXMgY29udGFpbiB0aGUgbmVjZXNzYXJ5IGluZm9ybWF0aW9uIG5ldmVydGhlbGVzcy5cbiAgcmV0dXJuIGluc3BlY3QodmFsLCB7XG4gICAgY29tcGFjdDogZmFsc2UsXG4gICAgY3VzdG9tSW5zcGVjdDogZmFsc2UsXG4gICAgZGVwdGg6IDEwMDAsXG4gICAgbWF4QXJyYXlMZW5ndGg6IEluZmluaXR5LFxuICAgIC8vIEFzc2VydCBjb21wYXJlcyBvbmx5IGVudW1lcmFibGUgcHJvcGVydGllcyAod2l0aCBhIGZldyBleGNlcHRpb25zKS5cbiAgICBzaG93SGlkZGVuOiBmYWxzZSxcbiAgICAvLyBIYXZpbmcgYSBsb25nIGxpbmUgYXMgZXJyb3IgaXMgYmV0dGVyIHRoYW4gd3JhcHBpbmcgdGhlIGxpbmUgZm9yXG4gICAgLy8gY29tcGFyaXNvbiBmb3Igbm93LlxuICAgIC8vIFRPRE8oQnJpZGdlQVIpOiBgYnJlYWtMZW5ndGhgIHNob3VsZCBiZSBsaW1pdGVkIGFzIHNvb24gYXMgc29vbiBhcyB3ZVxuICAgIC8vIGhhdmUgbWV0YSBpbmZvcm1hdGlvbiBhYm91dCB0aGUgaW5zcGVjdGVkIHByb3BlcnRpZXMgKGkuZS4sIGtub3cgd2hlcmVcbiAgICAvLyBpbiB3aGF0IGxpbmUgdGhlIHByb3BlcnR5IHN0YXJ0cyBhbmQgZW5kcykuXG4gICAgYnJlYWtMZW5ndGg6IEluZmluaXR5LFxuICAgIC8vIEFzc2VydCBkb2VzIG5vdCBkZXRlY3QgcHJveGllcyBjdXJyZW50bHkuXG4gICAgc2hvd1Byb3h5OiBmYWxzZSxcbiAgICBzb3J0ZWQ6IHRydWUsXG4gICAgLy8gSW5zcGVjdCBnZXR0ZXJzIGFzIHdlIGFsc28gY2hlY2sgdGhlbSB3aGVuIGNvbXBhcmluZyBlbnRyaWVzLlxuICAgIGdldHRlcnM6IHRydWVcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUVyckRpZmYoYWN0dWFsLCBleHBlY3RlZCwgb3BlcmF0b3IpIHtcbiAgdmFyIG90aGVyID0gJyc7XG4gIHZhciByZXMgPSAnJztcbiAgdmFyIGxhc3RQb3MgPSAwO1xuICB2YXIgZW5kID0gJyc7XG4gIHZhciBza2lwcGVkID0gZmFsc2U7XG4gIHZhciBhY3R1YWxJbnNwZWN0ZWQgPSBpbnNwZWN0VmFsdWUoYWN0dWFsKTtcbiAgdmFyIGFjdHVhbExpbmVzID0gYWN0dWFsSW5zcGVjdGVkLnNwbGl0KCdcXG4nKTtcbiAgdmFyIGV4cGVjdGVkTGluZXMgPSBpbnNwZWN0VmFsdWUoZXhwZWN0ZWQpLnNwbGl0KCdcXG4nKTtcbiAgdmFyIGkgPSAwO1xuICB2YXIgaW5kaWNhdG9yID0gJyc7IC8vIEluIGNhc2UgYm90aCB2YWx1ZXMgYXJlIG9iamVjdHMgZXhwbGljaXRseSBtYXJrIHRoZW0gYXMgbm90IHJlZmVyZW5jZSBlcXVhbFxuICAvLyBmb3IgdGhlIGBzdHJpY3RFcXVhbGAgb3BlcmF0b3IuXG5cbiAgaWYgKG9wZXJhdG9yID09PSAnc3RyaWN0RXF1YWwnICYmIF90eXBlb2YoYWN0dWFsKSA9PT0gJ29iamVjdCcgJiYgX3R5cGVvZihleHBlY3RlZCkgPT09ICdvYmplY3QnICYmIGFjdHVhbCAhPT0gbnVsbCAmJiBleHBlY3RlZCAhPT0gbnVsbCkge1xuICAgIG9wZXJhdG9yID0gJ3N0cmljdEVxdWFsT2JqZWN0JztcbiAgfSAvLyBJZiBcImFjdHVhbFwiIGFuZCBcImV4cGVjdGVkXCIgZml0IG9uIGEgc2luZ2xlIGxpbmUgYW5kIHRoZXkgYXJlIG5vdCBzdHJpY3RseVxuICAvLyBlcXVhbCwgY2hlY2sgZnVydGhlciBzcGVjaWFsIGhhbmRsaW5nLlxuXG5cbiAgaWYgKGFjdHVhbExpbmVzLmxlbmd0aCA9PT0gMSAmJiBleHBlY3RlZExpbmVzLmxlbmd0aCA9PT0gMSAmJiBhY3R1YWxMaW5lc1swXSAhPT0gZXhwZWN0ZWRMaW5lc1swXSkge1xuICAgIHZhciBpbnB1dExlbmd0aCA9IGFjdHVhbExpbmVzWzBdLmxlbmd0aCArIGV4cGVjdGVkTGluZXNbMF0ubGVuZ3RoOyAvLyBJZiB0aGUgY2hhcmFjdGVyIGxlbmd0aCBvZiBcImFjdHVhbFwiIGFuZCBcImV4cGVjdGVkXCIgdG9nZXRoZXIgaXMgbGVzcyB0aGFuXG4gICAgLy8ga01heFNob3J0TGVuZ3RoIGFuZCBpZiBuZWl0aGVyIGlzIGFuIG9iamVjdCBhbmQgYXQgbGVhc3Qgb25lIG9mIHRoZW0gaXNcbiAgICAvLyBub3QgYHplcm9gLCB1c2UgdGhlIHN0cmljdCBlcXVhbCBjb21wYXJpc29uIHRvIHZpc3VhbGl6ZSB0aGUgb3V0cHV0LlxuXG4gICAgaWYgKGlucHV0TGVuZ3RoIDw9IGtNYXhTaG9ydExlbmd0aCkge1xuICAgICAgaWYgKChfdHlwZW9mKGFjdHVhbCkgIT09ICdvYmplY3QnIHx8IGFjdHVhbCA9PT0gbnVsbCkgJiYgKF90eXBlb2YoZXhwZWN0ZWQpICE9PSAnb2JqZWN0JyB8fCBleHBlY3RlZCA9PT0gbnVsbCkgJiYgKGFjdHVhbCAhPT0gMCB8fCBleHBlY3RlZCAhPT0gMCkpIHtcbiAgICAgICAgLy8gLTAgPT09ICswXG4gICAgICAgIHJldHVybiBcIlwiLmNvbmNhdChrUmVhZGFibGVPcGVyYXRvcltvcGVyYXRvcl0sIFwiXFxuXFxuXCIpICsgXCJcIi5jb25jYXQoYWN0dWFsTGluZXNbMF0sIFwiICE9PSBcIikuY29uY2F0KGV4cGVjdGVkTGluZXNbMF0sIFwiXFxuXCIpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAob3BlcmF0b3IgIT09ICdzdHJpY3RFcXVhbE9iamVjdCcpIHtcbiAgICAgIC8vIElmIHRoZSBzdGRlcnIgaXMgYSB0dHkgYW5kIHRoZSBpbnB1dCBsZW5ndGggaXMgbG93ZXIgdGhhbiB0aGUgY3VycmVudFxuICAgICAgLy8gY29sdW1ucyBwZXIgbGluZSwgYWRkIGEgbWlzbWF0Y2ggaW5kaWNhdG9yIGJlbG93IHRoZSBvdXRwdXQuIElmIGl0IGlzXG4gICAgICAvLyBub3QgYSB0dHksIHVzZSBhIGRlZmF1bHQgdmFsdWUgb2YgODAgY2hhcmFjdGVycy5cbiAgICAgIHZhciBtYXhMZW5ndGggPSBwcm9jZXNzLnN0ZGVyciAmJiBwcm9jZXNzLnN0ZGVyci5pc1RUWSA/IHByb2Nlc3Muc3RkZXJyLmNvbHVtbnMgOiA4MDtcblxuICAgICAgaWYgKGlucHV0TGVuZ3RoIDwgbWF4TGVuZ3RoKSB7XG4gICAgICAgIHdoaWxlIChhY3R1YWxMaW5lc1swXVtpXSA9PT0gZXhwZWN0ZWRMaW5lc1swXVtpXSkge1xuICAgICAgICAgIGkrKztcbiAgICAgICAgfSAvLyBJZ25vcmUgdGhlIGZpcnN0IGNoYXJhY3RlcnMuXG5cblxuICAgICAgICBpZiAoaSA+IDIpIHtcbiAgICAgICAgICAvLyBBZGQgcG9zaXRpb24gaW5kaWNhdG9yIGZvciB0aGUgZmlyc3QgbWlzbWF0Y2ggaW4gY2FzZSBpdCBpcyBhXG4gICAgICAgICAgLy8gc2luZ2xlIGxpbmUgYW5kIHRoZSBpbnB1dCBsZW5ndGggaXMgbGVzcyB0aGFuIHRoZSBjb2x1bW4gbGVuZ3RoLlxuICAgICAgICAgIGluZGljYXRvciA9IFwiXFxuICBcIi5jb25jYXQocmVwZWF0KCcgJywgaSksIFwiXlwiKTtcbiAgICAgICAgICBpID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSAvLyBSZW1vdmUgYWxsIGVuZGluZyBsaW5lcyB0aGF0IG1hdGNoICh0aGlzIG9wdGltaXplcyB0aGUgb3V0cHV0IGZvclxuICAvLyByZWFkYWJpbGl0eSBieSByZWR1Y2luZyB0aGUgbnVtYmVyIG9mIHRvdGFsIGNoYW5nZWQgbGluZXMpLlxuXG5cbiAgdmFyIGEgPSBhY3R1YWxMaW5lc1thY3R1YWxMaW5lcy5sZW5ndGggLSAxXTtcbiAgdmFyIGIgPSBleHBlY3RlZExpbmVzW2V4cGVjdGVkTGluZXMubGVuZ3RoIC0gMV07XG5cbiAgd2hpbGUgKGEgPT09IGIpIHtcbiAgICBpZiAoaSsrIDwgMikge1xuICAgICAgZW5kID0gXCJcXG4gIFwiLmNvbmNhdChhKS5jb25jYXQoZW5kKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3RoZXIgPSBhO1xuICAgIH1cblxuICAgIGFjdHVhbExpbmVzLnBvcCgpO1xuICAgIGV4cGVjdGVkTGluZXMucG9wKCk7XG4gICAgaWYgKGFjdHVhbExpbmVzLmxlbmd0aCA9PT0gMCB8fCBleHBlY3RlZExpbmVzLmxlbmd0aCA9PT0gMCkgYnJlYWs7XG4gICAgYSA9IGFjdHVhbExpbmVzW2FjdHVhbExpbmVzLmxlbmd0aCAtIDFdO1xuICAgIGIgPSBleHBlY3RlZExpbmVzW2V4cGVjdGVkTGluZXMubGVuZ3RoIC0gMV07XG4gIH1cblxuICB2YXIgbWF4TGluZXMgPSBNYXRoLm1heChhY3R1YWxMaW5lcy5sZW5ndGgsIGV4cGVjdGVkTGluZXMubGVuZ3RoKTsgLy8gU3RyaWN0IGVxdWFsIHdpdGggaWRlbnRpY2FsIG9iamVjdHMgdGhhdCBhcmUgbm90IGlkZW50aWNhbCBieSByZWZlcmVuY2UuXG4gIC8vIEUuZy4sIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoeyBhOiBTeW1ib2woKSB9LCB7IGE6IFN5bWJvbCgpIH0pXG5cbiAgaWYgKG1heExpbmVzID09PSAwKSB7XG4gICAgLy8gV2UgaGF2ZSB0byBnZXQgdGhlIHJlc3VsdCBhZ2Fpbi4gVGhlIGxpbmVzIHdlcmUgYWxsIHJlbW92ZWQgYmVmb3JlLlxuICAgIHZhciBfYWN0dWFsTGluZXMgPSBhY3R1YWxJbnNwZWN0ZWQuc3BsaXQoJ1xcbicpOyAvLyBPbmx5IHJlbW92ZSBsaW5lcyBpbiBjYXNlIGl0IG1ha2VzIHNlbnNlIHRvIGNvbGxhcHNlIHRob3NlLlxuICAgIC8vIFRPRE86IEFjY2VwdCBlbnYgdG8gYWx3YXlzIHNob3cgdGhlIGZ1bGwgZXJyb3IuXG5cblxuICAgIGlmIChfYWN0dWFsTGluZXMubGVuZ3RoID4gMzApIHtcbiAgICAgIF9hY3R1YWxMaW5lc1syNl0gPSBcIlwiLmNvbmNhdChibHVlLCBcIi4uLlwiKS5jb25jYXQod2hpdGUpO1xuXG4gICAgICB3aGlsZSAoX2FjdHVhbExpbmVzLmxlbmd0aCA+IDI3KSB7XG4gICAgICAgIF9hY3R1YWxMaW5lcy5wb3AoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gXCJcIi5jb25jYXQoa1JlYWRhYmxlT3BlcmF0b3Iubm90SWRlbnRpY2FsLCBcIlxcblxcblwiKS5jb25jYXQoX2FjdHVhbExpbmVzLmpvaW4oJ1xcbicpLCBcIlxcblwiKTtcbiAgfVxuXG4gIGlmIChpID4gMykge1xuICAgIGVuZCA9IFwiXFxuXCIuY29uY2F0KGJsdWUsIFwiLi4uXCIpLmNvbmNhdCh3aGl0ZSkuY29uY2F0KGVuZCk7XG4gICAgc2tpcHBlZCA9IHRydWU7XG4gIH1cblxuICBpZiAob3RoZXIgIT09ICcnKSB7XG4gICAgZW5kID0gXCJcXG4gIFwiLmNvbmNhdChvdGhlcikuY29uY2F0KGVuZCk7XG4gICAgb3RoZXIgPSAnJztcbiAgfVxuXG4gIHZhciBwcmludGVkTGluZXMgPSAwO1xuICB2YXIgbXNnID0ga1JlYWRhYmxlT3BlcmF0b3Jbb3BlcmF0b3JdICsgXCJcXG5cIi5jb25jYXQoZ3JlZW4sIFwiKyBhY3R1YWxcIikuY29uY2F0KHdoaXRlLCBcIiBcIikuY29uY2F0KHJlZCwgXCItIGV4cGVjdGVkXCIpLmNvbmNhdCh3aGl0ZSk7XG4gIHZhciBza2lwcGVkTXNnID0gXCIgXCIuY29uY2F0KGJsdWUsIFwiLi4uXCIpLmNvbmNhdCh3aGl0ZSwgXCIgTGluZXMgc2tpcHBlZFwiKTtcblxuICBmb3IgKGkgPSAwOyBpIDwgbWF4TGluZXM7IGkrKykge1xuICAgIC8vIE9ubHkgZXh0cmEgZXhwZWN0ZWQgbGluZXMgZXhpc3RcbiAgICB2YXIgY3VyID0gaSAtIGxhc3RQb3M7XG5cbiAgICBpZiAoYWN0dWFsTGluZXMubGVuZ3RoIDwgaSArIDEpIHtcbiAgICAgIC8vIElmIHRoZSBsYXN0IGRpdmVyZ2luZyBsaW5lIGlzIG1vcmUgdGhhbiBvbmUgbGluZSBhYm92ZSBhbmQgdGhlXG4gICAgICAvLyBjdXJyZW50IGxpbmUgaXMgYXQgbGVhc3QgbGluZSB0aHJlZSwgYWRkIHNvbWUgb2YgdGhlIGZvcm1lciBsaW5lcyBhbmRcbiAgICAgIC8vIGFsc28gYWRkIGRvdHMgdG8gaW5kaWNhdGUgc2tpcHBlZCBlbnRyaWVzLlxuICAgICAgaWYgKGN1ciA+IDEgJiYgaSA+IDIpIHtcbiAgICAgICAgaWYgKGN1ciA+IDQpIHtcbiAgICAgICAgICByZXMgKz0gXCJcXG5cIi5jb25jYXQoYmx1ZSwgXCIuLi5cIikuY29uY2F0KHdoaXRlKTtcbiAgICAgICAgICBza2lwcGVkID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChjdXIgPiAzKSB7XG4gICAgICAgICAgcmVzICs9IFwiXFxuICBcIi5jb25jYXQoZXhwZWN0ZWRMaW5lc1tpIC0gMl0pO1xuICAgICAgICAgIHByaW50ZWRMaW5lcysrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzICs9IFwiXFxuICBcIi5jb25jYXQoZXhwZWN0ZWRMaW5lc1tpIC0gMV0pO1xuICAgICAgICBwcmludGVkTGluZXMrKztcbiAgICAgIH0gLy8gTWFyayB0aGUgY3VycmVudCBsaW5lIGFzIHRoZSBsYXN0IGRpdmVyZ2luZyBvbmUuXG5cblxuICAgICAgbGFzdFBvcyA9IGk7IC8vIEFkZCB0aGUgZXhwZWN0ZWQgbGluZSB0byB0aGUgY2FjaGUuXG5cbiAgICAgIG90aGVyICs9IFwiXFxuXCIuY29uY2F0KHJlZCwgXCItXCIpLmNvbmNhdCh3aGl0ZSwgXCIgXCIpLmNvbmNhdChleHBlY3RlZExpbmVzW2ldKTtcbiAgICAgIHByaW50ZWRMaW5lcysrOyAvLyBPbmx5IGV4dHJhIGFjdHVhbCBsaW5lcyBleGlzdFxuICAgIH0gZWxzZSBpZiAoZXhwZWN0ZWRMaW5lcy5sZW5ndGggPCBpICsgMSkge1xuICAgICAgLy8gSWYgdGhlIGxhc3QgZGl2ZXJnaW5nIGxpbmUgaXMgbW9yZSB0aGFuIG9uZSBsaW5lIGFib3ZlIGFuZCB0aGVcbiAgICAgIC8vIGN1cnJlbnQgbGluZSBpcyBhdCBsZWFzdCBsaW5lIHRocmVlLCBhZGQgc29tZSBvZiB0aGUgZm9ybWVyIGxpbmVzIGFuZFxuICAgICAgLy8gYWxzbyBhZGQgZG90cyB0byBpbmRpY2F0ZSBza2lwcGVkIGVudHJpZXMuXG4gICAgICBpZiAoY3VyID4gMSAmJiBpID4gMikge1xuICAgICAgICBpZiAoY3VyID4gNCkge1xuICAgICAgICAgIHJlcyArPSBcIlxcblwiLmNvbmNhdChibHVlLCBcIi4uLlwiKS5jb25jYXQod2hpdGUpO1xuICAgICAgICAgIHNraXBwZWQgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGN1ciA+IDMpIHtcbiAgICAgICAgICByZXMgKz0gXCJcXG4gIFwiLmNvbmNhdChhY3R1YWxMaW5lc1tpIC0gMl0pO1xuICAgICAgICAgIHByaW50ZWRMaW5lcysrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzICs9IFwiXFxuICBcIi5jb25jYXQoYWN0dWFsTGluZXNbaSAtIDFdKTtcbiAgICAgICAgcHJpbnRlZExpbmVzKys7XG4gICAgICB9IC8vIE1hcmsgdGhlIGN1cnJlbnQgbGluZSBhcyB0aGUgbGFzdCBkaXZlcmdpbmcgb25lLlxuXG5cbiAgICAgIGxhc3RQb3MgPSBpOyAvLyBBZGQgdGhlIGFjdHVhbCBsaW5lIHRvIHRoZSByZXN1bHQuXG5cbiAgICAgIHJlcyArPSBcIlxcblwiLmNvbmNhdChncmVlbiwgXCIrXCIpLmNvbmNhdCh3aGl0ZSwgXCIgXCIpLmNvbmNhdChhY3R1YWxMaW5lc1tpXSk7XG4gICAgICBwcmludGVkTGluZXMrKzsgLy8gTGluZXMgZGl2ZXJnZVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZXhwZWN0ZWRMaW5lID0gZXhwZWN0ZWRMaW5lc1tpXTtcbiAgICAgIHZhciBhY3R1YWxMaW5lID0gYWN0dWFsTGluZXNbaV07IC8vIElmIHRoZSBsaW5lcyBkaXZlcmdlLCBzcGVjaWZpY2FsbHkgY2hlY2sgZm9yIGxpbmVzIHRoYXQgb25seSBkaXZlcmdlIGJ5XG4gICAgICAvLyBhIHRyYWlsaW5nIGNvbW1hLiBJbiB0aGF0IGNhc2UgaXQgaXMgYWN0dWFsbHkgaWRlbnRpY2FsIGFuZCB3ZSBzaG91bGRcbiAgICAgIC8vIG1hcmsgaXQgYXMgc3VjaC5cblxuICAgICAgdmFyIGRpdmVyZ2luZ0xpbmVzID0gYWN0dWFsTGluZSAhPT0gZXhwZWN0ZWRMaW5lICYmICghZW5kc1dpdGgoYWN0dWFsTGluZSwgJywnKSB8fCBhY3R1YWxMaW5lLnNsaWNlKDAsIC0xKSAhPT0gZXhwZWN0ZWRMaW5lKTsgLy8gSWYgdGhlIGV4cGVjdGVkIGxpbmUgaGFzIGEgdHJhaWxpbmcgY29tbWEgYnV0IGlzIG90aGVyd2lzZSBpZGVudGljYWwsXG4gICAgICAvLyBhZGQgYSBjb21tYSBhdCB0aGUgZW5kIG9mIHRoZSBhY3R1YWwgbGluZS4gT3RoZXJ3aXNlIHRoZSBvdXRwdXQgY291bGRcbiAgICAgIC8vIGxvb2sgd2VpcmQgYXMgaW46XG4gICAgICAvL1xuICAgICAgLy8gICBbXG4gICAgICAvLyAgICAgMSAgICAgICAgIC8vIE5vIGNvbW1hIGF0IHRoZSBlbmQhXG4gICAgICAvLyArICAgMlxuICAgICAgLy8gICBdXG4gICAgICAvL1xuXG4gICAgICBpZiAoZGl2ZXJnaW5nTGluZXMgJiYgZW5kc1dpdGgoZXhwZWN0ZWRMaW5lLCAnLCcpICYmIGV4cGVjdGVkTGluZS5zbGljZSgwLCAtMSkgPT09IGFjdHVhbExpbmUpIHtcbiAgICAgICAgZGl2ZXJnaW5nTGluZXMgPSBmYWxzZTtcbiAgICAgICAgYWN0dWFsTGluZSArPSAnLCc7XG4gICAgICB9XG5cbiAgICAgIGlmIChkaXZlcmdpbmdMaW5lcykge1xuICAgICAgICAvLyBJZiB0aGUgbGFzdCBkaXZlcmdpbmcgbGluZSBpcyBtb3JlIHRoYW4gb25lIGxpbmUgYWJvdmUgYW5kIHRoZVxuICAgICAgICAvLyBjdXJyZW50IGxpbmUgaXMgYXQgbGVhc3QgbGluZSB0aHJlZSwgYWRkIHNvbWUgb2YgdGhlIGZvcm1lciBsaW5lcyBhbmRcbiAgICAgICAgLy8gYWxzbyBhZGQgZG90cyB0byBpbmRpY2F0ZSBza2lwcGVkIGVudHJpZXMuXG4gICAgICAgIGlmIChjdXIgPiAxICYmIGkgPiAyKSB7XG4gICAgICAgICAgaWYgKGN1ciA+IDQpIHtcbiAgICAgICAgICAgIHJlcyArPSBcIlxcblwiLmNvbmNhdChibHVlLCBcIi4uLlwiKS5jb25jYXQod2hpdGUpO1xuICAgICAgICAgICAgc2tpcHBlZCA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIGlmIChjdXIgPiAzKSB7XG4gICAgICAgICAgICByZXMgKz0gXCJcXG4gIFwiLmNvbmNhdChhY3R1YWxMaW5lc1tpIC0gMl0pO1xuICAgICAgICAgICAgcHJpbnRlZExpbmVzKys7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmVzICs9IFwiXFxuICBcIi5jb25jYXQoYWN0dWFsTGluZXNbaSAtIDFdKTtcbiAgICAgICAgICBwcmludGVkTGluZXMrKztcbiAgICAgICAgfSAvLyBNYXJrIHRoZSBjdXJyZW50IGxpbmUgYXMgdGhlIGxhc3QgZGl2ZXJnaW5nIG9uZS5cblxuXG4gICAgICAgIGxhc3RQb3MgPSBpOyAvLyBBZGQgdGhlIGFjdHVhbCBsaW5lIHRvIHRoZSByZXN1bHQgYW5kIGNhY2hlIHRoZSBleHBlY3RlZCBkaXZlcmdpbmdcbiAgICAgICAgLy8gbGluZSBzbyBjb25zZWN1dGl2ZSBkaXZlcmdpbmcgbGluZXMgc2hvdyB1cCBhcyArKystLS0gYW5kIG5vdCArLSstKy0uXG5cbiAgICAgICAgcmVzICs9IFwiXFxuXCIuY29uY2F0KGdyZWVuLCBcIitcIikuY29uY2F0KHdoaXRlLCBcIiBcIikuY29uY2F0KGFjdHVhbExpbmUpO1xuICAgICAgICBvdGhlciArPSBcIlxcblwiLmNvbmNhdChyZWQsIFwiLVwiKS5jb25jYXQod2hpdGUsIFwiIFwiKS5jb25jYXQoZXhwZWN0ZWRMaW5lKTtcbiAgICAgICAgcHJpbnRlZExpbmVzICs9IDI7IC8vIExpbmVzIGFyZSBpZGVudGljYWxcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEFkZCBhbGwgY2FjaGVkIGluZm9ybWF0aW9uIHRvIHRoZSByZXN1bHQgYmVmb3JlIGFkZGluZyBvdGhlciB0aGluZ3NcbiAgICAgICAgLy8gYW5kIHJlc2V0IHRoZSBjYWNoZS5cbiAgICAgICAgcmVzICs9IG90aGVyO1xuICAgICAgICBvdGhlciA9ICcnOyAvLyBJZiB0aGUgbGFzdCBkaXZlcmdpbmcgbGluZSBpcyBleGFjdGx5IG9uZSBsaW5lIGFib3ZlIG9yIGlmIGl0IGlzIHRoZVxuICAgICAgICAvLyB2ZXJ5IGZpcnN0IGxpbmUsIGFkZCB0aGUgbGluZSB0byB0aGUgcmVzdWx0LlxuXG4gICAgICAgIGlmIChjdXIgPT09IDEgfHwgaSA9PT0gMCkge1xuICAgICAgICAgIHJlcyArPSBcIlxcbiAgXCIuY29uY2F0KGFjdHVhbExpbmUpO1xuICAgICAgICAgIHByaW50ZWRMaW5lcysrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSAvLyBJbnNwZWN0ZWQgb2JqZWN0IHRvIGJpZyAoU2hvdyB+MjAgcm93cyBtYXgpXG5cblxuICAgIGlmIChwcmludGVkTGluZXMgPiAyMCAmJiBpIDwgbWF4TGluZXMgLSAyKSB7XG4gICAgICByZXR1cm4gXCJcIi5jb25jYXQobXNnKS5jb25jYXQoc2tpcHBlZE1zZywgXCJcXG5cIikuY29uY2F0KHJlcywgXCJcXG5cIikuY29uY2F0KGJsdWUsIFwiLi4uXCIpLmNvbmNhdCh3aGl0ZSkuY29uY2F0KG90aGVyLCBcIlxcblwiKSArIFwiXCIuY29uY2F0KGJsdWUsIFwiLi4uXCIpLmNvbmNhdCh3aGl0ZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFwiXCIuY29uY2F0KG1zZykuY29uY2F0KHNraXBwZWQgPyBza2lwcGVkTXNnIDogJycsIFwiXFxuXCIpLmNvbmNhdChyZXMpLmNvbmNhdChvdGhlcikuY29uY2F0KGVuZCkuY29uY2F0KGluZGljYXRvcik7XG59XG5cbnZhciBBc3NlcnRpb25FcnJvciA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0Vycm9yKSB7XG4gIF9pbmhlcml0cyhBc3NlcnRpb25FcnJvciwgX0Vycm9yKTtcblxuICBmdW5jdGlvbiBBc3NlcnRpb25FcnJvcihvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEFzc2VydGlvbkVycm9yKTtcblxuICAgIGlmIChfdHlwZW9mKG9wdGlvbnMpICE9PSAnb2JqZWN0JyB8fCBvcHRpb25zID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoJ29wdGlvbnMnLCAnT2JqZWN0Jywgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgdmFyIG1lc3NhZ2UgPSBvcHRpb25zLm1lc3NhZ2UsXG4gICAgICAgIG9wZXJhdG9yID0gb3B0aW9ucy5vcGVyYXRvcixcbiAgICAgICAgc3RhY2tTdGFydEZuID0gb3B0aW9ucy5zdGFja1N0YXJ0Rm47XG4gICAgdmFyIGFjdHVhbCA9IG9wdGlvbnMuYWN0dWFsLFxuICAgICAgICBleHBlY3RlZCA9IG9wdGlvbnMuZXhwZWN0ZWQ7XG4gICAgdmFyIGxpbWl0ID0gRXJyb3Iuc3RhY2tUcmFjZUxpbWl0O1xuICAgIEVycm9yLnN0YWNrVHJhY2VMaW1pdCA9IDA7XG5cbiAgICBpZiAobWVzc2FnZSAhPSBudWxsKSB7XG4gICAgICBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihBc3NlcnRpb25FcnJvcikuY2FsbCh0aGlzLCBTdHJpbmcobWVzc2FnZSkpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByb2Nlc3Muc3RkZXJyICYmIHByb2Nlc3Muc3RkZXJyLmlzVFRZKSB7XG4gICAgICAgIC8vIFJlc2V0IG9uIGVhY2ggY2FsbCB0byBtYWtlIHN1cmUgd2UgaGFuZGxlIGR5bmFtaWNhbGx5IHNldCBlbnZpcm9ubWVudFxuICAgICAgICAvLyB2YXJpYWJsZXMgY29ycmVjdC5cbiAgICAgICAgaWYgKHByb2Nlc3Muc3RkZXJyICYmIHByb2Nlc3Muc3RkZXJyLmdldENvbG9yRGVwdGggJiYgcHJvY2Vzcy5zdGRlcnIuZ2V0Q29sb3JEZXB0aCgpICE9PSAxKSB7XG4gICAgICAgICAgYmx1ZSA9IFwiXFx4MUJbMzRtXCI7XG4gICAgICAgICAgZ3JlZW4gPSBcIlxceDFCWzMybVwiO1xuICAgICAgICAgIHdoaXRlID0gXCJcXHgxQlszOW1cIjtcbiAgICAgICAgICByZWQgPSBcIlxceDFCWzMxbVwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJsdWUgPSAnJztcbiAgICAgICAgICBncmVlbiA9ICcnO1xuICAgICAgICAgIHdoaXRlID0gJyc7XG4gICAgICAgICAgcmVkID0gJyc7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gUHJldmVudCB0aGUgZXJyb3Igc3RhY2sgZnJvbSBiZWluZyB2aXNpYmxlIGJ5IGR1cGxpY2F0aW5nIHRoZSBlcnJvclxuICAgICAgLy8gaW4gYSB2ZXJ5IGNsb3NlIHdheSB0byB0aGUgb3JpZ2luYWwgaW4gY2FzZSBib3RoIHNpZGVzIGFyZSBhY3R1YWxseVxuICAgICAgLy8gaW5zdGFuY2VzIG9mIEVycm9yLlxuXG5cbiAgICAgIGlmIChfdHlwZW9mKGFjdHVhbCkgPT09ICdvYmplY3QnICYmIGFjdHVhbCAhPT0gbnVsbCAmJiBfdHlwZW9mKGV4cGVjdGVkKSA9PT0gJ29iamVjdCcgJiYgZXhwZWN0ZWQgIT09IG51bGwgJiYgJ3N0YWNrJyBpbiBhY3R1YWwgJiYgYWN0dWFsIGluc3RhbmNlb2YgRXJyb3IgJiYgJ3N0YWNrJyBpbiBleHBlY3RlZCAmJiBleHBlY3RlZCBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIGFjdHVhbCA9IGNvcHlFcnJvcihhY3R1YWwpO1xuICAgICAgICBleHBlY3RlZCA9IGNvcHlFcnJvcihleHBlY3RlZCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcGVyYXRvciA9PT0gJ2RlZXBTdHJpY3RFcXVhbCcgfHwgb3BlcmF0b3IgPT09ICdzdHJpY3RFcXVhbCcpIHtcbiAgICAgICAgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoQXNzZXJ0aW9uRXJyb3IpLmNhbGwodGhpcywgY3JlYXRlRXJyRGlmZihhY3R1YWwsIGV4cGVjdGVkLCBvcGVyYXRvcikpKTtcbiAgICAgIH0gZWxzZSBpZiAob3BlcmF0b3IgPT09ICdub3REZWVwU3RyaWN0RXF1YWwnIHx8IG9wZXJhdG9yID09PSAnbm90U3RyaWN0RXF1YWwnKSB7XG4gICAgICAgIC8vIEluIGNhc2UgdGhlIG9iamVjdHMgYXJlIGVxdWFsIGJ1dCB0aGUgb3BlcmF0b3IgcmVxdWlyZXMgdW5lcXVhbCwgc2hvd1xuICAgICAgICAvLyB0aGUgZmlyc3Qgb2JqZWN0IGFuZCBzYXkgQSBlcXVhbHMgQlxuICAgICAgICB2YXIgYmFzZSA9IGtSZWFkYWJsZU9wZXJhdG9yW29wZXJhdG9yXTtcbiAgICAgICAgdmFyIHJlcyA9IGluc3BlY3RWYWx1ZShhY3R1YWwpLnNwbGl0KCdcXG4nKTsgLy8gSW4gY2FzZSBcImFjdHVhbFwiIGlzIGFuIG9iamVjdCwgaXQgc2hvdWxkIG5vdCBiZSByZWZlcmVuY2UgZXF1YWwuXG5cbiAgICAgICAgaWYgKG9wZXJhdG9yID09PSAnbm90U3RyaWN0RXF1YWwnICYmIF90eXBlb2YoYWN0dWFsKSA9PT0gJ29iamVjdCcgJiYgYWN0dWFsICE9PSBudWxsKSB7XG4gICAgICAgICAgYmFzZSA9IGtSZWFkYWJsZU9wZXJhdG9yLm5vdFN0cmljdEVxdWFsT2JqZWN0O1xuICAgICAgICB9IC8vIE9ubHkgcmVtb3ZlIGxpbmVzIGluIGNhc2UgaXQgbWFrZXMgc2Vuc2UgdG8gY29sbGFwc2UgdGhvc2UuXG4gICAgICAgIC8vIFRPRE86IEFjY2VwdCBlbnYgdG8gYWx3YXlzIHNob3cgdGhlIGZ1bGwgZXJyb3IuXG5cblxuICAgICAgICBpZiAocmVzLmxlbmd0aCA+IDMwKSB7XG4gICAgICAgICAgcmVzWzI2XSA9IFwiXCIuY29uY2F0KGJsdWUsIFwiLi4uXCIpLmNvbmNhdCh3aGl0ZSk7XG5cbiAgICAgICAgICB3aGlsZSAocmVzLmxlbmd0aCA+IDI3KSB7XG4gICAgICAgICAgICByZXMucG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIE9ubHkgcHJpbnQgYSBzaW5nbGUgaW5wdXQuXG5cblxuICAgICAgICBpZiAocmVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKEFzc2VydGlvbkVycm9yKS5jYWxsKHRoaXMsIFwiXCIuY29uY2F0KGJhc2UsIFwiIFwiKS5jb25jYXQocmVzWzBdKSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKEFzc2VydGlvbkVycm9yKS5jYWxsKHRoaXMsIFwiXCIuY29uY2F0KGJhc2UsIFwiXFxuXFxuXCIpLmNvbmNhdChyZXMuam9pbignXFxuJyksIFwiXFxuXCIpKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBfcmVzID0gaW5zcGVjdFZhbHVlKGFjdHVhbCk7XG5cbiAgICAgICAgdmFyIG90aGVyID0gJyc7XG4gICAgICAgIHZhciBrbm93bk9wZXJhdG9ycyA9IGtSZWFkYWJsZU9wZXJhdG9yW29wZXJhdG9yXTtcblxuICAgICAgICBpZiAob3BlcmF0b3IgPT09ICdub3REZWVwRXF1YWwnIHx8IG9wZXJhdG9yID09PSAnbm90RXF1YWwnKSB7XG4gICAgICAgICAgX3JlcyA9IFwiXCIuY29uY2F0KGtSZWFkYWJsZU9wZXJhdG9yW29wZXJhdG9yXSwgXCJcXG5cXG5cIikuY29uY2F0KF9yZXMpO1xuXG4gICAgICAgICAgaWYgKF9yZXMubGVuZ3RoID4gMTAyNCkge1xuICAgICAgICAgICAgX3JlcyA9IFwiXCIuY29uY2F0KF9yZXMuc2xpY2UoMCwgMTAyMSksIFwiLi4uXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdGhlciA9IFwiXCIuY29uY2F0KGluc3BlY3RWYWx1ZShleHBlY3RlZCkpO1xuXG4gICAgICAgICAgaWYgKF9yZXMubGVuZ3RoID4gNTEyKSB7XG4gICAgICAgICAgICBfcmVzID0gXCJcIi5jb25jYXQoX3Jlcy5zbGljZSgwLCA1MDkpLCBcIi4uLlwiKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAob3RoZXIubGVuZ3RoID4gNTEyKSB7XG4gICAgICAgICAgICBvdGhlciA9IFwiXCIuY29uY2F0KG90aGVyLnNsaWNlKDAsIDUwOSksIFwiLi4uXCIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChvcGVyYXRvciA9PT0gJ2RlZXBFcXVhbCcgfHwgb3BlcmF0b3IgPT09ICdlcXVhbCcpIHtcbiAgICAgICAgICAgIF9yZXMgPSBcIlwiLmNvbmNhdChrbm93bk9wZXJhdG9ycywgXCJcXG5cXG5cIikuY29uY2F0KF9yZXMsIFwiXFxuXFxuc2hvdWxkIGVxdWFsXFxuXFxuXCIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvdGhlciA9IFwiIFwiLmNvbmNhdChvcGVyYXRvciwgXCIgXCIpLmNvbmNhdChvdGhlcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoQXNzZXJ0aW9uRXJyb3IpLmNhbGwodGhpcywgXCJcIi5jb25jYXQoX3JlcykuY29uY2F0KG90aGVyKSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIEVycm9yLnN0YWNrVHJhY2VMaW1pdCA9IGxpbWl0O1xuICAgIF90aGlzLmdlbmVyYXRlZE1lc3NhZ2UgPSAhbWVzc2FnZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksICduYW1lJywge1xuICAgICAgdmFsdWU6ICdBc3NlcnRpb25FcnJvciBbRVJSX0FTU0VSVElPTl0nLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIF90aGlzLmNvZGUgPSAnRVJSX0FTU0VSVElPTic7XG4gICAgX3RoaXMuYWN0dWFsID0gYWN0dWFsO1xuICAgIF90aGlzLmV4cGVjdGVkID0gZXhwZWN0ZWQ7XG4gICAgX3RoaXMub3BlcmF0b3IgPSBvcGVyYXRvcjtcblxuICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG4gICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgc3RhY2tTdGFydEZuKTtcbiAgICB9IC8vIENyZWF0ZSBlcnJvciBtZXNzYWdlIGluY2x1ZGluZyB0aGUgZXJyb3IgY29kZSBpbiB0aGUgbmFtZS5cblxuXG4gICAgX3RoaXMuc3RhY2s7IC8vIFJlc2V0IHRoZSBuYW1lLlxuXG4gICAgX3RoaXMubmFtZSA9ICdBc3NlcnRpb25FcnJvcic7XG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhBc3NlcnRpb25FcnJvciwgW3tcbiAgICBrZXk6IFwidG9TdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gXCJcIi5jb25jYXQodGhpcy5uYW1lLCBcIiBbXCIpLmNvbmNhdCh0aGlzLmNvZGUsIFwiXTogXCIpLmNvbmNhdCh0aGlzLm1lc3NhZ2UpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogaW5zcGVjdC5jdXN0b20sXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKHJlY3Vyc2VUaW1lcywgY3R4KSB7XG4gICAgICAvLyBUaGlzIGxpbWl0cyB0aGUgYGFjdHVhbGAgYW5kIGBleHBlY3RlZGAgcHJvcGVydHkgZGVmYXVsdCBpbnNwZWN0aW9uIHRvXG4gICAgICAvLyB0aGUgbWluaW11bSBkZXB0aC4gT3RoZXJ3aXNlIHRob3NlIHZhbHVlcyB3b3VsZCBiZSB0b28gdmVyYm9zZSBjb21wYXJlZFxuICAgICAgLy8gdG8gdGhlIGFjdHVhbCBlcnJvciBtZXNzYWdlIHdoaWNoIGNvbnRhaW5zIGEgY29tYmluZWQgdmlldyBvZiB0aGVzZSB0d29cbiAgICAgIC8vIGlucHV0IHZhbHVlcy5cbiAgICAgIHJldHVybiBpbnNwZWN0KHRoaXMsIF9vYmplY3RTcHJlYWQoe30sIGN0eCwge1xuICAgICAgICBjdXN0b21JbnNwZWN0OiBmYWxzZSxcbiAgICAgICAgZGVwdGg6IDBcbiAgICAgIH0pKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQXNzZXJ0aW9uRXJyb3I7XG59KF93cmFwTmF0aXZlU3VwZXIoRXJyb3IpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBBc3NlcnRpb25FcnJvcjtcblxuLyoqKi8gfSksXG5cbi8qKiovIDEzNDI6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuLy8gQ3VycmVudGx5IGluIHN5bmMgd2l0aCBOb2RlLmpzIGxpYi9pbnRlcm5hbC9lcnJvcnMuanNcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9jb21taXQvM2IwNDQ5NjJjNDhmZTMxMzkwNTg3N2E5NmI1ZDA4OTRhNTQwNGY2ZlxuXG4vKiBlc2xpbnQgbm9kZS1jb3JlL2RvY3VtZW50ZWQtZXJyb3JzOiBcImVycm9yXCIgKi9cblxuLyogZXNsaW50IG5vZGUtY29yZS9hbHBoYWJldGl6ZS1lcnJvcnM6IFwiZXJyb3JcIiAqL1xuXG4vKiBlc2xpbnQgbm9kZS1jb3JlL3ByZWZlci11dGlsLWZvcm1hdC1lcnJvcnM6IFwiZXJyb3JcIiAqL1xuIC8vIFRoZSB3aG9sZSBwb2ludCBiZWhpbmQgdGhpcyBpbnRlcm5hbCBtb2R1bGUgaXMgdG8gYWxsb3cgTm9kZS5qcyB0byBub1xuLy8gbG9uZ2VyIGJlIGZvcmNlZCB0byB0cmVhdCBldmVyeSBlcnJvciBtZXNzYWdlIGNoYW5nZSBhcyBhIHNlbXZlci1tYWpvclxuLy8gY2hhbmdlLiBUaGUgTm9kZUVycm9yIGNsYXNzZXMgaGVyZSBhbGwgZXhwb3NlIGEgYGNvZGVgIHByb3BlcnR5IHdob3NlXG4vLyB2YWx1ZSBzdGF0aWNhbGx5IGFuZCBwZXJtYW5lbnRseSBpZGVudGlmaWVzIHRoZSBlcnJvci4gV2hpbGUgdGhlIGVycm9yXG4vLyBtZXNzYWdlIG1heSBjaGFuZ2UsIHRoZSBjb2RlIHNob3VsZCBub3QuXG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxudmFyIGNvZGVzID0ge307IC8vIExhenkgbG9hZGVkXG5cbnZhciBhc3NlcnQ7XG52YXIgdXRpbDtcblxuZnVuY3Rpb24gY3JlYXRlRXJyb3JUeXBlKGNvZGUsIG1lc3NhZ2UsIEJhc2UpIHtcbiAgaWYgKCFCYXNlKSB7XG4gICAgQmFzZSA9IEVycm9yO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0TWVzc2FnZShhcmcxLCBhcmcyLCBhcmczKSB7XG4gICAgaWYgKHR5cGVvZiBtZXNzYWdlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBtZXNzYWdlKGFyZzEsIGFyZzIsIGFyZzMpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBOb2RlRXJyb3IgPVxuICAvKiNfX1BVUkVfXyovXG4gIGZ1bmN0aW9uIChfQmFzZSkge1xuICAgIF9pbmhlcml0cyhOb2RlRXJyb3IsIF9CYXNlKTtcblxuICAgIGZ1bmN0aW9uIE5vZGVFcnJvcihhcmcxLCBhcmcyLCBhcmczKSB7XG4gICAgICB2YXIgX3RoaXM7XG5cbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBOb2RlRXJyb3IpO1xuXG4gICAgICBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihOb2RlRXJyb3IpLmNhbGwodGhpcywgZ2V0TWVzc2FnZShhcmcxLCBhcmcyLCBhcmczKSkpO1xuICAgICAgX3RoaXMuY29kZSA9IGNvZGU7XG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIE5vZGVFcnJvcjtcbiAgfShCYXNlKTtcblxuICBjb2Rlc1tjb2RlXSA9IE5vZGVFcnJvcjtcbn0gLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvdjEwLjguMC9saWIvaW50ZXJuYWwvZXJyb3JzLmpzXG5cblxuZnVuY3Rpb24gb25lT2YoZXhwZWN0ZWQsIHRoaW5nKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGV4cGVjdGVkKSkge1xuICAgIHZhciBsZW4gPSBleHBlY3RlZC5sZW5ndGg7XG4gICAgZXhwZWN0ZWQgPSBleHBlY3RlZC5tYXAoZnVuY3Rpb24gKGkpIHtcbiAgICAgIHJldHVybiBTdHJpbmcoaSk7XG4gICAgfSk7XG5cbiAgICBpZiAobGVuID4gMikge1xuICAgICAgcmV0dXJuIFwib25lIG9mIFwiLmNvbmNhdCh0aGluZywgXCIgXCIpLmNvbmNhdChleHBlY3RlZC5zbGljZSgwLCBsZW4gLSAxKS5qb2luKCcsICcpLCBcIiwgb3IgXCIpICsgZXhwZWN0ZWRbbGVuIC0gMV07XG4gICAgfSBlbHNlIGlmIChsZW4gPT09IDIpIHtcbiAgICAgIHJldHVybiBcIm9uZSBvZiBcIi5jb25jYXQodGhpbmcsIFwiIFwiKS5jb25jYXQoZXhwZWN0ZWRbMF0sIFwiIG9yIFwiKS5jb25jYXQoZXhwZWN0ZWRbMV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gXCJvZiBcIi5jb25jYXQodGhpbmcsIFwiIFwiKS5jb25jYXQoZXhwZWN0ZWRbMF0pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gXCJvZiBcIi5jb25jYXQodGhpbmcsIFwiIFwiKS5jb25jYXQoU3RyaW5nKGV4cGVjdGVkKSk7XG4gIH1cbn0gLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL3N0YXJ0c1dpdGhcblxuXG5mdW5jdGlvbiBzdGFydHNXaXRoKHN0ciwgc2VhcmNoLCBwb3MpIHtcbiAgcmV0dXJuIHN0ci5zdWJzdHIoIXBvcyB8fCBwb3MgPCAwID8gMCA6ICtwb3MsIHNlYXJjaC5sZW5ndGgpID09PSBzZWFyY2g7XG59IC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9lbmRzV2l0aFxuXG5cbmZ1bmN0aW9uIGVuZHNXaXRoKHN0ciwgc2VhcmNoLCB0aGlzX2xlbikge1xuICBpZiAodGhpc19sZW4gPT09IHVuZGVmaW5lZCB8fCB0aGlzX2xlbiA+IHN0ci5sZW5ndGgpIHtcbiAgICB0aGlzX2xlbiA9IHN0ci5sZW5ndGg7XG4gIH1cblxuICByZXR1cm4gc3RyLnN1YnN0cmluZyh0aGlzX2xlbiAtIHNlYXJjaC5sZW5ndGgsIHRoaXNfbGVuKSA9PT0gc2VhcmNoO1xufSAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvaW5jbHVkZXNcblxuXG5mdW5jdGlvbiBpbmNsdWRlcyhzdHIsIHNlYXJjaCwgc3RhcnQpIHtcbiAgaWYgKHR5cGVvZiBzdGFydCAhPT0gJ251bWJlcicpIHtcbiAgICBzdGFydCA9IDA7XG4gIH1cblxuICBpZiAoc3RhcnQgKyBzZWFyY2gubGVuZ3RoID4gc3RyLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RyLmluZGV4T2Yoc2VhcmNoLCBzdGFydCkgIT09IC0xO1xuICB9XG59XG5cbmNyZWF0ZUVycm9yVHlwZSgnRVJSX0FNQklHVU9VU19BUkdVTUVOVCcsICdUaGUgXCIlc1wiIGFyZ3VtZW50IGlzIGFtYmlndW91cy4gJXMnLCBUeXBlRXJyb3IpO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfSU5WQUxJRF9BUkdfVFlQRScsIGZ1bmN0aW9uIChuYW1lLCBleHBlY3RlZCwgYWN0dWFsKSB7XG4gIGlmIChhc3NlcnQgPT09IHVuZGVmaW5lZCkgYXNzZXJ0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2MDkzKTtcbiAgYXNzZXJ0KHR5cGVvZiBuYW1lID09PSAnc3RyaW5nJywgXCInbmFtZScgbXVzdCBiZSBhIHN0cmluZ1wiKTsgLy8gZGV0ZXJtaW5lcjogJ211c3QgYmUnIG9yICdtdXN0IG5vdCBiZSdcblxuICB2YXIgZGV0ZXJtaW5lcjtcblxuICBpZiAodHlwZW9mIGV4cGVjdGVkID09PSAnc3RyaW5nJyAmJiBzdGFydHNXaXRoKGV4cGVjdGVkLCAnbm90ICcpKSB7XG4gICAgZGV0ZXJtaW5lciA9ICdtdXN0IG5vdCBiZSc7XG4gICAgZXhwZWN0ZWQgPSBleHBlY3RlZC5yZXBsYWNlKC9ebm90IC8sICcnKTtcbiAgfSBlbHNlIHtcbiAgICBkZXRlcm1pbmVyID0gJ211c3QgYmUnO1xuICB9XG5cbiAgdmFyIG1zZztcblxuICBpZiAoZW5kc1dpdGgobmFtZSwgJyBhcmd1bWVudCcpKSB7XG4gICAgLy8gRm9yIGNhc2VzIGxpa2UgJ2ZpcnN0IGFyZ3VtZW50J1xuICAgIG1zZyA9IFwiVGhlIFwiLmNvbmNhdChuYW1lLCBcIiBcIikuY29uY2F0KGRldGVybWluZXIsIFwiIFwiKS5jb25jYXQob25lT2YoZXhwZWN0ZWQsICd0eXBlJykpO1xuICB9IGVsc2Uge1xuICAgIHZhciB0eXBlID0gaW5jbHVkZXMobmFtZSwgJy4nKSA/ICdwcm9wZXJ0eScgOiAnYXJndW1lbnQnO1xuICAgIG1zZyA9IFwiVGhlIFxcXCJcIi5jb25jYXQobmFtZSwgXCJcXFwiIFwiKS5jb25jYXQodHlwZSwgXCIgXCIpLmNvbmNhdChkZXRlcm1pbmVyLCBcIiBcIikuY29uY2F0KG9uZU9mKGV4cGVjdGVkLCAndHlwZScpKTtcbiAgfSAvLyBUT0RPKEJyaWRnZUFSKTogSW1wcm92ZSB0aGUgb3V0cHV0IGJ5IHNob3dpbmcgYG51bGxgIGFuZCBzaW1pbGFyLlxuXG5cbiAgbXNnICs9IFwiLiBSZWNlaXZlZCB0eXBlIFwiLmNvbmNhdChfdHlwZW9mKGFjdHVhbCkpO1xuICByZXR1cm4gbXNnO1xufSwgVHlwZUVycm9yKTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX0lOVkFMSURfQVJHX1ZBTFVFJywgZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gIHZhciByZWFzb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6ICdpcyBpbnZhbGlkJztcbiAgaWYgKHV0aWwgPT09IHVuZGVmaW5lZCkgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oNjgyNyk7XG4gIHZhciBpbnNwZWN0ZWQgPSB1dGlsLmluc3BlY3QodmFsdWUpO1xuXG4gIGlmIChpbnNwZWN0ZWQubGVuZ3RoID4gMTI4KSB7XG4gICAgaW5zcGVjdGVkID0gXCJcIi5jb25jYXQoaW5zcGVjdGVkLnNsaWNlKDAsIDEyOCksIFwiLi4uXCIpO1xuICB9XG5cbiAgcmV0dXJuIFwiVGhlIGFyZ3VtZW50ICdcIi5jb25jYXQobmFtZSwgXCInIFwiKS5jb25jYXQocmVhc29uLCBcIi4gUmVjZWl2ZWQgXCIpLmNvbmNhdChpbnNwZWN0ZWQpO1xufSwgVHlwZUVycm9yLCBSYW5nZUVycm9yKTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX0lOVkFMSURfUkVUVVJOX1ZBTFVFJywgZnVuY3Rpb24gKGlucHV0LCBuYW1lLCB2YWx1ZSkge1xuICB2YXIgdHlwZTtcblxuICBpZiAodmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IgJiYgdmFsdWUuY29uc3RydWN0b3IubmFtZSkge1xuICAgIHR5cGUgPSBcImluc3RhbmNlIG9mIFwiLmNvbmNhdCh2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lKTtcbiAgfSBlbHNlIHtcbiAgICB0eXBlID0gXCJ0eXBlIFwiLmNvbmNhdChfdHlwZW9mKHZhbHVlKSk7XG4gIH1cblxuICByZXR1cm4gXCJFeHBlY3RlZCBcIi5jb25jYXQoaW5wdXQsIFwiIHRvIGJlIHJldHVybmVkIGZyb20gdGhlIFxcXCJcIikuY29uY2F0KG5hbWUsIFwiXFxcIlwiKSArIFwiIGZ1bmN0aW9uIGJ1dCBnb3QgXCIuY29uY2F0KHR5cGUsIFwiLlwiKTtcbn0sIFR5cGVFcnJvcik7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9NSVNTSU5HX0FSR1MnLCBmdW5jdGlvbiAoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICBpZiAoYXNzZXJ0ID09PSB1bmRlZmluZWQpIGFzc2VydCA9IF9fd2VicGFja19yZXF1aXJlX18oNjA5Myk7XG4gIGFzc2VydChhcmdzLmxlbmd0aCA+IDAsICdBdCBsZWFzdCBvbmUgYXJnIG5lZWRzIHRvIGJlIHNwZWNpZmllZCcpO1xuICB2YXIgbXNnID0gJ1RoZSAnO1xuICB2YXIgbGVuID0gYXJncy5sZW5ndGg7XG4gIGFyZ3MgPSBhcmdzLm1hcChmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybiBcIlxcXCJcIi5jb25jYXQoYSwgXCJcXFwiXCIpO1xuICB9KTtcblxuICBzd2l0Y2ggKGxlbikge1xuICAgIGNhc2UgMTpcbiAgICAgIG1zZyArPSBcIlwiLmNvbmNhdChhcmdzWzBdLCBcIiBhcmd1bWVudFwiKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAyOlxuICAgICAgbXNnICs9IFwiXCIuY29uY2F0KGFyZ3NbMF0sIFwiIGFuZCBcIikuY29uY2F0KGFyZ3NbMV0sIFwiIGFyZ3VtZW50c1wiKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIG1zZyArPSBhcmdzLnNsaWNlKDAsIGxlbiAtIDEpLmpvaW4oJywgJyk7XG4gICAgICBtc2cgKz0gXCIsIGFuZCBcIi5jb25jYXQoYXJnc1tsZW4gLSAxXSwgXCIgYXJndW1lbnRzXCIpO1xuICAgICAgYnJlYWs7XG4gIH1cblxuICByZXR1cm4gXCJcIi5jb25jYXQobXNnLCBcIiBtdXN0IGJlIHNwZWNpZmllZFwiKTtcbn0sIFR5cGVFcnJvcik7XG5tb2R1bGUuZXhwb3J0cy5jb2RlcyA9IGNvZGVzO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gNTY1Njpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vLyBDdXJyZW50bHkgaW4gc3luYyB3aXRoIE5vZGUuanMgbGliL2ludGVybmFsL3V0aWwvY29tcGFyaXNvbnMuanNcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9jb21taXQvMTEyY2M3YzI3NTUxMjU0YWEyYjE3MDk4ZmI3NzQ4NjdmMDVlZDBkOVxuXG5cbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkgeyByZXR1cm4gX2FycmF5V2l0aEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgX25vbkl0ZXJhYmxlUmVzdCgpOyB9XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpOyB9XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHsgdmFyIF9hcnIgPSBbXTsgdmFyIF9uID0gdHJ1ZTsgdmFyIF9kID0gZmFsc2U7IHZhciBfZSA9IHVuZGVmaW5lZDsgdHJ5IHsgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkgeyBfYXJyLnB1c2goX3MudmFsdWUpOyBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7IH0gfSBjYXRjaCAoZXJyKSB7IF9kID0gdHJ1ZTsgX2UgPSBlcnI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0gIT0gbnVsbCkgX2lbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKF9kKSB0aHJvdyBfZTsgfSB9IHJldHVybiBfYXJyOyB9XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjsgfVxuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG52YXIgcmVnZXhGbGFnc1N1cHBvcnRlZCA9IC9hL2cuZmxhZ3MgIT09IHVuZGVmaW5lZDtcblxudmFyIGFycmF5RnJvbVNldCA9IGZ1bmN0aW9uIGFycmF5RnJvbVNldChzZXQpIHtcbiAgdmFyIGFycmF5ID0gW107XG4gIHNldC5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiBhcnJheS5wdXNoKHZhbHVlKTtcbiAgfSk7XG4gIHJldHVybiBhcnJheTtcbn07XG5cbnZhciBhcnJheUZyb21NYXAgPSBmdW5jdGlvbiBhcnJheUZyb21NYXAobWFwKSB7XG4gIHZhciBhcnJheSA9IFtdO1xuICBtYXAuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgIHJldHVybiBhcnJheS5wdXNoKFtrZXksIHZhbHVlXSk7XG4gIH0pO1xuICByZXR1cm4gYXJyYXk7XG59O1xuXG52YXIgb2JqZWN0SXMgPSBPYmplY3QuaXMgPyBPYmplY3QuaXMgOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDU5NjgpO1xudmFyIG9iamVjdEdldE93blByb3BlcnR5U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzIDogZnVuY3Rpb24gKCkge1xuICByZXR1cm4gW107XG59O1xudmFyIG51bWJlcklzTmFOID0gTnVtYmVyLmlzTmFOID8gTnVtYmVyLmlzTmFOIDogX193ZWJwYWNrX3JlcXVpcmVfXyg3ODM4KTtcblxuZnVuY3Rpb24gdW5jdXJyeVRoaXMoZikge1xuICByZXR1cm4gZi5jYWxsLmJpbmQoZik7XG59XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IHVuY3VycnlUaGlzKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkpO1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gdW5jdXJyeVRoaXMoT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZSk7XG52YXIgb2JqZWN0VG9TdHJpbmcgPSB1bmN1cnJ5VGhpcyhPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKTtcblxudmFyIF9yZXF1aXJlJHR5cGVzID0gKF9fd2VicGFja19yZXF1aXJlX18oNjgyNykudHlwZXMpLFxuICAgIGlzQW55QXJyYXlCdWZmZXIgPSBfcmVxdWlyZSR0eXBlcy5pc0FueUFycmF5QnVmZmVyLFxuICAgIGlzQXJyYXlCdWZmZXJWaWV3ID0gX3JlcXVpcmUkdHlwZXMuaXNBcnJheUJ1ZmZlclZpZXcsXG4gICAgaXNEYXRlID0gX3JlcXVpcmUkdHlwZXMuaXNEYXRlLFxuICAgIGlzTWFwID0gX3JlcXVpcmUkdHlwZXMuaXNNYXAsXG4gICAgaXNSZWdFeHAgPSBfcmVxdWlyZSR0eXBlcy5pc1JlZ0V4cCxcbiAgICBpc1NldCA9IF9yZXF1aXJlJHR5cGVzLmlzU2V0LFxuICAgIGlzTmF0aXZlRXJyb3IgPSBfcmVxdWlyZSR0eXBlcy5pc05hdGl2ZUVycm9yLFxuICAgIGlzQm94ZWRQcmltaXRpdmUgPSBfcmVxdWlyZSR0eXBlcy5pc0JveGVkUHJpbWl0aXZlLFxuICAgIGlzTnVtYmVyT2JqZWN0ID0gX3JlcXVpcmUkdHlwZXMuaXNOdW1iZXJPYmplY3QsXG4gICAgaXNTdHJpbmdPYmplY3QgPSBfcmVxdWlyZSR0eXBlcy5pc1N0cmluZ09iamVjdCxcbiAgICBpc0Jvb2xlYW5PYmplY3QgPSBfcmVxdWlyZSR0eXBlcy5pc0Jvb2xlYW5PYmplY3QsXG4gICAgaXNCaWdJbnRPYmplY3QgPSBfcmVxdWlyZSR0eXBlcy5pc0JpZ0ludE9iamVjdCxcbiAgICBpc1N5bWJvbE9iamVjdCA9IF9yZXF1aXJlJHR5cGVzLmlzU3ltYm9sT2JqZWN0LFxuICAgIGlzRmxvYXQzMkFycmF5ID0gX3JlcXVpcmUkdHlwZXMuaXNGbG9hdDMyQXJyYXksXG4gICAgaXNGbG9hdDY0QXJyYXkgPSBfcmVxdWlyZSR0eXBlcy5pc0Zsb2F0NjRBcnJheTtcblxuZnVuY3Rpb24gaXNOb25JbmRleChrZXkpIHtcbiAgaWYgKGtleS5sZW5ndGggPT09IDAgfHwga2V5Lmxlbmd0aCA+IDEwKSByZXR1cm4gdHJ1ZTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleS5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjb2RlID0ga2V5LmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGNvZGUgPCA0OCB8fCBjb2RlID4gNTcpIHJldHVybiB0cnVlO1xuICB9IC8vIFRoZSBtYXhpbXVtIHNpemUgZm9yIGFuIGFycmF5IGlzIDIgKiogMzIgLTEuXG5cblxuICByZXR1cm4ga2V5Lmxlbmd0aCA9PT0gMTAgJiYga2V5ID49IE1hdGgucG93KDIsIDMyKTtcbn1cblxuZnVuY3Rpb24gZ2V0T3duTm9uSW5kZXhQcm9wZXJ0aWVzKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyh2YWx1ZSkuZmlsdGVyKGlzTm9uSW5kZXgpLmNvbmNhdChvYmplY3RHZXRPd25Qcm9wZXJ0eVN5bWJvbHModmFsdWUpLmZpbHRlcihPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmJpbmQodmFsdWUpKSk7XG59IC8vIFRha2VuIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvYmxvYi82ODBlOWU1ZTQ4OGYyMmFhYzI3NTk5YTU3ZGM4NDRhNjMxNTkyOGRkL2luZGV4LmpzXG4vLyBvcmlnaW5hbCBub3RpY2U6XG5cbi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGZlcm9zc0BmZXJvc3Mub3JnPiA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cblxuXG5mdW5jdGlvbiBjb21wYXJlKGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHZhciB4ID0gYS5sZW5ndGg7XG4gIHZhciB5ID0gYi5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgeCA9IGFbaV07XG4gICAgICB5ID0gYltpXTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIGlmICh5IDwgeCkge1xuICAgIHJldHVybiAxO1xuICB9XG5cbiAgcmV0dXJuIDA7XG59XG5cbnZhciBPTkxZX0VOVU1FUkFCTEUgPSB1bmRlZmluZWQ7XG52YXIga1N0cmljdCA9IHRydWU7XG52YXIga0xvb3NlID0gZmFsc2U7XG52YXIga05vSXRlcmF0b3IgPSAwO1xudmFyIGtJc0FycmF5ID0gMTtcbnZhciBrSXNTZXQgPSAyO1xudmFyIGtJc01hcCA9IDM7IC8vIENoZWNrIGlmIHRoZXkgaGF2ZSB0aGUgc2FtZSBzb3VyY2UgYW5kIGZsYWdzXG5cbmZ1bmN0aW9uIGFyZVNpbWlsYXJSZWdFeHBzKGEsIGIpIHtcbiAgcmV0dXJuIHJlZ2V4RmxhZ3NTdXBwb3J0ZWQgPyBhLnNvdXJjZSA9PT0gYi5zb3VyY2UgJiYgYS5mbGFncyA9PT0gYi5mbGFncyA6IFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhKSA9PT0gUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGIpO1xufVxuXG5mdW5jdGlvbiBhcmVTaW1pbGFyRmxvYXRBcnJheXMoYSwgYikge1xuICBpZiAoYS5ieXRlTGVuZ3RoICE9PSBiLmJ5dGVMZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmb3IgKHZhciBvZmZzZXQgPSAwOyBvZmZzZXQgPCBhLmJ5dGVMZW5ndGg7IG9mZnNldCsrKSB7XG4gICAgaWYgKGFbb2Zmc2V0XSAhPT0gYltvZmZzZXRdKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGFyZVNpbWlsYXJUeXBlZEFycmF5cyhhLCBiKSB7XG4gIGlmIChhLmJ5dGVMZW5ndGggIT09IGIuYnl0ZUxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBjb21wYXJlKG5ldyBVaW50OEFycmF5KGEuYnVmZmVyLCBhLmJ5dGVPZmZzZXQsIGEuYnl0ZUxlbmd0aCksIG5ldyBVaW50OEFycmF5KGIuYnVmZmVyLCBiLmJ5dGVPZmZzZXQsIGIuYnl0ZUxlbmd0aCkpID09PSAwO1xufVxuXG5mdW5jdGlvbiBhcmVFcXVhbEFycmF5QnVmZmVycyhidWYxLCBidWYyKSB7XG4gIHJldHVybiBidWYxLmJ5dGVMZW5ndGggPT09IGJ1ZjIuYnl0ZUxlbmd0aCAmJiBjb21wYXJlKG5ldyBVaW50OEFycmF5KGJ1ZjEpLCBuZXcgVWludDhBcnJheShidWYyKSkgPT09IDA7XG59XG5cbmZ1bmN0aW9uIGlzRXF1YWxCb3hlZFByaW1pdGl2ZSh2YWwxLCB2YWwyKSB7XG4gIGlmIChpc051bWJlck9iamVjdCh2YWwxKSkge1xuICAgIHJldHVybiBpc051bWJlck9iamVjdCh2YWwyKSAmJiBvYmplY3RJcyhOdW1iZXIucHJvdG90eXBlLnZhbHVlT2YuY2FsbCh2YWwxKSwgTnVtYmVyLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwodmFsMikpO1xuICB9XG5cbiAgaWYgKGlzU3RyaW5nT2JqZWN0KHZhbDEpKSB7XG4gICAgcmV0dXJuIGlzU3RyaW5nT2JqZWN0KHZhbDIpICYmIFN0cmluZy5wcm90b3R5cGUudmFsdWVPZi5jYWxsKHZhbDEpID09PSBTdHJpbmcucHJvdG90eXBlLnZhbHVlT2YuY2FsbCh2YWwyKTtcbiAgfVxuXG4gIGlmIChpc0Jvb2xlYW5PYmplY3QodmFsMSkpIHtcbiAgICByZXR1cm4gaXNCb29sZWFuT2JqZWN0KHZhbDIpICYmIEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbCh2YWwxKSA9PT0gQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKHZhbDIpO1xuICB9XG5cbiAgaWYgKGlzQmlnSW50T2JqZWN0KHZhbDEpKSB7XG4gICAgcmV0dXJuIGlzQmlnSW50T2JqZWN0KHZhbDIpICYmIEJpZ0ludC5wcm90b3R5cGUudmFsdWVPZi5jYWxsKHZhbDEpID09PSBCaWdJbnQucHJvdG90eXBlLnZhbHVlT2YuY2FsbCh2YWwyKTtcbiAgfVxuXG4gIHJldHVybiBpc1N5bWJvbE9iamVjdCh2YWwyKSAmJiBTeW1ib2wucHJvdG90eXBlLnZhbHVlT2YuY2FsbCh2YWwxKSA9PT0gU3ltYm9sLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwodmFsMik7XG59IC8vIE5vdGVzOiBUeXBlIHRhZ3MgYXJlIGhpc3RvcmljYWwgW1tDbGFzc11dIHByb3BlcnRpZXMgdGhhdCBjYW4gYmUgc2V0IGJ5XG4vLyBGdW5jdGlvblRlbXBsYXRlOjpTZXRDbGFzc05hbWUoKSBpbiBDKysgb3IgU3ltYm9sLnRvU3RyaW5nVGFnIGluIEpTXG4vLyBhbmQgcmV0cmlldmVkIHVzaW5nIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopIGluIEpTXG4vLyBTZWUgaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZ1xuLy8gZm9yIGEgbGlzdCBvZiB0YWdzIHByZS1kZWZpbmVkIGluIHRoZSBzcGVjLlxuLy8gVGhlcmUgYXJlIHNvbWUgdW5zcGVjaWZpZWQgdGFncyBpbiB0aGUgd2lsZCB0b28gKGUuZy4gdHlwZWQgYXJyYXkgdGFncykuXG4vLyBTaW5jZSB0YWdzIGNhbiBiZSBhbHRlcmVkLCB0aGV5IG9ubHkgc2VydmUgZmFzdCBmYWlsdXJlc1xuLy9cbi8vIFR5cGVkIGFycmF5cyBhbmQgYnVmZmVycyBhcmUgY2hlY2tlZCBieSBjb21wYXJpbmcgdGhlIGNvbnRlbnQgaW4gdGhlaXJcbi8vIHVuZGVybHlpbmcgQXJyYXlCdWZmZXIuIFRoaXMgb3B0aW1pemF0aW9uIHJlcXVpcmVzIHRoYXQgaXQnc1xuLy8gcmVhc29uYWJsZSB0byBpbnRlcnByZXQgdGhlaXIgdW5kZXJseWluZyBtZW1vcnkgaW4gdGhlIHNhbWUgd2F5LFxuLy8gd2hpY2ggaXMgY2hlY2tlZCBieSBjb21wYXJpbmcgdGhlaXIgdHlwZSB0YWdzLlxuLy8gKGUuZy4gYSBVaW50OEFycmF5IGFuZCBhIFVpbnQxNkFycmF5IHdpdGggdGhlIHNhbWUgbWVtb3J5IGNvbnRlbnRcbi8vIGNvdWxkIHN0aWxsIGJlIGRpZmZlcmVudCBiZWNhdXNlIHRoZXkgd2lsbCBiZSBpbnRlcnByZXRlZCBkaWZmZXJlbnRseSkuXG4vL1xuLy8gRm9yIHN0cmljdCBjb21wYXJpc29uLCBvYmplY3RzIHNob3VsZCBoYXZlXG4vLyBhKSBUaGUgc2FtZSBidWlsdC1pbiB0eXBlIHRhZ3Ncbi8vIGIpIFRoZSBzYW1lIHByb3RvdHlwZXMuXG5cblxuZnVuY3Rpb24gaW5uZXJEZWVwRXF1YWwodmFsMSwgdmFsMiwgc3RyaWN0LCBtZW1vcykge1xuICAvLyBBbGwgaWRlbnRpY2FsIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgYXMgZGV0ZXJtaW5lZCBieSA9PT0uXG4gIGlmICh2YWwxID09PSB2YWwyKSB7XG4gICAgaWYgKHZhbDEgIT09IDApIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBzdHJpY3QgPyBvYmplY3RJcyh2YWwxLCB2YWwyKSA6IHRydWU7XG4gIH0gLy8gQ2hlY2sgbW9yZSBjbG9zZWx5IGlmIHZhbDEgYW5kIHZhbDIgYXJlIGVxdWFsLlxuXG5cbiAgaWYgKHN0cmljdCkge1xuICAgIGlmIChfdHlwZW9mKHZhbDEpICE9PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWwxID09PSAnbnVtYmVyJyAmJiBudW1iZXJJc05hTih2YWwxKSAmJiBudW1iZXJJc05hTih2YWwyKTtcbiAgICB9XG5cbiAgICBpZiAoX3R5cGVvZih2YWwyKSAhPT0gJ29iamVjdCcgfHwgdmFsMSA9PT0gbnVsbCB8fCB2YWwyID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWwxKSAhPT0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbDIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICh2YWwxID09PSBudWxsIHx8IF90eXBlb2YodmFsMSkgIT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAodmFsMiA9PT0gbnVsbCB8fCBfdHlwZW9mKHZhbDIpICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG4gICAgICAgIHJldHVybiB2YWwxID09IHZhbDI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAodmFsMiA9PT0gbnVsbCB8fCBfdHlwZW9mKHZhbDIpICE9PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHZhciB2YWwxVGFnID0gb2JqZWN0VG9TdHJpbmcodmFsMSk7XG4gIHZhciB2YWwyVGFnID0gb2JqZWN0VG9TdHJpbmcodmFsMik7XG5cbiAgaWYgKHZhbDFUYWcgIT09IHZhbDJUYWcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWwxKSkge1xuICAgIC8vIENoZWNrIGZvciBzcGFyc2UgYXJyYXlzIGFuZCBnZW5lcmFsIGZhc3QgcGF0aFxuICAgIGlmICh2YWwxLmxlbmd0aCAhPT0gdmFsMi5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIga2V5czEgPSBnZXRPd25Ob25JbmRleFByb3BlcnRpZXModmFsMSwgT05MWV9FTlVNRVJBQkxFKTtcbiAgICB2YXIga2V5czIgPSBnZXRPd25Ob25JbmRleFByb3BlcnRpZXModmFsMiwgT05MWV9FTlVNRVJBQkxFKTtcblxuICAgIGlmIChrZXlzMS5sZW5ndGggIT09IGtleXMyLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiBrZXlDaGVjayh2YWwxLCB2YWwyLCBzdHJpY3QsIG1lbW9zLCBrSXNBcnJheSwga2V5czEpO1xuICB9IC8vIFticm93c2VyaWZ5XSBUaGlzIHRyaWdnZXJzIG9uIGNlcnRhaW4gdHlwZXMgaW4gSUUgKE1hcC9TZXQpIHNvIHdlIGRvbid0XG4gIC8vIHdhbid0IHRvIGVhcmx5IHJldHVybiBvdXQgb2YgdGhlIHJlc3Qgb2YgdGhlIGNoZWNrcy4gSG93ZXZlciB3ZSBjYW4gY2hlY2tcbiAgLy8gaWYgdGhlIHNlY29uZCB2YWx1ZSBpcyBvbmUgb2YgdGhlc2UgdmFsdWVzIGFuZCB0aGUgZmlyc3QgaXNuJ3QuXG5cblxuICBpZiAodmFsMVRhZyA9PT0gJ1tvYmplY3QgT2JqZWN0XScpIHtcbiAgICAvLyByZXR1cm4ga2V5Q2hlY2sodmFsMSwgdmFsMiwgc3RyaWN0LCBtZW1vcywga05vSXRlcmF0b3IpO1xuICAgIGlmICghaXNNYXAodmFsMSkgJiYgaXNNYXAodmFsMikgfHwgIWlzU2V0KHZhbDEpICYmIGlzU2V0KHZhbDIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgaWYgKGlzRGF0ZSh2YWwxKSkge1xuICAgIGlmICghaXNEYXRlKHZhbDIpIHx8IERhdGUucHJvdG90eXBlLmdldFRpbWUuY2FsbCh2YWwxKSAhPT0gRGF0ZS5wcm90b3R5cGUuZ2V0VGltZS5jYWxsKHZhbDIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzUmVnRXhwKHZhbDEpKSB7XG4gICAgaWYgKCFpc1JlZ0V4cCh2YWwyKSB8fCAhYXJlU2ltaWxhclJlZ0V4cHModmFsMSwgdmFsMikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNOYXRpdmVFcnJvcih2YWwxKSB8fCB2YWwxIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAvLyBEbyBub3QgY29tcGFyZSB0aGUgc3RhY2sgYXMgaXQgbWlnaHQgZGlmZmVyIGV2ZW4gdGhvdWdoIHRoZSBlcnJvciBpdHNlbGZcbiAgICAvLyBpcyBvdGhlcndpc2UgaWRlbnRpY2FsLlxuICAgIGlmICh2YWwxLm1lc3NhZ2UgIT09IHZhbDIubWVzc2FnZSB8fCB2YWwxLm5hbWUgIT09IHZhbDIubmFtZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc0FycmF5QnVmZmVyVmlldyh2YWwxKSkge1xuICAgIGlmICghc3RyaWN0ICYmIChpc0Zsb2F0MzJBcnJheSh2YWwxKSB8fCBpc0Zsb2F0NjRBcnJheSh2YWwxKSkpIHtcbiAgICAgIGlmICghYXJlU2ltaWxhckZsb2F0QXJyYXlzKHZhbDEsIHZhbDIpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFhcmVTaW1pbGFyVHlwZWRBcnJheXModmFsMSwgdmFsMikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IC8vIEJ1ZmZlci5jb21wYXJlIHJldHVybnMgdHJ1ZSwgc28gdmFsMS5sZW5ndGggPT09IHZhbDIubGVuZ3RoLiBJZiB0aGV5IGJvdGhcbiAgICAvLyBvbmx5IGNvbnRhaW4gbnVtZXJpYyBrZXlzLCB3ZSBkb24ndCBuZWVkIHRvIGV4YW0gZnVydGhlciB0aGFuIGNoZWNraW5nXG4gICAgLy8gdGhlIHN5bWJvbHMuXG5cblxuICAgIHZhciBfa2V5cyA9IGdldE93bk5vbkluZGV4UHJvcGVydGllcyh2YWwxLCBPTkxZX0VOVU1FUkFCTEUpO1xuXG4gICAgdmFyIF9rZXlzMiA9IGdldE93bk5vbkluZGV4UHJvcGVydGllcyh2YWwyLCBPTkxZX0VOVU1FUkFCTEUpO1xuXG4gICAgaWYgKF9rZXlzLmxlbmd0aCAhPT0gX2tleXMyLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiBrZXlDaGVjayh2YWwxLCB2YWwyLCBzdHJpY3QsIG1lbW9zLCBrTm9JdGVyYXRvciwgX2tleXMpO1xuICB9IGVsc2UgaWYgKGlzU2V0KHZhbDEpKSB7XG4gICAgaWYgKCFpc1NldCh2YWwyKSB8fCB2YWwxLnNpemUgIT09IHZhbDIuc2l6ZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiBrZXlDaGVjayh2YWwxLCB2YWwyLCBzdHJpY3QsIG1lbW9zLCBrSXNTZXQpO1xuICB9IGVsc2UgaWYgKGlzTWFwKHZhbDEpKSB7XG4gICAgaWYgKCFpc01hcCh2YWwyKSB8fCB2YWwxLnNpemUgIT09IHZhbDIuc2l6ZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiBrZXlDaGVjayh2YWwxLCB2YWwyLCBzdHJpY3QsIG1lbW9zLCBrSXNNYXApO1xuICB9IGVsc2UgaWYgKGlzQW55QXJyYXlCdWZmZXIodmFsMSkpIHtcbiAgICBpZiAoIWFyZUVxdWFsQXJyYXlCdWZmZXJzKHZhbDEsIHZhbDIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzQm94ZWRQcmltaXRpdmUodmFsMSkgJiYgIWlzRXF1YWxCb3hlZFByaW1pdGl2ZSh2YWwxLCB2YWwyKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBrZXlDaGVjayh2YWwxLCB2YWwyLCBzdHJpY3QsIG1lbW9zLCBrTm9JdGVyYXRvcik7XG59XG5cbmZ1bmN0aW9uIGdldEVudW1lcmFibGVzKHZhbCwga2V5cykge1xuICByZXR1cm4ga2V5cy5maWx0ZXIoZnVuY3Rpb24gKGspIHtcbiAgICByZXR1cm4gcHJvcGVydHlJc0VudW1lcmFibGUodmFsLCBrKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGtleUNoZWNrKHZhbDEsIHZhbDIsIHN0cmljdCwgbWVtb3MsIGl0ZXJhdGlvblR5cGUsIGFLZXlzKSB7XG4gIC8vIEZvciBhbGwgcmVtYWluaW5nIE9iamVjdCBwYWlycywgaW5jbHVkaW5nIEFycmF5LCBvYmplY3RzIGFuZCBNYXBzLFxuICAvLyBlcXVpdmFsZW5jZSBpcyBkZXRlcm1pbmVkIGJ5IGhhdmluZzpcbiAgLy8gYSkgVGhlIHNhbWUgbnVtYmVyIG9mIG93bmVkIGVudW1lcmFibGUgcHJvcGVydGllc1xuICAvLyBiKSBUaGUgc2FtZSBzZXQgb2Yga2V5cy9pbmRleGVzIChhbHRob3VnaCBub3QgbmVjZXNzYXJpbHkgdGhlIHNhbWUgb3JkZXIpXG4gIC8vIGMpIEVxdWl2YWxlbnQgdmFsdWVzIGZvciBldmVyeSBjb3JyZXNwb25kaW5nIGtleS9pbmRleFxuICAvLyBkKSBGb3IgU2V0cyBhbmQgTWFwcywgZXF1YWwgY29udGVudHNcbiAgLy8gTm90ZTogdGhpcyBhY2NvdW50cyBmb3IgYm90aCBuYW1lZCBhbmQgaW5kZXhlZCBwcm9wZXJ0aWVzIG9uIEFycmF5cy5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDUpIHtcbiAgICBhS2V5cyA9IE9iamVjdC5rZXlzKHZhbDEpO1xuICAgIHZhciBiS2V5cyA9IE9iamVjdC5rZXlzKHZhbDIpOyAvLyBUaGUgcGFpciBtdXN0IGhhdmUgdGhlIHNhbWUgbnVtYmVyIG9mIG93bmVkIHByb3BlcnRpZXMuXG5cbiAgICBpZiAoYUtleXMubGVuZ3RoICE9PSBiS2V5cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gLy8gQ2hlYXAga2V5IHRlc3RcblxuXG4gIHZhciBpID0gMDtcblxuICBmb3IgKDsgaSA8IGFLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCFoYXNPd25Qcm9wZXJ0eSh2YWwyLCBhS2V5c1tpXSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBpZiAoc3RyaWN0ICYmIGFyZ3VtZW50cy5sZW5ndGggPT09IDUpIHtcbiAgICB2YXIgc3ltYm9sS2V5c0EgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eVN5bWJvbHModmFsMSk7XG5cbiAgICBpZiAoc3ltYm9sS2V5c0EubGVuZ3RoICE9PSAwKSB7XG4gICAgICB2YXIgY291bnQgPSAwO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgc3ltYm9sS2V5c0EubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGtleSA9IHN5bWJvbEtleXNBW2ldO1xuXG4gICAgICAgIGlmIChwcm9wZXJ0eUlzRW51bWVyYWJsZSh2YWwxLCBrZXkpKSB7XG4gICAgICAgICAgaWYgKCFwcm9wZXJ0eUlzRW51bWVyYWJsZSh2YWwyLCBrZXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYUtleXMucHVzaChrZXkpO1xuICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvcGVydHlJc0VudW1lcmFibGUodmFsMiwga2V5KSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgc3ltYm9sS2V5c0IgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eVN5bWJvbHModmFsMik7XG5cbiAgICAgIGlmIChzeW1ib2xLZXlzQS5sZW5ndGggIT09IHN5bWJvbEtleXNCLmxlbmd0aCAmJiBnZXRFbnVtZXJhYmxlcyh2YWwyLCBzeW1ib2xLZXlzQikubGVuZ3RoICE9PSBjb3VudCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBfc3ltYm9sS2V5c0IgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eVN5bWJvbHModmFsMik7XG5cbiAgICAgIGlmIChfc3ltYm9sS2V5c0IubGVuZ3RoICE9PSAwICYmIGdldEVudW1lcmFibGVzKHZhbDIsIF9zeW1ib2xLZXlzQikubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoYUtleXMubGVuZ3RoID09PSAwICYmIChpdGVyYXRpb25UeXBlID09PSBrTm9JdGVyYXRvciB8fCBpdGVyYXRpb25UeXBlID09PSBrSXNBcnJheSAmJiB2YWwxLmxlbmd0aCA9PT0gMCB8fCB2YWwxLnNpemUgPT09IDApKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gVXNlIG1lbW9zIHRvIGhhbmRsZSBjeWNsZXMuXG5cblxuICBpZiAobWVtb3MgPT09IHVuZGVmaW5lZCkge1xuICAgIG1lbW9zID0ge1xuICAgICAgdmFsMTogbmV3IE1hcCgpLFxuICAgICAgdmFsMjogbmV3IE1hcCgpLFxuICAgICAgcG9zaXRpb246IDBcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIC8vIFdlIHByZXZlbnQgdXAgdG8gdHdvIG1hcC5oYXMoeCkgY2FsbHMgYnkgZGlyZWN0bHkgcmV0cmlldmluZyB0aGUgdmFsdWVcbiAgICAvLyBhbmQgY2hlY2tpbmcgZm9yIHVuZGVmaW5lZC4gVGhlIG1hcCBjYW4gb25seSBjb250YWluIG51bWJlcnMsIHNvIGl0IGlzXG4gICAgLy8gc2FmZSB0byBjaGVjayBmb3IgdW5kZWZpbmVkIG9ubHkuXG4gICAgdmFyIHZhbDJNZW1vQSA9IG1lbW9zLnZhbDEuZ2V0KHZhbDEpO1xuXG4gICAgaWYgKHZhbDJNZW1vQSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgdmFsMk1lbW9CID0gbWVtb3MudmFsMi5nZXQodmFsMik7XG5cbiAgICAgIGlmICh2YWwyTWVtb0IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdmFsMk1lbW9BID09PSB2YWwyTWVtb0I7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbWVtb3MucG9zaXRpb24rKztcbiAgfVxuXG4gIG1lbW9zLnZhbDEuc2V0KHZhbDEsIG1lbW9zLnBvc2l0aW9uKTtcbiAgbWVtb3MudmFsMi5zZXQodmFsMiwgbWVtb3MucG9zaXRpb24pO1xuICB2YXIgYXJlRXEgPSBvYmpFcXVpdih2YWwxLCB2YWwyLCBzdHJpY3QsIGFLZXlzLCBtZW1vcywgaXRlcmF0aW9uVHlwZSk7XG4gIG1lbW9zLnZhbDEuZGVsZXRlKHZhbDEpO1xuICBtZW1vcy52YWwyLmRlbGV0ZSh2YWwyKTtcbiAgcmV0dXJuIGFyZUVxO1xufVxuXG5mdW5jdGlvbiBzZXRIYXNFcXVhbEVsZW1lbnQoc2V0LCB2YWwxLCBzdHJpY3QsIG1lbW8pIHtcbiAgLy8gR28gbG9va2luZy5cbiAgdmFyIHNldFZhbHVlcyA9IGFycmF5RnJvbVNldChzZXQpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2V0VmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHZhbDIgPSBzZXRWYWx1ZXNbaV07XG5cbiAgICBpZiAoaW5uZXJEZWVwRXF1YWwodmFsMSwgdmFsMiwgc3RyaWN0LCBtZW1vKSkge1xuICAgICAgLy8gUmVtb3ZlIHRoZSBtYXRjaGluZyBlbGVtZW50IHRvIG1ha2Ugc3VyZSB3ZSBkbyBub3QgY2hlY2sgdGhhdCBhZ2Fpbi5cbiAgICAgIHNldC5kZWxldGUodmFsMik7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59IC8vIFNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L0VxdWFsaXR5X2NvbXBhcmlzb25zX2FuZF9zYW1lbmVzcyNMb29zZV9lcXVhbGl0eV91c2luZ1xuLy8gU2FkbHkgaXQgaXMgbm90IHBvc3NpYmxlIHRvIGRldGVjdCBjb3JyZXNwb25kaW5nIHZhbHVlcyBwcm9wZXJseSBpbiBjYXNlIHRoZVxuLy8gdHlwZSBpcyBhIHN0cmluZywgbnVtYmVyLCBiaWdpbnQgb3IgYm9vbGVhbi4gVGhlIHJlYXNvbiBpcyB0aGF0IHRob3NlIHZhbHVlc1xuLy8gY2FuIG1hdGNoIGxvdHMgb2YgZGlmZmVyZW50IHN0cmluZyB2YWx1ZXMgKGUuZy4sIDFuID09ICcrMDAwMDEnKS5cblxuXG5mdW5jdGlvbiBmaW5kTG9vc2VNYXRjaGluZ1ByaW1pdGl2ZXMocHJpbSkge1xuICBzd2l0Y2ggKF90eXBlb2YocHJpbSkpIHtcbiAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICBjYXNlICdvYmplY3QnOlxuICAgICAgLy8gT25seSBwYXNzIGluIG51bGwgYXMgb2JqZWN0IVxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcblxuICAgIGNhc2UgJ3N5bWJvbCc6XG4gICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgcHJpbSA9ICtwcmltO1xuICAgIC8vIExvb3NlIGVxdWFsIGVudHJpZXMgZXhpc3Qgb25seSBpZiB0aGUgc3RyaW5nIGlzIHBvc3NpYmxlIHRvIGNvbnZlcnQgdG9cbiAgICAvLyBhIHJlZ3VsYXIgbnVtYmVyIGFuZCBub3QgTmFOLlxuICAgIC8vIEZhbGwgdGhyb3VnaFxuXG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIGlmIChudW1iZXJJc05hTihwcmltKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBzZXRNaWdodEhhdmVMb29zZVByaW0oYSwgYiwgcHJpbSkge1xuICB2YXIgYWx0VmFsdWUgPSBmaW5kTG9vc2VNYXRjaGluZ1ByaW1pdGl2ZXMocHJpbSk7XG4gIGlmIChhbHRWYWx1ZSAhPSBudWxsKSByZXR1cm4gYWx0VmFsdWU7XG4gIHJldHVybiBiLmhhcyhhbHRWYWx1ZSkgJiYgIWEuaGFzKGFsdFZhbHVlKTtcbn1cblxuZnVuY3Rpb24gbWFwTWlnaHRIYXZlTG9vc2VQcmltKGEsIGIsIHByaW0sIGl0ZW0sIG1lbW8pIHtcbiAgdmFyIGFsdFZhbHVlID0gZmluZExvb3NlTWF0Y2hpbmdQcmltaXRpdmVzKHByaW0pO1xuXG4gIGlmIChhbHRWYWx1ZSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIGFsdFZhbHVlO1xuICB9XG5cbiAgdmFyIGN1ckIgPSBiLmdldChhbHRWYWx1ZSk7XG5cbiAgaWYgKGN1ckIgPT09IHVuZGVmaW5lZCAmJiAhYi5oYXMoYWx0VmFsdWUpIHx8ICFpbm5lckRlZXBFcXVhbChpdGVtLCBjdXJCLCBmYWxzZSwgbWVtbykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gIWEuaGFzKGFsdFZhbHVlKSAmJiBpbm5lckRlZXBFcXVhbChpdGVtLCBjdXJCLCBmYWxzZSwgbWVtbyk7XG59XG5cbmZ1bmN0aW9uIHNldEVxdWl2KGEsIGIsIHN0cmljdCwgbWVtbykge1xuICAvLyBUaGlzIGlzIGEgbGF6aWx5IGluaXRpYXRlZCBTZXQgb2YgZW50cmllcyB3aGljaCBoYXZlIHRvIGJlIGNvbXBhcmVkXG4gIC8vIHBhaXJ3aXNlLlxuICB2YXIgc2V0ID0gbnVsbDtcbiAgdmFyIGFWYWx1ZXMgPSBhcnJheUZyb21TZXQoYSk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhVmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHZhbCA9IGFWYWx1ZXNbaV07IC8vIE5vdGU6IENoZWNraW5nIGZvciB0aGUgb2JqZWN0cyBmaXJzdCBpbXByb3ZlcyB0aGUgcGVyZm9ybWFuY2UgZm9yIG9iamVjdFxuICAgIC8vIGhlYXZ5IHNldHMgYnV0IGl0IGlzIGEgbWlub3Igc2xvdyBkb3duIGZvciBwcmltaXRpdmVzLiBBcyB0aGV5IGFyZSBmYXN0XG4gICAgLy8gdG8gY2hlY2sgdGhpcyBpbXByb3ZlcyB0aGUgd29yc3QgY2FzZSBzY2VuYXJpbyBpbnN0ZWFkLlxuXG4gICAgaWYgKF90eXBlb2YodmFsKSA9PT0gJ29iamVjdCcgJiYgdmFsICE9PSBudWxsKSB7XG4gICAgICBpZiAoc2V0ID09PSBudWxsKSB7XG4gICAgICAgIHNldCA9IG5ldyBTZXQoKTtcbiAgICAgIH0gLy8gSWYgdGhlIHNwZWNpZmllZCB2YWx1ZSBkb2Vzbid0IGV4aXN0IGluIHRoZSBzZWNvbmQgc2V0IGl0cyBhbiBub3QgbnVsbFxuICAgICAgLy8gb2JqZWN0IChvciBub24gc3RyaWN0IG9ubHk6IGEgbm90IG1hdGNoaW5nIHByaW1pdGl2ZSkgd2UnbGwgbmVlZCB0byBnb1xuICAgICAgLy8gaHVudGluZyBmb3Igc29tZXRoaW5nIHRoYXRzIGRlZXAtKHN0cmljdC0pZXF1YWwgdG8gaXQuIFRvIG1ha2UgdGhpc1xuICAgICAgLy8gTyhuIGxvZyBuKSBjb21wbGV4aXR5IHdlIGhhdmUgdG8gY29weSB0aGVzZSB2YWx1ZXMgaW4gYSBuZXcgc2V0IGZpcnN0LlxuXG5cbiAgICAgIHNldC5hZGQodmFsKTtcbiAgICB9IGVsc2UgaWYgKCFiLmhhcyh2YWwpKSB7XG4gICAgICBpZiAoc3RyaWN0KSByZXR1cm4gZmFsc2U7IC8vIEZhc3QgcGF0aCB0byBkZXRlY3QgbWlzc2luZyBzdHJpbmcsIHN5bWJvbCwgdW5kZWZpbmVkIGFuZCBudWxsIHZhbHVlcy5cblxuICAgICAgaWYgKCFzZXRNaWdodEhhdmVMb29zZVByaW0oYSwgYiwgdmFsKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZXQgPT09IG51bGwpIHtcbiAgICAgICAgc2V0ID0gbmV3IFNldCgpO1xuICAgICAgfVxuXG4gICAgICBzZXQuYWRkKHZhbCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHNldCAhPT0gbnVsbCkge1xuICAgIHZhciBiVmFsdWVzID0gYXJyYXlGcm9tU2V0KGIpO1xuXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGJWYWx1ZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgX3ZhbCA9IGJWYWx1ZXNbX2ldOyAvLyBXZSBoYXZlIHRvIGNoZWNrIGlmIGEgcHJpbWl0aXZlIHZhbHVlIGlzIGFscmVhZHlcbiAgICAgIC8vIG1hdGNoaW5nIGFuZCBvbmx5IGlmIGl0J3Mgbm90LCBnbyBodW50aW5nIGZvciBpdC5cblxuICAgICAgaWYgKF90eXBlb2YoX3ZhbCkgPT09ICdvYmplY3QnICYmIF92YWwgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKCFzZXRIYXNFcXVhbEVsZW1lbnQoc2V0LCBfdmFsLCBzdHJpY3QsIG1lbW8pKSByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKCFzdHJpY3QgJiYgIWEuaGFzKF92YWwpICYmICFzZXRIYXNFcXVhbEVsZW1lbnQoc2V0LCBfdmFsLCBzdHJpY3QsIG1lbW8pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc2V0LnNpemUgPT09IDA7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gbWFwSGFzRXF1YWxFbnRyeShzZXQsIG1hcCwga2V5MSwgaXRlbTEsIHN0cmljdCwgbWVtbykge1xuICAvLyBUbyBiZSBhYmxlIHRvIGhhbmRsZSBjYXNlcyBsaWtlOlxuICAvLyAgIE1hcChbW3t9LCAnYSddLCBbe30sICdiJ11dKSB2cyBNYXAoW1t7fSwgJ2InXSwgW3t9LCAnYSddXSlcbiAgLy8gLi4uIHdlIG5lZWQgdG8gY29uc2lkZXIgKmFsbCogbWF0Y2hpbmcga2V5cywgbm90IGp1c3QgdGhlIGZpcnN0IHdlIGZpbmQuXG4gIHZhciBzZXRWYWx1ZXMgPSBhcnJheUZyb21TZXQoc2V0KTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHNldFZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBrZXkyID0gc2V0VmFsdWVzW2ldO1xuXG4gICAgaWYgKGlubmVyRGVlcEVxdWFsKGtleTEsIGtleTIsIHN0cmljdCwgbWVtbykgJiYgaW5uZXJEZWVwRXF1YWwoaXRlbTEsIG1hcC5nZXQoa2V5MiksIHN0cmljdCwgbWVtbykpIHtcbiAgICAgIHNldC5kZWxldGUoa2V5Mik7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG1hcEVxdWl2KGEsIGIsIHN0cmljdCwgbWVtbykge1xuICB2YXIgc2V0ID0gbnVsbDtcbiAgdmFyIGFFbnRyaWVzID0gYXJyYXlGcm9tTWFwKGEpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYUVudHJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgX2FFbnRyaWVzJGkgPSBfc2xpY2VkVG9BcnJheShhRW50cmllc1tpXSwgMiksXG4gICAgICAgIGtleSA9IF9hRW50cmllcyRpWzBdLFxuICAgICAgICBpdGVtMSA9IF9hRW50cmllcyRpWzFdO1xuXG4gICAgaWYgKF90eXBlb2Yoa2V5KSA9PT0gJ29iamVjdCcgJiYga2V5ICE9PSBudWxsKSB7XG4gICAgICBpZiAoc2V0ID09PSBudWxsKSB7XG4gICAgICAgIHNldCA9IG5ldyBTZXQoKTtcbiAgICAgIH1cblxuICAgICAgc2V0LmFkZChrZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBCeSBkaXJlY3RseSByZXRyaWV2aW5nIHRoZSB2YWx1ZSB3ZSBwcmV2ZW50IGFub3RoZXIgYi5oYXMoa2V5KSBjaGVjayBpblxuICAgICAgLy8gYWxtb3N0IGFsbCBwb3NzaWJsZSBjYXNlcy5cbiAgICAgIHZhciBpdGVtMiA9IGIuZ2V0KGtleSk7XG5cbiAgICAgIGlmIChpdGVtMiA9PT0gdW5kZWZpbmVkICYmICFiLmhhcyhrZXkpIHx8ICFpbm5lckRlZXBFcXVhbChpdGVtMSwgaXRlbTIsIHN0cmljdCwgbWVtbykpIHtcbiAgICAgICAgaWYgKHN0cmljdCkgcmV0dXJuIGZhbHNlOyAvLyBGYXN0IHBhdGggdG8gZGV0ZWN0IG1pc3Npbmcgc3RyaW5nLCBzeW1ib2wsIHVuZGVmaW5lZCBhbmQgbnVsbFxuICAgICAgICAvLyBrZXlzLlxuXG4gICAgICAgIGlmICghbWFwTWlnaHRIYXZlTG9vc2VQcmltKGEsIGIsIGtleSwgaXRlbTEsIG1lbW8pKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgaWYgKHNldCA9PT0gbnVsbCkge1xuICAgICAgICAgIHNldCA9IG5ldyBTZXQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNldC5hZGQoa2V5KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoc2V0ICE9PSBudWxsKSB7XG4gICAgdmFyIGJFbnRyaWVzID0gYXJyYXlGcm9tTWFwKGIpO1xuXG4gICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgYkVudHJpZXMubGVuZ3RoOyBfaTIrKykge1xuICAgICAgdmFyIF9iRW50cmllcyRfaSA9IF9zbGljZWRUb0FycmF5KGJFbnRyaWVzW19pMl0sIDIpLFxuICAgICAgICAgIGtleSA9IF9iRW50cmllcyRfaVswXSxcbiAgICAgICAgICBpdGVtID0gX2JFbnRyaWVzJF9pWzFdO1xuXG4gICAgICBpZiAoX3R5cGVvZihrZXkpID09PSAnb2JqZWN0JyAmJiBrZXkgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKCFtYXBIYXNFcXVhbEVudHJ5KHNldCwgYSwga2V5LCBpdGVtLCBzdHJpY3QsIG1lbW8pKSByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKCFzdHJpY3QgJiYgKCFhLmhhcyhrZXkpIHx8ICFpbm5lckRlZXBFcXVhbChhLmdldChrZXkpLCBpdGVtLCBmYWxzZSwgbWVtbykpICYmICFtYXBIYXNFcXVhbEVudHJ5KHNldCwgYSwga2V5LCBpdGVtLCBmYWxzZSwgbWVtbykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzZXQuc2l6ZSA9PT0gMDtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBvYmpFcXVpdihhLCBiLCBzdHJpY3QsIGtleXMsIG1lbW9zLCBpdGVyYXRpb25UeXBlKSB7XG4gIC8vIFNldHMgYW5kIG1hcHMgZG9uJ3QgaGF2ZSB0aGVpciBlbnRyaWVzIGFjY2Vzc2libGUgdmlhIG5vcm1hbCBvYmplY3RcbiAgLy8gcHJvcGVydGllcy5cbiAgdmFyIGkgPSAwO1xuXG4gIGlmIChpdGVyYXRpb25UeXBlID09PSBrSXNTZXQpIHtcbiAgICBpZiAoIXNldEVxdWl2KGEsIGIsIHN0cmljdCwgbWVtb3MpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9IGVsc2UgaWYgKGl0ZXJhdGlvblR5cGUgPT09IGtJc01hcCkge1xuICAgIGlmICghbWFwRXF1aXYoYSwgYiwgc3RyaWN0LCBtZW1vcykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXRlcmF0aW9uVHlwZSA9PT0ga0lzQXJyYXkpIHtcbiAgICBmb3IgKDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eShhLCBpKSkge1xuICAgICAgICBpZiAoIWhhc093blByb3BlcnR5KGIsIGkpIHx8ICFpbm5lckRlZXBFcXVhbChhW2ldLCBiW2ldLCBzdHJpY3QsIG1lbW9zKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChoYXNPd25Qcm9wZXJ0eShiLCBpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBBcnJheSBpcyBzcGFyc2UuXG4gICAgICAgIHZhciBrZXlzQSA9IE9iamVjdC5rZXlzKGEpO1xuXG4gICAgICAgIGZvciAoOyBpIDwga2V5c0EubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIga2V5ID0ga2V5c0FbaV07XG5cbiAgICAgICAgICBpZiAoIWhhc093blByb3BlcnR5KGIsIGtleSkgfHwgIWlubmVyRGVlcEVxdWFsKGFba2V5XSwgYltrZXldLCBzdHJpY3QsIG1lbW9zKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChrZXlzQS5sZW5ndGggIT09IE9iamVjdC5rZXlzKGIpLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfSAvLyBUaGUgcGFpciBtdXN0IGhhdmUgZXF1aXZhbGVudCB2YWx1ZXMgZm9yIGV2ZXJ5IGNvcnJlc3BvbmRpbmcga2V5LlxuICAvLyBQb3NzaWJseSBleHBlbnNpdmUgZGVlcCB0ZXN0OlxuXG5cbiAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgX2tleSA9IGtleXNbaV07XG5cbiAgICBpZiAoIWlubmVyRGVlcEVxdWFsKGFbX2tleV0sIGJbX2tleV0sIHN0cmljdCwgbWVtb3MpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGlzRGVlcEVxdWFsKHZhbDEsIHZhbDIpIHtcbiAgcmV0dXJuIGlubmVyRGVlcEVxdWFsKHZhbDEsIHZhbDIsIGtMb29zZSk7XG59XG5cbmZ1bmN0aW9uIGlzRGVlcFN0cmljdEVxdWFsKHZhbDEsIHZhbDIpIHtcbiAgcmV0dXJuIGlubmVyRGVlcEVxdWFsKHZhbDEsIHZhbDIsIGtTdHJpY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaXNEZWVwRXF1YWw6IGlzRGVlcEVxdWFsLFxuICBpc0RlZXBTdHJpY3RFcXVhbDogaXNEZWVwU3RyaWN0RXF1YWxcbn07XG5cbi8qKiovIH0pLFxuXG4vKioqLyA5ODE4OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgR2V0SW50cmluc2ljID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MjgpO1xuXG52YXIgY2FsbEJpbmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg0OTgpO1xuXG52YXIgJGluZGV4T2YgPSBjYWxsQmluZChHZXRJbnRyaW5zaWMoJ1N0cmluZy5wcm90b3R5cGUuaW5kZXhPZicpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjYWxsQm91bmRJbnRyaW5zaWMobmFtZSwgYWxsb3dNaXNzaW5nKSB7XG5cdHZhciBpbnRyaW5zaWMgPSBHZXRJbnRyaW5zaWMobmFtZSwgISFhbGxvd01pc3NpbmcpO1xuXHRpZiAodHlwZW9mIGludHJpbnNpYyA9PT0gJ2Z1bmN0aW9uJyAmJiAkaW5kZXhPZihuYW1lLCAnLnByb3RvdHlwZS4nKSA+IC0xKSB7XG5cdFx0cmV0dXJuIGNhbGxCaW5kKGludHJpbnNpYyk7XG5cdH1cblx0cmV0dXJuIGludHJpbnNpYztcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDg0OTg6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBiaW5kID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MTM4KTtcbnZhciBHZXRJbnRyaW5zaWMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUyOCk7XG52YXIgc2V0RnVuY3Rpb25MZW5ndGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYxMDgpO1xuXG52YXIgJFR5cGVFcnJvciA9IF9fd2VicGFja19yZXF1aXJlX18oMzQ2OCk7XG52YXIgJGFwcGx5ID0gR2V0SW50cmluc2ljKCclRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5JScpO1xudmFyICRjYWxsID0gR2V0SW50cmluc2ljKCclRnVuY3Rpb24ucHJvdG90eXBlLmNhbGwlJyk7XG52YXIgJHJlZmxlY3RBcHBseSA9IEdldEludHJpbnNpYygnJVJlZmxlY3QuYXBwbHklJywgdHJ1ZSkgfHwgYmluZC5jYWxsKCRjYWxsLCAkYXBwbHkpO1xuXG52YXIgJGRlZmluZVByb3BlcnR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0OTQwKTtcbnZhciAkbWF4ID0gR2V0SW50cmluc2ljKCclTWF0aC5tYXglJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY2FsbEJpbmQob3JpZ2luYWxGdW5jdGlvbikge1xuXHRpZiAodHlwZW9mIG9yaWdpbmFsRnVuY3Rpb24gIT09ICdmdW5jdGlvbicpIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignYSBmdW5jdGlvbiBpcyByZXF1aXJlZCcpO1xuXHR9XG5cdHZhciBmdW5jID0gJHJlZmxlY3RBcHBseShiaW5kLCAkY2FsbCwgYXJndW1lbnRzKTtcblx0cmV0dXJuIHNldEZ1bmN0aW9uTGVuZ3RoKFxuXHRcdGZ1bmMsXG5cdFx0MSArICRtYXgoMCwgb3JpZ2luYWxGdW5jdGlvbi5sZW5ndGggLSAoYXJndW1lbnRzLmxlbmd0aCAtIDEpKSxcblx0XHR0cnVlXG5cdCk7XG59O1xuXG52YXIgYXBwbHlCaW5kID0gZnVuY3Rpb24gYXBwbHlCaW5kKCkge1xuXHRyZXR1cm4gJHJlZmxlY3RBcHBseShiaW5kLCAkYXBwbHksIGFyZ3VtZW50cyk7XG59O1xuXG5pZiAoJGRlZmluZVByb3BlcnR5KSB7XG5cdCRkZWZpbmVQcm9wZXJ0eShtb2R1bGUuZXhwb3J0cywgJ2FwcGx5JywgeyB2YWx1ZTogYXBwbHlCaW5kIH0pO1xufSBlbHNlIHtcblx0bW9kdWxlLmV4cG9ydHMuYXBwbHkgPSBhcHBseUJpbmQ7XG59XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDQzNjQ6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbi8qZ2xvYmFsIHdpbmRvdywgZ2xvYmFsKi9cbnZhciB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2ODI3KVxudmFyIGFzc2VydCA9IF9fd2VicGFja19yZXF1aXJlX18oNjA5MylcbmZ1bmN0aW9uIG5vdygpIHsgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpIH1cblxudmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlXG52YXIgY29uc29sZVxudmFyIHRpbWVzID0ge31cblxuaWYgKHR5cGVvZiBfX3dlYnBhY2tfcmVxdWlyZV9fLmcgIT09IFwidW5kZWZpbmVkXCIgJiYgX193ZWJwYWNrX3JlcXVpcmVfXy5nLmNvbnNvbGUpIHtcbiAgICBjb25zb2xlID0gX193ZWJwYWNrX3JlcXVpcmVfXy5nLmNvbnNvbGVcbn0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cuY29uc29sZSkge1xuICAgIGNvbnNvbGUgPSB3aW5kb3cuY29uc29sZVxufSBlbHNlIHtcbiAgICBjb25zb2xlID0ge31cbn1cblxudmFyIGZ1bmN0aW9ucyA9IFtcbiAgICBbbG9nLCBcImxvZ1wiXSxcbiAgICBbaW5mbywgXCJpbmZvXCJdLFxuICAgIFt3YXJuLCBcIndhcm5cIl0sXG4gICAgW2Vycm9yLCBcImVycm9yXCJdLFxuICAgIFt0aW1lLCBcInRpbWVcIl0sXG4gICAgW3RpbWVFbmQsIFwidGltZUVuZFwiXSxcbiAgICBbdHJhY2UsIFwidHJhY2VcIl0sXG4gICAgW2RpciwgXCJkaXJcIl0sXG4gICAgW2NvbnNvbGVBc3NlcnQsIFwiYXNzZXJ0XCJdXG5dXG5cbmZvciAodmFyIGkgPSAwOyBpIDwgZnVuY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHR1cGxlID0gZnVuY3Rpb25zW2ldXG4gICAgdmFyIGYgPSB0dXBsZVswXVxuICAgIHZhciBuYW1lID0gdHVwbGVbMV1cblxuICAgIGlmICghY29uc29sZVtuYW1lXSkge1xuICAgICAgICBjb25zb2xlW25hbWVdID0gZlxuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb25zb2xlXG5cbmZ1bmN0aW9uIGxvZygpIHt9XG5cbmZ1bmN0aW9uIGluZm8oKSB7XG4gICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKVxufVxuXG5mdW5jdGlvbiB3YXJuKCkge1xuICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3VtZW50cylcbn1cblxuZnVuY3Rpb24gZXJyb3IoKSB7XG4gICAgY29uc29sZS53YXJuLmFwcGx5KGNvbnNvbGUsIGFyZ3VtZW50cylcbn1cblxuZnVuY3Rpb24gdGltZShsYWJlbCkge1xuICAgIHRpbWVzW2xhYmVsXSA9IG5vdygpXG59XG5cbmZ1bmN0aW9uIHRpbWVFbmQobGFiZWwpIHtcbiAgICB2YXIgdGltZSA9IHRpbWVzW2xhYmVsXVxuICAgIGlmICghdGltZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBzdWNoIGxhYmVsOiBcIiArIGxhYmVsKVxuICAgIH1cblxuICAgIGRlbGV0ZSB0aW1lc1tsYWJlbF1cbiAgICB2YXIgZHVyYXRpb24gPSBub3coKSAtIHRpbWVcbiAgICBjb25zb2xlLmxvZyhsYWJlbCArIFwiOiBcIiArIGR1cmF0aW9uICsgXCJtc1wiKVxufVxuXG5mdW5jdGlvbiB0cmFjZSgpIHtcbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKClcbiAgICBlcnIubmFtZSA9IFwiVHJhY2VcIlxuICAgIGVyci5tZXNzYWdlID0gdXRpbC5mb3JtYXQuYXBwbHkobnVsbCwgYXJndW1lbnRzKVxuICAgIGNvbnNvbGUuZXJyb3IoZXJyLnN0YWNrKVxufVxuXG5mdW5jdGlvbiBkaXIob2JqZWN0KSB7XG4gICAgY29uc29sZS5sb2codXRpbC5pbnNwZWN0KG9iamVjdCkgKyBcIlxcblwiKVxufVxuXG5mdW5jdGlvbiBjb25zb2xlQXNzZXJ0KGV4cHJlc3Npb24pIHtcbiAgICBpZiAoIWV4cHJlc3Npb24pIHtcbiAgICAgICAgdmFyIGFyciA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKVxuICAgICAgICBhc3NlcnQub2soZmFsc2UsIHV0aWwuZm9ybWF0LmFwcGx5KG51bGwsIGFycikpXG4gICAgfVxufVxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA2ODY6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciAkZGVmaW5lUHJvcGVydHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ5NDApO1xuXG52YXIgJFN5bnRheEVycm9yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NzMxKTtcbnZhciAkVHlwZUVycm9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNDY4KTtcblxudmFyIGdvcGQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkzMzYpO1xuXG4vKiogQHR5cGUge2ltcG9ydCgnLicpfSAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkZWZpbmVEYXRhUHJvcGVydHkoXG5cdG9iaixcblx0cHJvcGVydHksXG5cdHZhbHVlXG4pIHtcblx0aWYgKCFvYmogfHwgKHR5cGVvZiBvYmogIT09ICdvYmplY3QnICYmIHR5cGVvZiBvYmogIT09ICdmdW5jdGlvbicpKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ2BvYmpgIG11c3QgYmUgYW4gb2JqZWN0IG9yIGEgZnVuY3Rpb25gJyk7XG5cdH1cblx0aWYgKHR5cGVvZiBwcm9wZXJ0eSAhPT0gJ3N0cmluZycgJiYgdHlwZW9mIHByb3BlcnR5ICE9PSAnc3ltYm9sJykge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdgcHJvcGVydHlgIG11c3QgYmUgYSBzdHJpbmcgb3IgYSBzeW1ib2xgJyk7XG5cdH1cblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIHR5cGVvZiBhcmd1bWVudHNbM10gIT09ICdib29sZWFuJyAmJiBhcmd1bWVudHNbM10gIT09IG51bGwpIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignYG5vbkVudW1lcmFibGVgLCBpZiBwcm92aWRlZCwgbXVzdCBiZSBhIGJvb2xlYW4gb3IgbnVsbCcpO1xuXHR9XG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID4gNCAmJiB0eXBlb2YgYXJndW1lbnRzWzRdICE9PSAnYm9vbGVhbicgJiYgYXJndW1lbnRzWzRdICE9PSBudWxsKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ2Bub25Xcml0YWJsZWAsIGlmIHByb3ZpZGVkLCBtdXN0IGJlIGEgYm9vbGVhbiBvciBudWxsJyk7XG5cdH1cblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiA1ICYmIHR5cGVvZiBhcmd1bWVudHNbNV0gIT09ICdib29sZWFuJyAmJiBhcmd1bWVudHNbNV0gIT09IG51bGwpIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignYG5vbkNvbmZpZ3VyYWJsZWAsIGlmIHByb3ZpZGVkLCBtdXN0IGJlIGEgYm9vbGVhbiBvciBudWxsJyk7XG5cdH1cblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiA2ICYmIHR5cGVvZiBhcmd1bWVudHNbNl0gIT09ICdib29sZWFuJykge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdgbG9vc2VgLCBpZiBwcm92aWRlZCwgbXVzdCBiZSBhIGJvb2xlYW4nKTtcblx0fVxuXG5cdHZhciBub25FbnVtZXJhYmxlID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgPyBhcmd1bWVudHNbM10gOiBudWxsO1xuXHR2YXIgbm9uV3JpdGFibGUgPSBhcmd1bWVudHMubGVuZ3RoID4gNCA/IGFyZ3VtZW50c1s0XSA6IG51bGw7XG5cdHZhciBub25Db25maWd1cmFibGUgPSBhcmd1bWVudHMubGVuZ3RoID4gNSA/IGFyZ3VtZW50c1s1XSA6IG51bGw7XG5cdHZhciBsb29zZSA9IGFyZ3VtZW50cy5sZW5ndGggPiA2ID8gYXJndW1lbnRzWzZdIDogZmFsc2U7XG5cblx0LyogQHR5cGUge2ZhbHNlIHwgVHlwZWRQcm9wZXJ0eURlc2NyaXB0b3I8dW5rbm93bj59ICovXG5cdHZhciBkZXNjID0gISFnb3BkICYmIGdvcGQob2JqLCBwcm9wZXJ0eSk7XG5cblx0aWYgKCRkZWZpbmVQcm9wZXJ0eSkge1xuXHRcdCRkZWZpbmVQcm9wZXJ0eShvYmosIHByb3BlcnR5LCB7XG5cdFx0XHRjb25maWd1cmFibGU6IG5vbkNvbmZpZ3VyYWJsZSA9PT0gbnVsbCAmJiBkZXNjID8gZGVzYy5jb25maWd1cmFibGUgOiAhbm9uQ29uZmlndXJhYmxlLFxuXHRcdFx0ZW51bWVyYWJsZTogbm9uRW51bWVyYWJsZSA9PT0gbnVsbCAmJiBkZXNjID8gZGVzYy5lbnVtZXJhYmxlIDogIW5vbkVudW1lcmFibGUsXG5cdFx0XHR2YWx1ZTogdmFsdWUsXG5cdFx0XHR3cml0YWJsZTogbm9uV3JpdGFibGUgPT09IG51bGwgJiYgZGVzYyA/IGRlc2Mud3JpdGFibGUgOiAhbm9uV3JpdGFibGVcblx0XHR9KTtcblx0fSBlbHNlIGlmIChsb29zZSB8fCAoIW5vbkVudW1lcmFibGUgJiYgIW5vbldyaXRhYmxlICYmICFub25Db25maWd1cmFibGUpKSB7XG5cdFx0Ly8gbXVzdCBmYWxsIGJhY2sgdG8gW1tTZXRdXSwgYW5kIHdhcyBub3QgZXhwbGljaXRseSBhc2tlZCB0byBtYWtlIG5vbi1lbnVtZXJhYmxlLCBub24td3JpdGFibGUsIG9yIG5vbi1jb25maWd1cmFibGVcblx0XHRvYmpbcHJvcGVydHldID0gdmFsdWU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgJFN5bnRheEVycm9yKCdUaGlzIGVudmlyb25tZW50IGRvZXMgbm90IHN1cHBvcnQgZGVmaW5pbmcgYSBwcm9wZXJ0eSBhcyBub24tY29uZmlndXJhYmxlLCBub24td3JpdGFibGUsIG9yIG5vbi1lbnVtZXJhYmxlLicpO1xuXHR9XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAxODU3OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIga2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oOTIyOCk7XG52YXIgaGFzU3ltYm9scyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFN5bWJvbCgnZm9vJykgPT09ICdzeW1ib2wnO1xuXG52YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIGNvbmNhdCA9IEFycmF5LnByb3RvdHlwZS5jb25jYXQ7XG52YXIgb3JpZ0RlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXG52YXIgaXNGdW5jdGlvbiA9IGZ1bmN0aW9uIChmbikge1xuXHRyZXR1cm4gdHlwZW9mIGZuID09PSAnZnVuY3Rpb24nICYmIHRvU3RyLmNhbGwoZm4pID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xufTtcblxudmFyIGhhc1Byb3BlcnR5RGVzY3JpcHRvcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcyMzkpKCk7XG5cbnZhciBzdXBwb3J0c0Rlc2NyaXB0b3JzID0gb3JpZ0RlZmluZVByb3BlcnR5ICYmIGhhc1Byb3BlcnR5RGVzY3JpcHRvcnM7XG5cbnZhciBkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWUsIHZhbHVlLCBwcmVkaWNhdGUpIHtcblx0aWYgKG5hbWUgaW4gb2JqZWN0KSB7XG5cdFx0aWYgKHByZWRpY2F0ZSA9PT0gdHJ1ZSkge1xuXHRcdFx0aWYgKG9iamVjdFtuYW1lXSA9PT0gdmFsdWUpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoIWlzRnVuY3Rpb24ocHJlZGljYXRlKSB8fCAhcHJlZGljYXRlKCkpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdH1cblx0aWYgKHN1cHBvcnRzRGVzY3JpcHRvcnMpIHtcblx0XHRvcmlnRGVmaW5lUHJvcGVydHkob2JqZWN0LCBuYW1lLCB7XG5cdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0XHRlbnVtZXJhYmxlOiBmYWxzZSxcblx0XHRcdHZhbHVlOiB2YWx1ZSxcblx0XHRcdHdyaXRhYmxlOiB0cnVlXG5cdFx0fSk7XG5cdH0gZWxzZSB7XG5cdFx0b2JqZWN0W25hbWVdID0gdmFsdWU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cblx0fVxufTtcblxudmFyIGRlZmluZVByb3BlcnRpZXMgPSBmdW5jdGlvbiAob2JqZWN0LCBtYXApIHtcblx0dmFyIHByZWRpY2F0ZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHt9O1xuXHR2YXIgcHJvcHMgPSBrZXlzKG1hcCk7XG5cdGlmIChoYXNTeW1ib2xzKSB7XG5cdFx0cHJvcHMgPSBjb25jYXQuY2FsbChwcm9wcywgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhtYXApKTtcblx0fVxuXHRmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSArPSAxKSB7XG5cdFx0ZGVmaW5lUHJvcGVydHkob2JqZWN0LCBwcm9wc1tpXSwgbWFwW3Byb3BzW2ldXSwgcHJlZGljYXRlc1twcm9wc1tpXV0pO1xuXHR9XG59O1xuXG5kZWZpbmVQcm9wZXJ0aWVzLnN1cHBvcnRzRGVzY3JpcHRvcnMgPSAhIXN1cHBvcnRzRGVzY3JpcHRvcnM7XG5cbm1vZHVsZS5leHBvcnRzID0gZGVmaW5lUHJvcGVydGllcztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNDk0MDpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIEdldEludHJpbnNpYyA9IF9fd2VicGFja19yZXF1aXJlX18oNTI4KTtcblxuLyoqIEB0eXBlIHtpbXBvcnQoJy4nKX0gKi9cbnZhciAkZGVmaW5lUHJvcGVydHkgPSBHZXRJbnRyaW5zaWMoJyVPYmplY3QuZGVmaW5lUHJvcGVydHklJywgdHJ1ZSkgfHwgZmFsc2U7XG5pZiAoJGRlZmluZVByb3BlcnR5KSB7XG5cdHRyeSB7XG5cdFx0JGRlZmluZVByb3BlcnR5KHt9LCAnYScsIHsgdmFsdWU6IDEgfSk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHQvLyBJRSA4IGhhcyBhIGJyb2tlbiBkZWZpbmVQcm9wZXJ0eVxuXHRcdCRkZWZpbmVQcm9wZXJ0eSA9IGZhbHNlO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gJGRlZmluZVByb3BlcnR5O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA2NzI5OlxuLyoqKi8gKChtb2R1bGUpID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuLyoqIEB0eXBlIHtpbXBvcnQoJy4vZXZhbCcpfSAqL1xubW9kdWxlLmV4cG9ydHMgPSBFdmFsRXJyb3I7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDk4Mzg6XG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG4vKiogQHR5cGUge2ltcG9ydCgnLicpfSAqL1xubW9kdWxlLmV4cG9ydHMgPSBFcnJvcjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMTE1NTpcbi8qKiovICgobW9kdWxlKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuL3JhbmdlJyl9ICovXG5tb2R1bGUuZXhwb3J0cyA9IFJhbmdlRXJyb3I7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDQ5NDM6XG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG4vKiogQHR5cGUge2ltcG9ydCgnLi9yZWYnKX0gKi9cbm1vZHVsZS5leHBvcnRzID0gUmVmZXJlbmNlRXJyb3I7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDU3MzE6XG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG4vKiogQHR5cGUge2ltcG9ydCgnLi9zeW50YXgnKX0gKi9cbm1vZHVsZS5leHBvcnRzID0gU3ludGF4RXJyb3I7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDM0Njg6XG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG4vKiogQHR5cGUge2ltcG9ydCgnLi90eXBlJyl9ICovXG5tb2R1bGUuZXhwb3J0cyA9IFR5cGVFcnJvcjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMjE0MDpcbi8qKiovICgobW9kdWxlKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuL3VyaScpfSAqL1xubW9kdWxlLmV4cG9ydHMgPSBVUklFcnJvcjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMzA0Njpcbi8qKiovICgobW9kdWxlKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb2RlIHJlZmFjdG9yZWQgZnJvbSBNb3ppbGxhIERldmVsb3BlciBOZXR3b3JrOlxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2Fzc2lnblxuICovXG5cblxuXG5mdW5jdGlvbiBhc3NpZ24odGFyZ2V0LCBmaXJzdFNvdXJjZSkge1xuICBpZiAodGFyZ2V0ID09PSB1bmRlZmluZWQgfHwgdGFyZ2V0ID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNvbnZlcnQgZmlyc3QgYXJndW1lbnQgdG8gb2JqZWN0Jyk7XG4gIH1cblxuICB2YXIgdG8gPSBPYmplY3QodGFyZ2V0KTtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbmV4dFNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcbiAgICBpZiAobmV4dFNvdXJjZSA9PT0gdW5kZWZpbmVkIHx8IG5leHRTb3VyY2UgPT09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciBrZXlzQXJyYXkgPSBPYmplY3Qua2V5cyhPYmplY3QobmV4dFNvdXJjZSkpO1xuICAgIGZvciAodmFyIG5leHRJbmRleCA9IDAsIGxlbiA9IGtleXNBcnJheS5sZW5ndGg7IG5leHRJbmRleCA8IGxlbjsgbmV4dEluZGV4KyspIHtcbiAgICAgIHZhciBuZXh0S2V5ID0ga2V5c0FycmF5W25leHRJbmRleF07XG4gICAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobmV4dFNvdXJjZSwgbmV4dEtleSk7XG4gICAgICBpZiAoZGVzYyAhPT0gdW5kZWZpbmVkICYmIGRlc2MuZW51bWVyYWJsZSkge1xuICAgICAgICB0b1tuZXh0S2V5XSA9IG5leHRTb3VyY2VbbmV4dEtleV07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0bztcbn1cblxuZnVuY3Rpb24gcG9seWZpbGwoKSB7XG4gIGlmICghT2JqZWN0LmFzc2lnbikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPYmplY3QsICdhc3NpZ24nLCB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IGFzc2lnblxuICAgIH0pO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBhc3NpZ246IGFzc2lnbixcbiAgcG9seWZpbGw6IHBvbHlmaWxsXG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA3MDU6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBpc0NhbGxhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NjE3KTtcblxudmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbnZhciBmb3JFYWNoQXJyYXkgPSBmdW5jdGlvbiBmb3JFYWNoQXJyYXkoYXJyYXksIGl0ZXJhdG9yLCByZWNlaXZlcikge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhcnJheS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChhcnJheSwgaSkpIHtcbiAgICAgICAgICAgIGlmIChyZWNlaXZlciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaXRlcmF0b3IoYXJyYXlbaV0sIGksIGFycmF5KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaXRlcmF0b3IuY2FsbChyZWNlaXZlciwgYXJyYXlbaV0sIGksIGFycmF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cbnZhciBmb3JFYWNoU3RyaW5nID0gZnVuY3Rpb24gZm9yRWFjaFN0cmluZyhzdHJpbmcsIGl0ZXJhdG9yLCByZWNlaXZlcikge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzdHJpbmcubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgLy8gbm8gc3VjaCB0aGluZyBhcyBhIHNwYXJzZSBzdHJpbmcuXG4gICAgICAgIGlmIChyZWNlaXZlciA9PSBudWxsKSB7XG4gICAgICAgICAgICBpdGVyYXRvcihzdHJpbmcuY2hhckF0KGkpLCBpLCBzdHJpbmcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaXRlcmF0b3IuY2FsbChyZWNlaXZlciwgc3RyaW5nLmNoYXJBdChpKSwgaSwgc3RyaW5nKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbnZhciBmb3JFYWNoT2JqZWN0ID0gZnVuY3Rpb24gZm9yRWFjaE9iamVjdChvYmplY3QsIGl0ZXJhdG9yLCByZWNlaXZlcikge1xuICAgIGZvciAodmFyIGsgaW4gb2JqZWN0KSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgaykpIHtcbiAgICAgICAgICAgIGlmIChyZWNlaXZlciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaXRlcmF0b3Iob2JqZWN0W2tdLCBrLCBvYmplY3QpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpdGVyYXRvci5jYWxsKHJlY2VpdmVyLCBvYmplY3Rba10sIGssIG9iamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG52YXIgZm9yRWFjaCA9IGZ1bmN0aW9uIGZvckVhY2gobGlzdCwgaXRlcmF0b3IsIHRoaXNBcmcpIHtcbiAgICBpZiAoIWlzQ2FsbGFibGUoaXRlcmF0b3IpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2l0ZXJhdG9yIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgIH1cblxuICAgIHZhciByZWNlaXZlcjtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAzKSB7XG4gICAgICAgIHJlY2VpdmVyID0gdGhpc0FyZztcbiAgICB9XG5cbiAgICBpZiAodG9TdHIuY2FsbChsaXN0KSA9PT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgICAgICBmb3JFYWNoQXJyYXkobGlzdCwgaXRlcmF0b3IsIHJlY2VpdmVyKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBsaXN0ID09PSAnc3RyaW5nJykge1xuICAgICAgICBmb3JFYWNoU3RyaW5nKGxpc3QsIGl0ZXJhdG9yLCByZWNlaXZlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yRWFjaE9iamVjdChsaXN0LCBpdGVyYXRvciwgcmVjZWl2ZXIpO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZm9yRWFjaDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gODc5NDpcbi8qKiovICgobW9kdWxlKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbi8qIGVzbGludCBuby1pbnZhbGlkLXRoaXM6IDEgKi9cblxudmFyIEVSUk9SX01FU1NBR0UgPSAnRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgY2FsbGVkIG9uIGluY29tcGF0aWJsZSAnO1xudmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciBtYXggPSBNYXRoLm1heDtcbnZhciBmdW5jVHlwZSA9ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG5cbnZhciBjb25jYXR0eSA9IGZ1bmN0aW9uIGNvbmNhdHR5KGEsIGIpIHtcbiAgICB2YXIgYXJyID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgYXJyW2ldID0gYVtpXTtcbiAgICB9XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBiLmxlbmd0aDsgaiArPSAxKSB7XG4gICAgICAgIGFycltqICsgYS5sZW5ndGhdID0gYltqXTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJyO1xufTtcblxudmFyIHNsaWN5ID0gZnVuY3Rpb24gc2xpY3koYXJyTGlrZSwgb2Zmc2V0KSB7XG4gICAgdmFyIGFyciA9IFtdO1xuICAgIGZvciAodmFyIGkgPSBvZmZzZXQgfHwgMCwgaiA9IDA7IGkgPCBhcnJMaWtlLmxlbmd0aDsgaSArPSAxLCBqICs9IDEpIHtcbiAgICAgICAgYXJyW2pdID0gYXJyTGlrZVtpXTtcbiAgICB9XG4gICAgcmV0dXJuIGFycjtcbn07XG5cbnZhciBqb2lueSA9IGZ1bmN0aW9uIChhcnIsIGpvaW5lcikge1xuICAgIHZhciBzdHIgPSAnJztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBzdHIgKz0gYXJyW2ldO1xuICAgICAgICBpZiAoaSArIDEgPCBhcnIubGVuZ3RoKSB7XG4gICAgICAgICAgICBzdHIgKz0gam9pbmVyO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJpbmQodGhhdCkge1xuICAgIHZhciB0YXJnZXQgPSB0aGlzO1xuICAgIGlmICh0eXBlb2YgdGFyZ2V0ICE9PSAnZnVuY3Rpb24nIHx8IHRvU3RyLmFwcGx5KHRhcmdldCkgIT09IGZ1bmNUeXBlKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRVJST1JfTUVTU0FHRSArIHRhcmdldCk7XG4gICAgfVxuICAgIHZhciBhcmdzID0gc2xpY3koYXJndW1lbnRzLCAxKTtcblxuICAgIHZhciBib3VuZDtcbiAgICB2YXIgYmluZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIGJvdW5kKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGFyZ2V0LmFwcGx5KFxuICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgY29uY2F0dHkoYXJncywgYXJndW1lbnRzKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChPYmplY3QocmVzdWx0KSA9PT0gcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YXJnZXQuYXBwbHkoXG4gICAgICAgICAgICB0aGF0LFxuICAgICAgICAgICAgY29uY2F0dHkoYXJncywgYXJndW1lbnRzKVxuICAgICAgICApO1xuXG4gICAgfTtcblxuICAgIHZhciBib3VuZExlbmd0aCA9IG1heCgwLCB0YXJnZXQubGVuZ3RoIC0gYXJncy5sZW5ndGgpO1xuICAgIHZhciBib3VuZEFyZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvdW5kTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYm91bmRBcmdzW2ldID0gJyQnICsgaTtcbiAgICB9XG5cbiAgICBib3VuZCA9IEZ1bmN0aW9uKCdiaW5kZXInLCAncmV0dXJuIGZ1bmN0aW9uICgnICsgam9pbnkoYm91bmRBcmdzLCAnLCcpICsgJyl7IHJldHVybiBiaW5kZXIuYXBwbHkodGhpcyxhcmd1bWVudHMpOyB9JykoYmluZGVyKTtcblxuICAgIGlmICh0YXJnZXQucHJvdG90eXBlKSB7XG4gICAgICAgIHZhciBFbXB0eSA9IGZ1bmN0aW9uIEVtcHR5KCkge307XG4gICAgICAgIEVtcHR5LnByb3RvdHlwZSA9IHRhcmdldC5wcm90b3R5cGU7XG4gICAgICAgIGJvdW5kLnByb3RvdHlwZSA9IG5ldyBFbXB0eSgpO1xuICAgICAgICBFbXB0eS5wcm90b3R5cGUgPSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBib3VuZDtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDkxMzg6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBpbXBsZW1lbnRhdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oODc5NCk7XG5cbm1vZHVsZS5leHBvcnRzID0gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgfHwgaW1wbGVtZW50YXRpb247XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDUyODpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIHVuZGVmaW5lZDtcblxudmFyICRFcnJvciA9IF9fd2VicGFja19yZXF1aXJlX18oOTgzOCk7XG52YXIgJEV2YWxFcnJvciA9IF9fd2VicGFja19yZXF1aXJlX18oNjcyOSk7XG52YXIgJFJhbmdlRXJyb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExNTUpO1xudmFyICRSZWZlcmVuY2VFcnJvciA9IF9fd2VicGFja19yZXF1aXJlX18oNDk0Myk7XG52YXIgJFN5bnRheEVycm9yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NzMxKTtcbnZhciAkVHlwZUVycm9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNDY4KTtcbnZhciAkVVJJRXJyb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxNDApO1xuXG52YXIgJEZ1bmN0aW9uID0gRnVuY3Rpb247XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb25zaXN0ZW50LXJldHVyblxudmFyIGdldEV2YWxsZWRDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uIChleHByZXNzaW9uU3ludGF4KSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuICRGdW5jdGlvbignXCJ1c2Ugc3RyaWN0XCI7IHJldHVybiAoJyArIGV4cHJlc3Npb25TeW50YXggKyAnKS5jb25zdHJ1Y3RvcjsnKSgpO1xuXHR9IGNhdGNoIChlKSB7fVxufTtcblxudmFyICRnT1BEID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbmlmICgkZ09QRCkge1xuXHR0cnkge1xuXHRcdCRnT1BEKHt9LCAnJyk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHQkZ09QRCA9IG51bGw7IC8vIHRoaXMgaXMgSUUgOCwgd2hpY2ggaGFzIGEgYnJva2VuIGdPUERcblx0fVxufVxuXG52YXIgdGhyb3dUeXBlRXJyb3IgPSBmdW5jdGlvbiAoKSB7XG5cdHRocm93IG5ldyAkVHlwZUVycm9yKCk7XG59O1xudmFyIFRocm93VHlwZUVycm9yID0gJGdPUERcblx0PyAoZnVuY3Rpb24gKCkge1xuXHRcdHRyeSB7XG5cdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLWV4cHJlc3Npb25zLCBuby1jYWxsZXIsIG5vLXJlc3RyaWN0ZWQtcHJvcGVydGllc1xuXHRcdFx0YXJndW1lbnRzLmNhbGxlZTsgLy8gSUUgOCBkb2VzIG5vdCB0aHJvdyBoZXJlXG5cdFx0XHRyZXR1cm4gdGhyb3dUeXBlRXJyb3I7XG5cdFx0fSBjYXRjaCAoY2FsbGVlVGhyb3dzKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHQvLyBJRSA4IHRocm93cyBvbiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGFyZ3VtZW50cywgJycpXG5cdFx0XHRcdHJldHVybiAkZ09QRChhcmd1bWVudHMsICdjYWxsZWUnKS5nZXQ7XG5cdFx0XHR9IGNhdGNoIChnT1BEdGhyb3dzKSB7XG5cdFx0XHRcdHJldHVybiB0aHJvd1R5cGVFcnJvcjtcblx0XHRcdH1cblx0XHR9XG5cdH0oKSlcblx0OiB0aHJvd1R5cGVFcnJvcjtcblxudmFyIGhhc1N5bWJvbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM1NTgpKCk7XG52YXIgaGFzUHJvdG8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY4NjkpKCk7XG5cbnZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiB8fCAoXG5cdGhhc1Byb3RvXG5cdFx0PyBmdW5jdGlvbiAoeCkgeyByZXR1cm4geC5fX3Byb3RvX187IH0gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wcm90b1xuXHRcdDogbnVsbFxuKTtcblxudmFyIG5lZWRzRXZhbCA9IHt9O1xuXG52YXIgVHlwZWRBcnJheSA9IHR5cGVvZiBVaW50OEFycmF5ID09PSAndW5kZWZpbmVkJyB8fCAhZ2V0UHJvdG8gPyB1bmRlZmluZWQgOiBnZXRQcm90byhVaW50OEFycmF5KTtcblxudmFyIElOVFJJTlNJQ1MgPSB7XG5cdF9fcHJvdG9fXzogbnVsbCxcblx0JyVBZ2dyZWdhdGVFcnJvciUnOiB0eXBlb2YgQWdncmVnYXRlRXJyb3IgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogQWdncmVnYXRlRXJyb3IsXG5cdCclQXJyYXklJzogQXJyYXksXG5cdCclQXJyYXlCdWZmZXIlJzogdHlwZW9mIEFycmF5QnVmZmVyID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEFycmF5QnVmZmVyLFxuXHQnJUFycmF5SXRlcmF0b3JQcm90b3R5cGUlJzogaGFzU3ltYm9scyAmJiBnZXRQcm90byA/IGdldFByb3RvKFtdW1N5bWJvbC5pdGVyYXRvcl0oKSkgOiB1bmRlZmluZWQsXG5cdCclQXN5bmNGcm9tU3luY0l0ZXJhdG9yUHJvdG90eXBlJSc6IHVuZGVmaW5lZCxcblx0JyVBc3luY0Z1bmN0aW9uJSc6IG5lZWRzRXZhbCxcblx0JyVBc3luY0dlbmVyYXRvciUnOiBuZWVkc0V2YWwsXG5cdCclQXN5bmNHZW5lcmF0b3JGdW5jdGlvbiUnOiBuZWVkc0V2YWwsXG5cdCclQXN5bmNJdGVyYXRvclByb3RvdHlwZSUnOiBuZWVkc0V2YWwsXG5cdCclQXRvbWljcyUnOiB0eXBlb2YgQXRvbWljcyA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBBdG9taWNzLFxuXHQnJUJpZ0ludCUnOiB0eXBlb2YgQmlnSW50ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEJpZ0ludCxcblx0JyVCaWdJbnQ2NEFycmF5JSc6IHR5cGVvZiBCaWdJbnQ2NEFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEJpZ0ludDY0QXJyYXksXG5cdCclQmlnVWludDY0QXJyYXklJzogdHlwZW9mIEJpZ1VpbnQ2NEFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEJpZ1VpbnQ2NEFycmF5LFxuXHQnJUJvb2xlYW4lJzogQm9vbGVhbixcblx0JyVEYXRhVmlldyUnOiB0eXBlb2YgRGF0YVZpZXcgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogRGF0YVZpZXcsXG5cdCclRGF0ZSUnOiBEYXRlLFxuXHQnJWRlY29kZVVSSSUnOiBkZWNvZGVVUkksXG5cdCclZGVjb2RlVVJJQ29tcG9uZW50JSc6IGRlY29kZVVSSUNvbXBvbmVudCxcblx0JyVlbmNvZGVVUkklJzogZW5jb2RlVVJJLFxuXHQnJWVuY29kZVVSSUNvbXBvbmVudCUnOiBlbmNvZGVVUklDb21wb25lbnQsXG5cdCclRXJyb3IlJzogJEVycm9yLFxuXHQnJWV2YWwlJzogZXZhbCwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1ldmFsXG5cdCclRXZhbEVycm9yJSc6ICRFdmFsRXJyb3IsXG5cdCclRmxvYXQzMkFycmF5JSc6IHR5cGVvZiBGbG9hdDMyQXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogRmxvYXQzMkFycmF5LFxuXHQnJUZsb2F0NjRBcnJheSUnOiB0eXBlb2YgRmxvYXQ2NEFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEZsb2F0NjRBcnJheSxcblx0JyVGaW5hbGl6YXRpb25SZWdpc3RyeSUnOiB0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogRmluYWxpemF0aW9uUmVnaXN0cnksXG5cdCclRnVuY3Rpb24lJzogJEZ1bmN0aW9uLFxuXHQnJUdlbmVyYXRvckZ1bmN0aW9uJSc6IG5lZWRzRXZhbCxcblx0JyVJbnQ4QXJyYXklJzogdHlwZW9mIEludDhBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBJbnQ4QXJyYXksXG5cdCclSW50MTZBcnJheSUnOiB0eXBlb2YgSW50MTZBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBJbnQxNkFycmF5LFxuXHQnJUludDMyQXJyYXklJzogdHlwZW9mIEludDMyQXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogSW50MzJBcnJheSxcblx0JyVpc0Zpbml0ZSUnOiBpc0Zpbml0ZSxcblx0JyVpc05hTiUnOiBpc05hTixcblx0JyVJdGVyYXRvclByb3RvdHlwZSUnOiBoYXNTeW1ib2xzICYmIGdldFByb3RvID8gZ2V0UHJvdG8oZ2V0UHJvdG8oW11bU3ltYm9sLml0ZXJhdG9yXSgpKSkgOiB1bmRlZmluZWQsXG5cdCclSlNPTiUnOiB0eXBlb2YgSlNPTiA9PT0gJ29iamVjdCcgPyBKU09OIDogdW5kZWZpbmVkLFxuXHQnJU1hcCUnOiB0eXBlb2YgTWFwID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IE1hcCxcblx0JyVNYXBJdGVyYXRvclByb3RvdHlwZSUnOiB0eXBlb2YgTWFwID09PSAndW5kZWZpbmVkJyB8fCAhaGFzU3ltYm9scyB8fCAhZ2V0UHJvdG8gPyB1bmRlZmluZWQgOiBnZXRQcm90byhuZXcgTWFwKClbU3ltYm9sLml0ZXJhdG9yXSgpKSxcblx0JyVNYXRoJSc6IE1hdGgsXG5cdCclTnVtYmVyJSc6IE51bWJlcixcblx0JyVPYmplY3QlJzogT2JqZWN0LFxuXHQnJXBhcnNlRmxvYXQlJzogcGFyc2VGbG9hdCxcblx0JyVwYXJzZUludCUnOiBwYXJzZUludCxcblx0JyVQcm9taXNlJSc6IHR5cGVvZiBQcm9taXNlID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFByb21pc2UsXG5cdCclUHJveHklJzogdHlwZW9mIFByb3h5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFByb3h5LFxuXHQnJVJhbmdlRXJyb3IlJzogJFJhbmdlRXJyb3IsXG5cdCclUmVmZXJlbmNlRXJyb3IlJzogJFJlZmVyZW5jZUVycm9yLFxuXHQnJVJlZmxlY3QlJzogdHlwZW9mIFJlZmxlY3QgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogUmVmbGVjdCxcblx0JyVSZWdFeHAlJzogUmVnRXhwLFxuXHQnJVNldCUnOiB0eXBlb2YgU2V0ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFNldCxcblx0JyVTZXRJdGVyYXRvclByb3RvdHlwZSUnOiB0eXBlb2YgU2V0ID09PSAndW5kZWZpbmVkJyB8fCAhaGFzU3ltYm9scyB8fCAhZ2V0UHJvdG8gPyB1bmRlZmluZWQgOiBnZXRQcm90byhuZXcgU2V0KClbU3ltYm9sLml0ZXJhdG9yXSgpKSxcblx0JyVTaGFyZWRBcnJheUJ1ZmZlciUnOiB0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXIgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogU2hhcmVkQXJyYXlCdWZmZXIsXG5cdCclU3RyaW5nJSc6IFN0cmluZyxcblx0JyVTdHJpbmdJdGVyYXRvclByb3RvdHlwZSUnOiBoYXNTeW1ib2xzICYmIGdldFByb3RvID8gZ2V0UHJvdG8oJydbU3ltYm9sLml0ZXJhdG9yXSgpKSA6IHVuZGVmaW5lZCxcblx0JyVTeW1ib2wlJzogaGFzU3ltYm9scyA/IFN5bWJvbCA6IHVuZGVmaW5lZCxcblx0JyVTeW50YXhFcnJvciUnOiAkU3ludGF4RXJyb3IsXG5cdCclVGhyb3dUeXBlRXJyb3IlJzogVGhyb3dUeXBlRXJyb3IsXG5cdCclVHlwZWRBcnJheSUnOiBUeXBlZEFycmF5LFxuXHQnJVR5cGVFcnJvciUnOiAkVHlwZUVycm9yLFxuXHQnJVVpbnQ4QXJyYXklJzogdHlwZW9mIFVpbnQ4QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogVWludDhBcnJheSxcblx0JyVVaW50OENsYW1wZWRBcnJheSUnOiB0eXBlb2YgVWludDhDbGFtcGVkQXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogVWludDhDbGFtcGVkQXJyYXksXG5cdCclVWludDE2QXJyYXklJzogdHlwZW9mIFVpbnQxNkFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFVpbnQxNkFycmF5LFxuXHQnJVVpbnQzMkFycmF5JSc6IHR5cGVvZiBVaW50MzJBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBVaW50MzJBcnJheSxcblx0JyVVUklFcnJvciUnOiAkVVJJRXJyb3IsXG5cdCclV2Vha01hcCUnOiB0eXBlb2YgV2Vha01hcCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBXZWFrTWFwLFxuXHQnJVdlYWtSZWYlJzogdHlwZW9mIFdlYWtSZWYgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogV2Vha1JlZixcblx0JyVXZWFrU2V0JSc6IHR5cGVvZiBXZWFrU2V0ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFdlYWtTZXRcbn07XG5cbmlmIChnZXRQcm90bykge1xuXHR0cnkge1xuXHRcdG51bGwuZXJyb3I7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLWV4cHJlc3Npb25zXG5cdH0gY2F0Y2ggKGUpIHtcblx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1zaGFkb3dyZWFsbS9wdWxsLzM4NCNpc3N1ZWNvbW1lbnQtMTM2NDI2NDIyOVxuXHRcdHZhciBlcnJvclByb3RvID0gZ2V0UHJvdG8oZ2V0UHJvdG8oZSkpO1xuXHRcdElOVFJJTlNJQ1NbJyVFcnJvci5wcm90b3R5cGUlJ10gPSBlcnJvclByb3RvO1xuXHR9XG59XG5cbnZhciBkb0V2YWwgPSBmdW5jdGlvbiBkb0V2YWwobmFtZSkge1xuXHR2YXIgdmFsdWU7XG5cdGlmIChuYW1lID09PSAnJUFzeW5jRnVuY3Rpb24lJykge1xuXHRcdHZhbHVlID0gZ2V0RXZhbGxlZENvbnN0cnVjdG9yKCdhc3luYyBmdW5jdGlvbiAoKSB7fScpO1xuXHR9IGVsc2UgaWYgKG5hbWUgPT09ICclR2VuZXJhdG9yRnVuY3Rpb24lJykge1xuXHRcdHZhbHVlID0gZ2V0RXZhbGxlZENvbnN0cnVjdG9yKCdmdW5jdGlvbiogKCkge30nKTtcblx0fSBlbHNlIGlmIChuYW1lID09PSAnJUFzeW5jR2VuZXJhdG9yRnVuY3Rpb24lJykge1xuXHRcdHZhbHVlID0gZ2V0RXZhbGxlZENvbnN0cnVjdG9yKCdhc3luYyBmdW5jdGlvbiogKCkge30nKTtcblx0fSBlbHNlIGlmIChuYW1lID09PSAnJUFzeW5jR2VuZXJhdG9yJScpIHtcblx0XHR2YXIgZm4gPSBkb0V2YWwoJyVBc3luY0dlbmVyYXRvckZ1bmN0aW9uJScpO1xuXHRcdGlmIChmbikge1xuXHRcdFx0dmFsdWUgPSBmbi5wcm90b3R5cGU7XG5cdFx0fVxuXHR9IGVsc2UgaWYgKG5hbWUgPT09ICclQXN5bmNJdGVyYXRvclByb3RvdHlwZSUnKSB7XG5cdFx0dmFyIGdlbiA9IGRvRXZhbCgnJUFzeW5jR2VuZXJhdG9yJScpO1xuXHRcdGlmIChnZW4gJiYgZ2V0UHJvdG8pIHtcblx0XHRcdHZhbHVlID0gZ2V0UHJvdG8oZ2VuLnByb3RvdHlwZSk7XG5cdFx0fVxuXHR9XG5cblx0SU5UUklOU0lDU1tuYW1lXSA9IHZhbHVlO1xuXG5cdHJldHVybiB2YWx1ZTtcbn07XG5cbnZhciBMRUdBQ1lfQUxJQVNFUyA9IHtcblx0X19wcm90b19fOiBudWxsLFxuXHQnJUFycmF5QnVmZmVyUHJvdG90eXBlJSc6IFsnQXJyYXlCdWZmZXInLCAncHJvdG90eXBlJ10sXG5cdCclQXJyYXlQcm90b3R5cGUlJzogWydBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVBcnJheVByb3RvX2VudHJpZXMlJzogWydBcnJheScsICdwcm90b3R5cGUnLCAnZW50cmllcyddLFxuXHQnJUFycmF5UHJvdG9fZm9yRWFjaCUnOiBbJ0FycmF5JywgJ3Byb3RvdHlwZScsICdmb3JFYWNoJ10sXG5cdCclQXJyYXlQcm90b19rZXlzJSc6IFsnQXJyYXknLCAncHJvdG90eXBlJywgJ2tleXMnXSxcblx0JyVBcnJheVByb3RvX3ZhbHVlcyUnOiBbJ0FycmF5JywgJ3Byb3RvdHlwZScsICd2YWx1ZXMnXSxcblx0JyVBc3luY0Z1bmN0aW9uUHJvdG90eXBlJSc6IFsnQXN5bmNGdW5jdGlvbicsICdwcm90b3R5cGUnXSxcblx0JyVBc3luY0dlbmVyYXRvciUnOiBbJ0FzeW5jR2VuZXJhdG9yRnVuY3Rpb24nLCAncHJvdG90eXBlJ10sXG5cdCclQXN5bmNHZW5lcmF0b3JQcm90b3R5cGUlJzogWydBc3luY0dlbmVyYXRvckZ1bmN0aW9uJywgJ3Byb3RvdHlwZScsICdwcm90b3R5cGUnXSxcblx0JyVCb29sZWFuUHJvdG90eXBlJSc6IFsnQm9vbGVhbicsICdwcm90b3R5cGUnXSxcblx0JyVEYXRhVmlld1Byb3RvdHlwZSUnOiBbJ0RhdGFWaWV3JywgJ3Byb3RvdHlwZSddLFxuXHQnJURhdGVQcm90b3R5cGUlJzogWydEYXRlJywgJ3Byb3RvdHlwZSddLFxuXHQnJUVycm9yUHJvdG90eXBlJSc6IFsnRXJyb3InLCAncHJvdG90eXBlJ10sXG5cdCclRXZhbEVycm9yUHJvdG90eXBlJSc6IFsnRXZhbEVycm9yJywgJ3Byb3RvdHlwZSddLFxuXHQnJUZsb2F0MzJBcnJheVByb3RvdHlwZSUnOiBbJ0Zsb2F0MzJBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVGbG9hdDY0QXJyYXlQcm90b3R5cGUlJzogWydGbG9hdDY0QXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclRnVuY3Rpb25Qcm90b3R5cGUlJzogWydGdW5jdGlvbicsICdwcm90b3R5cGUnXSxcblx0JyVHZW5lcmF0b3IlJzogWydHZW5lcmF0b3JGdW5jdGlvbicsICdwcm90b3R5cGUnXSxcblx0JyVHZW5lcmF0b3JQcm90b3R5cGUlJzogWydHZW5lcmF0b3JGdW5jdGlvbicsICdwcm90b3R5cGUnLCAncHJvdG90eXBlJ10sXG5cdCclSW50OEFycmF5UHJvdG90eXBlJSc6IFsnSW50OEFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJUludDE2QXJyYXlQcm90b3R5cGUlJzogWydJbnQxNkFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJUludDMyQXJyYXlQcm90b3R5cGUlJzogWydJbnQzMkFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJUpTT05QYXJzZSUnOiBbJ0pTT04nLCAncGFyc2UnXSxcblx0JyVKU09OU3RyaW5naWZ5JSc6IFsnSlNPTicsICdzdHJpbmdpZnknXSxcblx0JyVNYXBQcm90b3R5cGUlJzogWydNYXAnLCAncHJvdG90eXBlJ10sXG5cdCclTnVtYmVyUHJvdG90eXBlJSc6IFsnTnVtYmVyJywgJ3Byb3RvdHlwZSddLFxuXHQnJU9iamVjdFByb3RvdHlwZSUnOiBbJ09iamVjdCcsICdwcm90b3R5cGUnXSxcblx0JyVPYmpQcm90b190b1N0cmluZyUnOiBbJ09iamVjdCcsICdwcm90b3R5cGUnLCAndG9TdHJpbmcnXSxcblx0JyVPYmpQcm90b192YWx1ZU9mJSc6IFsnT2JqZWN0JywgJ3Byb3RvdHlwZScsICd2YWx1ZU9mJ10sXG5cdCclUHJvbWlzZVByb3RvdHlwZSUnOiBbJ1Byb21pc2UnLCAncHJvdG90eXBlJ10sXG5cdCclUHJvbWlzZVByb3RvX3RoZW4lJzogWydQcm9taXNlJywgJ3Byb3RvdHlwZScsICd0aGVuJ10sXG5cdCclUHJvbWlzZV9hbGwlJzogWydQcm9taXNlJywgJ2FsbCddLFxuXHQnJVByb21pc2VfcmVqZWN0JSc6IFsnUHJvbWlzZScsICdyZWplY3QnXSxcblx0JyVQcm9taXNlX3Jlc29sdmUlJzogWydQcm9taXNlJywgJ3Jlc29sdmUnXSxcblx0JyVSYW5nZUVycm9yUHJvdG90eXBlJSc6IFsnUmFuZ2VFcnJvcicsICdwcm90b3R5cGUnXSxcblx0JyVSZWZlcmVuY2VFcnJvclByb3RvdHlwZSUnOiBbJ1JlZmVyZW5jZUVycm9yJywgJ3Byb3RvdHlwZSddLFxuXHQnJVJlZ0V4cFByb3RvdHlwZSUnOiBbJ1JlZ0V4cCcsICdwcm90b3R5cGUnXSxcblx0JyVTZXRQcm90b3R5cGUlJzogWydTZXQnLCAncHJvdG90eXBlJ10sXG5cdCclU2hhcmVkQXJyYXlCdWZmZXJQcm90b3R5cGUlJzogWydTaGFyZWRBcnJheUJ1ZmZlcicsICdwcm90b3R5cGUnXSxcblx0JyVTdHJpbmdQcm90b3R5cGUlJzogWydTdHJpbmcnLCAncHJvdG90eXBlJ10sXG5cdCclU3ltYm9sUHJvdG90eXBlJSc6IFsnU3ltYm9sJywgJ3Byb3RvdHlwZSddLFxuXHQnJVN5bnRheEVycm9yUHJvdG90eXBlJSc6IFsnU3ludGF4RXJyb3InLCAncHJvdG90eXBlJ10sXG5cdCclVHlwZWRBcnJheVByb3RvdHlwZSUnOiBbJ1R5cGVkQXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclVHlwZUVycm9yUHJvdG90eXBlJSc6IFsnVHlwZUVycm9yJywgJ3Byb3RvdHlwZSddLFxuXHQnJVVpbnQ4QXJyYXlQcm90b3R5cGUlJzogWydVaW50OEFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJVVpbnQ4Q2xhbXBlZEFycmF5UHJvdG90eXBlJSc6IFsnVWludDhDbGFtcGVkQXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclVWludDE2QXJyYXlQcm90b3R5cGUlJzogWydVaW50MTZBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVVaW50MzJBcnJheVByb3RvdHlwZSUnOiBbJ1VpbnQzMkFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJVVSSUVycm9yUHJvdG90eXBlJSc6IFsnVVJJRXJyb3InLCAncHJvdG90eXBlJ10sXG5cdCclV2Vha01hcFByb3RvdHlwZSUnOiBbJ1dlYWtNYXAnLCAncHJvdG90eXBlJ10sXG5cdCclV2Vha1NldFByb3RvdHlwZSUnOiBbJ1dlYWtTZXQnLCAncHJvdG90eXBlJ11cbn07XG5cbnZhciBiaW5kID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MTM4KTtcbnZhciBoYXNPd24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg1NTQpO1xudmFyICRjb25jYXQgPSBiaW5kLmNhbGwoRnVuY3Rpb24uY2FsbCwgQXJyYXkucHJvdG90eXBlLmNvbmNhdCk7XG52YXIgJHNwbGljZUFwcGx5ID0gYmluZC5jYWxsKEZ1bmN0aW9uLmFwcGx5LCBBcnJheS5wcm90b3R5cGUuc3BsaWNlKTtcbnZhciAkcmVwbGFjZSA9IGJpbmQuY2FsbChGdW5jdGlvbi5jYWxsLCBTdHJpbmcucHJvdG90eXBlLnJlcGxhY2UpO1xudmFyICRzdHJTbGljZSA9IGJpbmQuY2FsbChGdW5jdGlvbi5jYWxsLCBTdHJpbmcucHJvdG90eXBlLnNsaWNlKTtcbnZhciAkZXhlYyA9IGJpbmQuY2FsbChGdW5jdGlvbi5jYWxsLCBSZWdFeHAucHJvdG90eXBlLmV4ZWMpO1xuXG4vKiBhZGFwdGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2xvZGFzaC9sb2Rhc2gvYmxvYi80LjE3LjE1L2Rpc3QvbG9kYXNoLmpzI0w2NzM1LUw2NzQ0ICovXG52YXIgcmVQcm9wTmFtZSA9IC9bXiUuW1xcXV0rfFxcWyg/OigtP1xcZCsoPzpcXC5cXGQrKT8pfChbXCInXSkoKD86KD8hXFwyKVteXFxcXF18XFxcXC4pKj8pXFwyKVxcXXwoPz0oPzpcXC58XFxbXFxdKSg/OlxcLnxcXFtcXF18JSQpKS9nO1xudmFyIHJlRXNjYXBlQ2hhciA9IC9cXFxcKFxcXFwpPy9nOyAvKiogVXNlZCB0byBtYXRjaCBiYWNrc2xhc2hlcyBpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciBzdHJpbmdUb1BhdGggPSBmdW5jdGlvbiBzdHJpbmdUb1BhdGgoc3RyaW5nKSB7XG5cdHZhciBmaXJzdCA9ICRzdHJTbGljZShzdHJpbmcsIDAsIDEpO1xuXHR2YXIgbGFzdCA9ICRzdHJTbGljZShzdHJpbmcsIC0xKTtcblx0aWYgKGZpcnN0ID09PSAnJScgJiYgbGFzdCAhPT0gJyUnKSB7XG5cdFx0dGhyb3cgbmV3ICRTeW50YXhFcnJvcignaW52YWxpZCBpbnRyaW5zaWMgc3ludGF4LCBleHBlY3RlZCBjbG9zaW5nIGAlYCcpO1xuXHR9IGVsc2UgaWYgKGxhc3QgPT09ICclJyAmJiBmaXJzdCAhPT0gJyUnKSB7XG5cdFx0dGhyb3cgbmV3ICRTeW50YXhFcnJvcignaW52YWxpZCBpbnRyaW5zaWMgc3ludGF4LCBleHBlY3RlZCBvcGVuaW5nIGAlYCcpO1xuXHR9XG5cdHZhciByZXN1bHQgPSBbXTtcblx0JHJlcGxhY2Uoc3RyaW5nLCByZVByb3BOYW1lLCBmdW5jdGlvbiAobWF0Y2gsIG51bWJlciwgcXVvdGUsIHN1YlN0cmluZykge1xuXHRcdHJlc3VsdFtyZXN1bHQubGVuZ3RoXSA9IHF1b3RlID8gJHJlcGxhY2Uoc3ViU3RyaW5nLCByZUVzY2FwZUNoYXIsICckMScpIDogbnVtYmVyIHx8IG1hdGNoO1xuXHR9KTtcblx0cmV0dXJuIHJlc3VsdDtcbn07XG4vKiBlbmQgYWRhcHRhdGlvbiAqL1xuXG52YXIgZ2V0QmFzZUludHJpbnNpYyA9IGZ1bmN0aW9uIGdldEJhc2VJbnRyaW5zaWMobmFtZSwgYWxsb3dNaXNzaW5nKSB7XG5cdHZhciBpbnRyaW5zaWNOYW1lID0gbmFtZTtcblx0dmFyIGFsaWFzO1xuXHRpZiAoaGFzT3duKExFR0FDWV9BTElBU0VTLCBpbnRyaW5zaWNOYW1lKSkge1xuXHRcdGFsaWFzID0gTEVHQUNZX0FMSUFTRVNbaW50cmluc2ljTmFtZV07XG5cdFx0aW50cmluc2ljTmFtZSA9ICclJyArIGFsaWFzWzBdICsgJyUnO1xuXHR9XG5cblx0aWYgKGhhc093bihJTlRSSU5TSUNTLCBpbnRyaW5zaWNOYW1lKSkge1xuXHRcdHZhciB2YWx1ZSA9IElOVFJJTlNJQ1NbaW50cmluc2ljTmFtZV07XG5cdFx0aWYgKHZhbHVlID09PSBuZWVkc0V2YWwpIHtcblx0XHRcdHZhbHVlID0gZG9FdmFsKGludHJpbnNpY05hbWUpO1xuXHRcdH1cblx0XHRpZiAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyAmJiAhYWxsb3dNaXNzaW5nKSB7XG5cdFx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignaW50cmluc2ljICcgKyBuYW1lICsgJyBleGlzdHMsIGJ1dCBpcyBub3QgYXZhaWxhYmxlLiBQbGVhc2UgZmlsZSBhbiBpc3N1ZSEnKTtcblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0YWxpYXM6IGFsaWFzLFxuXHRcdFx0bmFtZTogaW50cmluc2ljTmFtZSxcblx0XHRcdHZhbHVlOiB2YWx1ZVxuXHRcdH07XG5cdH1cblxuXHR0aHJvdyBuZXcgJFN5bnRheEVycm9yKCdpbnRyaW5zaWMgJyArIG5hbWUgKyAnIGRvZXMgbm90IGV4aXN0IScpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBHZXRJbnRyaW5zaWMobmFtZSwgYWxsb3dNaXNzaW5nKSB7XG5cdGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycgfHwgbmFtZS5sZW5ndGggPT09IDApIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignaW50cmluc2ljIG5hbWUgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcblx0fVxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgdHlwZW9mIGFsbG93TWlzc2luZyAhPT0gJ2Jvb2xlYW4nKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ1wiYWxsb3dNaXNzaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBhIGJvb2xlYW4nKTtcblx0fVxuXG5cdGlmICgkZXhlYygvXiU/W14lXSolPyQvLCBuYW1lKSA9PT0gbnVsbCkge1xuXHRcdHRocm93IG5ldyAkU3ludGF4RXJyb3IoJ2AlYCBtYXkgbm90IGJlIHByZXNlbnQgYW55d2hlcmUgYnV0IGF0IHRoZSBiZWdpbm5pbmcgYW5kIGVuZCBvZiB0aGUgaW50cmluc2ljIG5hbWUnKTtcblx0fVxuXHR2YXIgcGFydHMgPSBzdHJpbmdUb1BhdGgobmFtZSk7XG5cdHZhciBpbnRyaW5zaWNCYXNlTmFtZSA9IHBhcnRzLmxlbmd0aCA+IDAgPyBwYXJ0c1swXSA6ICcnO1xuXG5cdHZhciBpbnRyaW5zaWMgPSBnZXRCYXNlSW50cmluc2ljKCclJyArIGludHJpbnNpY0Jhc2VOYW1lICsgJyUnLCBhbGxvd01pc3NpbmcpO1xuXHR2YXIgaW50cmluc2ljUmVhbE5hbWUgPSBpbnRyaW5zaWMubmFtZTtcblx0dmFyIHZhbHVlID0gaW50cmluc2ljLnZhbHVlO1xuXHR2YXIgc2tpcEZ1cnRoZXJDYWNoaW5nID0gZmFsc2U7XG5cblx0dmFyIGFsaWFzID0gaW50cmluc2ljLmFsaWFzO1xuXHRpZiAoYWxpYXMpIHtcblx0XHRpbnRyaW5zaWNCYXNlTmFtZSA9IGFsaWFzWzBdO1xuXHRcdCRzcGxpY2VBcHBseShwYXJ0cywgJGNvbmNhdChbMCwgMV0sIGFsaWFzKSk7XG5cdH1cblxuXHRmb3IgKHZhciBpID0gMSwgaXNPd24gPSB0cnVlOyBpIDwgcGFydHMubGVuZ3RoOyBpICs9IDEpIHtcblx0XHR2YXIgcGFydCA9IHBhcnRzW2ldO1xuXHRcdHZhciBmaXJzdCA9ICRzdHJTbGljZShwYXJ0LCAwLCAxKTtcblx0XHR2YXIgbGFzdCA9ICRzdHJTbGljZShwYXJ0LCAtMSk7XG5cdFx0aWYgKFxuXHRcdFx0KFxuXHRcdFx0XHQoZmlyc3QgPT09ICdcIicgfHwgZmlyc3QgPT09IFwiJ1wiIHx8IGZpcnN0ID09PSAnYCcpXG5cdFx0XHRcdHx8IChsYXN0ID09PSAnXCInIHx8IGxhc3QgPT09IFwiJ1wiIHx8IGxhc3QgPT09ICdgJylcblx0XHRcdClcblx0XHRcdCYmIGZpcnN0ICE9PSBsYXN0XG5cdFx0KSB7XG5cdFx0XHR0aHJvdyBuZXcgJFN5bnRheEVycm9yKCdwcm9wZXJ0eSBuYW1lcyB3aXRoIHF1b3RlcyBtdXN0IGhhdmUgbWF0Y2hpbmcgcXVvdGVzJyk7XG5cdFx0fVxuXHRcdGlmIChwYXJ0ID09PSAnY29uc3RydWN0b3InIHx8ICFpc093bikge1xuXHRcdFx0c2tpcEZ1cnRoZXJDYWNoaW5nID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRpbnRyaW5zaWNCYXNlTmFtZSArPSAnLicgKyBwYXJ0O1xuXHRcdGludHJpbnNpY1JlYWxOYW1lID0gJyUnICsgaW50cmluc2ljQmFzZU5hbWUgKyAnJSc7XG5cblx0XHRpZiAoaGFzT3duKElOVFJJTlNJQ1MsIGludHJpbnNpY1JlYWxOYW1lKSkge1xuXHRcdFx0dmFsdWUgPSBJTlRSSU5TSUNTW2ludHJpbnNpY1JlYWxOYW1lXTtcblx0XHR9IGVsc2UgaWYgKHZhbHVlICE9IG51bGwpIHtcblx0XHRcdGlmICghKHBhcnQgaW4gdmFsdWUpKSB7XG5cdFx0XHRcdGlmICghYWxsb3dNaXNzaW5nKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ2Jhc2UgaW50cmluc2ljIGZvciAnICsgbmFtZSArICcgZXhpc3RzLCBidXQgdGhlIHByb3BlcnR5IGlzIG5vdCBhdmFpbGFibGUuJyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHZvaWQgdW5kZWZpbmVkO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCRnT1BEICYmIChpICsgMSkgPj0gcGFydHMubGVuZ3RoKSB7XG5cdFx0XHRcdHZhciBkZXNjID0gJGdPUEQodmFsdWUsIHBhcnQpO1xuXHRcdFx0XHRpc093biA9ICEhZGVzYztcblxuXHRcdFx0XHQvLyBCeSBjb252ZW50aW9uLCB3aGVuIGEgZGF0YSBwcm9wZXJ0eSBpcyBjb252ZXJ0ZWQgdG8gYW4gYWNjZXNzb3Jcblx0XHRcdFx0Ly8gcHJvcGVydHkgdG8gZW11bGF0ZSBhIGRhdGEgcHJvcGVydHkgdGhhdCBkb2VzIG5vdCBzdWZmZXIgZnJvbVxuXHRcdFx0XHQvLyB0aGUgb3ZlcnJpZGUgbWlzdGFrZSwgdGhhdCBhY2Nlc3NvcidzIGdldHRlciBpcyBtYXJrZWQgd2l0aFxuXHRcdFx0XHQvLyBhbiBgb3JpZ2luYWxWYWx1ZWAgcHJvcGVydHkuIEhlcmUsIHdoZW4gd2UgZGV0ZWN0IHRoaXMsIHdlXG5cdFx0XHRcdC8vIHVwaG9sZCB0aGUgaWxsdXNpb24gYnkgcHJldGVuZGluZyB0byBzZWUgdGhhdCBvcmlnaW5hbCBkYXRhXG5cdFx0XHRcdC8vIHByb3BlcnR5LCBpLmUuLCByZXR1cm5pbmcgdGhlIHZhbHVlIHJhdGhlciB0aGFuIHRoZSBnZXR0ZXJcblx0XHRcdFx0Ly8gaXRzZWxmLlxuXHRcdFx0XHRpZiAoaXNPd24gJiYgJ2dldCcgaW4gZGVzYyAmJiAhKCdvcmlnaW5hbFZhbHVlJyBpbiBkZXNjLmdldCkpIHtcblx0XHRcdFx0XHR2YWx1ZSA9IGRlc2MuZ2V0O1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHZhbHVlID0gdmFsdWVbcGFydF07XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlzT3duID0gaGFzT3duKHZhbHVlLCBwYXJ0KTtcblx0XHRcdFx0dmFsdWUgPSB2YWx1ZVtwYXJ0XTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGlzT3duICYmICFza2lwRnVydGhlckNhY2hpbmcpIHtcblx0XHRcdFx0SU5UUklOU0lDU1tpbnRyaW5zaWNSZWFsTmFtZV0gPSB2YWx1ZTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0cmV0dXJuIHZhbHVlO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gOTMzNjpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIEdldEludHJpbnNpYyA9IF9fd2VicGFja19yZXF1aXJlX18oNTI4KTtcblxudmFyICRnT1BEID0gR2V0SW50cmluc2ljKCclT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciUnLCB0cnVlKTtcblxuaWYgKCRnT1BEKSB7XG5cdHRyeSB7XG5cdFx0JGdPUEQoW10sICdsZW5ndGgnKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdC8vIElFIDggaGFzIGEgYnJva2VuIGdPUERcblx0XHQkZ09QRCA9IG51bGw7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSAkZ09QRDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNzIzOTpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyICRkZWZpbmVQcm9wZXJ0eSA9IF9fd2VicGFja19yZXF1aXJlX18oNDk0MCk7XG5cbnZhciBoYXNQcm9wZXJ0eURlc2NyaXB0b3JzID0gZnVuY3Rpb24gaGFzUHJvcGVydHlEZXNjcmlwdG9ycygpIHtcblx0cmV0dXJuICEhJGRlZmluZVByb3BlcnR5O1xufTtcblxuaGFzUHJvcGVydHlEZXNjcmlwdG9ycy5oYXNBcnJheUxlbmd0aERlZmluZUJ1ZyA9IGZ1bmN0aW9uIGhhc0FycmF5TGVuZ3RoRGVmaW5lQnVnKCkge1xuXHQvLyBub2RlIHYwLjYgaGFzIGEgYnVnIHdoZXJlIGFycmF5IGxlbmd0aHMgY2FuIGJlIFNldCBidXQgbm90IERlZmluZWRcblx0aWYgKCEkZGVmaW5lUHJvcGVydHkpIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXHR0cnkge1xuXHRcdHJldHVybiAkZGVmaW5lUHJvcGVydHkoW10sICdsZW5ndGgnLCB7IHZhbHVlOiAxIH0pLmxlbmd0aCAhPT0gMTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdC8vIEluIEZpcmVmb3ggNC0yMiwgZGVmaW5pbmcgbGVuZ3RoIG9uIGFuIGFycmF5IHRocm93cyBhbiBleGNlcHRpb24uXG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzUHJvcGVydHlEZXNjcmlwdG9ycztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNjg2OTpcbi8qKiovICgobW9kdWxlKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciB0ZXN0ID0ge1xuXHRmb286IHt9XG59O1xuXG52YXIgJE9iamVjdCA9IE9iamVjdDtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBoYXNQcm90bygpIHtcblx0cmV0dXJuIHsgX19wcm90b19fOiB0ZXN0IH0uZm9vID09PSB0ZXN0LmZvbyAmJiAhKHsgX19wcm90b19fOiBudWxsIH0gaW5zdGFuY2VvZiAkT2JqZWN0KTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDM1NTg6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBvcmlnU3ltYm9sID0gdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sO1xudmFyIGhhc1N5bWJvbFNoYW0gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI5MDgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGhhc05hdGl2ZVN5bWJvbHMoKSB7XG5cdGlmICh0eXBlb2Ygb3JpZ1N5bWJvbCAhPT0gJ2Z1bmN0aW9uJykgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKHR5cGVvZiBTeW1ib2wgIT09ICdmdW5jdGlvbicpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdGlmICh0eXBlb2Ygb3JpZ1N5bWJvbCgnZm9vJykgIT09ICdzeW1ib2wnKSB7IHJldHVybiBmYWxzZTsgfVxuXHRpZiAodHlwZW9mIFN5bWJvbCgnYmFyJykgIT09ICdzeW1ib2wnKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdHJldHVybiBoYXNTeW1ib2xTaGFtKCk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAyOTA4OlxuLyoqKi8gKChtb2R1bGUpID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuLyogZXNsaW50IGNvbXBsZXhpdHk6IFsyLCAxOF0sIG1heC1zdGF0ZW1lbnRzOiBbMiwgMzNdICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGhhc1N5bWJvbHMoKSB7XG5cdGlmICh0eXBlb2YgU3ltYm9sICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzICE9PSAnZnVuY3Rpb24nKSB7IHJldHVybiBmYWxzZTsgfVxuXHRpZiAodHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gJ3N5bWJvbCcpIHsgcmV0dXJuIHRydWU7IH1cblxuXHR2YXIgb2JqID0ge307XG5cdHZhciBzeW0gPSBTeW1ib2woJ3Rlc3QnKTtcblx0dmFyIHN5bU9iaiA9IE9iamVjdChzeW0pO1xuXHRpZiAodHlwZW9mIHN5bSA9PT0gJ3N0cmluZycpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0aWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzeW0pICE9PSAnW29iamVjdCBTeW1ib2xdJykgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzeW1PYmopICE9PSAnW29iamVjdCBTeW1ib2xdJykgeyByZXR1cm4gZmFsc2U7IH1cblxuXHQvLyB0ZW1wIGRpc2FibGVkIHBlciBodHRwczovL2dpdGh1Yi5jb20vbGpoYXJiL29iamVjdC5hc3NpZ24vaXNzdWVzLzE3XG5cdC8vIGlmIChzeW0gaW5zdGFuY2VvZiBTeW1ib2wpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdC8vIHRlbXAgZGlzYWJsZWQgcGVyIGh0dHBzOi8vZ2l0aHViLmNvbS9XZWJSZWZsZWN0aW9uL2dldC1vd24tcHJvcGVydHktc3ltYm9scy9pc3N1ZXMvNFxuXHQvLyBpZiAoIShzeW1PYmogaW5zdGFuY2VvZiBTeW1ib2wpKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdC8vIGlmICh0eXBlb2YgU3ltYm9sLnByb3RvdHlwZS50b1N0cmluZyAhPT0gJ2Z1bmN0aW9uJykgeyByZXR1cm4gZmFsc2U7IH1cblx0Ly8gaWYgKFN0cmluZyhzeW0pICE9PSBTeW1ib2wucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3ltKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHR2YXIgc3ltVmFsID0gNDI7XG5cdG9ialtzeW1dID0gc3ltVmFsO1xuXHRmb3IgKHN5bSBpbiBvYmopIHsgcmV0dXJuIGZhbHNlOyB9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXgsIG5vLXVucmVhY2hhYmxlLWxvb3Bcblx0aWYgKHR5cGVvZiBPYmplY3Qua2V5cyA9PT0gJ2Z1bmN0aW9uJyAmJiBPYmplY3Qua2V5cyhvYmopLmxlbmd0aCAhPT0gMCkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRpZiAodHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzID09PSAnZnVuY3Rpb24nICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iaikubGVuZ3RoICE9PSAwKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdHZhciBzeW1zID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmopO1xuXHRpZiAoc3ltcy5sZW5ndGggIT09IDEgfHwgc3ltc1swXSAhPT0gc3ltKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKG9iaiwgc3ltKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRpZiAodHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPT09ICdmdW5jdGlvbicpIHtcblx0XHR2YXIgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBzeW0pO1xuXHRcdGlmIChkZXNjcmlwdG9yLnZhbHVlICE9PSBzeW1WYWwgfHwgZGVzY3JpcHRvci5lbnVtZXJhYmxlICE9PSB0cnVlKSB7IHJldHVybiBmYWxzZTsgfVxuXHR9XG5cblx0cmV0dXJuIHRydWU7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAxOTEzOlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgaGFzU3ltYm9scyA9IF9fd2VicGFja19yZXF1aXJlX18oMjkwOCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaGFzVG9TdHJpbmdUYWdTaGFtcygpIHtcblx0cmV0dXJuIGhhc1N5bWJvbHMoKSAmJiAhIVN5bWJvbC50b1N0cmluZ1RhZztcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDg1NTQ6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBjYWxsID0gRnVuY3Rpb24ucHJvdG90eXBlLmNhbGw7XG52YXIgJGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgYmluZCA9IF9fd2VicGFja19yZXF1aXJlX18oOTEzOCk7XG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuJyl9ICovXG5tb2R1bGUuZXhwb3J0cyA9IGJpbmQuY2FsbChjYWxsLCAkaGFzT3duKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNTYxNTpcbi8qKiovICgobW9kdWxlKSA9PiB7XG5cbmlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAvLyBpbXBsZW1lbnRhdGlvbiBmcm9tIHN0YW5kYXJkIG5vZGUuanMgJ3V0aWwnIG1vZHVsZVxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGlmIChzdXBlckN0b3IpIHtcbiAgICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfTtcbn0gZWxzZSB7XG4gIC8vIG9sZCBzY2hvb2wgc2hpbSBmb3Igb2xkIGJyb3dzZXJzXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgaWYgKHN1cGVyQ3Rvcikge1xuICAgICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9XG4gICAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpXG4gICAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3JcbiAgICB9XG4gIH1cbn1cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNTM4Nzpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIGhhc1RvU3RyaW5nVGFnID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOTEzKSgpO1xudmFyIGNhbGxCb3VuZCA9IF9fd2VicGFja19yZXF1aXJlX18oOTgxOCk7XG5cbnZhciAkdG9TdHJpbmcgPSBjYWxsQm91bmQoJ09iamVjdC5wcm90b3R5cGUudG9TdHJpbmcnKTtcblxudmFyIGlzU3RhbmRhcmRBcmd1bWVudHMgPSBmdW5jdGlvbiBpc0FyZ3VtZW50cyh2YWx1ZSkge1xuXHRpZiAoaGFzVG9TdHJpbmdUYWcgJiYgdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiBTeW1ib2wudG9TdHJpbmdUYWcgaW4gdmFsdWUpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblx0cmV0dXJuICR0b1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xufTtcblxudmFyIGlzTGVnYWN5QXJndW1lbnRzID0gZnVuY3Rpb24gaXNBcmd1bWVudHModmFsdWUpIHtcblx0aWYgKGlzU3RhbmRhcmRBcmd1bWVudHModmFsdWUpKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblx0cmV0dXJuIHZhbHVlICE9PSBudWxsICYmXG5cdFx0dHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuXHRcdHR5cGVvZiB2YWx1ZS5sZW5ndGggPT09ICdudW1iZXInICYmXG5cdFx0dmFsdWUubGVuZ3RoID49IDAgJiZcblx0XHQkdG9TdHJpbmcodmFsdWUpICE9PSAnW29iamVjdCBBcnJheV0nICYmXG5cdFx0JHRvU3RyaW5nKHZhbHVlLmNhbGxlZSkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG59O1xuXG52YXIgc3VwcG9ydHNTdGFuZGFyZEFyZ3VtZW50cyA9IChmdW5jdGlvbiAoKSB7XG5cdHJldHVybiBpc1N0YW5kYXJkQXJndW1lbnRzKGFyZ3VtZW50cyk7XG59KCkpO1xuXG5pc1N0YW5kYXJkQXJndW1lbnRzLmlzTGVnYWN5QXJndW1lbnRzID0gaXNMZWdhY3lBcmd1bWVudHM7IC8vIGZvciB0ZXN0c1xuXG5tb2R1bGUuZXhwb3J0cyA9IHN1cHBvcnRzU3RhbmRhcmRBcmd1bWVudHMgPyBpc1N0YW5kYXJkQXJndW1lbnRzIDogaXNMZWdhY3lBcmd1bWVudHM7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDk2MTc6XG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgZm5Ub1N0ciA9IEZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZztcbnZhciByZWZsZWN0QXBwbHkgPSB0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgJiYgUmVmbGVjdCAhPT0gbnVsbCAmJiBSZWZsZWN0LmFwcGx5O1xudmFyIGJhZEFycmF5TGlrZTtcbnZhciBpc0NhbGxhYmxlTWFya2VyO1xuaWYgKHR5cGVvZiByZWZsZWN0QXBwbHkgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSA9PT0gJ2Z1bmN0aW9uJykge1xuXHR0cnkge1xuXHRcdGJhZEFycmF5TGlrZSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ2xlbmd0aCcsIHtcblx0XHRcdGdldDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHR0aHJvdyBpc0NhbGxhYmxlTWFya2VyO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdGlzQ2FsbGFibGVNYXJrZXIgPSB7fTtcblx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdGhyb3ctbGl0ZXJhbFxuXHRcdHJlZmxlY3RBcHBseShmdW5jdGlvbiAoKSB7IHRocm93IDQyOyB9LCBudWxsLCBiYWRBcnJheUxpa2UpO1xuXHR9IGNhdGNoIChfKSB7XG5cdFx0aWYgKF8gIT09IGlzQ2FsbGFibGVNYXJrZXIpIHtcblx0XHRcdHJlZmxlY3RBcHBseSA9IG51bGw7XG5cdFx0fVxuXHR9XG59IGVsc2Uge1xuXHRyZWZsZWN0QXBwbHkgPSBudWxsO1xufVxuXG52YXIgY29uc3RydWN0b3JSZWdleCA9IC9eXFxzKmNsYXNzXFxiLztcbnZhciBpc0VTNkNsYXNzRm4gPSBmdW5jdGlvbiBpc0VTNkNsYXNzRnVuY3Rpb24odmFsdWUpIHtcblx0dHJ5IHtcblx0XHR2YXIgZm5TdHIgPSBmblRvU3RyLmNhbGwodmFsdWUpO1xuXHRcdHJldHVybiBjb25zdHJ1Y3RvclJlZ2V4LnRlc3QoZm5TdHIpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0cmV0dXJuIGZhbHNlOyAvLyBub3QgYSBmdW5jdGlvblxuXHR9XG59O1xuXG52YXIgdHJ5RnVuY3Rpb25PYmplY3QgPSBmdW5jdGlvbiB0cnlGdW5jdGlvblRvU3RyKHZhbHVlKSB7XG5cdHRyeSB7XG5cdFx0aWYgKGlzRVM2Q2xhc3NGbih2YWx1ZSkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0Zm5Ub1N0ci5jYWxsKHZhbHVlKTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufTtcbnZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgb2JqZWN0Q2xhc3MgPSAnW29iamVjdCBPYmplY3RdJztcbnZhciBmbkNsYXNzID0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbnZhciBnZW5DbGFzcyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXSc7XG52YXIgZGRhQ2xhc3MgPSAnW29iamVjdCBIVE1MQWxsQ29sbGVjdGlvbl0nOyAvLyBJRSAxMVxudmFyIGRkYUNsYXNzMiA9ICdbb2JqZWN0IEhUTUwgZG9jdW1lbnQuYWxsIGNsYXNzXSc7XG52YXIgZGRhQ2xhc3MzID0gJ1tvYmplY3QgSFRNTENvbGxlY3Rpb25dJzsgLy8gSUUgOS0xMFxudmFyIGhhc1RvU3RyaW5nVGFnID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiAhIVN5bWJvbC50b1N0cmluZ1RhZzsgLy8gYmV0dGVyOiB1c2UgYGhhcy10b3N0cmluZ3RhZ2BcblxudmFyIGlzSUU2OCA9ICEoMCBpbiBbLF0pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNwYXJzZS1hcnJheXMsIGNvbW1hLXNwYWNpbmdcblxudmFyIGlzRERBID0gZnVuY3Rpb24gaXNEb2N1bWVudERvdEFsbCgpIHsgcmV0dXJuIGZhbHNlOyB9O1xuaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ29iamVjdCcpIHtcblx0Ly8gRmlyZWZveCAzIGNhbm9uaWNhbGl6ZXMgRERBIHRvIHVuZGVmaW5lZCB3aGVuIGl0J3Mgbm90IGFjY2Vzc2VkIGRpcmVjdGx5XG5cdHZhciBhbGwgPSBkb2N1bWVudC5hbGw7XG5cdGlmICh0b1N0ci5jYWxsKGFsbCkgPT09IHRvU3RyLmNhbGwoZG9jdW1lbnQuYWxsKSkge1xuXHRcdGlzRERBID0gZnVuY3Rpb24gaXNEb2N1bWVudERvdEFsbCh2YWx1ZSkge1xuXHRcdFx0LyogZ2xvYmFscyBkb2N1bWVudDogZmFsc2UgKi9cblx0XHRcdC8vIGluIElFIDYtOCwgdHlwZW9mIGRvY3VtZW50LmFsbCBpcyBcIm9iamVjdFwiIGFuZCBpdCdzIHRydXRoeVxuXHRcdFx0aWYgKChpc0lFNjggfHwgIXZhbHVlKSAmJiAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyB8fCB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSkge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdHZhciBzdHIgPSB0b1N0ci5jYWxsKHZhbHVlKTtcblx0XHRcdFx0XHRyZXR1cm4gKFxuXHRcdFx0XHRcdFx0c3RyID09PSBkZGFDbGFzc1xuXHRcdFx0XHRcdFx0fHwgc3RyID09PSBkZGFDbGFzczJcblx0XHRcdFx0XHRcdHx8IHN0ciA9PT0gZGRhQ2xhc3MzIC8vIG9wZXJhIDEyLjE2XG5cdFx0XHRcdFx0XHR8fCBzdHIgPT09IG9iamVjdENsYXNzIC8vIElFIDYtOFxuXHRcdFx0XHRcdCkgJiYgdmFsdWUoJycpID09IG51bGw7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG5cdFx0XHRcdH0gY2F0Y2ggKGUpIHsgLyoqLyB9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlZmxlY3RBcHBseVxuXHQ/IGZ1bmN0aW9uIGlzQ2FsbGFibGUodmFsdWUpIHtcblx0XHRpZiAoaXNEREEodmFsdWUpKSB7IHJldHVybiB0cnVlOyB9XG5cdFx0aWYgKCF2YWx1ZSkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRpZiAodHlwZW9mIHZhbHVlICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0dHJ5IHtcblx0XHRcdHJlZmxlY3RBcHBseSh2YWx1ZSwgbnVsbCwgYmFkQXJyYXlMaWtlKTtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRpZiAoZSAhPT0gaXNDYWxsYWJsZU1hcmtlcikgeyByZXR1cm4gZmFsc2U7IH1cblx0XHR9XG5cdFx0cmV0dXJuICFpc0VTNkNsYXNzRm4odmFsdWUpICYmIHRyeUZ1bmN0aW9uT2JqZWN0KHZhbHVlKTtcblx0fVxuXHQ6IGZ1bmN0aW9uIGlzQ2FsbGFibGUodmFsdWUpIHtcblx0XHRpZiAoaXNEREEodmFsdWUpKSB7IHJldHVybiB0cnVlOyB9XG5cdFx0aWYgKCF2YWx1ZSkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRpZiAodHlwZW9mIHZhbHVlICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0aWYgKGhhc1RvU3RyaW5nVGFnKSB7IHJldHVybiB0cnlGdW5jdGlvbk9iamVjdCh2YWx1ZSk7IH1cblx0XHRpZiAoaXNFUzZDbGFzc0ZuKHZhbHVlKSkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHR2YXIgc3RyQ2xhc3MgPSB0b1N0ci5jYWxsKHZhbHVlKTtcblx0XHRpZiAoc3RyQ2xhc3MgIT09IGZuQ2xhc3MgJiYgc3RyQ2xhc3MgIT09IGdlbkNsYXNzICYmICEoL15cXFtvYmplY3QgSFRNTC8pLnRlc3Qoc3RyQ2xhc3MpKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdHJldHVybiB0cnlGdW5jdGlvbk9iamVjdCh2YWx1ZSk7XG5cdH07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDI2MjU6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgZm5Ub1N0ciA9IEZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZztcbnZhciBpc0ZuUmVnZXggPSAvXlxccyooPzpmdW5jdGlvbik/XFwqLztcbnZhciBoYXNUb1N0cmluZ1RhZyA9IF9fd2VicGFja19yZXF1aXJlX18oMTkxMykoKTtcbnZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBnZXRHZW5lcmF0b3JGdW5jID0gZnVuY3Rpb24gKCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG5cdGlmICghaGFzVG9TdHJpbmdUYWcpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblx0dHJ5IHtcblx0XHRyZXR1cm4gRnVuY3Rpb24oJ3JldHVybiBmdW5jdGlvbiooKSB7fScpKCk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0fVxufTtcbnZhciBHZW5lcmF0b3JGdW5jdGlvbjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0dlbmVyYXRvckZ1bmN0aW9uKGZuKSB7XG5cdGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblx0aWYgKGlzRm5SZWdleC50ZXN0KGZuVG9TdHIuY2FsbChmbikpKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblx0aWYgKCFoYXNUb1N0cmluZ1RhZykge1xuXHRcdHZhciBzdHIgPSB0b1N0ci5jYWxsKGZuKTtcblx0XHRyZXR1cm4gc3RyID09PSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nO1xuXHR9XG5cdGlmICghZ2V0UHJvdG8pIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblx0aWYgKHR5cGVvZiBHZW5lcmF0b3JGdW5jdGlvbiA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHR2YXIgZ2VuZXJhdG9yRnVuYyA9IGdldEdlbmVyYXRvckZ1bmMoKTtcblx0XHRHZW5lcmF0b3JGdW5jdGlvbiA9IGdlbmVyYXRvckZ1bmMgPyBnZXRQcm90byhnZW5lcmF0b3JGdW5jKSA6IGZhbHNlO1xuXHR9XG5cdHJldHVybiBnZXRQcm90byhmbikgPT09IEdlbmVyYXRvckZ1bmN0aW9uO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gODAwNjpcbi8qKiovICgobW9kdWxlKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbi8qIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1udW1iZXIuaXNuYW4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc05hTih2YWx1ZSkge1xuXHRyZXR1cm4gdmFsdWUgIT09IHZhbHVlO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNzgzODpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIGNhbGxCaW5kID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NDk4KTtcbnZhciBkZWZpbmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4NTcpO1xuXG52YXIgaW1wbGVtZW50YXRpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgwMDYpO1xudmFyIGdldFBvbHlmaWxsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNTkxKTtcbnZhciBzaGltID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNjQxKTtcblxudmFyIHBvbHlmaWxsID0gY2FsbEJpbmQoZ2V0UG9seWZpbGwoKSwgTnVtYmVyKTtcblxuLyogaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLW51bWJlci5pc25hbiAqL1xuXG5kZWZpbmUocG9seWZpbGwsIHtcblx0Z2V0UG9seWZpbGw6IGdldFBvbHlmaWxsLFxuXHRpbXBsZW1lbnRhdGlvbjogaW1wbGVtZW50YXRpb24sXG5cdHNoaW06IHNoaW1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBvbHlmaWxsO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAxNTkxOlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgaW1wbGVtZW50YXRpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgwMDYpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldFBvbHlmaWxsKCkge1xuXHRpZiAoTnVtYmVyLmlzTmFOICYmIE51bWJlci5pc05hTihOYU4pICYmICFOdW1iZXIuaXNOYU4oJ2EnKSkge1xuXHRcdHJldHVybiBOdW1iZXIuaXNOYU47XG5cdH1cblx0cmV0dXJuIGltcGxlbWVudGF0aW9uO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMTY0MTpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIGRlZmluZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTg1Nyk7XG52YXIgZ2V0UG9seWZpbGwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1OTEpO1xuXG4vKiBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtbnVtYmVyLmlzbmFuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc2hpbU51bWJlcklzTmFOKCkge1xuXHR2YXIgcG9seWZpbGwgPSBnZXRQb2x5ZmlsbCgpO1xuXHRkZWZpbmUoTnVtYmVyLCB7IGlzTmFOOiBwb2x5ZmlsbCB9LCB7XG5cdFx0aXNOYU46IGZ1bmN0aW9uIHRlc3RJc05hTigpIHtcblx0XHRcdHJldHVybiBOdW1iZXIuaXNOYU4gIT09IHBvbHlmaWxsO1xuXHRcdH1cblx0fSk7XG5cdHJldHVybiBwb2x5ZmlsbDtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDU5NDM6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciB3aGljaFR5cGVkQXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI3MzApO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzVHlwZWRBcnJheSh2YWx1ZSkge1xuXHRyZXR1cm4gISF3aGljaFR5cGVkQXJyYXkodmFsdWUpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMjM3Mjpcbi8qKiovICgobW9kdWxlKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBudW1iZXJJc05hTiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRyZXR1cm4gdmFsdWUgIT09IHZhbHVlO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpcyhhLCBiKSB7XG5cdGlmIChhID09PSAwICYmIGIgPT09IDApIHtcblx0XHRyZXR1cm4gMSAvIGEgPT09IDEgLyBiO1xuXHR9XG5cdGlmIChhID09PSBiKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblx0aWYgKG51bWJlcklzTmFOKGEpICYmIG51bWJlcklzTmFOKGIpKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblx0cmV0dXJuIGZhbHNlO1xufTtcblxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA1OTY4OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgZGVmaW5lID0gX193ZWJwYWNrX3JlcXVpcmVfXygxODU3KTtcbnZhciBjYWxsQmluZCA9IF9fd2VicGFja19yZXF1aXJlX18oODQ5OCk7XG5cbnZhciBpbXBsZW1lbnRhdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMjM3Mik7XG52YXIgZ2V0UG9seWZpbGwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5MzcpO1xudmFyIHNoaW0gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUwODcpO1xuXG52YXIgcG9seWZpbGwgPSBjYWxsQmluZChnZXRQb2x5ZmlsbCgpLCBPYmplY3QpO1xuXG5kZWZpbmUocG9seWZpbGwsIHtcblx0Z2V0UG9seWZpbGw6IGdldFBvbHlmaWxsLFxuXHRpbXBsZW1lbnRhdGlvbjogaW1wbGVtZW50YXRpb24sXG5cdHNoaW06IHNoaW1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBvbHlmaWxsO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAxOTM3OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgaW1wbGVtZW50YXRpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIzNzIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldFBvbHlmaWxsKCkge1xuXHRyZXR1cm4gdHlwZW9mIE9iamVjdC5pcyA9PT0gJ2Z1bmN0aW9uJyA/IE9iamVjdC5pcyA6IGltcGxlbWVudGF0aW9uO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNTA4Nzpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIGdldFBvbHlmaWxsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOTM3KTtcbnZhciBkZWZpbmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4NTcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNoaW1PYmplY3RJcygpIHtcblx0dmFyIHBvbHlmaWxsID0gZ2V0UG9seWZpbGwoKTtcblx0ZGVmaW5lKE9iamVjdCwgeyBpczogcG9seWZpbGwgfSwge1xuXHRcdGlzOiBmdW5jdGlvbiB0ZXN0T2JqZWN0SXMoKSB7XG5cdFx0XHRyZXR1cm4gT2JqZWN0LmlzICE9PSBwb2x5ZmlsbDtcblx0XHR9XG5cdH0pO1xuXHRyZXR1cm4gcG9seWZpbGw7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA4MTYwOlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIga2V5c1NoaW07XG5pZiAoIU9iamVjdC5rZXlzKSB7XG5cdC8vIG1vZGlmaWVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2VzLXNoaW1zL2VzNS1zaGltXG5cdHZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXHR2YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXHR2YXIgaXNBcmdzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NjgpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGdsb2JhbC1yZXF1aXJlXG5cdHZhciBpc0VudW1lcmFibGUgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXHR2YXIgaGFzRG9udEVudW1CdWcgPSAhaXNFbnVtZXJhYmxlLmNhbGwoeyB0b1N0cmluZzogbnVsbCB9LCAndG9TdHJpbmcnKTtcblx0dmFyIGhhc1Byb3RvRW51bUJ1ZyA9IGlzRW51bWVyYWJsZS5jYWxsKGZ1bmN0aW9uICgpIHt9LCAncHJvdG90eXBlJyk7XG5cdHZhciBkb250RW51bXMgPSBbXG5cdFx0J3RvU3RyaW5nJyxcblx0XHQndG9Mb2NhbGVTdHJpbmcnLFxuXHRcdCd2YWx1ZU9mJyxcblx0XHQnaGFzT3duUHJvcGVydHknLFxuXHRcdCdpc1Byb3RvdHlwZU9mJyxcblx0XHQncHJvcGVydHlJc0VudW1lcmFibGUnLFxuXHRcdCdjb25zdHJ1Y3Rvcidcblx0XTtcblx0dmFyIGVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlID0gZnVuY3Rpb24gKG8pIHtcblx0XHR2YXIgY3RvciA9IG8uY29uc3RydWN0b3I7XG5cdFx0cmV0dXJuIGN0b3IgJiYgY3Rvci5wcm90b3R5cGUgPT09IG87XG5cdH07XG5cdHZhciBleGNsdWRlZEtleXMgPSB7XG5cdFx0JGFwcGxpY2F0aW9uQ2FjaGU6IHRydWUsXG5cdFx0JGNvbnNvbGU6IHRydWUsXG5cdFx0JGV4dGVybmFsOiB0cnVlLFxuXHRcdCRmcmFtZTogdHJ1ZSxcblx0XHQkZnJhbWVFbGVtZW50OiB0cnVlLFxuXHRcdCRmcmFtZXM6IHRydWUsXG5cdFx0JGlubmVySGVpZ2h0OiB0cnVlLFxuXHRcdCRpbm5lcldpZHRoOiB0cnVlLFxuXHRcdCRvbm1vemZ1bGxzY3JlZW5jaGFuZ2U6IHRydWUsXG5cdFx0JG9ubW96ZnVsbHNjcmVlbmVycm9yOiB0cnVlLFxuXHRcdCRvdXRlckhlaWdodDogdHJ1ZSxcblx0XHQkb3V0ZXJXaWR0aDogdHJ1ZSxcblx0XHQkcGFnZVhPZmZzZXQ6IHRydWUsXG5cdFx0JHBhZ2VZT2Zmc2V0OiB0cnVlLFxuXHRcdCRwYXJlbnQ6IHRydWUsXG5cdFx0JHNjcm9sbExlZnQ6IHRydWUsXG5cdFx0JHNjcm9sbFRvcDogdHJ1ZSxcblx0XHQkc2Nyb2xsWDogdHJ1ZSxcblx0XHQkc2Nyb2xsWTogdHJ1ZSxcblx0XHQkc2VsZjogdHJ1ZSxcblx0XHQkd2Via2l0SW5kZXhlZERCOiB0cnVlLFxuXHRcdCR3ZWJraXRTdG9yYWdlSW5mbzogdHJ1ZSxcblx0XHQkd2luZG93OiB0cnVlXG5cdH07XG5cdHZhciBoYXNBdXRvbWF0aW9uRXF1YWxpdHlCdWcgPSAoZnVuY3Rpb24gKCkge1xuXHRcdC8qIGdsb2JhbCB3aW5kb3cgKi9cblx0XHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0Zm9yICh2YXIgayBpbiB3aW5kb3cpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGlmICghZXhjbHVkZWRLZXlzWyckJyArIGtdICYmIGhhcy5jYWxsKHdpbmRvdywgaykgJiYgd2luZG93W2tdICE9PSBudWxsICYmIHR5cGVvZiB3aW5kb3dba10gPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdGVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlKHdpbmRvd1trXSk7XG5cdFx0XHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0oKSk7XG5cdHZhciBlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZUlmTm90QnVnZ3kgPSBmdW5jdGlvbiAobykge1xuXHRcdC8qIGdsb2JhbCB3aW5kb3cgKi9cblx0XHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgfHwgIWhhc0F1dG9tYXRpb25FcXVhbGl0eUJ1Zykge1xuXHRcdFx0cmV0dXJuIGVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlKG8pO1xuXHRcdH1cblx0XHR0cnkge1xuXHRcdFx0cmV0dXJuIGVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlKG8pO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdH07XG5cblx0a2V5c1NoaW0gPSBmdW5jdGlvbiBrZXlzKG9iamVjdCkge1xuXHRcdHZhciBpc09iamVjdCA9IG9iamVjdCAhPT0gbnVsbCAmJiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0Jztcblx0XHR2YXIgaXNGdW5jdGlvbiA9IHRvU3RyLmNhbGwob2JqZWN0KSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcblx0XHR2YXIgaXNBcmd1bWVudHMgPSBpc0FyZ3Mob2JqZWN0KTtcblx0XHR2YXIgaXNTdHJpbmcgPSBpc09iamVjdCAmJiB0b1N0ci5jYWxsKG9iamVjdCkgPT09ICdbb2JqZWN0IFN0cmluZ10nO1xuXHRcdHZhciB0aGVLZXlzID0gW107XG5cblx0XHRpZiAoIWlzT2JqZWN0ICYmICFpc0Z1bmN0aW9uICYmICFpc0FyZ3VtZW50cykge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0LmtleXMgY2FsbGVkIG9uIGEgbm9uLW9iamVjdCcpO1xuXHRcdH1cblxuXHRcdHZhciBza2lwUHJvdG8gPSBoYXNQcm90b0VudW1CdWcgJiYgaXNGdW5jdGlvbjtcblx0XHRpZiAoaXNTdHJpbmcgJiYgb2JqZWN0Lmxlbmd0aCA+IDAgJiYgIWhhcy5jYWxsKG9iamVjdCwgMCkpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0Lmxlbmd0aDsgKytpKSB7XG5cdFx0XHRcdHRoZUtleXMucHVzaChTdHJpbmcoaSkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChpc0FyZ3VtZW50cyAmJiBvYmplY3QubGVuZ3RoID4gMCkge1xuXHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBvYmplY3QubGVuZ3RoOyArK2opIHtcblx0XHRcdFx0dGhlS2V5cy5wdXNoKFN0cmluZyhqKSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGZvciAodmFyIG5hbWUgaW4gb2JqZWN0KSB7XG5cdFx0XHRcdGlmICghKHNraXBQcm90byAmJiBuYW1lID09PSAncHJvdG90eXBlJykgJiYgaGFzLmNhbGwob2JqZWN0LCBuYW1lKSkge1xuXHRcdFx0XHRcdHRoZUtleXMucHVzaChTdHJpbmcobmFtZSkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGhhc0RvbnRFbnVtQnVnKSB7XG5cdFx0XHR2YXIgc2tpcENvbnN0cnVjdG9yID0gZXF1YWxzQ29uc3RydWN0b3JQcm90b3R5cGVJZk5vdEJ1Z2d5KG9iamVjdCk7XG5cblx0XHRcdGZvciAodmFyIGsgPSAwOyBrIDwgZG9udEVudW1zLmxlbmd0aDsgKytrKSB7XG5cdFx0XHRcdGlmICghKHNraXBDb25zdHJ1Y3RvciAmJiBkb250RW51bXNba10gPT09ICdjb25zdHJ1Y3RvcicpICYmIGhhcy5jYWxsKG9iamVjdCwgZG9udEVudW1zW2tdKSkge1xuXHRcdFx0XHRcdHRoZUtleXMucHVzaChkb250RW51bXNba10pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0aGVLZXlzO1xuXHR9O1xufVxubW9kdWxlLmV4cG9ydHMgPSBrZXlzU2hpbTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gOTIyODpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xudmFyIGlzQXJncyA9IF9fd2VicGFja19yZXF1aXJlX18oOTY4KTtcblxudmFyIG9yaWdLZXlzID0gT2JqZWN0LmtleXM7XG52YXIga2V5c1NoaW0gPSBvcmlnS2V5cyA/IGZ1bmN0aW9uIGtleXMobykgeyByZXR1cm4gb3JpZ0tleXMobyk7IH0gOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDgxNjApO1xuXG52YXIgb3JpZ2luYWxLZXlzID0gT2JqZWN0LmtleXM7XG5cbmtleXNTaGltLnNoaW0gPSBmdW5jdGlvbiBzaGltT2JqZWN0S2V5cygpIHtcblx0aWYgKE9iamVjdC5rZXlzKSB7XG5cdFx0dmFyIGtleXNXb3Jrc1dpdGhBcmd1bWVudHMgPSAoZnVuY3Rpb24gKCkge1xuXHRcdFx0Ly8gU2FmYXJpIDUuMCBidWdcblx0XHRcdHZhciBhcmdzID0gT2JqZWN0LmtleXMoYXJndW1lbnRzKTtcblx0XHRcdHJldHVybiBhcmdzICYmIGFyZ3MubGVuZ3RoID09PSBhcmd1bWVudHMubGVuZ3RoO1xuXHRcdH0oMSwgMikpO1xuXHRcdGlmICgha2V5c1dvcmtzV2l0aEFyZ3VtZW50cykge1xuXHRcdFx0T2JqZWN0LmtleXMgPSBmdW5jdGlvbiBrZXlzKG9iamVjdCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGZ1bmMtbmFtZS1tYXRjaGluZ1xuXHRcdFx0XHRpZiAoaXNBcmdzKG9iamVjdCkpIHtcblx0XHRcdFx0XHRyZXR1cm4gb3JpZ2luYWxLZXlzKHNsaWNlLmNhbGwob2JqZWN0KSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG9yaWdpbmFsS2V5cyhvYmplY3QpO1xuXHRcdFx0fTtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0T2JqZWN0LmtleXMgPSBrZXlzU2hpbTtcblx0fVxuXHRyZXR1cm4gT2JqZWN0LmtleXMgfHwga2V5c1NoaW07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGtleXNTaGltO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA5Njg6XG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQXJndW1lbnRzKHZhbHVlKSB7XG5cdHZhciBzdHIgPSB0b1N0ci5jYWxsKHZhbHVlKTtcblx0dmFyIGlzQXJncyA9IHN0ciA9PT0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG5cdGlmICghaXNBcmdzKSB7XG5cdFx0aXNBcmdzID0gc3RyICE9PSAnW29iamVjdCBBcnJheV0nICYmXG5cdFx0XHR2YWx1ZSAhPT0gbnVsbCAmJlxuXHRcdFx0dHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuXHRcdFx0dHlwZW9mIHZhbHVlLmxlbmd0aCA9PT0gJ251bWJlcicgJiZcblx0XHRcdHZhbHVlLmxlbmd0aCA+PSAwICYmXG5cdFx0XHR0b1N0ci5jYWxsKHZhbHVlLmNhbGxlZSkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG5cdH1cblx0cmV0dXJuIGlzQXJncztcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDk5MDc6XG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG4vLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA2MTA4OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgR2V0SW50cmluc2ljID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MjgpO1xudmFyIGRlZmluZSA9IF9fd2VicGFja19yZXF1aXJlX18oNjg2KTtcbnZhciBoYXNEZXNjcmlwdG9ycyA9IF9fd2VicGFja19yZXF1aXJlX18oNzIzOSkoKTtcbnZhciBnT1BEID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MzM2KTtcblxudmFyICRUeXBlRXJyb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM0NjgpO1xudmFyICRmbG9vciA9IEdldEludHJpbnNpYygnJU1hdGguZmxvb3IlJyk7XG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuJyl9ICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNldEZ1bmN0aW9uTGVuZ3RoKGZuLCBsZW5ndGgpIHtcblx0aWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdgZm5gIGlzIG5vdCBhIGZ1bmN0aW9uJyk7XG5cdH1cblx0aWYgKHR5cGVvZiBsZW5ndGggIT09ICdudW1iZXInIHx8IGxlbmd0aCA8IDAgfHwgbGVuZ3RoID4gMHhGRkZGRkZGRiB8fCAkZmxvb3IobGVuZ3RoKSAhPT0gbGVuZ3RoKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ2BsZW5ndGhgIG11c3QgYmUgYSBwb3NpdGl2ZSAzMi1iaXQgaW50ZWdlcicpO1xuXHR9XG5cblx0dmFyIGxvb3NlID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgISFhcmd1bWVudHNbMl07XG5cblx0dmFyIGZ1bmN0aW9uTGVuZ3RoSXNDb25maWd1cmFibGUgPSB0cnVlO1xuXHR2YXIgZnVuY3Rpb25MZW5ndGhJc1dyaXRhYmxlID0gdHJ1ZTtcblx0aWYgKCdsZW5ndGgnIGluIGZuICYmIGdPUEQpIHtcblx0XHR2YXIgZGVzYyA9IGdPUEQoZm4sICdsZW5ndGgnKTtcblx0XHRpZiAoZGVzYyAmJiAhZGVzYy5jb25maWd1cmFibGUpIHtcblx0XHRcdGZ1bmN0aW9uTGVuZ3RoSXNDb25maWd1cmFibGUgPSBmYWxzZTtcblx0XHR9XG5cdFx0aWYgKGRlc2MgJiYgIWRlc2Mud3JpdGFibGUpIHtcblx0XHRcdGZ1bmN0aW9uTGVuZ3RoSXNXcml0YWJsZSA9IGZhbHNlO1xuXHRcdH1cblx0fVxuXG5cdGlmIChmdW5jdGlvbkxlbmd0aElzQ29uZmlndXJhYmxlIHx8IGZ1bmN0aW9uTGVuZ3RoSXNXcml0YWJsZSB8fCAhbG9vc2UpIHtcblx0XHRpZiAoaGFzRGVzY3JpcHRvcnMpIHtcblx0XHRcdGRlZmluZSgvKiogQHR5cGUge1BhcmFtZXRlcnM8ZGVmaW5lPlswXX0gKi8gKGZuKSwgJ2xlbmd0aCcsIGxlbmd0aCwgdHJ1ZSwgdHJ1ZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRlZmluZSgvKiogQHR5cGUge1BhcmFtZXRlcnM8ZGVmaW5lPlswXX0gKi8gKGZuKSwgJ2xlbmd0aCcsIGxlbmd0aCk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBmbjtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDIxMjU6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgQmFzZVNlcnZpY2U6ICgpID0+ICgvKiBiaW5kaW5nICovIEJhc2VTZXJ2aWNlKVxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgdnNjb2RlX2xhbmd1YWdlc2VydmVyX3Byb3RvY29sX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU1MDEpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHZzY29kZV9sYW5ndWFnZXNlcnZlcl9wcm90b2NvbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKHZzY29kZV9sYW5ndWFnZXNlcnZlcl9wcm90b2NvbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNzc3MCk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgdnNjb2RlX2xhbmd1YWdlc2VydmVyX3RleHRkb2N1bWVudF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4MDQxKTtcbmZ1bmN0aW9uIF9kZWZpbmVfcHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgaWYgKGtleSBpbiBvYmopIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbn1cblxuXG5cbmNsYXNzIEJhc2VTZXJ2aWNlIHtcbiAgICBhZGREb2N1bWVudChkb2N1bWVudCkge1xuICAgICAgICB0aGlzLmRvY3VtZW50c1tkb2N1bWVudC51cmldID0gdnNjb2RlX2xhbmd1YWdlc2VydmVyX3RleHRkb2N1bWVudF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLyogLlRleHREb2N1bWVudCAqLyAuVi5jcmVhdGUoZG9jdW1lbnQudXJpLCBkb2N1bWVudC5sYW5ndWFnZUlkLCBkb2N1bWVudC52ZXJzaW9uLCBkb2N1bWVudC50ZXh0KTtcbiAgICB9XG4gICAgZ2V0RG9jdW1lbnQodXJpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRvY3VtZW50c1t1cmldO1xuICAgIH1cbiAgICByZW1vdmVEb2N1bWVudChkb2N1bWVudCkge1xuICAgICAgICBkZWxldGUgdGhpcy5kb2N1bWVudHNbZG9jdW1lbnQudXJpXTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9uc1tkb2N1bWVudC51cmldKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5vcHRpb25zW2RvY3VtZW50LnVyaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0RG9jdW1lbnRWYWx1ZSh1cmkpIHtcbiAgICAgICAgdmFyIF90aGlzX2dldERvY3VtZW50O1xuICAgICAgICByZXR1cm4gKF90aGlzX2dldERvY3VtZW50ID0gdGhpcy5nZXREb2N1bWVudCh1cmkpKSA9PT0gbnVsbCB8fCBfdGhpc19nZXREb2N1bWVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXNfZ2V0RG9jdW1lbnQuZ2V0VGV4dCgpO1xuICAgIH1cbiAgICBzZXRWYWx1ZShpZGVudGlmaWVyLCB2YWx1ZSkge1xuICAgICAgICBsZXQgZG9jdW1lbnQgPSB0aGlzLmdldERvY3VtZW50KGlkZW50aWZpZXIudXJpKTtcbiAgICAgICAgaWYgKGRvY3VtZW50KSB7XG4gICAgICAgICAgICBkb2N1bWVudCA9IHZzY29kZV9sYW5ndWFnZXNlcnZlcl90ZXh0ZG9jdW1lbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy8qIC5UZXh0RG9jdW1lbnQgKi8gLlYuY3JlYXRlKGRvY3VtZW50LnVyaSwgZG9jdW1lbnQubGFuZ3VhZ2VJZCwgZG9jdW1lbnQudmVyc2lvbiwgdmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5kb2N1bWVudHNbZG9jdW1lbnQudXJpXSA9IGRvY3VtZW50O1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldEdsb2JhbE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICB0aGlzLmdsb2JhbE9wdGlvbnMgPSBvcHRpb25zICE9PSBudWxsICYmIG9wdGlvbnMgIT09IHZvaWQgMCA/IG9wdGlvbnMgOiB7fTtcbiAgICB9XG4gICAgc2V0V29ya3NwYWNlKHdvcmtzcGFjZVVyaSkge1xuICAgICAgICB0aGlzLndvcmtzcGFjZVVyaSA9IHdvcmtzcGFjZVVyaTtcbiAgICB9XG4gICAgc2V0T3B0aW9ucyhkb2N1bWVudFVyaSwgb3B0aW9ucywgbWVyZ2UgPSBmYWxzZSkge1xuICAgICAgICB0aGlzLm9wdGlvbnNbZG9jdW1lbnRVcmldID0gbWVyZ2UgPyAoMCxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXy8qIC5tZXJnZU9iamVjdHMgKi8gLnJMKShvcHRpb25zLCB0aGlzLm9wdGlvbnNbZG9jdW1lbnRVcmldKSA6IG9wdGlvbnM7XG4gICAgfVxuICAgIGdldE9wdGlvbihkb2N1bWVudFVyaSwgb3B0aW9uTmFtZSkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zW2RvY3VtZW50VXJpXSAmJiB0aGlzLm9wdGlvbnNbZG9jdW1lbnRVcmldW29wdGlvbk5hbWVdKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zW2RvY3VtZW50VXJpXVtvcHRpb25OYW1lXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdsb2JhbE9wdGlvbnNbb3B0aW9uTmFtZV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXBwbHlEZWx0YXMoaWRlbnRpZmllciwgZGVsdGFzKSB7XG4gICAgICAgIGxldCBkb2N1bWVudCA9IHRoaXMuZ2V0RG9jdW1lbnQoaWRlbnRpZmllci51cmkpO1xuICAgICAgICBpZiAoZG9jdW1lbnQpIHZzY29kZV9sYW5ndWFnZXNlcnZlcl90ZXh0ZG9jdW1lbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy8qIC5UZXh0RG9jdW1lbnQgKi8gLlYudXBkYXRlKGRvY3VtZW50LCBkZWx0YXMsIGlkZW50aWZpZXIudmVyc2lvbik7XG4gICAgfVxuICAgIGFzeW5jIGRvQ29tcGxldGUoZG9jdW1lbnQsIHBvc2l0aW9uKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBhc3luYyBkb0hvdmVyKGRvY3VtZW50LCBwb3NpdGlvbikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgYXN5bmMgZG9SZXNvbHZlKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGFzeW5jIGRvVmFsaWRhdGlvbihkb2N1bWVudCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGZvcm1hdChkb2N1bWVudCwgcmFuZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShbXSk7XG4gICAgfVxuICAgIGFzeW5jIHByb3ZpZGVTaWduYXR1cmVIZWxwKGRvY3VtZW50LCBwb3NpdGlvbikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgYXN5bmMgZmluZERvY3VtZW50SGlnaGxpZ2h0cyhkb2N1bWVudCwgcG9zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBnZXQgb3B0aW9uc1RvRmlsdGVyRGlhZ25vc3RpY3MoKSB7XG4gICAgICAgIHZhciBfdGhpc19nbG9iYWxPcHRpb25zX2Vycm9yQ29kZXNUb0lnbm9yZSwgX3RoaXNfZ2xvYmFsT3B0aW9uc19lcnJvckNvZGVzVG9UcmVhdEFzV2FybmluZywgX3RoaXNfZ2xvYmFsT3B0aW9uc19lcnJvckNvZGVzVG9UcmVhdEFzSW5mbywgX3RoaXNfZ2xvYmFsT3B0aW9uc19lcnJvck1lc3NhZ2VzVG9JZ25vcmUsIF90aGlzX2dsb2JhbE9wdGlvbnNfZXJyb3JNZXNzYWdlc1RvVHJlYXRBc1dhcm5pbmcsIF90aGlzX2dsb2JhbE9wdGlvbnNfZXJyb3JNZXNzYWdlc1RvVHJlYXRBc0luZm87XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlcnJvckNvZGVzVG9JZ25vcmU6IChfdGhpc19nbG9iYWxPcHRpb25zX2Vycm9yQ29kZXNUb0lnbm9yZSA9IHRoaXMuZ2xvYmFsT3B0aW9ucy5lcnJvckNvZGVzVG9JZ25vcmUpICE9PSBudWxsICYmIF90aGlzX2dsb2JhbE9wdGlvbnNfZXJyb3JDb2Rlc1RvSWdub3JlICE9PSB2b2lkIDAgPyBfdGhpc19nbG9iYWxPcHRpb25zX2Vycm9yQ29kZXNUb0lnbm9yZSA6IFtdLFxuICAgICAgICAgICAgZXJyb3JDb2Rlc1RvVHJlYXRBc1dhcm5pbmc6IChfdGhpc19nbG9iYWxPcHRpb25zX2Vycm9yQ29kZXNUb1RyZWF0QXNXYXJuaW5nID0gdGhpcy5nbG9iYWxPcHRpb25zLmVycm9yQ29kZXNUb1RyZWF0QXNXYXJuaW5nKSAhPT0gbnVsbCAmJiBfdGhpc19nbG9iYWxPcHRpb25zX2Vycm9yQ29kZXNUb1RyZWF0QXNXYXJuaW5nICE9PSB2b2lkIDAgPyBfdGhpc19nbG9iYWxPcHRpb25zX2Vycm9yQ29kZXNUb1RyZWF0QXNXYXJuaW5nIDogW10sXG4gICAgICAgICAgICBlcnJvckNvZGVzVG9UcmVhdEFzSW5mbzogKF90aGlzX2dsb2JhbE9wdGlvbnNfZXJyb3JDb2Rlc1RvVHJlYXRBc0luZm8gPSB0aGlzLmdsb2JhbE9wdGlvbnMuZXJyb3JDb2Rlc1RvVHJlYXRBc0luZm8pICE9PSBudWxsICYmIF90aGlzX2dsb2JhbE9wdGlvbnNfZXJyb3JDb2Rlc1RvVHJlYXRBc0luZm8gIT09IHZvaWQgMCA/IF90aGlzX2dsb2JhbE9wdGlvbnNfZXJyb3JDb2Rlc1RvVHJlYXRBc0luZm8gOiBbXSxcbiAgICAgICAgICAgIGVycm9yTWVzc2FnZXNUb0lnbm9yZTogKF90aGlzX2dsb2JhbE9wdGlvbnNfZXJyb3JNZXNzYWdlc1RvSWdub3JlID0gdGhpcy5nbG9iYWxPcHRpb25zLmVycm9yTWVzc2FnZXNUb0lnbm9yZSkgIT09IG51bGwgJiYgX3RoaXNfZ2xvYmFsT3B0aW9uc19lcnJvck1lc3NhZ2VzVG9JZ25vcmUgIT09IHZvaWQgMCA/IF90aGlzX2dsb2JhbE9wdGlvbnNfZXJyb3JNZXNzYWdlc1RvSWdub3JlIDogW10sXG4gICAgICAgICAgICBlcnJvck1lc3NhZ2VzVG9UcmVhdEFzV2FybmluZzogKF90aGlzX2dsb2JhbE9wdGlvbnNfZXJyb3JNZXNzYWdlc1RvVHJlYXRBc1dhcm5pbmcgPSB0aGlzLmdsb2JhbE9wdGlvbnMuZXJyb3JNZXNzYWdlc1RvVHJlYXRBc1dhcm5pbmcpICE9PSBudWxsICYmIF90aGlzX2dsb2JhbE9wdGlvbnNfZXJyb3JNZXNzYWdlc1RvVHJlYXRBc1dhcm5pbmcgIT09IHZvaWQgMCA/IF90aGlzX2dsb2JhbE9wdGlvbnNfZXJyb3JNZXNzYWdlc1RvVHJlYXRBc1dhcm5pbmcgOiBbXSxcbiAgICAgICAgICAgIGVycm9yTWVzc2FnZXNUb1RyZWF0QXNJbmZvOiAoX3RoaXNfZ2xvYmFsT3B0aW9uc19lcnJvck1lc3NhZ2VzVG9UcmVhdEFzSW5mbyA9IHRoaXMuZ2xvYmFsT3B0aW9ucy5lcnJvck1lc3NhZ2VzVG9UcmVhdEFzSW5mbykgIT09IG51bGwgJiYgX3RoaXNfZ2xvYmFsT3B0aW9uc19lcnJvck1lc3NhZ2VzVG9UcmVhdEFzSW5mbyAhPT0gdm9pZCAwID8gX3RoaXNfZ2xvYmFsT3B0aW9uc19lcnJvck1lc3NhZ2VzVG9UcmVhdEFzSW5mbyA6IFtdXG4gICAgICAgIH07XG4gICAgfVxuICAgIGdldFNlbWFudGljVG9rZW5zKGRvY3VtZW50LCByYW5nZSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xuICAgIH1cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIGNsb3NlQ29ubmVjdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICBnZXRDb2RlQWN0aW9ucyhkb2N1bWVudCwgcmFuZ2UsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShudWxsKTtcbiAgICB9XG4gICAgZXhlY3V0ZUNvbW1hbmQoY29tbWFuZCwgYXJncykge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xuICAgIH1cbiAgICBzZW5kQXBwbGllZFJlc3VsdChyZXN1bHQsIGNhbGxiYWNrSWQpIHt9XG4gICAgY29uc3RydWN0b3IobW9kZSwgd29ya3NwYWNlVXJpKXtcbiAgICAgICAgX2RlZmluZV9wcm9wZXJ0eSh0aGlzLCBcInNlcnZpY2VOYW1lXCIsIHZvaWQgMCk7XG4gICAgICAgIF9kZWZpbmVfcHJvcGVydHkodGhpcywgXCJtb2RlXCIsIHZvaWQgMCk7XG4gICAgICAgIF9kZWZpbmVfcHJvcGVydHkodGhpcywgXCJkb2N1bWVudHNcIiwge30pO1xuICAgICAgICBfZGVmaW5lX3Byb3BlcnR5KHRoaXMsIFwib3B0aW9uc1wiLCB7fSk7XG4gICAgICAgIF9kZWZpbmVfcHJvcGVydHkodGhpcywgXCJnbG9iYWxPcHRpb25zXCIsIHt9KTtcbiAgICAgICAgX2RlZmluZV9wcm9wZXJ0eSh0aGlzLCBcInNlcnZpY2VEYXRhXCIsIHZvaWQgMCk7XG4gICAgICAgIF9kZWZpbmVfcHJvcGVydHkodGhpcywgXCJzZXJ2aWNlQ2FwYWJpbGl0aWVzXCIsIHt9KTtcbiAgICAgICAgX2RlZmluZV9wcm9wZXJ0eSh0aGlzLCBcIndvcmtzcGFjZVVyaVwiLCB2b2lkIDApO1xuICAgICAgICBfZGVmaW5lX3Byb3BlcnR5KHRoaXMsIFwiY2xpZW50Q2FwYWJpbGl0aWVzXCIsIHtcbiAgICAgICAgICAgIHRleHREb2N1bWVudDoge1xuICAgICAgICAgICAgICAgIGRpYWdub3N0aWM6IHtcbiAgICAgICAgICAgICAgICAgICAgZHluYW1pY1JlZ2lzdHJhdGlvbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgcmVsYXRlZERvY3VtZW50U3VwcG9ydDogdHJ1ZVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcHVibGlzaERpYWdub3N0aWNzOiB7XG4gICAgICAgICAgICAgICAgICAgIHJlbGF0ZWRJbmZvcm1hdGlvbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgdmVyc2lvblN1cHBvcnQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICB0YWdTdXBwb3J0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVNldDogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZzY29kZV9sYW5ndWFnZXNlcnZlcl9wcm90b2NvbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLkRpYWdub3N0aWNUYWcuVW5uZWNlc3NhcnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdnNjb2RlX2xhbmd1YWdlc2VydmVyX3Byb3RvY29sX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uRGlhZ25vc3RpY1RhZy5EZXByZWNhdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGhvdmVyOiB7XG4gICAgICAgICAgICAgICAgICAgIGR5bmFtaWNSZWdpc3RyYXRpb246IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRGb3JtYXQ6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdtYXJrZG93bicsXG4gICAgICAgICAgICAgICAgICAgICAgICAncGxhaW50ZXh0J1xuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzeW5jaHJvbml6YXRpb246IHtcbiAgICAgICAgICAgICAgICAgICAgZHluYW1pY1JlZ2lzdHJhdGlvbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgd2lsbFNhdmU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBkaWRTYXZlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgd2lsbFNhdmVXYWl0VW50aWw6IGZhbHNlXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBmb3JtYXR0aW5nOiB7XG4gICAgICAgICAgICAgICAgICAgIGR5bmFtaWNSZWdpc3RyYXRpb246IHRydWVcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGNvbXBsZXRpb246IHtcbiAgICAgICAgICAgICAgICAgICAgZHluYW1pY1JlZ2lzdHJhdGlvbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgY29tcGxldGlvbkl0ZW06IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNuaXBwZXRTdXBwb3J0OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29tbWl0Q2hhcmFjdGVyc1N1cHBvcnQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnRhdGlvbkZvcm1hdDogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdtYXJrZG93bicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3BsYWludGV4dCdcbiAgICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXByZWNhdGVkU3VwcG9ydDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVzZWxlY3RTdXBwb3J0OiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0U3VwcG9ydDogZmFsc2VcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNpZ25hdHVyZUhlbHA6IHtcbiAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlSW5mb3JtYXRpb246IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50YXRpb25Gb3JtYXQ6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbWFya2Rvd24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdwbGFpbnRleHQnXG4gICAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlUGFyYW1ldGVyU3VwcG9ydDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBkb2N1bWVudEhpZ2hsaWdodDoge1xuICAgICAgICAgICAgICAgICAgICBkeW5hbWljUmVnaXN0cmF0aW9uOiB0cnVlXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZW1hbnRpY1Rva2Vuczoge1xuICAgICAgICAgICAgICAgICAgICBtdWx0aWxpbmVUb2tlblN1cHBvcnQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBvdmVybGFwcGluZ1Rva2VuU3VwcG9ydDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHRva2VuVHlwZXM6IFtdLFxuICAgICAgICAgICAgICAgICAgICB0b2tlbk1vZGlmaWVyczogW10sXG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdHM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwicmVsYXRpdmVcIlxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0czoge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnVsbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbHRhOiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGF1Z21lbnRzU3ludGF4VG9rZW5zOiB0cnVlXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjb2RlQWN0aW9uOiB7XG4gICAgICAgICAgICAgICAgICAgIGR5bmFtaWNSZWdpc3RyYXRpb246IHRydWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgd29ya3NwYWNlOiB7XG4gICAgICAgICAgICAgICAgZGlkQ2hhbmdlQ29uZmlndXJhdGlvbjoge1xuICAgICAgICAgICAgICAgICAgICBkeW5hbWljUmVnaXN0cmF0aW9uOiB0cnVlXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBleGVjdXRlQ29tbWFuZDoge1xuICAgICAgICAgICAgICAgICAgICBkeW5hbWljUmVnaXN0cmF0aW9uOiB0cnVlXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBhcHBseUVkaXQ6IHRydWUsXG4gICAgICAgICAgICAgICAgd29ya3NwYWNlRWRpdDoge1xuICAgICAgICAgICAgICAgICAgICBmYWlsdXJlSGFuZGxpbmc6IFwiYWJvcnRcIixcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsaXplc0xpbmVFbmRpbmdzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnRDaGFuZ2VzOiBmYWxzZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubW9kZSA9IG1vZGU7XG4gICAgICAgIHRoaXMud29ya3NwYWNlVXJpID0gd29ya3NwYWNlVXJpO1xuICAgIH1cbn1cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNzc3MDpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xuLyogaGFybW9ueSBleHBvcnQgKi8gICByTDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gbWVyZ2VPYmplY3RzKVxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XG4vKiB1bnVzZWQgaGFybW9ueSBleHBvcnRzIG5vdEVtcHR5LCBtZXJnZVJhbmdlcywgY2hlY2tWYWx1ZUFnYWluc3RSZWdleHBBcnJheSwgY29udmVydFRvVXJpICovXG5cbmZ1bmN0aW9uIG1lcmdlT2JqZWN0cyhvYmoxLCBvYmoyLCBleGNsdWRlVW5kZWZpbmVkID0gZmFsc2UpIHtcbiAgICBpZiAoIW9iajEpIHJldHVybiBvYmoyO1xuICAgIGlmICghb2JqMikgcmV0dXJuIG9iajE7XG4gICAgaWYgKGV4Y2x1ZGVVbmRlZmluZWQpIHtcbiAgICAgICAgb2JqMSA9IGV4Y2x1ZGVVbmRlZmluZWRWYWx1ZXMob2JqMSk7XG4gICAgICAgIG9iajIgPSBleGNsdWRlVW5kZWZpbmVkVmFsdWVzKG9iajIpO1xuICAgIH1cbiAgICBjb25zdCBtZXJnZWRPYmplY3RzID0ge1xuICAgICAgICAuLi5vYmoyLFxuICAgICAgICAuLi5vYmoxXG4gICAgfTsgLy8gR2l2ZSBwcmlvcml0eSB0byBvYmoxIHZhbHVlcyBieSBzcHJlYWRpbmcgb2JqMiBmaXJzdCwgdGhlbiBvYmoxXG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMobWVyZ2VkT2JqZWN0cykpe1xuICAgICAgICBpZiAob2JqMVtrZXldICYmIG9iajJba2V5XSkge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqMVtrZXldKSkge1xuICAgICAgICAgICAgICAgIG1lcmdlZE9iamVjdHNba2V5XSA9IG9iajFba2V5XS5jb25jYXQob2JqMltrZXldKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShvYmoyW2tleV0pKSB7XG4gICAgICAgICAgICAgICAgbWVyZ2VkT2JqZWN0c1trZXldID0gb2JqMltrZXldLmNvbmNhdChvYmoxW2tleV0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygb2JqMVtrZXldID09PSAnb2JqZWN0JyAmJiB0eXBlb2Ygb2JqMltrZXldID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIG1lcmdlZE9iamVjdHNba2V5XSA9IG1lcmdlT2JqZWN0cyhvYmoxW2tleV0sIG9iajJba2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1lcmdlZE9iamVjdHM7XG59XG5mdW5jdGlvbiBleGNsdWRlVW5kZWZpbmVkVmFsdWVzKG9iaikge1xuICAgIGNvbnN0IGZpbHRlcmVkRW50cmllcyA9IE9iamVjdC5lbnRyaWVzKG9iaikuZmlsdGVyKChbXywgdmFsdWVdKT0+dmFsdWUgIT09IHVuZGVmaW5lZCk7XG4gICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhmaWx0ZXJlZEVudHJpZXMpO1xufVxuZnVuY3Rpb24gbm90RW1wdHkodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZDtcbn1cbi8vdGFrZW4gd2l0aCBzbWFsbCBjaGFuZ2VzIGZyb20gYWNlLWNvZGVcbmZ1bmN0aW9uIG1lcmdlUmFuZ2VzKHJhbmdlcykge1xuICAgIHZhciBsaXN0ID0gcmFuZ2VzO1xuICAgIGxpc3QgPSBsaXN0LnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgICByZXR1cm4gY29tcGFyZVBvaW50cyhhLnN0YXJ0LCBiLnN0YXJ0KTtcbiAgICB9KTtcbiAgICB2YXIgbmV4dCA9IGxpc3RbMF0sIHJhbmdlO1xuICAgIGZvcih2YXIgaSA9IDE7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKXtcbiAgICAgICAgcmFuZ2UgPSBuZXh0O1xuICAgICAgICBuZXh0ID0gbGlzdFtpXTtcbiAgICAgICAgdmFyIGNtcCA9IGNvbXBhcmVQb2ludHMocmFuZ2UuZW5kLCBuZXh0LnN0YXJ0KTtcbiAgICAgICAgaWYgKGNtcCA8IDApIGNvbnRpbnVlO1xuICAgICAgICBpZiAoY21wID09IDAgJiYgIXJhbmdlLmlzRW1wdHkoKSAmJiAhbmV4dC5pc0VtcHR5KCkpIGNvbnRpbnVlO1xuICAgICAgICBpZiAoY29tcGFyZVBvaW50cyhyYW5nZS5lbmQsIG5leHQuZW5kKSA8IDApIHtcbiAgICAgICAgICAgIHJhbmdlLmVuZC5yb3cgPSBuZXh0LmVuZC5yb3c7XG4gICAgICAgICAgICByYW5nZS5lbmQuY29sdW1uID0gbmV4dC5lbmQuY29sdW1uO1xuICAgICAgICB9XG4gICAgICAgIGxpc3Quc3BsaWNlKGksIDEpO1xuICAgICAgICBuZXh0ID0gcmFuZ2U7XG4gICAgICAgIGktLTtcbiAgICB9XG4gICAgcmV0dXJuIGxpc3Q7XG59XG5mdW5jdGlvbiBjb21wYXJlUG9pbnRzKHAxLCBwMikge1xuICAgIHJldHVybiBwMS5yb3cgLSBwMi5yb3cgfHwgcDEuY29sdW1uIC0gcDIuY29sdW1uO1xufVxuZnVuY3Rpb24gY2hlY2tWYWx1ZUFnYWluc3RSZWdleHBBcnJheSh2YWx1ZSwgcmVnZXhwQXJyYXkpIHtcbiAgICBpZiAoIXJlZ2V4cEFycmF5KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yKGxldCBpID0gMDsgaSA8IHJlZ2V4cEFycmF5Lmxlbmd0aDsgaSsrKXtcbiAgICAgICAgaWYgKHJlZ2V4cEFycmF5W2ldLnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBjb252ZXJ0VG9VcmkoZmlsZVBhdGgpIHtcbiAgICAvL2FscmVhZHkgVVJJXG4gICAgaWYgKGZpbGVQYXRoLnN0YXJ0c1dpdGgoXCJmaWxlOi8vL1wiKSkge1xuICAgICAgICByZXR1cm4gZmlsZVBhdGg7XG4gICAgfVxuICAgIHJldHVybiBVUkkuZmlsZShmaWxlUGF0aCkudG9TdHJpbmcoKTtcbn1cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNTI3Mjpcbi8qKiovICgobW9kdWxlKSA9PiB7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNCdWZmZXIoYXJnKSB7XG4gIHJldHVybiBhcmcgJiYgdHlwZW9mIGFyZyA9PT0gJ29iamVjdCdcbiAgICAmJiB0eXBlb2YgYXJnLmNvcHkgPT09ICdmdW5jdGlvbidcbiAgICAmJiB0eXBlb2YgYXJnLmZpbGwgPT09ICdmdW5jdGlvbidcbiAgICAmJiB0eXBlb2YgYXJnLnJlYWRVSW50OCA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuLyoqKi8gfSksXG5cbi8qKiovIDE1MzE6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuLy8gQ3VycmVudGx5IGluIHN5bmMgd2l0aCBOb2RlLmpzIGxpYi9pbnRlcm5hbC91dGlsL3R5cGVzLmpzXG4vLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvY29tbWl0LzExMmNjN2MyNzU1MTI1NGFhMmIxNzA5OGZiNzc0ODY3ZjA1ZWQwZDlcblxuXG5cbnZhciBpc0FyZ3VtZW50c09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oNTM4Nyk7XG52YXIgaXNHZW5lcmF0b3JGdW5jdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMjYyNSk7XG52YXIgd2hpY2hUeXBlZEFycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNzMwKTtcbnZhciBpc1R5cGVkQXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU5NDMpO1xuXG5mdW5jdGlvbiB1bmN1cnJ5VGhpcyhmKSB7XG4gIHJldHVybiBmLmNhbGwuYmluZChmKTtcbn1cblxudmFyIEJpZ0ludFN1cHBvcnRlZCA9IHR5cGVvZiBCaWdJbnQgIT09ICd1bmRlZmluZWQnO1xudmFyIFN5bWJvbFN1cHBvcnRlZCA9IHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnO1xuXG52YXIgT2JqZWN0VG9TdHJpbmcgPSB1bmN1cnJ5VGhpcyhPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKTtcblxudmFyIG51bWJlclZhbHVlID0gdW5jdXJyeVRoaXMoTnVtYmVyLnByb3RvdHlwZS52YWx1ZU9mKTtcbnZhciBzdHJpbmdWYWx1ZSA9IHVuY3VycnlUaGlzKFN0cmluZy5wcm90b3R5cGUudmFsdWVPZik7XG52YXIgYm9vbGVhblZhbHVlID0gdW5jdXJyeVRoaXMoQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZik7XG5cbmlmIChCaWdJbnRTdXBwb3J0ZWQpIHtcbiAgdmFyIGJpZ0ludFZhbHVlID0gdW5jdXJyeVRoaXMoQmlnSW50LnByb3RvdHlwZS52YWx1ZU9mKTtcbn1cblxuaWYgKFN5bWJvbFN1cHBvcnRlZCkge1xuICB2YXIgc3ltYm9sVmFsdWUgPSB1bmN1cnJ5VGhpcyhTeW1ib2wucHJvdG90eXBlLnZhbHVlT2YpO1xufVxuXG5mdW5jdGlvbiBjaGVja0JveGVkUHJpbWl0aXZlKHZhbHVlLCBwcm90b3R5cGVWYWx1ZU9mKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHRyeSB7XG4gICAgcHJvdG90eXBlVmFsdWVPZih2YWx1ZSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2goZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5leHBvcnRzLmlzQXJndW1lbnRzT2JqZWN0ID0gaXNBcmd1bWVudHNPYmplY3Q7XG5leHBvcnRzLmlzR2VuZXJhdG9yRnVuY3Rpb24gPSBpc0dlbmVyYXRvckZ1bmN0aW9uO1xuZXhwb3J0cy5pc1R5cGVkQXJyYXkgPSBpc1R5cGVkQXJyYXk7XG5cbi8vIFRha2VuIGZyb20gaGVyZSBhbmQgbW9kaWZpZWQgZm9yIGJldHRlciBicm93c2VyIHN1cHBvcnRcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zaW5kcmVzb3JodXMvcC1pcy1wcm9taXNlL2Jsb2IvY2RhMzVhNTEzYmRhMDNmOTc3YWQ1Y2RlM2EwNzlkMjM3ZTgyZDdlZi9pbmRleC5qc1xuZnVuY3Rpb24gaXNQcm9taXNlKGlucHV0KSB7XG5cdHJldHVybiAoXG5cdFx0KFxuXHRcdFx0dHlwZW9mIFByb21pc2UgIT09ICd1bmRlZmluZWQnICYmXG5cdFx0XHRpbnB1dCBpbnN0YW5jZW9mIFByb21pc2Vcblx0XHQpIHx8XG5cdFx0KFxuXHRcdFx0aW5wdXQgIT09IG51bGwgJiZcblx0XHRcdHR5cGVvZiBpbnB1dCA9PT0gJ29iamVjdCcgJiZcblx0XHRcdHR5cGVvZiBpbnB1dC50aGVuID09PSAnZnVuY3Rpb24nICYmXG5cdFx0XHR0eXBlb2YgaW5wdXQuY2F0Y2ggPT09ICdmdW5jdGlvbidcblx0XHQpXG5cdCk7XG59XG5leHBvcnRzLmlzUHJvbWlzZSA9IGlzUHJvbWlzZTtcblxuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlclZpZXcodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgQXJyYXlCdWZmZXIuaXNWaWV3KSB7XG4gICAgcmV0dXJuIEFycmF5QnVmZmVyLmlzVmlldyh2YWx1ZSk7XG4gIH1cblxuICByZXR1cm4gKFxuICAgIGlzVHlwZWRBcnJheSh2YWx1ZSkgfHxcbiAgICBpc0RhdGFWaWV3KHZhbHVlKVxuICApO1xufVxuZXhwb3J0cy5pc0FycmF5QnVmZmVyVmlldyA9IGlzQXJyYXlCdWZmZXJWaWV3O1xuXG5cbmZ1bmN0aW9uIGlzVWludDhBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ1VpbnQ4QXJyYXknO1xufVxuZXhwb3J0cy5pc1VpbnQ4QXJyYXkgPSBpc1VpbnQ4QXJyYXk7XG5cbmZ1bmN0aW9uIGlzVWludDhDbGFtcGVkQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdVaW50OENsYW1wZWRBcnJheSc7XG59XG5leHBvcnRzLmlzVWludDhDbGFtcGVkQXJyYXkgPSBpc1VpbnQ4Q2xhbXBlZEFycmF5O1xuXG5mdW5jdGlvbiBpc1VpbnQxNkFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnVWludDE2QXJyYXknO1xufVxuZXhwb3J0cy5pc1VpbnQxNkFycmF5ID0gaXNVaW50MTZBcnJheTtcblxuZnVuY3Rpb24gaXNVaW50MzJBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ1VpbnQzMkFycmF5Jztcbn1cbmV4cG9ydHMuaXNVaW50MzJBcnJheSA9IGlzVWludDMyQXJyYXk7XG5cbmZ1bmN0aW9uIGlzSW50OEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnSW50OEFycmF5Jztcbn1cbmV4cG9ydHMuaXNJbnQ4QXJyYXkgPSBpc0ludDhBcnJheTtcblxuZnVuY3Rpb24gaXNJbnQxNkFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnSW50MTZBcnJheSc7XG59XG5leHBvcnRzLmlzSW50MTZBcnJheSA9IGlzSW50MTZBcnJheTtcblxuZnVuY3Rpb24gaXNJbnQzMkFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnSW50MzJBcnJheSc7XG59XG5leHBvcnRzLmlzSW50MzJBcnJheSA9IGlzSW50MzJBcnJheTtcblxuZnVuY3Rpb24gaXNGbG9hdDMyQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdGbG9hdDMyQXJyYXknO1xufVxuZXhwb3J0cy5pc0Zsb2F0MzJBcnJheSA9IGlzRmxvYXQzMkFycmF5O1xuXG5mdW5jdGlvbiBpc0Zsb2F0NjRBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ0Zsb2F0NjRBcnJheSc7XG59XG5leHBvcnRzLmlzRmxvYXQ2NEFycmF5ID0gaXNGbG9hdDY0QXJyYXk7XG5cbmZ1bmN0aW9uIGlzQmlnSW50NjRBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ0JpZ0ludDY0QXJyYXknO1xufVxuZXhwb3J0cy5pc0JpZ0ludDY0QXJyYXkgPSBpc0JpZ0ludDY0QXJyYXk7XG5cbmZ1bmN0aW9uIGlzQmlnVWludDY0QXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdCaWdVaW50NjRBcnJheSc7XG59XG5leHBvcnRzLmlzQmlnVWludDY0QXJyYXkgPSBpc0JpZ1VpbnQ2NEFycmF5O1xuXG5mdW5jdGlvbiBpc01hcFRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IE1hcF0nO1xufVxuaXNNYXBUb1N0cmluZy53b3JraW5nID0gKFxuICB0eXBlb2YgTWFwICE9PSAndW5kZWZpbmVkJyAmJlxuICBpc01hcFRvU3RyaW5nKG5ldyBNYXAoKSlcbik7XG5cbmZ1bmN0aW9uIGlzTWFwKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgTWFwID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBpc01hcFRvU3RyaW5nLndvcmtpbmdcbiAgICA/IGlzTWFwVG9TdHJpbmcodmFsdWUpXG4gICAgOiB2YWx1ZSBpbnN0YW5jZW9mIE1hcDtcbn1cbmV4cG9ydHMuaXNNYXAgPSBpc01hcDtcblxuZnVuY3Rpb24gaXNTZXRUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBTZXRdJztcbn1cbmlzU2V0VG9TdHJpbmcud29ya2luZyA9IChcbiAgdHlwZW9mIFNldCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgaXNTZXRUb1N0cmluZyhuZXcgU2V0KCkpXG4pO1xuZnVuY3Rpb24gaXNTZXQodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBTZXQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGlzU2V0VG9TdHJpbmcud29ya2luZ1xuICAgID8gaXNTZXRUb1N0cmluZyh2YWx1ZSlcbiAgICA6IHZhbHVlIGluc3RhbmNlb2YgU2V0O1xufVxuZXhwb3J0cy5pc1NldCA9IGlzU2V0O1xuXG5mdW5jdGlvbiBpc1dlYWtNYXBUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBXZWFrTWFwXSc7XG59XG5pc1dlYWtNYXBUb1N0cmluZy53b3JraW5nID0gKFxuICB0eXBlb2YgV2Vha01hcCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgaXNXZWFrTWFwVG9TdHJpbmcobmV3IFdlYWtNYXAoKSlcbik7XG5mdW5jdGlvbiBpc1dlYWtNYXAodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBXZWFrTWFwID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBpc1dlYWtNYXBUb1N0cmluZy53b3JraW5nXG4gICAgPyBpc1dlYWtNYXBUb1N0cmluZyh2YWx1ZSlcbiAgICA6IHZhbHVlIGluc3RhbmNlb2YgV2Vha01hcDtcbn1cbmV4cG9ydHMuaXNXZWFrTWFwID0gaXNXZWFrTWFwO1xuXG5mdW5jdGlvbiBpc1dlYWtTZXRUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBXZWFrU2V0XSc7XG59XG5pc1dlYWtTZXRUb1N0cmluZy53b3JraW5nID0gKFxuICB0eXBlb2YgV2Vha1NldCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgaXNXZWFrU2V0VG9TdHJpbmcobmV3IFdlYWtTZXQoKSlcbik7XG5mdW5jdGlvbiBpc1dlYWtTZXQodmFsdWUpIHtcbiAgcmV0dXJuIGlzV2Vha1NldFRvU3RyaW5nKHZhbHVlKTtcbn1cbmV4cG9ydHMuaXNXZWFrU2V0ID0gaXNXZWFrU2V0O1xuXG5mdW5jdGlvbiBpc0FycmF5QnVmZmVyVG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJztcbn1cbmlzQXJyYXlCdWZmZXJUb1N0cmluZy53b3JraW5nID0gKFxuICB0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmXG4gIGlzQXJyYXlCdWZmZXJUb1N0cmluZyhuZXcgQXJyYXlCdWZmZXIoKSlcbik7XG5mdW5jdGlvbiBpc0FycmF5QnVmZmVyKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGlzQXJyYXlCdWZmZXJUb1N0cmluZy53b3JraW5nXG4gICAgPyBpc0FycmF5QnVmZmVyVG9TdHJpbmcodmFsdWUpXG4gICAgOiB2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyO1xufVxuZXhwb3J0cy5pc0FycmF5QnVmZmVyID0gaXNBcnJheUJ1ZmZlcjtcblxuZnVuY3Rpb24gaXNEYXRhVmlld1RvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IERhdGFWaWV3XSc7XG59XG5pc0RhdGFWaWV3VG9TdHJpbmcud29ya2luZyA9IChcbiAgdHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJlxuICB0eXBlb2YgRGF0YVZpZXcgIT09ICd1bmRlZmluZWQnICYmXG4gIGlzRGF0YVZpZXdUb1N0cmluZyhuZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKDEpLCAwLCAxKSlcbik7XG5mdW5jdGlvbiBpc0RhdGFWaWV3KHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgRGF0YVZpZXcgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGlzRGF0YVZpZXdUb1N0cmluZy53b3JraW5nXG4gICAgPyBpc0RhdGFWaWV3VG9TdHJpbmcodmFsdWUpXG4gICAgOiB2YWx1ZSBpbnN0YW5jZW9mIERhdGFWaWV3O1xufVxuZXhwb3J0cy5pc0RhdGFWaWV3ID0gaXNEYXRhVmlldztcblxuLy8gU3RvcmUgYSBjb3B5IG9mIFNoYXJlZEFycmF5QnVmZmVyIGluIGNhc2UgaXQncyBkZWxldGVkIGVsc2V3aGVyZVxudmFyIFNoYXJlZEFycmF5QnVmZmVyQ29weSA9IHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgPyBTaGFyZWRBcnJheUJ1ZmZlciA6IHVuZGVmaW5lZDtcbmZ1bmN0aW9uIGlzU2hhcmVkQXJyYXlCdWZmZXJUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBTaGFyZWRBcnJheUJ1ZmZlcl0nO1xufVxuZnVuY3Rpb24gaXNTaGFyZWRBcnJheUJ1ZmZlcih2YWx1ZSkge1xuICBpZiAodHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyQ29weSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAodHlwZW9mIGlzU2hhcmVkQXJyYXlCdWZmZXJUb1N0cmluZy53b3JraW5nID09PSAndW5kZWZpbmVkJykge1xuICAgIGlzU2hhcmVkQXJyYXlCdWZmZXJUb1N0cmluZy53b3JraW5nID0gaXNTaGFyZWRBcnJheUJ1ZmZlclRvU3RyaW5nKG5ldyBTaGFyZWRBcnJheUJ1ZmZlckNvcHkoKSk7XG4gIH1cblxuICByZXR1cm4gaXNTaGFyZWRBcnJheUJ1ZmZlclRvU3RyaW5nLndvcmtpbmdcbiAgICA/IGlzU2hhcmVkQXJyYXlCdWZmZXJUb1N0cmluZyh2YWx1ZSlcbiAgICA6IHZhbHVlIGluc3RhbmNlb2YgU2hhcmVkQXJyYXlCdWZmZXJDb3B5O1xufVxuZXhwb3J0cy5pc1NoYXJlZEFycmF5QnVmZmVyID0gaXNTaGFyZWRBcnJheUJ1ZmZlcjtcblxuZnVuY3Rpb24gaXNBc3luY0Z1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IEFzeW5jRnVuY3Rpb25dJztcbn1cbmV4cG9ydHMuaXNBc3luY0Z1bmN0aW9uID0gaXNBc3luY0Z1bmN0aW9uO1xuXG5mdW5jdGlvbiBpc01hcEl0ZXJhdG9yKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IE1hcCBJdGVyYXRvcl0nO1xufVxuZXhwb3J0cy5pc01hcEl0ZXJhdG9yID0gaXNNYXBJdGVyYXRvcjtcblxuZnVuY3Rpb24gaXNTZXRJdGVyYXRvcih2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBTZXQgSXRlcmF0b3JdJztcbn1cbmV4cG9ydHMuaXNTZXRJdGVyYXRvciA9IGlzU2V0SXRlcmF0b3I7XG5cbmZ1bmN0aW9uIGlzR2VuZXJhdG9yT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IEdlbmVyYXRvcl0nO1xufVxuZXhwb3J0cy5pc0dlbmVyYXRvck9iamVjdCA9IGlzR2VuZXJhdG9yT2JqZWN0O1xuXG5mdW5jdGlvbiBpc1dlYkFzc2VtYmx5Q29tcGlsZWRNb2R1bGUodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgV2ViQXNzZW1ibHkuTW9kdWxlXSc7XG59XG5leHBvcnRzLmlzV2ViQXNzZW1ibHlDb21waWxlZE1vZHVsZSA9IGlzV2ViQXNzZW1ibHlDb21waWxlZE1vZHVsZTtcblxuZnVuY3Rpb24gaXNOdW1iZXJPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIGNoZWNrQm94ZWRQcmltaXRpdmUodmFsdWUsIG51bWJlclZhbHVlKTtcbn1cbmV4cG9ydHMuaXNOdW1iZXJPYmplY3QgPSBpc051bWJlck9iamVjdDtcblxuZnVuY3Rpb24gaXNTdHJpbmdPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIGNoZWNrQm94ZWRQcmltaXRpdmUodmFsdWUsIHN0cmluZ1ZhbHVlKTtcbn1cbmV4cG9ydHMuaXNTdHJpbmdPYmplY3QgPSBpc1N0cmluZ09iamVjdDtcblxuZnVuY3Rpb24gaXNCb29sZWFuT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBjaGVja0JveGVkUHJpbWl0aXZlKHZhbHVlLCBib29sZWFuVmFsdWUpO1xufVxuZXhwb3J0cy5pc0Jvb2xlYW5PYmplY3QgPSBpc0Jvb2xlYW5PYmplY3Q7XG5cbmZ1bmN0aW9uIGlzQmlnSW50T2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBCaWdJbnRTdXBwb3J0ZWQgJiYgY2hlY2tCb3hlZFByaW1pdGl2ZSh2YWx1ZSwgYmlnSW50VmFsdWUpO1xufVxuZXhwb3J0cy5pc0JpZ0ludE9iamVjdCA9IGlzQmlnSW50T2JqZWN0O1xuXG5mdW5jdGlvbiBpc1N5bWJvbE9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gU3ltYm9sU3VwcG9ydGVkICYmIGNoZWNrQm94ZWRQcmltaXRpdmUodmFsdWUsIHN5bWJvbFZhbHVlKTtcbn1cbmV4cG9ydHMuaXNTeW1ib2xPYmplY3QgPSBpc1N5bWJvbE9iamVjdDtcblxuZnVuY3Rpb24gaXNCb3hlZFByaW1pdGl2ZSh2YWx1ZSkge1xuICByZXR1cm4gKFxuICAgIGlzTnVtYmVyT2JqZWN0KHZhbHVlKSB8fFxuICAgIGlzU3RyaW5nT2JqZWN0KHZhbHVlKSB8fFxuICAgIGlzQm9vbGVhbk9iamVjdCh2YWx1ZSkgfHxcbiAgICBpc0JpZ0ludE9iamVjdCh2YWx1ZSkgfHxcbiAgICBpc1N5bWJvbE9iamVjdCh2YWx1ZSlcbiAgKTtcbn1cbmV4cG9ydHMuaXNCb3hlZFByaW1pdGl2ZSA9IGlzQm94ZWRQcmltaXRpdmU7XG5cbmZ1bmN0aW9uIGlzQW55QXJyYXlCdWZmZXIodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyAmJiAoXG4gICAgaXNBcnJheUJ1ZmZlcih2YWx1ZSkgfHxcbiAgICBpc1NoYXJlZEFycmF5QnVmZmVyKHZhbHVlKVxuICApO1xufVxuZXhwb3J0cy5pc0FueUFycmF5QnVmZmVyID0gaXNBbnlBcnJheUJ1ZmZlcjtcblxuWydpc1Byb3h5JywgJ2lzRXh0ZXJuYWwnLCAnaXNNb2R1bGVOYW1lc3BhY2VPYmplY3QnXS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbWV0aG9kLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKG1ldGhvZCArICcgaXMgbm90IHN1cHBvcnRlZCBpbiB1c2VybGFuZCcpO1xuICAgIH1cbiAgfSk7XG59KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNjgyNzpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuLyogcHJvdmlkZWQgZGVwZW5kZW5jeSAqLyB2YXIgcHJvY2VzcyA9IF9fd2VicGFja19yZXF1aXJlX18oOTkwNyk7XG4vKiBwcm92aWRlZCBkZXBlbmRlbmN5ICovIHZhciBjb25zb2xlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MzY0KTtcbi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIHx8XG4gIGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMob2JqKSB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICAgIHZhciBkZXNjcmlwdG9ycyA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgZGVzY3JpcHRvcnNba2V5c1tpXV0gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5c1tpXSk7XG4gICAgfVxuICAgIHJldHVybiBkZXNjcmlwdG9ycztcbiAgfTtcblxudmFyIGZvcm1hdFJlZ0V4cCA9IC8lW3NkaiVdL2c7XG5leHBvcnRzLmZvcm1hdCA9IGZ1bmN0aW9uKGYpIHtcbiAgaWYgKCFpc1N0cmluZyhmKSkge1xuICAgIHZhciBvYmplY3RzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG9iamVjdHMucHVzaChpbnNwZWN0KGFyZ3VtZW50c1tpXSkpO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0cy5qb2luKCcgJyk7XG4gIH1cblxuICB2YXIgaSA9IDE7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICB2YXIgbGVuID0gYXJncy5sZW5ndGg7XG4gIHZhciBzdHIgPSBTdHJpbmcoZikucmVwbGFjZShmb3JtYXRSZWdFeHAsIGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoeCA9PT0gJyUlJykgcmV0dXJuICclJztcbiAgICBpZiAoaSA+PSBsZW4pIHJldHVybiB4O1xuICAgIHN3aXRjaCAoeCkge1xuICAgICAgY2FzZSAnJXMnOiByZXR1cm4gU3RyaW5nKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclZCc6IHJldHVybiBOdW1iZXIoYXJnc1tpKytdKTtcbiAgICAgIGNhc2UgJyVqJzpcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYXJnc1tpKytdKTtcbiAgICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICAgIHJldHVybiAnW0NpcmN1bGFyXSc7XG4gICAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB4O1xuICAgIH1cbiAgfSk7XG4gIGZvciAodmFyIHggPSBhcmdzW2ldOyBpIDwgbGVuOyB4ID0gYXJnc1srK2ldKSB7XG4gICAgaWYgKGlzTnVsbCh4KSB8fCAhaXNPYmplY3QoeCkpIHtcbiAgICAgIHN0ciArPSAnICcgKyB4O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgKz0gJyAnICsgaW5zcGVjdCh4KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn07XG5cblxuLy8gTWFyayB0aGF0IGEgbWV0aG9kIHNob3VsZCBub3QgYmUgdXNlZC5cbi8vIFJldHVybnMgYSBtb2RpZmllZCBmdW5jdGlvbiB3aGljaCB3YXJucyBvbmNlIGJ5IGRlZmF1bHQuXG4vLyBJZiAtLW5vLWRlcHJlY2F0aW9uIGlzIHNldCwgdGhlbiBpdCBpcyBhIG5vLW9wLlxuZXhwb3J0cy5kZXByZWNhdGUgPSBmdW5jdGlvbihmbiwgbXNnKSB7XG4gIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy5ub0RlcHJlY2F0aW9uID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgLy8gQWxsb3cgZm9yIGRlcHJlY2F0aW5nIHRoaW5ncyBpbiB0aGUgcHJvY2VzcyBvZiBzdGFydGluZyB1cC5cbiAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBleHBvcnRzLmRlcHJlY2F0ZShmbiwgbXNnKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH1cblxuICB2YXIgd2FybmVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGRlcHJlY2F0ZWQoKSB7XG4gICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgIGlmIChwcm9jZXNzLnRocm93RGVwcmVjYXRpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICB9IGVsc2UgaWYgKHByb2Nlc3MudHJhY2VEZXByZWNhdGlvbikge1xuICAgICAgICBjb25zb2xlLnRyYWNlKG1zZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKG1zZyk7XG4gICAgICB9XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHJldHVybiBkZXByZWNhdGVkO1xufTtcblxuXG52YXIgZGVidWdzID0ge307XG52YXIgZGVidWdFbnZSZWdleCA9IC9eJC87XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0RFQlVHKSB7XG4gIHZhciBkZWJ1Z0VudiA9IHByb2Nlc3MuZW52Lk5PREVfREVCVUc7XG4gIGRlYnVnRW52ID0gZGVidWdFbnYucmVwbGFjZSgvW3xcXFxce30oKVtcXF1eJCs/Ll0vZywgJ1xcXFwkJicpXG4gICAgLnJlcGxhY2UoL1xcKi9nLCAnLionKVxuICAgIC5yZXBsYWNlKC8sL2csICckfF4nKVxuICAgIC50b1VwcGVyQ2FzZSgpO1xuICBkZWJ1Z0VudlJlZ2V4ID0gbmV3IFJlZ0V4cCgnXicgKyBkZWJ1Z0VudiArICckJywgJ2knKTtcbn1cbmV4cG9ydHMuZGVidWdsb2cgPSBmdW5jdGlvbihzZXQpIHtcbiAgc2V0ID0gc2V0LnRvVXBwZXJDYXNlKCk7XG4gIGlmICghZGVidWdzW3NldF0pIHtcbiAgICBpZiAoZGVidWdFbnZSZWdleC50ZXN0KHNldCkpIHtcbiAgICAgIHZhciBwaWQgPSBwcm9jZXNzLnBpZDtcbiAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBtc2cgPSBleHBvcnRzLmZvcm1hdC5hcHBseShleHBvcnRzLCBhcmd1bWVudHMpO1xuICAgICAgICBjb25zb2xlLmVycm9yKCclcyAlZDogJXMnLCBzZXQsIHBpZCwgbXNnKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7fTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRlYnVnc1tzZXRdO1xufTtcblxuXG4vKipcbiAqIEVjaG9zIHRoZSB2YWx1ZSBvZiBhIHZhbHVlLiBUcnlzIHRvIHByaW50IHRoZSB2YWx1ZSBvdXRcbiAqIGluIHRoZSBiZXN0IHdheSBwb3NzaWJsZSBnaXZlbiB0aGUgZGlmZmVyZW50IHR5cGVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBwcmludCBvdXQuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyBPcHRpb25hbCBvcHRpb25zIG9iamVjdCB0aGF0IGFsdGVycyB0aGUgb3V0cHV0LlxuICovXG4vKiBsZWdhY3k6IG9iaiwgc2hvd0hpZGRlbiwgZGVwdGgsIGNvbG9ycyovXG5mdW5jdGlvbiBpbnNwZWN0KG9iaiwgb3B0cykge1xuICAvLyBkZWZhdWx0IG9wdGlvbnNcbiAgdmFyIGN0eCA9IHtcbiAgICBzZWVuOiBbXSxcbiAgICBzdHlsaXplOiBzdHlsaXplTm9Db2xvclxuICB9O1xuICAvLyBsZWdhY3kuLi5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMykgY3R4LmRlcHRoID0gYXJndW1lbnRzWzJdO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSA0KSBjdHguY29sb3JzID0gYXJndW1lbnRzWzNdO1xuICBpZiAoaXNCb29sZWFuKG9wdHMpKSB7XG4gICAgLy8gbGVnYWN5Li4uXG4gICAgY3R4LnNob3dIaWRkZW4gPSBvcHRzO1xuICB9IGVsc2UgaWYgKG9wdHMpIHtcbiAgICAvLyBnb3QgYW4gXCJvcHRpb25zXCIgb2JqZWN0XG4gICAgZXhwb3J0cy5fZXh0ZW5kKGN0eCwgb3B0cyk7XG4gIH1cbiAgLy8gc2V0IGRlZmF1bHQgb3B0aW9uc1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LnNob3dIaWRkZW4pKSBjdHguc2hvd0hpZGRlbiA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmRlcHRoKSkgY3R4LmRlcHRoID0gMjtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jb2xvcnMpKSBjdHguY29sb3JzID0gZmFsc2U7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY3VzdG9tSW5zcGVjdCkpIGN0eC5jdXN0b21JbnNwZWN0ID0gdHJ1ZTtcbiAgaWYgKGN0eC5jb2xvcnMpIGN0eC5zdHlsaXplID0gc3R5bGl6ZVdpdGhDb2xvcjtcbiAgcmV0dXJuIGZvcm1hdFZhbHVlKGN0eCwgb2JqLCBjdHguZGVwdGgpO1xufVxuZXhwb3J0cy5pbnNwZWN0ID0gaW5zcGVjdDtcblxuXG4vLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0FOU0lfZXNjYXBlX2NvZGUjZ3JhcGhpY3Ncbmluc3BlY3QuY29sb3JzID0ge1xuICAnYm9sZCcgOiBbMSwgMjJdLFxuICAnaXRhbGljJyA6IFszLCAyM10sXG4gICd1bmRlcmxpbmUnIDogWzQsIDI0XSxcbiAgJ2ludmVyc2UnIDogWzcsIDI3XSxcbiAgJ3doaXRlJyA6IFszNywgMzldLFxuICAnZ3JleScgOiBbOTAsIDM5XSxcbiAgJ2JsYWNrJyA6IFszMCwgMzldLFxuICAnYmx1ZScgOiBbMzQsIDM5XSxcbiAgJ2N5YW4nIDogWzM2LCAzOV0sXG4gICdncmVlbicgOiBbMzIsIDM5XSxcbiAgJ21hZ2VudGEnIDogWzM1LCAzOV0sXG4gICdyZWQnIDogWzMxLCAzOV0sXG4gICd5ZWxsb3cnIDogWzMzLCAzOV1cbn07XG5cbi8vIERvbid0IHVzZSAnYmx1ZScgbm90IHZpc2libGUgb24gY21kLmV4ZVxuaW5zcGVjdC5zdHlsZXMgPSB7XG4gICdzcGVjaWFsJzogJ2N5YW4nLFxuICAnbnVtYmVyJzogJ3llbGxvdycsXG4gICdib29sZWFuJzogJ3llbGxvdycsXG4gICd1bmRlZmluZWQnOiAnZ3JleScsXG4gICdudWxsJzogJ2JvbGQnLFxuICAnc3RyaW5nJzogJ2dyZWVuJyxcbiAgJ2RhdGUnOiAnbWFnZW50YScsXG4gIC8vIFwibmFtZVwiOiBpbnRlbnRpb25hbGx5IG5vdCBzdHlsaW5nXG4gICdyZWdleHAnOiAncmVkJ1xufTtcblxuXG5mdW5jdGlvbiBzdHlsaXplV2l0aENvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gIHZhciBzdHlsZSA9IGluc3BlY3Quc3R5bGVzW3N0eWxlVHlwZV07XG5cbiAgaWYgKHN0eWxlKSB7XG4gICAgcmV0dXJuICdcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMF0gKyAnbScgKyBzdHIgK1xuICAgICAgICAgICAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzFdICsgJ20nO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzdHI7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBzdHlsaXplTm9Db2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICByZXR1cm4gc3RyO1xufVxuXG5cbmZ1bmN0aW9uIGFycmF5VG9IYXNoKGFycmF5KSB7XG4gIHZhciBoYXNoID0ge307XG5cbiAgYXJyYXkuZm9yRWFjaChmdW5jdGlvbih2YWwsIGlkeCkge1xuICAgIGhhc2hbdmFsXSA9IHRydWU7XG4gIH0pO1xuXG4gIHJldHVybiBoYXNoO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFZhbHVlKGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcykge1xuICAvLyBQcm92aWRlIGEgaG9vayBmb3IgdXNlci1zcGVjaWZpZWQgaW5zcGVjdCBmdW5jdGlvbnMuXG4gIC8vIENoZWNrIHRoYXQgdmFsdWUgaXMgYW4gb2JqZWN0IHdpdGggYW4gaW5zcGVjdCBmdW5jdGlvbiBvbiBpdFxuICBpZiAoY3R4LmN1c3RvbUluc3BlY3QgJiZcbiAgICAgIHZhbHVlICYmXG4gICAgICBpc0Z1bmN0aW9uKHZhbHVlLmluc3BlY3QpICYmXG4gICAgICAvLyBGaWx0ZXIgb3V0IHRoZSB1dGlsIG1vZHVsZSwgaXQncyBpbnNwZWN0IGZ1bmN0aW9uIGlzIHNwZWNpYWxcbiAgICAgIHZhbHVlLmluc3BlY3QgIT09IGV4cG9ydHMuaW5zcGVjdCAmJlxuICAgICAgLy8gQWxzbyBmaWx0ZXIgb3V0IGFueSBwcm90b3R5cGUgb2JqZWN0cyB1c2luZyB0aGUgY2lyY3VsYXIgY2hlY2suXG4gICAgICAhKHZhbHVlLmNvbnN0cnVjdG9yICYmIHZhbHVlLmNvbnN0cnVjdG9yLnByb3RvdHlwZSA9PT0gdmFsdWUpKSB7XG4gICAgdmFyIHJldCA9IHZhbHVlLmluc3BlY3QocmVjdXJzZVRpbWVzLCBjdHgpO1xuICAgIGlmICghaXNTdHJpbmcocmV0KSkge1xuICAgICAgcmV0ID0gZm9ybWF0VmFsdWUoY3R4LCByZXQsIHJlY3Vyc2VUaW1lcyk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICAvLyBQcmltaXRpdmUgdHlwZXMgY2Fubm90IGhhdmUgcHJvcGVydGllc1xuICB2YXIgcHJpbWl0aXZlID0gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpO1xuICBpZiAocHJpbWl0aXZlKSB7XG4gICAgcmV0dXJuIHByaW1pdGl2ZTtcbiAgfVxuXG4gIC8vIExvb2sgdXAgdGhlIGtleXMgb2YgdGhlIG9iamVjdC5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSk7XG4gIHZhciB2aXNpYmxlS2V5cyA9IGFycmF5VG9IYXNoKGtleXMpO1xuXG4gIGlmIChjdHguc2hvd0hpZGRlbikge1xuICAgIGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh2YWx1ZSk7XG4gIH1cblxuICAvLyBJRSBkb2Vzbid0IG1ha2UgZXJyb3IgZmllbGRzIG5vbi1lbnVtZXJhYmxlXG4gIC8vIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9pZS9kd3c1MnNidCh2PXZzLjk0KS5hc3B4XG4gIGlmIChpc0Vycm9yKHZhbHVlKVxuICAgICAgJiYgKGtleXMuaW5kZXhPZignbWVzc2FnZScpID49IDAgfHwga2V5cy5pbmRleE9mKCdkZXNjcmlwdGlvbicpID49IDApKSB7XG4gICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIC8vIFNvbWUgdHlwZSBvZiBvYmplY3Qgd2l0aG91dCBwcm9wZXJ0aWVzIGNhbiBiZSBzaG9ydGN1dHRlZC5cbiAgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICB2YXIgbmFtZSA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbRnVuY3Rpb24nICsgbmFtZSArICddJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9XG4gICAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ2RhdGUnKTtcbiAgICB9XG4gICAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBiYXNlID0gJycsIGFycmF5ID0gZmFsc2UsIGJyYWNlcyA9IFsneycsICd9J107XG5cbiAgLy8gTWFrZSBBcnJheSBzYXkgdGhhdCB0aGV5IGFyZSBBcnJheVxuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBhcnJheSA9IHRydWU7XG4gICAgYnJhY2VzID0gWydbJywgJ10nXTtcbiAgfVxuXG4gIC8vIE1ha2UgZnVuY3Rpb25zIHNheSB0aGF0IHRoZXkgYXJlIGZ1bmN0aW9uc1xuICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICB2YXIgbiA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuICAgIGJhc2UgPSAnIFtGdW5jdGlvbicgKyBuICsgJ10nO1xuICB9XG5cbiAgLy8gTWFrZSBSZWdFeHBzIHNheSB0aGF0IHRoZXkgYXJlIFJlZ0V4cHNcbiAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgLy8gTWFrZSBkYXRlcyB3aXRoIHByb3BlcnRpZXMgZmlyc3Qgc2F5IHRoZSBkYXRlXG4gIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIERhdGUucHJvdG90eXBlLnRvVVRDU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgLy8gTWFrZSBlcnJvciB3aXRoIG1lc3NhZ2UgZmlyc3Qgc2F5IHRoZSBlcnJvclxuICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgaWYgKGtleXMubGVuZ3RoID09PSAwICYmICghYXJyYXkgfHwgdmFsdWUubGVuZ3RoID09IDApKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyBicmFjZXNbMV07XG4gIH1cblxuICBpZiAocmVjdXJzZVRpbWVzIDwgMCkge1xuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW09iamVjdF0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuXG4gIGN0eC5zZWVuLnB1c2godmFsdWUpO1xuXG4gIHZhciBvdXRwdXQ7XG4gIGlmIChhcnJheSkge1xuICAgIG91dHB1dCA9IGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpO1xuICB9IGVsc2Uge1xuICAgIG91dHB1dCA9IGtleXMubWFwKGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpO1xuICAgIH0pO1xuICB9XG5cbiAgY3R4LnNlZW4ucG9wKCk7XG5cbiAgcmV0dXJuIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKTtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSkge1xuICBpZiAoaXNVbmRlZmluZWQodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgndW5kZWZpbmVkJywgJ3VuZGVmaW5lZCcpO1xuICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgdmFyIHNpbXBsZSA9ICdcXCcnICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpLnJlcGxhY2UoL15cInxcIiQvZywgJycpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpICsgJ1xcJyc7XG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKHNpbXBsZSwgJ3N0cmluZycpO1xuICB9XG4gIGlmIChpc051bWJlcih2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdudW1iZXInKTtcbiAgaWYgKGlzQm9vbGVhbih2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdib29sZWFuJyk7XG4gIC8vIEZvciBzb21lIHJlYXNvbiB0eXBlb2YgbnVsbCBpcyBcIm9iamVjdFwiLCBzbyBzcGVjaWFsIGNhc2UgaGVyZS5cbiAgaWYgKGlzTnVsbCh2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCdudWxsJywgJ251bGwnKTtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRFcnJvcih2YWx1ZSkge1xuICByZXR1cm4gJ1snICsgRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpICsgJ10nO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpIHtcbiAgdmFyIG91dHB1dCA9IFtdO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eSh2YWx1ZSwgU3RyaW5nKGkpKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBTdHJpbmcoaSksIHRydWUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0cHV0LnB1c2goJycpO1xuICAgIH1cbiAgfVxuICBrZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgaWYgKCFrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIGtleSwgdHJ1ZSkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSkge1xuICB2YXIgbmFtZSwgc3RyLCBkZXNjO1xuICBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih2YWx1ZSwga2V5KSB8fCB7IHZhbHVlOiB2YWx1ZVtrZXldIH07XG4gIGlmIChkZXNjLmdldCkge1xuICAgIGlmIChkZXNjLnNldCkge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXIvU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChkZXNjLnNldCkge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tTZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFoYXNPd25Qcm9wZXJ0eSh2aXNpYmxlS2V5cywga2V5KSkge1xuICAgIG5hbWUgPSAnWycgKyBrZXkgKyAnXSc7XG4gIH1cbiAgaWYgKCFzdHIpIHtcbiAgICBpZiAoY3R4LnNlZW4uaW5kZXhPZihkZXNjLnZhbHVlKSA8IDApIHtcbiAgICAgIGlmIChpc051bGwocmVjdXJzZVRpbWVzKSkge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIG51bGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCByZWN1cnNlVGltZXMgLSAxKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHIuaW5kZXhPZignXFxuJykgPiAtMSkge1xuICAgICAgICBpZiAoYXJyYXkpIHtcbiAgICAgICAgICBzdHIgPSBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJykuc2xpY2UoMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyID0gJ1xcbicgKyBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbQ2lyY3VsYXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzVW5kZWZpbmVkKG5hbWUpKSB7XG4gICAgaWYgKGFycmF5ICYmIGtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIG5hbWUgPSBKU09OLnN0cmluZ2lmeSgnJyArIGtleSk7XG4gICAgaWYgKG5hbWUubWF0Y2goL15cIihbYS16QS1aX11bYS16QS1aXzAtOV0qKVwiJC8pKSB7XG4gICAgICBuYW1lID0gbmFtZS5zbGljZSgxLCAtMSk7XG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ25hbWUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJylcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLyheXCJ8XCIkKS9nLCBcIidcIik7XG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ3N0cmluZycpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuYW1lICsgJzogJyArIHN0cjtcbn1cblxuXG5mdW5jdGlvbiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcykge1xuICB2YXIgbnVtTGluZXNFc3QgPSAwO1xuICB2YXIgbGVuZ3RoID0gb3V0cHV0LnJlZHVjZShmdW5jdGlvbihwcmV2LCBjdXIpIHtcbiAgICBudW1MaW5lc0VzdCsrO1xuICAgIGlmIChjdXIuaW5kZXhPZignXFxuJykgPj0gMCkgbnVtTGluZXNFc3QrKztcbiAgICByZXR1cm4gcHJldiArIGN1ci5yZXBsYWNlKC9cXHUwMDFiXFxbXFxkXFxkP20vZywgJycpLmxlbmd0aCArIDE7XG4gIH0sIDApO1xuXG4gIGlmIChsZW5ndGggPiA2MCkge1xuICAgIHJldHVybiBicmFjZXNbMF0gK1xuICAgICAgICAgICAoYmFzZSA9PT0gJycgPyAnJyA6IGJhc2UgKyAnXFxuICcpICtcbiAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgb3V0cHV0LmpvaW4oJyxcXG4gICcpICtcbiAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgYnJhY2VzWzFdO1xuICB9XG5cbiAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyAnICcgKyBvdXRwdXQuam9pbignLCAnKSArICcgJyArIGJyYWNlc1sxXTtcbn1cblxuXG4vLyBOT1RFOiBUaGVzZSB0eXBlIGNoZWNraW5nIGZ1bmN0aW9ucyBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBgaW5zdGFuY2VvZmBcbi8vIGJlY2F1c2UgaXQgaXMgZnJhZ2lsZSBhbmQgY2FuIGJlIGVhc2lseSBmYWtlZCB3aXRoIGBPYmplY3QuY3JlYXRlKClgLlxuZXhwb3J0cy50eXBlcyA9IF9fd2VicGFja19yZXF1aXJlX18oMTUzMSk7XG5cbmZ1bmN0aW9uIGlzQXJyYXkoYXIpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXIpO1xufVxuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcblxuZnVuY3Rpb24gaXNCb29sZWFuKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nO1xufVxuZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG5cbmZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsID0gaXNOdWxsO1xuXG5mdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGlzTnVsbE9yVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xuXG5mdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xufVxuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuXG5mdW5jdGlvbiBpc1N5bWJvbChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnO1xufVxuZXhwb3J0cy5pc1N5bWJvbCA9IGlzU3ltYm9sO1xuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuZXhwb3J0cy5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xuICByZXR1cm4gaXNPYmplY3QocmUpICYmIG9iamVjdFRvU3RyaW5nKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5leHBvcnRzLmlzUmVnRXhwID0gaXNSZWdFeHA7XG5leHBvcnRzLnR5cGVzLmlzUmVnRXhwID0gaXNSZWdFeHA7XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0RhdGUoZCkge1xuICByZXR1cm4gaXNPYmplY3QoZCkgJiYgb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cbmV4cG9ydHMuaXNEYXRlID0gaXNEYXRlO1xuZXhwb3J0cy50eXBlcy5pc0RhdGUgPSBpc0RhdGU7XG5cbmZ1bmN0aW9uIGlzRXJyb3IoZSkge1xuICByZXR1cm4gaXNPYmplY3QoZSkgJiZcbiAgICAgIChvYmplY3RUb1N0cmluZyhlKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyB8fCBlIGluc3RhbmNlb2YgRXJyb3IpO1xufVxuZXhwb3J0cy5pc0Vycm9yID0gaXNFcnJvcjtcbmV4cG9ydHMudHlwZXMuaXNOYXRpdmVFcnJvciA9IGlzRXJyb3I7XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcblxuZnVuY3Rpb24gaXNQcmltaXRpdmUoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGwgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3ltYm9sJyB8fCAgLy8gRVM2IHN5bWJvbFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCc7XG59XG5leHBvcnRzLmlzUHJpbWl0aXZlID0gaXNQcmltaXRpdmU7XG5cbmV4cG9ydHMuaXNCdWZmZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUyNzIpO1xuXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyhvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XG59XG5cblxuZnVuY3Rpb24gcGFkKG4pIHtcbiAgcmV0dXJuIG4gPCAxMCA/ICcwJyArIG4udG9TdHJpbmcoMTApIDogbi50b1N0cmluZygxMCk7XG59XG5cblxudmFyIG1vbnRocyA9IFsnSmFuJywgJ0ZlYicsICdNYXInLCAnQXByJywgJ01heScsICdKdW4nLCAnSnVsJywgJ0F1ZycsICdTZXAnLFxuICAgICAgICAgICAgICAnT2N0JywgJ05vdicsICdEZWMnXTtcblxuLy8gMjYgRmViIDE2OjE5OjM0XG5mdW5jdGlvbiB0aW1lc3RhbXAoKSB7XG4gIHZhciBkID0gbmV3IERhdGUoKTtcbiAgdmFyIHRpbWUgPSBbcGFkKGQuZ2V0SG91cnMoKSksXG4gICAgICAgICAgICAgIHBhZChkLmdldE1pbnV0ZXMoKSksXG4gICAgICAgICAgICAgIHBhZChkLmdldFNlY29uZHMoKSldLmpvaW4oJzonKTtcbiAgcmV0dXJuIFtkLmdldERhdGUoKSwgbW9udGhzW2QuZ2V0TW9udGgoKV0sIHRpbWVdLmpvaW4oJyAnKTtcbn1cblxuXG4vLyBsb2cgaXMganVzdCBhIHRoaW4gd3JhcHBlciB0byBjb25zb2xlLmxvZyB0aGF0IHByZXBlbmRzIGEgdGltZXN0YW1wXG5leHBvcnRzLmxvZyA9IGZ1bmN0aW9uKCkge1xuICBjb25zb2xlLmxvZygnJXMgLSAlcycsIHRpbWVzdGFtcCgpLCBleHBvcnRzLmZvcm1hdC5hcHBseShleHBvcnRzLCBhcmd1bWVudHMpKTtcbn07XG5cblxuLyoqXG4gKiBJbmhlcml0IHRoZSBwcm90b3R5cGUgbWV0aG9kcyBmcm9tIG9uZSBjb25zdHJ1Y3RvciBpbnRvIGFub3RoZXIuXG4gKlxuICogVGhlIEZ1bmN0aW9uLnByb3RvdHlwZS5pbmhlcml0cyBmcm9tIGxhbmcuanMgcmV3cml0dGVuIGFzIGEgc3RhbmRhbG9uZVxuICogZnVuY3Rpb24gKG5vdCBvbiBGdW5jdGlvbi5wcm90b3R5cGUpLiBOT1RFOiBJZiB0aGlzIGZpbGUgaXMgdG8gYmUgbG9hZGVkXG4gKiBkdXJpbmcgYm9vdHN0cmFwcGluZyB0aGlzIGZ1bmN0aW9uIG5lZWRzIHRvIGJlIHJld3JpdHRlbiB1c2luZyBzb21lIG5hdGl2ZVxuICogZnVuY3Rpb25zIGFzIHByb3RvdHlwZSBzZXR1cCB1c2luZyBub3JtYWwgSmF2YVNjcmlwdCBkb2VzIG5vdCB3b3JrIGFzXG4gKiBleHBlY3RlZCBkdXJpbmcgYm9vdHN0cmFwcGluZyAoc2VlIG1pcnJvci5qcyBpbiByMTE0OTAzKS5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHdoaWNoIG5lZWRzIHRvIGluaGVyaXQgdGhlXG4gKiAgICAgcHJvdG90eXBlLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gc3VwZXJDdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHRvIGluaGVyaXQgcHJvdG90eXBlIGZyb20uXG4gKi9cbmV4cG9ydHMuaW5oZXJpdHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU2MTUpO1xuXG5leHBvcnRzLl9leHRlbmQgPSBmdW5jdGlvbihvcmlnaW4sIGFkZCkge1xuICAvLyBEb24ndCBkbyBhbnl0aGluZyBpZiBhZGQgaXNuJ3QgYW4gb2JqZWN0XG4gIGlmICghYWRkIHx8ICFpc09iamVjdChhZGQpKSByZXR1cm4gb3JpZ2luO1xuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoYWRkKTtcbiAgdmFyIGkgPSBrZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIG9yaWdpbltrZXlzW2ldXSA9IGFkZFtrZXlzW2ldXTtcbiAgfVxuICByZXR1cm4gb3JpZ2luO1xufTtcblxuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cblxudmFyIGtDdXN0b21Qcm9taXNpZmllZFN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnID8gU3ltYm9sKCd1dGlsLnByb21pc2lmeS5jdXN0b20nKSA6IHVuZGVmaW5lZDtcblxuZXhwb3J0cy5wcm9taXNpZnkgPSBmdW5jdGlvbiBwcm9taXNpZnkob3JpZ2luYWwpIHtcbiAgaWYgKHR5cGVvZiBvcmlnaW5hbCAhPT0gJ2Z1bmN0aW9uJylcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJvcmlnaW5hbFwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbicpO1xuXG4gIGlmIChrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2wgJiYgb3JpZ2luYWxba0N1c3RvbVByb21pc2lmaWVkU3ltYm9sXSkge1xuICAgIHZhciBmbiA9IG9yaWdpbmFsW2tDdXN0b21Qcm9taXNpZmllZFN5bWJvbF07XG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwidXRpbC5wcm9taXNpZnkuY3VzdG9tXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uJyk7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmbiwga0N1c3RvbVByb21pc2lmaWVkU3ltYm9sLCB7XG4gICAgICB2YWx1ZTogZm4sIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogZmFsc2UsIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZuKCkge1xuICAgIHZhciBwcm9taXNlUmVzb2x2ZSwgcHJvbWlzZVJlamVjdDtcbiAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHByb21pc2VSZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgIHByb21pc2VSZWplY3QgPSByZWplY3Q7XG4gICAgfSk7XG5cbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgICB9XG4gICAgYXJncy5wdXNoKGZ1bmN0aW9uIChlcnIsIHZhbHVlKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHByb21pc2VSZWplY3QoZXJyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb21pc2VSZXNvbHZlKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRyeSB7XG4gICAgICBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHByb21pc2VSZWplY3QoZXJyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuXG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihmbiwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG9yaWdpbmFsKSk7XG5cbiAgaWYgKGtDdXN0b21Qcm9taXNpZmllZFN5bWJvbCkgT2JqZWN0LmRlZmluZVByb3BlcnR5KGZuLCBrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2wsIHtcbiAgICB2YWx1ZTogZm4sIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogZmFsc2UsIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFxuICAgIGZuLFxuICAgIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMob3JpZ2luYWwpXG4gICk7XG59XG5cbmV4cG9ydHMucHJvbWlzaWZ5LmN1c3RvbSA9IGtDdXN0b21Qcm9taXNpZmllZFN5bWJvbFxuXG5mdW5jdGlvbiBjYWxsYmFja2lmeU9uUmVqZWN0ZWQocmVhc29uLCBjYikge1xuICAvLyBgIXJlYXNvbmAgZ3VhcmQgaW5zcGlyZWQgYnkgYmx1ZWJpcmQgKFJlZjogaHR0cHM6Ly9nb28uZ2wvdDVJUzZNKS5cbiAgLy8gQmVjYXVzZSBgbnVsbGAgaXMgYSBzcGVjaWFsIGVycm9yIHZhbHVlIGluIGNhbGxiYWNrcyB3aGljaCBtZWFucyBcIm5vIGVycm9yXG4gIC8vIG9jY3VycmVkXCIsIHdlIGVycm9yLXdyYXAgc28gdGhlIGNhbGxiYWNrIGNvbnN1bWVyIGNhbiBkaXN0aW5ndWlzaCBiZXR3ZWVuXG4gIC8vIFwidGhlIHByb21pc2UgcmVqZWN0ZWQgd2l0aCBudWxsXCIgb3IgXCJ0aGUgcHJvbWlzZSBmdWxmaWxsZWQgd2l0aCB1bmRlZmluZWRcIi5cbiAgaWYgKCFyZWFzb24pIHtcbiAgICB2YXIgbmV3UmVhc29uID0gbmV3IEVycm9yKCdQcm9taXNlIHdhcyByZWplY3RlZCB3aXRoIGEgZmFsc3kgdmFsdWUnKTtcbiAgICBuZXdSZWFzb24ucmVhc29uID0gcmVhc29uO1xuICAgIHJlYXNvbiA9IG5ld1JlYXNvbjtcbiAgfVxuICByZXR1cm4gY2IocmVhc29uKTtcbn1cblxuZnVuY3Rpb24gY2FsbGJhY2tpZnkob3JpZ2luYWwpIHtcbiAgaWYgKHR5cGVvZiBvcmlnaW5hbCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcIm9yaWdpbmFsXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uJyk7XG4gIH1cblxuICAvLyBXZSBETyBOT1QgcmV0dXJuIHRoZSBwcm9taXNlIGFzIGl0IGdpdmVzIHRoZSB1c2VyIGEgZmFsc2Ugc2Vuc2UgdGhhdFxuICAvLyB0aGUgcHJvbWlzZSBpcyBhY3R1YWxseSBzb21laG93IHJlbGF0ZWQgdG8gdGhlIGNhbGxiYWNrJ3MgZXhlY3V0aW9uXG4gIC8vIGFuZCB0aGF0IHRoZSBjYWxsYmFjayB0aHJvd2luZyB3aWxsIHJlamVjdCB0aGUgcHJvbWlzZS5cbiAgZnVuY3Rpb24gY2FsbGJhY2tpZmllZCgpIHtcbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgICB9XG5cbiAgICB2YXIgbWF5YmVDYiA9IGFyZ3MucG9wKCk7XG4gICAgaWYgKHR5cGVvZiBtYXliZUNiICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgbGFzdCBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24nKTtcbiAgICB9XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBjYiA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG1heWJlQ2IuYXBwbHkoc2VsZiwgYXJndW1lbnRzKTtcbiAgICB9O1xuICAgIC8vIEluIHRydWUgbm9kZSBzdHlsZSB3ZSBwcm9jZXNzIHRoZSBjYWxsYmFjayBvbiBgbmV4dFRpY2tgIHdpdGggYWxsIHRoZVxuICAgIC8vIGltcGxpY2F0aW9ucyAoc3RhY2ssIGB1bmNhdWdodEV4Y2VwdGlvbmAsIGBhc3luY19ob29rc2ApXG4gICAgb3JpZ2luYWwuYXBwbHkodGhpcywgYXJncylcbiAgICAgIC50aGVuKGZ1bmN0aW9uKHJldCkgeyBwcm9jZXNzLm5leHRUaWNrKGNiLmJpbmQobnVsbCwgbnVsbCwgcmV0KSkgfSxcbiAgICAgICAgICAgIGZ1bmN0aW9uKHJlaikgeyBwcm9jZXNzLm5leHRUaWNrKGNhbGxiYWNraWZ5T25SZWplY3RlZC5iaW5kKG51bGwsIHJlaiwgY2IpKSB9KTtcbiAgfVxuXG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihjYWxsYmFja2lmaWVkLCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob3JpZ2luYWwpKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY2FsbGJhY2tpZmllZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhvcmlnaW5hbCkpO1xuICByZXR1cm4gY2FsbGJhY2tpZmllZDtcbn1cbmV4cG9ydHMuY2FsbGJhY2tpZnkgPSBjYWxsYmFja2lmeTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gOTIwODpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXG5tb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oOTExMCk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyA5MTEwOlxuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5jcmVhdGVNZXNzYWdlQ29ubmVjdGlvbiA9IGV4cG9ydHMuQnJvd3Nlck1lc3NhZ2VXcml0ZXIgPSBleHBvcnRzLkJyb3dzZXJNZXNzYWdlUmVhZGVyID0gdm9pZCAwO1xuY29uc3QgcmlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMzMTIpO1xuLy8gSW5zdGFsbCB0aGUgYnJvd3NlciBydW50aW1lIGFic3RyYWN0LlxucmlsXzEuZGVmYXVsdC5pbnN0YWxsKCk7XG5jb25zdCBhcGlfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNzY3Mik7XG5fX2V4cG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXyg3NjcyKSwgZXhwb3J0cyk7XG5jbGFzcyBCcm93c2VyTWVzc2FnZVJlYWRlciBleHRlbmRzIGFwaV8xLkFic3RyYWN0TWVzc2FnZVJlYWRlciB7XG4gICAgY29uc3RydWN0b3IocG9ydCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl9vbkRhdGEgPSBuZXcgYXBpXzEuRW1pdHRlcigpO1xuICAgICAgICB0aGlzLl9tZXNzYWdlTGlzdGVuZXIgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX29uRGF0YS5maXJlKGV2ZW50LmRhdGEpO1xuICAgICAgICB9O1xuICAgICAgICBwb3J0LmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgKGV2ZW50KSA9PiB0aGlzLmZpcmVFcnJvcihldmVudCkpO1xuICAgICAgICBwb3J0Lm9ubWVzc2FnZSA9IHRoaXMuX21lc3NhZ2VMaXN0ZW5lcjtcbiAgICB9XG4gICAgbGlzdGVuKGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vbkRhdGEuZXZlbnQoY2FsbGJhY2spO1xuICAgIH1cbn1cbmV4cG9ydHMuQnJvd3Nlck1lc3NhZ2VSZWFkZXIgPSBCcm93c2VyTWVzc2FnZVJlYWRlcjtcbmNsYXNzIEJyb3dzZXJNZXNzYWdlV3JpdGVyIGV4dGVuZHMgYXBpXzEuQWJzdHJhY3RNZXNzYWdlV3JpdGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihwb3J0KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMucG9ydCA9IHBvcnQ7XG4gICAgICAgIHRoaXMuZXJyb3JDb3VudCA9IDA7XG4gICAgICAgIHBvcnQuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCAoZXZlbnQpID0+IHRoaXMuZmlyZUVycm9yKGV2ZW50KSk7XG4gICAgfVxuICAgIHdyaXRlKG1zZykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5wb3J0LnBvc3RNZXNzYWdlKG1zZyk7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZUVycm9yKGVycm9yLCBtc2cpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYW5kbGVFcnJvcihlcnJvciwgbXNnKSB7XG4gICAgICAgIHRoaXMuZXJyb3JDb3VudCsrO1xuICAgICAgICB0aGlzLmZpcmVFcnJvcihlcnJvciwgbXNnLCB0aGlzLmVycm9yQ291bnQpO1xuICAgIH1cbiAgICBlbmQoKSB7XG4gICAgfVxufVxuZXhwb3J0cy5Ccm93c2VyTWVzc2FnZVdyaXRlciA9IEJyb3dzZXJNZXNzYWdlV3JpdGVyO1xuZnVuY3Rpb24gY3JlYXRlTWVzc2FnZUNvbm5lY3Rpb24ocmVhZGVyLCB3cml0ZXIsIGxvZ2dlciwgb3B0aW9ucykge1xuICAgIGlmIChsb2dnZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBsb2dnZXIgPSBhcGlfMS5OdWxsTG9nZ2VyO1xuICAgIH1cbiAgICBpZiAoYXBpXzEuQ29ubmVjdGlvblN0cmF0ZWd5LmlzKG9wdGlvbnMpKSB7XG4gICAgICAgIG9wdGlvbnMgPSB7IGNvbm5lY3Rpb25TdHJhdGVneTogb3B0aW9ucyB9O1xuICAgIH1cbiAgICByZXR1cm4gKDAsIGFwaV8xLmNyZWF0ZU1lc3NhZ2VDb25uZWN0aW9uKShyZWFkZXIsIHdyaXRlciwgbG9nZ2VyLCBvcHRpb25zKTtcbn1cbmV4cG9ydHMuY3JlYXRlTWVzc2FnZUNvbm5lY3Rpb24gPSBjcmVhdGVNZXNzYWdlQ29ubmVjdGlvbjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMzMxMjpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBwcm92aWRlZCBkZXBlbmRlbmN5ICovIHZhciBjb25zb2xlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MzY0KTtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5jb25zdCBhcGlfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNzY3Mik7XG5jbGFzcyBNZXNzYWdlQnVmZmVyIGV4dGVuZHMgYXBpXzEuQWJzdHJhY3RNZXNzYWdlQnVmZmVyIHtcbiAgICBjb25zdHJ1Y3RvcihlbmNvZGluZyA9ICd1dGYtOCcpIHtcbiAgICAgICAgc3VwZXIoZW5jb2RpbmcpO1xuICAgICAgICB0aGlzLmFzY2lpRGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcignYXNjaWknKTtcbiAgICB9XG4gICAgZW1wdHlCdWZmZXIoKSB7XG4gICAgICAgIHJldHVybiBNZXNzYWdlQnVmZmVyLmVtcHR5QnVmZmVyO1xuICAgIH1cbiAgICBmcm9tU3RyaW5nKHZhbHVlLCBfZW5jb2RpbmcpIHtcbiAgICAgICAgcmV0dXJuIChuZXcgVGV4dEVuY29kZXIoKSkuZW5jb2RlKHZhbHVlKTtcbiAgICB9XG4gICAgdG9TdHJpbmcodmFsdWUsIGVuY29kaW5nKSB7XG4gICAgICAgIGlmIChlbmNvZGluZyA9PT0gJ2FzY2lpJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXNjaWlEZWNvZGVyLmRlY29kZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gKG5ldyBUZXh0RGVjb2RlcihlbmNvZGluZykpLmRlY29kZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXNOYXRpdmUoYnVmZmVyLCBsZW5ndGgpIHtcbiAgICAgICAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gYnVmZmVyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlci5zbGljZSgwLCBsZW5ndGgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFsbG9jTmF0aXZlKGxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgICB9XG59XG5NZXNzYWdlQnVmZmVyLmVtcHR5QnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoMCk7XG5jbGFzcyBSZWFkYWJsZVN0cmVhbVdyYXBwZXIge1xuICAgIGNvbnN0cnVjdG9yKHNvY2tldCkge1xuICAgICAgICB0aGlzLnNvY2tldCA9IHNvY2tldDtcbiAgICAgICAgdGhpcy5fb25EYXRhID0gbmV3IGFwaV8xLkVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5fbWVzc2FnZUxpc3RlbmVyID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBibG9iID0gZXZlbnQuZGF0YTtcbiAgICAgICAgICAgIGJsb2IuYXJyYXlCdWZmZXIoKS50aGVuKChidWZmZXIpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9vbkRhdGEuZmlyZShuZXcgVWludDhBcnJheShidWZmZXIpKTtcbiAgICAgICAgICAgIH0sICgpID0+IHtcbiAgICAgICAgICAgICAgICAoMCwgYXBpXzEuUkFMKSgpLmNvbnNvbGUuZXJyb3IoYENvbnZlcnRpbmcgYmxvYiB0byBhcnJheSBidWZmZXIgZmFpbGVkLmApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCB0aGlzLl9tZXNzYWdlTGlzdGVuZXIpO1xuICAgIH1cbiAgICBvbkNsb3NlKGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoJ2Nsb3NlJywgbGlzdGVuZXIpO1xuICAgICAgICByZXR1cm4gYXBpXzEuRGlzcG9zYWJsZS5jcmVhdGUoKCkgPT4gdGhpcy5zb2NrZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xvc2UnLCBsaXN0ZW5lcikpO1xuICAgIH1cbiAgICBvbkVycm9yKGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgbGlzdGVuZXIpO1xuICAgICAgICByZXR1cm4gYXBpXzEuRGlzcG9zYWJsZS5jcmVhdGUoKCkgPT4gdGhpcy5zb2NrZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCBsaXN0ZW5lcikpO1xuICAgIH1cbiAgICBvbkVuZChsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLnNvY2tldC5hZGRFdmVudExpc3RlbmVyKCdlbmQnLCBsaXN0ZW5lcik7XG4gICAgICAgIHJldHVybiBhcGlfMS5EaXNwb3NhYmxlLmNyZWF0ZSgoKSA9PiB0aGlzLnNvY2tldC5yZW1vdmVFdmVudExpc3RlbmVyKCdlbmQnLCBsaXN0ZW5lcikpO1xuICAgIH1cbiAgICBvbkRhdGEobGlzdGVuZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29uRGF0YS5ldmVudChsaXN0ZW5lcik7XG4gICAgfVxufVxuY2xhc3MgV3JpdGFibGVTdHJlYW1XcmFwcGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihzb2NrZXQpIHtcbiAgICAgICAgdGhpcy5zb2NrZXQgPSBzb2NrZXQ7XG4gICAgfVxuICAgIG9uQ2xvc2UobGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5zb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcignY2xvc2UnLCBsaXN0ZW5lcik7XG4gICAgICAgIHJldHVybiBhcGlfMS5EaXNwb3NhYmxlLmNyZWF0ZSgoKSA9PiB0aGlzLnNvY2tldC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbG9zZScsIGxpc3RlbmVyKSk7XG4gICAgfVxuICAgIG9uRXJyb3IobGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5zb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBsaXN0ZW5lcik7XG4gICAgICAgIHJldHVybiBhcGlfMS5EaXNwb3NhYmxlLmNyZWF0ZSgoKSA9PiB0aGlzLnNvY2tldC5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIGxpc3RlbmVyKSk7XG4gICAgfVxuICAgIG9uRW5kKGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoJ2VuZCcsIGxpc3RlbmVyKTtcbiAgICAgICAgcmV0dXJuIGFwaV8xLkRpc3Bvc2FibGUuY3JlYXRlKCgpID0+IHRoaXMuc29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2VuZCcsIGxpc3RlbmVyKSk7XG4gICAgfVxuICAgIHdyaXRlKGRhdGEsIGVuY29kaW5nKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkICYmIGVuY29kaW5nICE9PSAndXRmLTgnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbiBhIEJyb3dzZXIgZW52aXJvbm1lbnRzIG9ubHkgdXRmLTggdGV4dCBlbmNvZGluZyBpcyBzdXBwb3J0ZWQuIEJ1dCBnb3QgZW5jb2Rpbmc6ICR7ZW5jb2Rpbmd9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNvY2tldC5zZW5kKGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zb2NrZXQuc2VuZChkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIGVuZCgpIHtcbiAgICAgICAgdGhpcy5zb2NrZXQuY2xvc2UoKTtcbiAgICB9XG59XG5jb25zdCBfdGV4dEVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbmNvbnN0IF9yaWwgPSBPYmplY3QuZnJlZXplKHtcbiAgICBtZXNzYWdlQnVmZmVyOiBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgY3JlYXRlOiAoZW5jb2RpbmcpID0+IG5ldyBNZXNzYWdlQnVmZmVyKGVuY29kaW5nKVxuICAgIH0pLFxuICAgIGFwcGxpY2F0aW9uSnNvbjogT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIGVuY29kZXI6IE9iamVjdC5mcmVlemUoe1xuICAgICAgICAgICAgbmFtZTogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgZW5jb2RlOiAobXNnLCBvcHRpb25zKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuY2hhcnNldCAhPT0gJ3V0Zi04Jykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEluIGEgQnJvd3NlciBlbnZpcm9ubWVudHMgb25seSB1dGYtOCB0ZXh0IGVuY29kaW5nIGlzIHN1cHBvcnRlZC4gQnV0IGdvdCBlbmNvZGluZzogJHtvcHRpb25zLmNoYXJzZXR9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoX3RleHRFbmNvZGVyLmVuY29kZShKU09OLnN0cmluZ2lmeShtc2csIHVuZGVmaW5lZCwgMCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSksXG4gICAgICAgIGRlY29kZXI6IE9iamVjdC5mcmVlemUoe1xuICAgICAgICAgICAgbmFtZTogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgZGVjb2RlOiAoYnVmZmVyLCBvcHRpb25zKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCEoYnVmZmVyIGluc3RhbmNlb2YgVWludDhBcnJheSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbiBhIEJyb3dzZXIgZW52aXJvbm1lbnRzIG9ubHkgVWludDhBcnJheXMgYXJlIHN1cHBvcnRlZC5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShKU09OLnBhcnNlKG5ldyBUZXh0RGVjb2RlcihvcHRpb25zLmNoYXJzZXQpLmRlY29kZShidWZmZXIpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgfSksXG4gICAgc3RyZWFtOiBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgYXNSZWFkYWJsZVN0cmVhbTogKHNvY2tldCkgPT4gbmV3IFJlYWRhYmxlU3RyZWFtV3JhcHBlcihzb2NrZXQpLFxuICAgICAgICBhc1dyaXRhYmxlU3RyZWFtOiAoc29ja2V0KSA9PiBuZXcgV3JpdGFibGVTdHJlYW1XcmFwcGVyKHNvY2tldClcbiAgICB9KSxcbiAgICBjb25zb2xlOiBjb25zb2xlLFxuICAgIHRpbWVyOiBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgc2V0VGltZW91dChjYWxsYmFjaywgbXMsIC4uLmFyZ3MpIHtcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZSA9IHNldFRpbWVvdXQoY2FsbGJhY2ssIG1zLCAuLi5hcmdzKTtcbiAgICAgICAgICAgIHJldHVybiB7IGRpc3Bvc2U6ICgpID0+IGNsZWFyVGltZW91dChoYW5kbGUpIH07XG4gICAgICAgIH0sXG4gICAgICAgIHNldEltbWVkaWF0ZShjYWxsYmFjaywgLi4uYXJncykge1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlID0gc2V0VGltZW91dChjYWxsYmFjaywgMCwgLi4uYXJncyk7XG4gICAgICAgICAgICByZXR1cm4geyBkaXNwb3NlOiAoKSA9PiBjbGVhclRpbWVvdXQoaGFuZGxlKSB9O1xuICAgICAgICB9LFxuICAgICAgICBzZXRJbnRlcnZhbChjYWxsYmFjaywgbXMsIC4uLmFyZ3MpIHtcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZSA9IHNldEludGVydmFsKGNhbGxiYWNrLCBtcywgLi4uYXJncyk7XG4gICAgICAgICAgICByZXR1cm4geyBkaXNwb3NlOiAoKSA9PiBjbGVhckludGVydmFsKGhhbmRsZSkgfTtcbiAgICAgICAgfSxcbiAgICB9KVxufSk7XG5mdW5jdGlvbiBSSUwoKSB7XG4gICAgcmV0dXJuIF9yaWw7XG59XG4oZnVuY3Rpb24gKFJJTCkge1xuICAgIGZ1bmN0aW9uIGluc3RhbGwoKSB7XG4gICAgICAgIGFwaV8xLlJBTC5pbnN0YWxsKF9yaWwpO1xuICAgIH1cbiAgICBSSUwuaW5zdGFsbCA9IGluc3RhbGw7XG59KShSSUwgfHwgKFJJTCA9IHt9KSk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IFJJTDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNzY3Mjpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi8uLi90eXBpbmdzL3RoZW5hYmxlLmQudHNcIiAvPlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLlByb2dyZXNzVHlwZSA9IGV4cG9ydHMuUHJvZ3Jlc3NUb2tlbiA9IGV4cG9ydHMuY3JlYXRlTWVzc2FnZUNvbm5lY3Rpb24gPSBleHBvcnRzLk51bGxMb2dnZXIgPSBleHBvcnRzLkNvbm5lY3Rpb25PcHRpb25zID0gZXhwb3J0cy5Db25uZWN0aW9uU3RyYXRlZ3kgPSBleHBvcnRzLkFic3RyYWN0TWVzc2FnZUJ1ZmZlciA9IGV4cG9ydHMuV3JpdGVhYmxlU3RyZWFtTWVzc2FnZVdyaXRlciA9IGV4cG9ydHMuQWJzdHJhY3RNZXNzYWdlV3JpdGVyID0gZXhwb3J0cy5NZXNzYWdlV3JpdGVyID0gZXhwb3J0cy5SZWFkYWJsZVN0cmVhbU1lc3NhZ2VSZWFkZXIgPSBleHBvcnRzLkFic3RyYWN0TWVzc2FnZVJlYWRlciA9IGV4cG9ydHMuTWVzc2FnZVJlYWRlciA9IGV4cG9ydHMuU2hhcmVkQXJyYXlSZWNlaXZlclN0cmF0ZWd5ID0gZXhwb3J0cy5TaGFyZWRBcnJheVNlbmRlclN0cmF0ZWd5ID0gZXhwb3J0cy5DYW5jZWxsYXRpb25Ub2tlbiA9IGV4cG9ydHMuQ2FuY2VsbGF0aW9uVG9rZW5Tb3VyY2UgPSBleHBvcnRzLkVtaXR0ZXIgPSBleHBvcnRzLkV2ZW50ID0gZXhwb3J0cy5EaXNwb3NhYmxlID0gZXhwb3J0cy5MUlVDYWNoZSA9IGV4cG9ydHMuVG91Y2ggPSBleHBvcnRzLkxpbmtlZE1hcCA9IGV4cG9ydHMuUGFyYW1ldGVyU3RydWN0dXJlcyA9IGV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTkgPSBleHBvcnRzLk5vdGlmaWNhdGlvblR5cGU4ID0gZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlNyA9IGV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTYgPSBleHBvcnRzLk5vdGlmaWNhdGlvblR5cGU1ID0gZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlNCA9IGV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTMgPSBleHBvcnRzLk5vdGlmaWNhdGlvblR5cGUyID0gZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlMSA9IGV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTAgPSBleHBvcnRzLk5vdGlmaWNhdGlvblR5cGUgPSBleHBvcnRzLkVycm9yQ29kZXMgPSBleHBvcnRzLlJlc3BvbnNlRXJyb3IgPSBleHBvcnRzLlJlcXVlc3RUeXBlOSA9IGV4cG9ydHMuUmVxdWVzdFR5cGU4ID0gZXhwb3J0cy5SZXF1ZXN0VHlwZTcgPSBleHBvcnRzLlJlcXVlc3RUeXBlNiA9IGV4cG9ydHMuUmVxdWVzdFR5cGU1ID0gZXhwb3J0cy5SZXF1ZXN0VHlwZTQgPSBleHBvcnRzLlJlcXVlc3RUeXBlMyA9IGV4cG9ydHMuUmVxdWVzdFR5cGUyID0gZXhwb3J0cy5SZXF1ZXN0VHlwZTEgPSBleHBvcnRzLlJlcXVlc3RUeXBlMCA9IGV4cG9ydHMuUmVxdWVzdFR5cGUgPSBleHBvcnRzLk1lc3NhZ2UgPSBleHBvcnRzLlJBTCA9IHZvaWQgMDtcbmV4cG9ydHMuTWVzc2FnZVN0cmF0ZWd5ID0gZXhwb3J0cy5DYW5jZWxsYXRpb25TdHJhdGVneSA9IGV4cG9ydHMuQ2FuY2VsbGF0aW9uU2VuZGVyU3RyYXRlZ3kgPSBleHBvcnRzLkNhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kgPSBleHBvcnRzLkNvbm5lY3Rpb25FcnJvciA9IGV4cG9ydHMuQ29ubmVjdGlvbkVycm9ycyA9IGV4cG9ydHMuTG9nVHJhY2VOb3RpZmljYXRpb24gPSBleHBvcnRzLlNldFRyYWNlTm90aWZpY2F0aW9uID0gZXhwb3J0cy5UcmFjZUZvcm1hdCA9IGV4cG9ydHMuVHJhY2VWYWx1ZXMgPSBleHBvcnRzLlRyYWNlID0gdm9pZCAwO1xuY29uc3QgbWVzc2FnZXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNzE2Mik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJNZXNzYWdlXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZXNfMS5NZXNzYWdlOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJlcXVlc3RUeXBlXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZXNfMS5SZXF1ZXN0VHlwZTsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJSZXF1ZXN0VHlwZTBcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlc18xLlJlcXVlc3RUeXBlMDsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJSZXF1ZXN0VHlwZTFcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlc18xLlJlcXVlc3RUeXBlMTsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJSZXF1ZXN0VHlwZTJcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlc18xLlJlcXVlc3RUeXBlMjsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJSZXF1ZXN0VHlwZTNcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlc18xLlJlcXVlc3RUeXBlMzsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJSZXF1ZXN0VHlwZTRcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlc18xLlJlcXVlc3RUeXBlNDsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJSZXF1ZXN0VHlwZTVcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlc18xLlJlcXVlc3RUeXBlNTsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJSZXF1ZXN0VHlwZTZcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlc18xLlJlcXVlc3RUeXBlNjsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJSZXF1ZXN0VHlwZTdcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlc18xLlJlcXVlc3RUeXBlNzsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJSZXF1ZXN0VHlwZThcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlc18xLlJlcXVlc3RUeXBlODsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJSZXF1ZXN0VHlwZTlcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlc18xLlJlcXVlc3RUeXBlOTsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJSZXNwb25zZUVycm9yXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZXNfMS5SZXNwb25zZUVycm9yOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkVycm9yQ29kZXNcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlc18xLkVycm9yQ29kZXM7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTm90aWZpY2F0aW9uVHlwZVwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuTm90aWZpY2F0aW9uVHlwZTsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOb3RpZmljYXRpb25UeXBlMFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuTm90aWZpY2F0aW9uVHlwZTA7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTm90aWZpY2F0aW9uVHlwZTFcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlc18xLk5vdGlmaWNhdGlvblR5cGUxOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5vdGlmaWNhdGlvblR5cGUyXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZXNfMS5Ob3RpZmljYXRpb25UeXBlMjsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOb3RpZmljYXRpb25UeXBlM1wiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuTm90aWZpY2F0aW9uVHlwZTM7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTm90aWZpY2F0aW9uVHlwZTRcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlc18xLk5vdGlmaWNhdGlvblR5cGU0OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5vdGlmaWNhdGlvblR5cGU1XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZXNfMS5Ob3RpZmljYXRpb25UeXBlNTsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOb3RpZmljYXRpb25UeXBlNlwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuTm90aWZpY2F0aW9uVHlwZTY7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTm90aWZpY2F0aW9uVHlwZTdcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlc18xLk5vdGlmaWNhdGlvblR5cGU3OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5vdGlmaWNhdGlvblR5cGU4XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZXNfMS5Ob3RpZmljYXRpb25UeXBlODsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOb3RpZmljYXRpb25UeXBlOVwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuTm90aWZpY2F0aW9uVHlwZTk7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUGFyYW1ldGVyU3RydWN0dXJlc1wiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuUGFyYW1ldGVyU3RydWN0dXJlczsgfSB9KSk7XG5jb25zdCBsaW5rZWRNYXBfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTEwOSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJMaW5rZWRNYXBcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsaW5rZWRNYXBfMS5MaW5rZWRNYXA7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTFJVQ2FjaGVcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsaW5rZWRNYXBfMS5MUlVDYWNoZTsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUb3VjaFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxpbmtlZE1hcF8xLlRvdWNoOyB9IH0pKTtcbmNvbnN0IGRpc3Bvc2FibGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oODg0NCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJEaXNwb3NhYmxlXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZGlzcG9zYWJsZV8xLkRpc3Bvc2FibGU7IH0gfSkpO1xuY29uc3QgZXZlbnRzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI0NzkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRXZlbnRcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBldmVudHNfMS5FdmVudDsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJFbWl0dGVyXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZXZlbnRzXzEuRW1pdHRlcjsgfSB9KSk7XG5jb25zdCBjYW5jZWxsYXRpb25fMSA9IF9fd2VicGFja19yZXF1aXJlX18oNjk1Nyk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDYW5jZWxsYXRpb25Ub2tlblNvdXJjZVwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNhbmNlbGxhdGlvbl8xLkNhbmNlbGxhdGlvblRva2VuU291cmNlOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNhbmNlbGxhdGlvblRva2VuXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY2FuY2VsbGF0aW9uXzEuQ2FuY2VsbGF0aW9uVG9rZW47IH0gfSkpO1xuY29uc3Qgc2hhcmVkQXJyYXlDYW5jZWxsYXRpb25fMSA9IF9fd2VicGFja19yZXF1aXJlX18oMzQ4OSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTaGFyZWRBcnJheVNlbmRlclN0cmF0ZWd5XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2hhcmVkQXJyYXlDYW5jZWxsYXRpb25fMS5TaGFyZWRBcnJheVNlbmRlclN0cmF0ZWd5OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNoYXJlZEFycmF5UmVjZWl2ZXJTdHJhdGVneVwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNoYXJlZEFycmF5Q2FuY2VsbGF0aW9uXzEuU2hhcmVkQXJyYXlSZWNlaXZlclN0cmF0ZWd5OyB9IH0pKTtcbmNvbnN0IG1lc3NhZ2VSZWFkZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNjU2KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk1lc3NhZ2VSZWFkZXJcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlUmVhZGVyXzEuTWVzc2FnZVJlYWRlcjsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBYnN0cmFjdE1lc3NhZ2VSZWFkZXJcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlUmVhZGVyXzEuQWJzdHJhY3RNZXNzYWdlUmVhZGVyOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJlYWRhYmxlU3RyZWFtTWVzc2FnZVJlYWRlclwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VSZWFkZXJfMS5SZWFkYWJsZVN0cmVhbU1lc3NhZ2VSZWFkZXI7IH0gfSkpO1xuY29uc3QgbWVzc2FnZVdyaXRlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MDM2KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk1lc3NhZ2VXcml0ZXJcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlV3JpdGVyXzEuTWVzc2FnZVdyaXRlcjsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBYnN0cmFjdE1lc3NhZ2VXcml0ZXJcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlV3JpdGVyXzEuQWJzdHJhY3RNZXNzYWdlV3JpdGVyOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIldyaXRlYWJsZVN0cmVhbU1lc3NhZ2VXcml0ZXJcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlV3JpdGVyXzEuV3JpdGVhYmxlU3RyZWFtTWVzc2FnZVdyaXRlcjsgfSB9KSk7XG5jb25zdCBtZXNzYWdlQnVmZmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk4MDUpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQWJzdHJhY3RNZXNzYWdlQnVmZmVyXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZUJ1ZmZlcl8xLkFic3RyYWN0TWVzc2FnZUJ1ZmZlcjsgfSB9KSk7XG5jb25zdCBjb25uZWN0aW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQwNTQpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ29ubmVjdGlvblN0cmF0ZWd5XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29ubmVjdGlvbl8xLkNvbm5lY3Rpb25TdHJhdGVneTsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDb25uZWN0aW9uT3B0aW9uc1wiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbm5lY3Rpb25fMS5Db25uZWN0aW9uT3B0aW9uczsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOdWxsTG9nZ2VyXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29ubmVjdGlvbl8xLk51bGxMb2dnZXI7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY3JlYXRlTWVzc2FnZUNvbm5lY3Rpb25cIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25uZWN0aW9uXzEuY3JlYXRlTWVzc2FnZUNvbm5lY3Rpb247IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUHJvZ3Jlc3NUb2tlblwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbm5lY3Rpb25fMS5Qcm9ncmVzc1Rva2VuOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlByb2dyZXNzVHlwZVwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbm5lY3Rpb25fMS5Qcm9ncmVzc1R5cGU7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVHJhY2VcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25uZWN0aW9uXzEuVHJhY2U7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVHJhY2VWYWx1ZXNcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25uZWN0aW9uXzEuVHJhY2VWYWx1ZXM7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVHJhY2VGb3JtYXRcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25uZWN0aW9uXzEuVHJhY2VGb3JtYXQ7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU2V0VHJhY2VOb3RpZmljYXRpb25cIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25uZWN0aW9uXzEuU2V0VHJhY2VOb3RpZmljYXRpb247IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTG9nVHJhY2VOb3RpZmljYXRpb25cIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25uZWN0aW9uXzEuTG9nVHJhY2VOb3RpZmljYXRpb247IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ29ubmVjdGlvbkVycm9yc1wiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbm5lY3Rpb25fMS5Db25uZWN0aW9uRXJyb3JzOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNvbm5lY3Rpb25FcnJvclwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbm5lY3Rpb25fMS5Db25uZWN0aW9uRXJyb3I7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ2FuY2VsbGF0aW9uUmVjZWl2ZXJTdHJhdGVneVwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbm5lY3Rpb25fMS5DYW5jZWxsYXRpb25SZWNlaXZlclN0cmF0ZWd5OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNhbmNlbGxhdGlvblNlbmRlclN0cmF0ZWd5XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29ubmVjdGlvbl8xLkNhbmNlbGxhdGlvblNlbmRlclN0cmF0ZWd5OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNhbmNlbGxhdGlvblN0cmF0ZWd5XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29ubmVjdGlvbl8xLkNhbmNlbGxhdGlvblN0cmF0ZWd5OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk1lc3NhZ2VTdHJhdGVneVwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbm5lY3Rpb25fMS5NZXNzYWdlU3RyYXRlZ3k7IH0gfSkpO1xuY29uc3QgcmFsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUwOTEpO1xuZXhwb3J0cy5SQUwgPSByYWxfMS5kZWZhdWx0O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA2OTU3OlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuQ2FuY2VsbGF0aW9uVG9rZW5Tb3VyY2UgPSBleHBvcnRzLkNhbmNlbGxhdGlvblRva2VuID0gdm9pZCAwO1xuY29uc3QgcmFsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUwOTEpO1xuY29uc3QgSXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY2MTgpO1xuY29uc3QgZXZlbnRzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI0NzkpO1xudmFyIENhbmNlbGxhdGlvblRva2VuO1xuKGZ1bmN0aW9uIChDYW5jZWxsYXRpb25Ub2tlbikge1xuICAgIENhbmNlbGxhdGlvblRva2VuLk5vbmUgPSBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgaXNDYW5jZWxsYXRpb25SZXF1ZXN0ZWQ6IGZhbHNlLFxuICAgICAgICBvbkNhbmNlbGxhdGlvblJlcXVlc3RlZDogZXZlbnRzXzEuRXZlbnQuTm9uZVxuICAgIH0pO1xuICAgIENhbmNlbGxhdGlvblRva2VuLkNhbmNlbGxlZCA9IE9iamVjdC5mcmVlemUoe1xuICAgICAgICBpc0NhbmNlbGxhdGlvblJlcXVlc3RlZDogdHJ1ZSxcbiAgICAgICAgb25DYW5jZWxsYXRpb25SZXF1ZXN0ZWQ6IGV2ZW50c18xLkV2ZW50Lk5vbmVcbiAgICB9KTtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJiAoY2FuZGlkYXRlID09PSBDYW5jZWxsYXRpb25Ub2tlbi5Ob25lXG4gICAgICAgICAgICB8fCBjYW5kaWRhdGUgPT09IENhbmNlbGxhdGlvblRva2VuLkNhbmNlbGxlZFxuICAgICAgICAgICAgfHwgKElzLmJvb2xlYW4oY2FuZGlkYXRlLmlzQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKSAmJiAhIWNhbmRpZGF0ZS5vbkNhbmNlbGxhdGlvblJlcXVlc3RlZCkpO1xuICAgIH1cbiAgICBDYW5jZWxsYXRpb25Ub2tlbi5pcyA9IGlzO1xufSkoQ2FuY2VsbGF0aW9uVG9rZW4gPSBleHBvcnRzLkNhbmNlbGxhdGlvblRva2VuIHx8IChleHBvcnRzLkNhbmNlbGxhdGlvblRva2VuID0ge30pKTtcbmNvbnN0IHNob3J0Y3V0RXZlbnQgPSBPYmplY3QuZnJlZXplKGZ1bmN0aW9uIChjYWxsYmFjaywgY29udGV4dCkge1xuICAgIGNvbnN0IGhhbmRsZSA9ICgwLCByYWxfMS5kZWZhdWx0KSgpLnRpbWVyLnNldFRpbWVvdXQoY2FsbGJhY2suYmluZChjb250ZXh0KSwgMCk7XG4gICAgcmV0dXJuIHsgZGlzcG9zZSgpIHsgaGFuZGxlLmRpc3Bvc2UoKTsgfSB9O1xufSk7XG5jbGFzcyBNdXRhYmxlVG9rZW4ge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLl9pc0NhbmNlbGxlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBjYW5jZWwoKSB7XG4gICAgICAgIGlmICghdGhpcy5faXNDYW5jZWxsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2lzQ2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9lbWl0dGVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZW1pdHRlci5maXJlKHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGlzQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNDYW5jZWxsZWQ7XG4gICAgfVxuICAgIGdldCBvbkNhbmNlbGxhdGlvblJlcXVlc3RlZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzQ2FuY2VsbGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gc2hvcnRjdXRFdmVudDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX2VtaXR0ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX2VtaXR0ZXIgPSBuZXcgZXZlbnRzXzEuRW1pdHRlcigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9lbWl0dGVyLmV2ZW50O1xuICAgIH1cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICBpZiAodGhpcy5fZW1pdHRlcikge1xuICAgICAgICAgICAgdGhpcy5fZW1pdHRlci5kaXNwb3NlKCk7XG4gICAgICAgICAgICB0aGlzLl9lbWl0dGVyID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxufVxuY2xhc3MgQ2FuY2VsbGF0aW9uVG9rZW5Tb3VyY2Uge1xuICAgIGdldCB0b2tlbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLl90b2tlbikge1xuICAgICAgICAgICAgLy8gYmUgbGF6eSBhbmQgY3JlYXRlIHRoZSB0b2tlbiBvbmx5IHdoZW5cbiAgICAgICAgICAgIC8vIGFjdHVhbGx5IG5lZWRlZFxuICAgICAgICAgICAgdGhpcy5fdG9rZW4gPSBuZXcgTXV0YWJsZVRva2VuKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3Rva2VuO1xuICAgIH1cbiAgICBjYW5jZWwoKSB7XG4gICAgICAgIGlmICghdGhpcy5fdG9rZW4pIHtcbiAgICAgICAgICAgIC8vIHNhdmUgYW4gb2JqZWN0IGJ5IHJldHVybmluZyB0aGUgZGVmYXVsdFxuICAgICAgICAgICAgLy8gY2FuY2VsbGVkIHRva2VuIHdoZW4gY2FuY2VsbGF0aW9uIGhhcHBlbnNcbiAgICAgICAgICAgIC8vIGJlZm9yZSBzb21lb25lIGFza3MgZm9yIHRoZSB0b2tlblxuICAgICAgICAgICAgdGhpcy5fdG9rZW4gPSBDYW5jZWxsYXRpb25Ub2tlbi5DYW5jZWxsZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl90b2tlbi5jYW5jZWwoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3Rva2VuKSB7XG4gICAgICAgICAgICAvLyBlbnN1cmUgdG8gaW5pdGlhbGl6ZSB3aXRoIGFuIGVtcHR5IHRva2VuIGlmIHdlIGhhZCBub25lXG4gICAgICAgICAgICB0aGlzLl90b2tlbiA9IENhbmNlbGxhdGlvblRva2VuLk5vbmU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5fdG9rZW4gaW5zdGFuY2VvZiBNdXRhYmxlVG9rZW4pIHtcbiAgICAgICAgICAgIC8vIGFjdHVhbGx5IGRpc3Bvc2VcbiAgICAgICAgICAgIHRoaXMuX3Rva2VuLmRpc3Bvc2UoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuQ2FuY2VsbGF0aW9uVG9rZW5Tb3VyY2UgPSBDYW5jZWxsYXRpb25Ub2tlblNvdXJjZTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNDA1NDpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5jcmVhdGVNZXNzYWdlQ29ubmVjdGlvbiA9IGV4cG9ydHMuQ29ubmVjdGlvbk9wdGlvbnMgPSBleHBvcnRzLk1lc3NhZ2VTdHJhdGVneSA9IGV4cG9ydHMuQ2FuY2VsbGF0aW9uU3RyYXRlZ3kgPSBleHBvcnRzLkNhbmNlbGxhdGlvblNlbmRlclN0cmF0ZWd5ID0gZXhwb3J0cy5DYW5jZWxsYXRpb25SZWNlaXZlclN0cmF0ZWd5ID0gZXhwb3J0cy5SZXF1ZXN0Q2FuY2VsbGF0aW9uUmVjZWl2ZXJTdHJhdGVneSA9IGV4cG9ydHMuSWRDYW5jZWxsYXRpb25SZWNlaXZlclN0cmF0ZWd5ID0gZXhwb3J0cy5Db25uZWN0aW9uU3RyYXRlZ3kgPSBleHBvcnRzLkNvbm5lY3Rpb25FcnJvciA9IGV4cG9ydHMuQ29ubmVjdGlvbkVycm9ycyA9IGV4cG9ydHMuTG9nVHJhY2VOb3RpZmljYXRpb24gPSBleHBvcnRzLlNldFRyYWNlTm90aWZpY2F0aW9uID0gZXhwb3J0cy5UcmFjZUZvcm1hdCA9IGV4cG9ydHMuVHJhY2VWYWx1ZXMgPSBleHBvcnRzLlRyYWNlID0gZXhwb3J0cy5OdWxsTG9nZ2VyID0gZXhwb3J0cy5Qcm9ncmVzc1R5cGUgPSBleHBvcnRzLlByb2dyZXNzVG9rZW4gPSB2b2lkIDA7XG5jb25zdCByYWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNTA5MSk7XG5jb25zdCBJcyA9IF9fd2VicGFja19yZXF1aXJlX18oNjYxOCk7XG5jb25zdCBtZXNzYWdlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MTYyKTtcbmNvbnN0IGxpbmtlZE1hcF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMTA5KTtcbmNvbnN0IGV2ZW50c18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNDc5KTtcbmNvbnN0IGNhbmNlbGxhdGlvbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2OTU3KTtcbnZhciBDYW5jZWxOb3RpZmljYXRpb247XG4oZnVuY3Rpb24gKENhbmNlbE5vdGlmaWNhdGlvbikge1xuICAgIENhbmNlbE5vdGlmaWNhdGlvbi50eXBlID0gbmV3IG1lc3NhZ2VzXzEuTm90aWZpY2F0aW9uVHlwZSgnJC9jYW5jZWxSZXF1ZXN0Jyk7XG59KShDYW5jZWxOb3RpZmljYXRpb24gfHwgKENhbmNlbE5vdGlmaWNhdGlvbiA9IHt9KSk7XG52YXIgUHJvZ3Jlc3NUb2tlbjtcbihmdW5jdGlvbiAoUHJvZ3Jlc3NUb2tlbikge1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcic7XG4gICAgfVxuICAgIFByb2dyZXNzVG9rZW4uaXMgPSBpcztcbn0pKFByb2dyZXNzVG9rZW4gPSBleHBvcnRzLlByb2dyZXNzVG9rZW4gfHwgKGV4cG9ydHMuUHJvZ3Jlc3NUb2tlbiA9IHt9KSk7XG52YXIgUHJvZ3Jlc3NOb3RpZmljYXRpb247XG4oZnVuY3Rpb24gKFByb2dyZXNzTm90aWZpY2F0aW9uKSB7XG4gICAgUHJvZ3Jlc3NOb3RpZmljYXRpb24udHlwZSA9IG5ldyBtZXNzYWdlc18xLk5vdGlmaWNhdGlvblR5cGUoJyQvcHJvZ3Jlc3MnKTtcbn0pKFByb2dyZXNzTm90aWZpY2F0aW9uIHx8IChQcm9ncmVzc05vdGlmaWNhdGlvbiA9IHt9KSk7XG5jbGFzcyBQcm9ncmVzc1R5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgIH1cbn1cbmV4cG9ydHMuUHJvZ3Jlc3NUeXBlID0gUHJvZ3Jlc3NUeXBlO1xudmFyIFN0YXJSZXF1ZXN0SGFuZGxlcjtcbihmdW5jdGlvbiAoU3RhclJlcXVlc3RIYW5kbGVyKSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIElzLmZ1bmModmFsdWUpO1xuICAgIH1cbiAgICBTdGFyUmVxdWVzdEhhbmRsZXIuaXMgPSBpcztcbn0pKFN0YXJSZXF1ZXN0SGFuZGxlciB8fCAoU3RhclJlcXVlc3RIYW5kbGVyID0ge30pKTtcbmV4cG9ydHMuTnVsbExvZ2dlciA9IE9iamVjdC5mcmVlemUoe1xuICAgIGVycm9yOiAoKSA9PiB7IH0sXG4gICAgd2FybjogKCkgPT4geyB9LFxuICAgIGluZm86ICgpID0+IHsgfSxcbiAgICBsb2c6ICgpID0+IHsgfVxufSk7XG52YXIgVHJhY2U7XG4oZnVuY3Rpb24gKFRyYWNlKSB7XG4gICAgVHJhY2VbVHJhY2VbXCJPZmZcIl0gPSAwXSA9IFwiT2ZmXCI7XG4gICAgVHJhY2VbVHJhY2VbXCJNZXNzYWdlc1wiXSA9IDFdID0gXCJNZXNzYWdlc1wiO1xuICAgIFRyYWNlW1RyYWNlW1wiQ29tcGFjdFwiXSA9IDJdID0gXCJDb21wYWN0XCI7XG4gICAgVHJhY2VbVHJhY2VbXCJWZXJib3NlXCJdID0gM10gPSBcIlZlcmJvc2VcIjtcbn0pKFRyYWNlID0gZXhwb3J0cy5UcmFjZSB8fCAoZXhwb3J0cy5UcmFjZSA9IHt9KSk7XG52YXIgVHJhY2VWYWx1ZXM7XG4oZnVuY3Rpb24gKFRyYWNlVmFsdWVzKSB7XG4gICAgLyoqXG4gICAgICogVHVybiB0cmFjaW5nIG9mZi5cbiAgICAgKi9cbiAgICBUcmFjZVZhbHVlcy5PZmYgPSAnb2ZmJztcbiAgICAvKipcbiAgICAgKiBUcmFjZSBtZXNzYWdlcyBvbmx5LlxuICAgICAqL1xuICAgIFRyYWNlVmFsdWVzLk1lc3NhZ2VzID0gJ21lc3NhZ2VzJztcbiAgICAvKipcbiAgICAgKiBDb21wYWN0IG1lc3NhZ2UgdHJhY2luZy5cbiAgICAgKi9cbiAgICBUcmFjZVZhbHVlcy5Db21wYWN0ID0gJ2NvbXBhY3QnO1xuICAgIC8qKlxuICAgICAqIFZlcmJvc2UgbWVzc2FnZSB0cmFjaW5nLlxuICAgICAqL1xuICAgIFRyYWNlVmFsdWVzLlZlcmJvc2UgPSAndmVyYm9zZSc7XG59KShUcmFjZVZhbHVlcyA9IGV4cG9ydHMuVHJhY2VWYWx1ZXMgfHwgKGV4cG9ydHMuVHJhY2VWYWx1ZXMgPSB7fSkpO1xuKGZ1bmN0aW9uIChUcmFjZSkge1xuICAgIGZ1bmN0aW9uIGZyb21TdHJpbmcodmFsdWUpIHtcbiAgICAgICAgaWYgKCFJcy5zdHJpbmcodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gVHJhY2UuT2ZmO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlID0gdmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgc3dpdGNoICh2YWx1ZSkge1xuICAgICAgICAgICAgY2FzZSAnb2ZmJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gVHJhY2UuT2ZmO1xuICAgICAgICAgICAgY2FzZSAnbWVzc2FnZXMnOlxuICAgICAgICAgICAgICAgIHJldHVybiBUcmFjZS5NZXNzYWdlcztcbiAgICAgICAgICAgIGNhc2UgJ2NvbXBhY3QnOlxuICAgICAgICAgICAgICAgIHJldHVybiBUcmFjZS5Db21wYWN0O1xuICAgICAgICAgICAgY2FzZSAndmVyYm9zZSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFRyYWNlLlZlcmJvc2U7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBUcmFjZS5PZmY7XG4gICAgICAgIH1cbiAgICB9XG4gICAgVHJhY2UuZnJvbVN0cmluZyA9IGZyb21TdHJpbmc7XG4gICAgZnVuY3Rpb24gdG9TdHJpbmcodmFsdWUpIHtcbiAgICAgICAgc3dpdGNoICh2YWx1ZSkge1xuICAgICAgICAgICAgY2FzZSBUcmFjZS5PZmY6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdvZmYnO1xuICAgICAgICAgICAgY2FzZSBUcmFjZS5NZXNzYWdlczpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ21lc3NhZ2VzJztcbiAgICAgICAgICAgIGNhc2UgVHJhY2UuQ29tcGFjdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2NvbXBhY3QnO1xuICAgICAgICAgICAgY2FzZSBUcmFjZS5WZXJib3NlOlxuICAgICAgICAgICAgICAgIHJldHVybiAndmVyYm9zZSc7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiAnb2ZmJztcbiAgICAgICAgfVxuICAgIH1cbiAgICBUcmFjZS50b1N0cmluZyA9IHRvU3RyaW5nO1xufSkoVHJhY2UgPSBleHBvcnRzLlRyYWNlIHx8IChleHBvcnRzLlRyYWNlID0ge30pKTtcbnZhciBUcmFjZUZvcm1hdDtcbihmdW5jdGlvbiAoVHJhY2VGb3JtYXQpIHtcbiAgICBUcmFjZUZvcm1hdFtcIlRleHRcIl0gPSBcInRleHRcIjtcbiAgICBUcmFjZUZvcm1hdFtcIkpTT05cIl0gPSBcImpzb25cIjtcbn0pKFRyYWNlRm9ybWF0ID0gZXhwb3J0cy5UcmFjZUZvcm1hdCB8fCAoZXhwb3J0cy5UcmFjZUZvcm1hdCA9IHt9KSk7XG4oZnVuY3Rpb24gKFRyYWNlRm9ybWF0KSB7XG4gICAgZnVuY3Rpb24gZnJvbVN0cmluZyh2YWx1ZSkge1xuICAgICAgICBpZiAoIUlzLnN0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBUcmFjZUZvcm1hdC5UZXh0O1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlID0gdmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKHZhbHVlID09PSAnanNvbicpIHtcbiAgICAgICAgICAgIHJldHVybiBUcmFjZUZvcm1hdC5KU09OO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFRyYWNlRm9ybWF0LlRleHQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgVHJhY2VGb3JtYXQuZnJvbVN0cmluZyA9IGZyb21TdHJpbmc7XG59KShUcmFjZUZvcm1hdCA9IGV4cG9ydHMuVHJhY2VGb3JtYXQgfHwgKGV4cG9ydHMuVHJhY2VGb3JtYXQgPSB7fSkpO1xudmFyIFNldFRyYWNlTm90aWZpY2F0aW9uO1xuKGZ1bmN0aW9uIChTZXRUcmFjZU5vdGlmaWNhdGlvbikge1xuICAgIFNldFRyYWNlTm90aWZpY2F0aW9uLnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Ob3RpZmljYXRpb25UeXBlKCckL3NldFRyYWNlJyk7XG59KShTZXRUcmFjZU5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuU2V0VHJhY2VOb3RpZmljYXRpb24gfHwgKGV4cG9ydHMuU2V0VHJhY2VOb3RpZmljYXRpb24gPSB7fSkpO1xudmFyIExvZ1RyYWNlTm90aWZpY2F0aW9uO1xuKGZ1bmN0aW9uIChMb2dUcmFjZU5vdGlmaWNhdGlvbikge1xuICAgIExvZ1RyYWNlTm90aWZpY2F0aW9uLnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Ob3RpZmljYXRpb25UeXBlKCckL2xvZ1RyYWNlJyk7XG59KShMb2dUcmFjZU5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuTG9nVHJhY2VOb3RpZmljYXRpb24gfHwgKGV4cG9ydHMuTG9nVHJhY2VOb3RpZmljYXRpb24gPSB7fSkpO1xudmFyIENvbm5lY3Rpb25FcnJvcnM7XG4oZnVuY3Rpb24gKENvbm5lY3Rpb25FcnJvcnMpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgY29ubmVjdGlvbiBpcyBjbG9zZWQuXG4gICAgICovXG4gICAgQ29ubmVjdGlvbkVycm9yc1tDb25uZWN0aW9uRXJyb3JzW1wiQ2xvc2VkXCJdID0gMV0gPSBcIkNsb3NlZFwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBjb25uZWN0aW9uIGdvdCBkaXNwb3NlZC5cbiAgICAgKi9cbiAgICBDb25uZWN0aW9uRXJyb3JzW0Nvbm5lY3Rpb25FcnJvcnNbXCJEaXNwb3NlZFwiXSA9IDJdID0gXCJEaXNwb3NlZFwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBjb25uZWN0aW9uIGlzIGFscmVhZHkgaW4gbGlzdGVuaW5nIG1vZGUuXG4gICAgICovXG4gICAgQ29ubmVjdGlvbkVycm9yc1tDb25uZWN0aW9uRXJyb3JzW1wiQWxyZWFkeUxpc3RlbmluZ1wiXSA9IDNdID0gXCJBbHJlYWR5TGlzdGVuaW5nXCI7XG59KShDb25uZWN0aW9uRXJyb3JzID0gZXhwb3J0cy5Db25uZWN0aW9uRXJyb3JzIHx8IChleHBvcnRzLkNvbm5lY3Rpb25FcnJvcnMgPSB7fSkpO1xuY2xhc3MgQ29ubmVjdGlvbkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGNvZGUsIG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBDb25uZWN0aW9uRXJyb3IucHJvdG90eXBlKTtcbiAgICB9XG59XG5leHBvcnRzLkNvbm5lY3Rpb25FcnJvciA9IENvbm5lY3Rpb25FcnJvcjtcbnZhciBDb25uZWN0aW9uU3RyYXRlZ3k7XG4oZnVuY3Rpb24gKENvbm5lY3Rpb25TdHJhdGVneSkge1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICYmIElzLmZ1bmMoY2FuZGlkYXRlLmNhbmNlbFVuZGlzcGF0Y2hlZCk7XG4gICAgfVxuICAgIENvbm5lY3Rpb25TdHJhdGVneS5pcyA9IGlzO1xufSkoQ29ubmVjdGlvblN0cmF0ZWd5ID0gZXhwb3J0cy5Db25uZWN0aW9uU3RyYXRlZ3kgfHwgKGV4cG9ydHMuQ29ubmVjdGlvblN0cmF0ZWd5ID0ge30pKTtcbnZhciBJZENhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3k7XG4oZnVuY3Rpb24gKElkQ2FuY2VsbGF0aW9uUmVjZWl2ZXJTdHJhdGVneSkge1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICYmIChjYW5kaWRhdGUua2luZCA9PT0gdW5kZWZpbmVkIHx8IGNhbmRpZGF0ZS5raW5kID09PSAnaWQnKSAmJiBJcy5mdW5jKGNhbmRpZGF0ZS5jcmVhdGVDYW5jZWxsYXRpb25Ub2tlblNvdXJjZSkgJiYgKGNhbmRpZGF0ZS5kaXNwb3NlID09PSB1bmRlZmluZWQgfHwgSXMuZnVuYyhjYW5kaWRhdGUuZGlzcG9zZSkpO1xuICAgIH1cbiAgICBJZENhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kuaXMgPSBpcztcbn0pKElkQ2FuY2VsbGF0aW9uUmVjZWl2ZXJTdHJhdGVneSA9IGV4cG9ydHMuSWRDYW5jZWxsYXRpb25SZWNlaXZlclN0cmF0ZWd5IHx8IChleHBvcnRzLklkQ2FuY2VsbGF0aW9uUmVjZWl2ZXJTdHJhdGVneSA9IHt9KSk7XG52YXIgUmVxdWVzdENhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3k7XG4oZnVuY3Rpb24gKFJlcXVlc3RDYW5jZWxsYXRpb25SZWNlaXZlclN0cmF0ZWd5KSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgJiYgY2FuZGlkYXRlLmtpbmQgPT09ICdyZXF1ZXN0JyAmJiBJcy5mdW5jKGNhbmRpZGF0ZS5jcmVhdGVDYW5jZWxsYXRpb25Ub2tlblNvdXJjZSkgJiYgKGNhbmRpZGF0ZS5kaXNwb3NlID09PSB1bmRlZmluZWQgfHwgSXMuZnVuYyhjYW5kaWRhdGUuZGlzcG9zZSkpO1xuICAgIH1cbiAgICBSZXF1ZXN0Q2FuY2VsbGF0aW9uUmVjZWl2ZXJTdHJhdGVneS5pcyA9IGlzO1xufSkoUmVxdWVzdENhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kgPSBleHBvcnRzLlJlcXVlc3RDYW5jZWxsYXRpb25SZWNlaXZlclN0cmF0ZWd5IHx8IChleHBvcnRzLlJlcXVlc3RDYW5jZWxsYXRpb25SZWNlaXZlclN0cmF0ZWd5ID0ge30pKTtcbnZhciBDYW5jZWxsYXRpb25SZWNlaXZlclN0cmF0ZWd5O1xuKGZ1bmN0aW9uIChDYW5jZWxsYXRpb25SZWNlaXZlclN0cmF0ZWd5KSB7XG4gICAgQ2FuY2VsbGF0aW9uUmVjZWl2ZXJTdHJhdGVneS5NZXNzYWdlID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIGNyZWF0ZUNhbmNlbGxhdGlvblRva2VuU291cmNlKF8pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgY2FuY2VsbGF0aW9uXzEuQ2FuY2VsbGF0aW9uVG9rZW5Tb3VyY2UoKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBJZENhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kuaXModmFsdWUpIHx8IFJlcXVlc3RDYW5jZWxsYXRpb25SZWNlaXZlclN0cmF0ZWd5LmlzKHZhbHVlKTtcbiAgICB9XG4gICAgQ2FuY2VsbGF0aW9uUmVjZWl2ZXJTdHJhdGVneS5pcyA9IGlzO1xufSkoQ2FuY2VsbGF0aW9uUmVjZWl2ZXJTdHJhdGVneSA9IGV4cG9ydHMuQ2FuY2VsbGF0aW9uUmVjZWl2ZXJTdHJhdGVneSB8fCAoZXhwb3J0cy5DYW5jZWxsYXRpb25SZWNlaXZlclN0cmF0ZWd5ID0ge30pKTtcbnZhciBDYW5jZWxsYXRpb25TZW5kZXJTdHJhdGVneTtcbihmdW5jdGlvbiAoQ2FuY2VsbGF0aW9uU2VuZGVyU3RyYXRlZ3kpIHtcbiAgICBDYW5jZWxsYXRpb25TZW5kZXJTdHJhdGVneS5NZXNzYWdlID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIHNlbmRDYW5jZWxsYXRpb24oY29ubiwgaWQpIHtcbiAgICAgICAgICAgIHJldHVybiBjb25uLnNlbmROb3RpZmljYXRpb24oQ2FuY2VsTm90aWZpY2F0aW9uLnR5cGUsIHsgaWQgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGNsZWFudXAoXykgeyB9XG4gICAgfSk7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgJiYgSXMuZnVuYyhjYW5kaWRhdGUuc2VuZENhbmNlbGxhdGlvbikgJiYgSXMuZnVuYyhjYW5kaWRhdGUuY2xlYW51cCk7XG4gICAgfVxuICAgIENhbmNlbGxhdGlvblNlbmRlclN0cmF0ZWd5LmlzID0gaXM7XG59KShDYW5jZWxsYXRpb25TZW5kZXJTdHJhdGVneSA9IGV4cG9ydHMuQ2FuY2VsbGF0aW9uU2VuZGVyU3RyYXRlZ3kgfHwgKGV4cG9ydHMuQ2FuY2VsbGF0aW9uU2VuZGVyU3RyYXRlZ3kgPSB7fSkpO1xudmFyIENhbmNlbGxhdGlvblN0cmF0ZWd5O1xuKGZ1bmN0aW9uIChDYW5jZWxsYXRpb25TdHJhdGVneSkge1xuICAgIENhbmNlbGxhdGlvblN0cmF0ZWd5Lk1lc3NhZ2UgPSBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgcmVjZWl2ZXI6IENhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kuTWVzc2FnZSxcbiAgICAgICAgc2VuZGVyOiBDYW5jZWxsYXRpb25TZW5kZXJTdHJhdGVneS5NZXNzYWdlXG4gICAgfSk7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgJiYgQ2FuY2VsbGF0aW9uUmVjZWl2ZXJTdHJhdGVneS5pcyhjYW5kaWRhdGUucmVjZWl2ZXIpICYmIENhbmNlbGxhdGlvblNlbmRlclN0cmF0ZWd5LmlzKGNhbmRpZGF0ZS5zZW5kZXIpO1xuICAgIH1cbiAgICBDYW5jZWxsYXRpb25TdHJhdGVneS5pcyA9IGlzO1xufSkoQ2FuY2VsbGF0aW9uU3RyYXRlZ3kgPSBleHBvcnRzLkNhbmNlbGxhdGlvblN0cmF0ZWd5IHx8IChleHBvcnRzLkNhbmNlbGxhdGlvblN0cmF0ZWd5ID0ge30pKTtcbnZhciBNZXNzYWdlU3RyYXRlZ3k7XG4oZnVuY3Rpb24gKE1lc3NhZ2VTdHJhdGVneSkge1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICYmIElzLmZ1bmMoY2FuZGlkYXRlLmhhbmRsZU1lc3NhZ2UpO1xuICAgIH1cbiAgICBNZXNzYWdlU3RyYXRlZ3kuaXMgPSBpcztcbn0pKE1lc3NhZ2VTdHJhdGVneSA9IGV4cG9ydHMuTWVzc2FnZVN0cmF0ZWd5IHx8IChleHBvcnRzLk1lc3NhZ2VTdHJhdGVneSA9IHt9KSk7XG52YXIgQ29ubmVjdGlvbk9wdGlvbnM7XG4oZnVuY3Rpb24gKENvbm5lY3Rpb25PcHRpb25zKSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgJiYgKENhbmNlbGxhdGlvblN0cmF0ZWd5LmlzKGNhbmRpZGF0ZS5jYW5jZWxsYXRpb25TdHJhdGVneSkgfHwgQ29ubmVjdGlvblN0cmF0ZWd5LmlzKGNhbmRpZGF0ZS5jb25uZWN0aW9uU3RyYXRlZ3kpIHx8IE1lc3NhZ2VTdHJhdGVneS5pcyhjYW5kaWRhdGUubWVzc2FnZVN0cmF0ZWd5KSk7XG4gICAgfVxuICAgIENvbm5lY3Rpb25PcHRpb25zLmlzID0gaXM7XG59KShDb25uZWN0aW9uT3B0aW9ucyA9IGV4cG9ydHMuQ29ubmVjdGlvbk9wdGlvbnMgfHwgKGV4cG9ydHMuQ29ubmVjdGlvbk9wdGlvbnMgPSB7fSkpO1xudmFyIENvbm5lY3Rpb25TdGF0ZTtcbihmdW5jdGlvbiAoQ29ubmVjdGlvblN0YXRlKSB7XG4gICAgQ29ubmVjdGlvblN0YXRlW0Nvbm5lY3Rpb25TdGF0ZVtcIk5ld1wiXSA9IDFdID0gXCJOZXdcIjtcbiAgICBDb25uZWN0aW9uU3RhdGVbQ29ubmVjdGlvblN0YXRlW1wiTGlzdGVuaW5nXCJdID0gMl0gPSBcIkxpc3RlbmluZ1wiO1xuICAgIENvbm5lY3Rpb25TdGF0ZVtDb25uZWN0aW9uU3RhdGVbXCJDbG9zZWRcIl0gPSAzXSA9IFwiQ2xvc2VkXCI7XG4gICAgQ29ubmVjdGlvblN0YXRlW0Nvbm5lY3Rpb25TdGF0ZVtcIkRpc3Bvc2VkXCJdID0gNF0gPSBcIkRpc3Bvc2VkXCI7XG59KShDb25uZWN0aW9uU3RhdGUgfHwgKENvbm5lY3Rpb25TdGF0ZSA9IHt9KSk7XG5mdW5jdGlvbiBjcmVhdGVNZXNzYWdlQ29ubmVjdGlvbihtZXNzYWdlUmVhZGVyLCBtZXNzYWdlV3JpdGVyLCBfbG9nZ2VyLCBvcHRpb25zKSB7XG4gICAgY29uc3QgbG9nZ2VyID0gX2xvZ2dlciAhPT0gdW5kZWZpbmVkID8gX2xvZ2dlciA6IGV4cG9ydHMuTnVsbExvZ2dlcjtcbiAgICBsZXQgc2VxdWVuY2VOdW1iZXIgPSAwO1xuICAgIGxldCBub3RpZmljYXRpb25TZXF1ZW5jZU51bWJlciA9IDA7XG4gICAgbGV0IHVua25vd25SZXNwb25zZVNlcXVlbmNlTnVtYmVyID0gMDtcbiAgICBjb25zdCB2ZXJzaW9uID0gJzIuMCc7XG4gICAgbGV0IHN0YXJSZXF1ZXN0SGFuZGxlciA9IHVuZGVmaW5lZDtcbiAgICBjb25zdCByZXF1ZXN0SGFuZGxlcnMgPSBuZXcgTWFwKCk7XG4gICAgbGV0IHN0YXJOb3RpZmljYXRpb25IYW5kbGVyID0gdW5kZWZpbmVkO1xuICAgIGNvbnN0IG5vdGlmaWNhdGlvbkhhbmRsZXJzID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IHByb2dyZXNzSGFuZGxlcnMgPSBuZXcgTWFwKCk7XG4gICAgbGV0IHRpbWVyO1xuICAgIGxldCBtZXNzYWdlUXVldWUgPSBuZXcgbGlua2VkTWFwXzEuTGlua2VkTWFwKCk7XG4gICAgbGV0IHJlc3BvbnNlUHJvbWlzZXMgPSBuZXcgTWFwKCk7XG4gICAgbGV0IGtub3duQ2FuY2VsZWRSZXF1ZXN0cyA9IG5ldyBTZXQoKTtcbiAgICBsZXQgcmVxdWVzdFRva2VucyA9IG5ldyBNYXAoKTtcbiAgICBsZXQgdHJhY2UgPSBUcmFjZS5PZmY7XG4gICAgbGV0IHRyYWNlRm9ybWF0ID0gVHJhY2VGb3JtYXQuVGV4dDtcbiAgICBsZXQgdHJhY2VyO1xuICAgIGxldCBzdGF0ZSA9IENvbm5lY3Rpb25TdGF0ZS5OZXc7XG4gICAgY29uc3QgZXJyb3JFbWl0dGVyID0gbmV3IGV2ZW50c18xLkVtaXR0ZXIoKTtcbiAgICBjb25zdCBjbG9zZUVtaXR0ZXIgPSBuZXcgZXZlbnRzXzEuRW1pdHRlcigpO1xuICAgIGNvbnN0IHVuaGFuZGxlZE5vdGlmaWNhdGlvbkVtaXR0ZXIgPSBuZXcgZXZlbnRzXzEuRW1pdHRlcigpO1xuICAgIGNvbnN0IHVuaGFuZGxlZFByb2dyZXNzRW1pdHRlciA9IG5ldyBldmVudHNfMS5FbWl0dGVyKCk7XG4gICAgY29uc3QgZGlzcG9zZUVtaXR0ZXIgPSBuZXcgZXZlbnRzXzEuRW1pdHRlcigpO1xuICAgIGNvbnN0IGNhbmNlbGxhdGlvblN0cmF0ZWd5ID0gKG9wdGlvbnMgJiYgb3B0aW9ucy5jYW5jZWxsYXRpb25TdHJhdGVneSkgPyBvcHRpb25zLmNhbmNlbGxhdGlvblN0cmF0ZWd5IDogQ2FuY2VsbGF0aW9uU3RyYXRlZ3kuTWVzc2FnZTtcbiAgICBmdW5jdGlvbiBjcmVhdGVSZXF1ZXN0UXVldWVLZXkoaWQpIHtcbiAgICAgICAgaWYgKGlkID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbid0IHNlbmQgcmVxdWVzdHMgd2l0aCBpZCBudWxsIHNpbmNlIHRoZSByZXNwb25zZSBjYW4ndCBiZSBjb3JyZWxhdGVkLmApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAncmVxLScgKyBpZC50b1N0cmluZygpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVSZXNwb25zZVF1ZXVlS2V5KGlkKSB7XG4gICAgICAgIGlmIChpZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuICdyZXMtdW5rbm93bi0nICsgKCsrdW5rbm93blJlc3BvbnNlU2VxdWVuY2VOdW1iZXIpLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gJ3Jlcy0nICsgaWQudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVOb3RpZmljYXRpb25RdWV1ZUtleSgpIHtcbiAgICAgICAgcmV0dXJuICdub3QtJyArICgrK25vdGlmaWNhdGlvblNlcXVlbmNlTnVtYmVyKS50b1N0cmluZygpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhZGRNZXNzYWdlVG9RdWV1ZShxdWV1ZSwgbWVzc2FnZSkge1xuICAgICAgICBpZiAobWVzc2FnZXNfMS5NZXNzYWdlLmlzUmVxdWVzdChtZXNzYWdlKSkge1xuICAgICAgICAgICAgcXVldWUuc2V0KGNyZWF0ZVJlcXVlc3RRdWV1ZUtleShtZXNzYWdlLmlkKSwgbWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobWVzc2FnZXNfMS5NZXNzYWdlLmlzUmVzcG9uc2UobWVzc2FnZSkpIHtcbiAgICAgICAgICAgIHF1ZXVlLnNldChjcmVhdGVSZXNwb25zZVF1ZXVlS2V5KG1lc3NhZ2UuaWQpLCBtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHF1ZXVlLnNldChjcmVhdGVOb3RpZmljYXRpb25RdWV1ZUtleSgpLCBtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjYW5jZWxVbmRpc3BhdGNoZWQoX21lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNMaXN0ZW5pbmcoKSB7XG4gICAgICAgIHJldHVybiBzdGF0ZSA9PT0gQ29ubmVjdGlvblN0YXRlLkxpc3RlbmluZztcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNDbG9zZWQoKSB7XG4gICAgICAgIHJldHVybiBzdGF0ZSA9PT0gQ29ubmVjdGlvblN0YXRlLkNsb3NlZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNEaXNwb3NlZCgpIHtcbiAgICAgICAgcmV0dXJuIHN0YXRlID09PSBDb25uZWN0aW9uU3RhdGUuRGlzcG9zZWQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNsb3NlSGFuZGxlcigpIHtcbiAgICAgICAgaWYgKHN0YXRlID09PSBDb25uZWN0aW9uU3RhdGUuTmV3IHx8IHN0YXRlID09PSBDb25uZWN0aW9uU3RhdGUuTGlzdGVuaW5nKSB7XG4gICAgICAgICAgICBzdGF0ZSA9IENvbm5lY3Rpb25TdGF0ZS5DbG9zZWQ7XG4gICAgICAgICAgICBjbG9zZUVtaXR0ZXIuZmlyZSh1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZSBjb25uZWN0aW9uIGlzIGRpc3Bvc2VkIGRvbid0IHNlbnQgY2xvc2UgZXZlbnRzLlxuICAgIH1cbiAgICBmdW5jdGlvbiByZWFkRXJyb3JIYW5kbGVyKGVycm9yKSB7XG4gICAgICAgIGVycm9yRW1pdHRlci5maXJlKFtlcnJvciwgdW5kZWZpbmVkLCB1bmRlZmluZWRdKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gd3JpdGVFcnJvckhhbmRsZXIoZGF0YSkge1xuICAgICAgICBlcnJvckVtaXR0ZXIuZmlyZShkYXRhKTtcbiAgICB9XG4gICAgbWVzc2FnZVJlYWRlci5vbkNsb3NlKGNsb3NlSGFuZGxlcik7XG4gICAgbWVzc2FnZVJlYWRlci5vbkVycm9yKHJlYWRFcnJvckhhbmRsZXIpO1xuICAgIG1lc3NhZ2VXcml0ZXIub25DbG9zZShjbG9zZUhhbmRsZXIpO1xuICAgIG1lc3NhZ2VXcml0ZXIub25FcnJvcih3cml0ZUVycm9ySGFuZGxlcik7XG4gICAgZnVuY3Rpb24gdHJpZ2dlck1lc3NhZ2VRdWV1ZSgpIHtcbiAgICAgICAgaWYgKHRpbWVyIHx8IG1lc3NhZ2VRdWV1ZS5zaXplID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGltZXIgPSAoMCwgcmFsXzEuZGVmYXVsdCkoKS50aW1lci5zZXRJbW1lZGlhdGUoKCkgPT4ge1xuICAgICAgICAgICAgdGltZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBwcm9jZXNzTWVzc2FnZVF1ZXVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoYW5kbGVNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2VzXzEuTWVzc2FnZS5pc1JlcXVlc3QobWVzc2FnZSkpIHtcbiAgICAgICAgICAgIGhhbmRsZVJlcXVlc3QobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobWVzc2FnZXNfMS5NZXNzYWdlLmlzTm90aWZpY2F0aW9uKG1lc3NhZ2UpKSB7XG4gICAgICAgICAgICBoYW5kbGVOb3RpZmljYXRpb24obWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobWVzc2FnZXNfMS5NZXNzYWdlLmlzUmVzcG9uc2UobWVzc2FnZSkpIHtcbiAgICAgICAgICAgIGhhbmRsZVJlc3BvbnNlKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaGFuZGxlSW52YWxpZE1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcHJvY2Vzc01lc3NhZ2VRdWV1ZSgpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2VRdWV1ZS5zaXplID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IG1lc3NhZ2VRdWV1ZS5zaGlmdCgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgbWVzc2FnZVN0cmF0ZWd5ID0gb3B0aW9ucz8ubWVzc2FnZVN0cmF0ZWd5O1xuICAgICAgICAgICAgaWYgKE1lc3NhZ2VTdHJhdGVneS5pcyhtZXNzYWdlU3RyYXRlZ3kpKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZVN0cmF0ZWd5LmhhbmRsZU1lc3NhZ2UobWVzc2FnZSwgaGFuZGxlTWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVNZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdHJpZ2dlck1lc3NhZ2VRdWV1ZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGNhbGxiYWNrID0gKG1lc3NhZ2UpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdlIGhhdmUgcmVjZWl2ZWQgYSBjYW5jZWxsYXRpb24gbWVzc2FnZS4gQ2hlY2sgaWYgdGhlIG1lc3NhZ2UgaXMgc3RpbGwgaW4gdGhlIHF1ZXVlXG4gICAgICAgICAgICAvLyBhbmQgY2FuY2VsIGl0IGlmIGFsbG93ZWQgdG8gZG8gc28uXG4gICAgICAgICAgICBpZiAobWVzc2FnZXNfMS5NZXNzYWdlLmlzTm90aWZpY2F0aW9uKG1lc3NhZ2UpICYmIG1lc3NhZ2UubWV0aG9kID09PSBDYW5jZWxOb3RpZmljYXRpb24udHlwZS5tZXRob2QpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjYW5jZWxJZCA9IG1lc3NhZ2UucGFyYW1zLmlkO1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IGNyZWF0ZVJlcXVlc3RRdWV1ZUtleShjYW5jZWxJZCk7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9DYW5jZWwgPSBtZXNzYWdlUXVldWUuZ2V0KGtleSk7XG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2VzXzEuTWVzc2FnZS5pc1JlcXVlc3QodG9DYW5jZWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0cmF0ZWd5ID0gb3B0aW9ucz8uY29ubmVjdGlvblN0cmF0ZWd5O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IChzdHJhdGVneSAmJiBzdHJhdGVneS5jYW5jZWxVbmRpc3BhdGNoZWQpID8gc3RyYXRlZ3kuY2FuY2VsVW5kaXNwYXRjaGVkKHRvQ2FuY2VsLCBjYW5jZWxVbmRpc3BhdGNoZWQpIDogY2FuY2VsVW5kaXNwYXRjaGVkKHRvQ2FuY2VsKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlICYmIChyZXNwb25zZS5lcnJvciAhPT0gdW5kZWZpbmVkIHx8IHJlc3BvbnNlLnJlc3VsdCAhPT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZVF1ZXVlLmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdFRva2Vucy5kZWxldGUoY2FuY2VsSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UuaWQgPSB0b0NhbmNlbC5pZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNlU2VuZGluZ1Jlc3BvbnNlKHJlc3BvbnNlLCBtZXNzYWdlLm1ldGhvZCwgRGF0ZS5ub3coKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlV3JpdGVyLndyaXRlKHJlc3BvbnNlKS5jYXRjaCgoKSA9PiBsb2dnZXIuZXJyb3IoYFNlbmRpbmcgcmVzcG9uc2UgZm9yIGNhbmNlbGVkIG1lc3NhZ2UgZmFpbGVkLmApKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBjYW5jZWxsYXRpb25Ub2tlbiA9IHJlcXVlc3RUb2tlbnMuZ2V0KGNhbmNlbElkKTtcbiAgICAgICAgICAgICAgICAvLyBUaGUgcmVxdWVzdCBpcyBhbHJlYWR5IHJ1bm5pbmcuIENhbmNlbCB0aGUgdG9rZW5cbiAgICAgICAgICAgICAgICBpZiAoY2FuY2VsbGF0aW9uVG9rZW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBjYW5jZWxsYXRpb25Ub2tlbi5jYW5jZWwoKTtcbiAgICAgICAgICAgICAgICAgICAgdHJhY2VSZWNlaXZlZE5vdGlmaWNhdGlvbihtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVtZW1iZXIgdGhlIGNhbmNlbCBidXQgc3RpbGwgcXVldWUgdGhlIG1lc3NhZ2UgdG9cbiAgICAgICAgICAgICAgICAgICAgLy8gY2xlYW4gdXAgc3RhdGUgaW4gcHJvY2VzcyBtZXNzYWdlLlxuICAgICAgICAgICAgICAgICAgICBrbm93bkNhbmNlbGVkUmVxdWVzdHMuYWRkKGNhbmNlbElkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhZGRNZXNzYWdlVG9RdWV1ZShtZXNzYWdlUXVldWUsIG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdHJpZ2dlck1lc3NhZ2VRdWV1ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBmdW5jdGlvbiBoYW5kbGVSZXF1ZXN0KHJlcXVlc3RNZXNzYWdlKSB7XG4gICAgICAgIGlmIChpc0Rpc3Bvc2VkKCkpIHtcbiAgICAgICAgICAgIC8vIHdlIHJldHVybiBoZXJlIHNpbGVudGx5IHNpbmNlIHdlIGZpcmVkIGFuIGV2ZW50IHdoZW4gdGhlXG4gICAgICAgICAgICAvLyBjb25uZWN0aW9uIGdvdCBkaXNwb3NlZC5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiByZXBseShyZXN1bHRPckVycm9yLCBtZXRob2QsIHN0YXJ0VGltZSkge1xuICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IHtcbiAgICAgICAgICAgICAgICBqc29ucnBjOiB2ZXJzaW9uLFxuICAgICAgICAgICAgICAgIGlkOiByZXF1ZXN0TWVzc2FnZS5pZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChyZXN1bHRPckVycm9yIGluc3RhbmNlb2YgbWVzc2FnZXNfMS5SZXNwb25zZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5lcnJvciA9IHJlc3VsdE9yRXJyb3IudG9Kc29uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnJlc3VsdCA9IHJlc3VsdE9yRXJyb3IgPT09IHVuZGVmaW5lZCA/IG51bGwgOiByZXN1bHRPckVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJhY2VTZW5kaW5nUmVzcG9uc2UobWVzc2FnZSwgbWV0aG9kLCBzdGFydFRpbWUpO1xuICAgICAgICAgICAgbWVzc2FnZVdyaXRlci53cml0ZShtZXNzYWdlKS5jYXRjaCgoKSA9PiBsb2dnZXIuZXJyb3IoYFNlbmRpbmcgcmVzcG9uc2UgZmFpbGVkLmApKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiByZXBseUVycm9yKGVycm9yLCBtZXRob2QsIHN0YXJ0VGltZSkge1xuICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IHtcbiAgICAgICAgICAgICAgICBqc29ucnBjOiB2ZXJzaW9uLFxuICAgICAgICAgICAgICAgIGlkOiByZXF1ZXN0TWVzc2FnZS5pZCxcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3IudG9Kc29uKClcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0cmFjZVNlbmRpbmdSZXNwb25zZShtZXNzYWdlLCBtZXRob2QsIHN0YXJ0VGltZSk7XG4gICAgICAgICAgICBtZXNzYWdlV3JpdGVyLndyaXRlKG1lc3NhZ2UpLmNhdGNoKCgpID0+IGxvZ2dlci5lcnJvcihgU2VuZGluZyByZXNwb25zZSBmYWlsZWQuYCkpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHJlcGx5U3VjY2VzcyhyZXN1bHQsIG1ldGhvZCwgc3RhcnRUaW1lKSB7XG4gICAgICAgICAgICAvLyBUaGUgSlNPTiBSUEMgZGVmaW5lcyB0aGF0IGEgcmVzcG9uc2UgbXVzdCBlaXRoZXIgaGF2ZSBhIHJlc3VsdCBvciBhbiBlcnJvclxuICAgICAgICAgICAgLy8gU28gd2UgY2FuJ3QgdHJlYXQgdW5kZWZpbmVkIGFzIGEgdmFsaWQgcmVzcG9uc2UgcmVzdWx0LlxuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSB7XG4gICAgICAgICAgICAgICAganNvbnJwYzogdmVyc2lvbixcbiAgICAgICAgICAgICAgICBpZDogcmVxdWVzdE1lc3NhZ2UuaWQsXG4gICAgICAgICAgICAgICAgcmVzdWx0OiByZXN1bHRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0cmFjZVNlbmRpbmdSZXNwb25zZShtZXNzYWdlLCBtZXRob2QsIHN0YXJ0VGltZSk7XG4gICAgICAgICAgICBtZXNzYWdlV3JpdGVyLndyaXRlKG1lc3NhZ2UpLmNhdGNoKCgpID0+IGxvZ2dlci5lcnJvcihgU2VuZGluZyByZXNwb25zZSBmYWlsZWQuYCkpO1xuICAgICAgICB9XG4gICAgICAgIHRyYWNlUmVjZWl2ZWRSZXF1ZXN0KHJlcXVlc3RNZXNzYWdlKTtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IHJlcXVlc3RIYW5kbGVycy5nZXQocmVxdWVzdE1lc3NhZ2UubWV0aG9kKTtcbiAgICAgICAgbGV0IHR5cGU7XG4gICAgICAgIGxldCByZXF1ZXN0SGFuZGxlcjtcbiAgICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIHR5cGUgPSBlbGVtZW50LnR5cGU7XG4gICAgICAgICAgICByZXF1ZXN0SGFuZGxlciA9IGVsZW1lbnQuaGFuZGxlcjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICBpZiAocmVxdWVzdEhhbmRsZXIgfHwgc3RhclJlcXVlc3RIYW5kbGVyKSB7XG4gICAgICAgICAgICBjb25zdCB0b2tlbktleSA9IHJlcXVlc3RNZXNzYWdlLmlkID8/IFN0cmluZyhEYXRlLm5vdygpKTsgLy9cbiAgICAgICAgICAgIGNvbnN0IGNhbmNlbGxhdGlvblNvdXJjZSA9IElkQ2FuY2VsbGF0aW9uUmVjZWl2ZXJTdHJhdGVneS5pcyhjYW5jZWxsYXRpb25TdHJhdGVneS5yZWNlaXZlcilcbiAgICAgICAgICAgICAgICA/IGNhbmNlbGxhdGlvblN0cmF0ZWd5LnJlY2VpdmVyLmNyZWF0ZUNhbmNlbGxhdGlvblRva2VuU291cmNlKHRva2VuS2V5KVxuICAgICAgICAgICAgICAgIDogY2FuY2VsbGF0aW9uU3RyYXRlZ3kucmVjZWl2ZXIuY3JlYXRlQ2FuY2VsbGF0aW9uVG9rZW5Tb3VyY2UocmVxdWVzdE1lc3NhZ2UpO1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RNZXNzYWdlLmlkICE9PSBudWxsICYmIGtub3duQ2FuY2VsZWRSZXF1ZXN0cy5oYXMocmVxdWVzdE1lc3NhZ2UuaWQpKSB7XG4gICAgICAgICAgICAgICAgY2FuY2VsbGF0aW9uU291cmNlLmNhbmNlbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RNZXNzYWdlLmlkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdFRva2Vucy5zZXQodG9rZW5LZXksIGNhbmNlbGxhdGlvblNvdXJjZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGxldCBoYW5kbGVyUmVzdWx0O1xuICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0SGFuZGxlcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVxdWVzdE1lc3NhZ2UucGFyYW1zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlICE9PSB1bmRlZmluZWQgJiYgdHlwZS5udW1iZXJPZlBhcmFtcyAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcGx5RXJyb3IobmV3IG1lc3NhZ2VzXzEuUmVzcG9uc2VFcnJvcihtZXNzYWdlc18xLkVycm9yQ29kZXMuSW52YWxpZFBhcmFtcywgYFJlcXVlc3QgJHtyZXF1ZXN0TWVzc2FnZS5tZXRob2R9IGRlZmluZXMgJHt0eXBlLm51bWJlck9mUGFyYW1zfSBwYXJhbXMgYnV0IHJlY2VpdmVkIG5vbmUuYCksIHJlcXVlc3RNZXNzYWdlLm1ldGhvZCwgc3RhcnRUaW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVyUmVzdWx0ID0gcmVxdWVzdEhhbmRsZXIoY2FuY2VsbGF0aW9uU291cmNlLnRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHJlcXVlc3RNZXNzYWdlLnBhcmFtcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlICE9PSB1bmRlZmluZWQgJiYgdHlwZS5wYXJhbWV0ZXJTdHJ1Y3R1cmVzID09PSBtZXNzYWdlc18xLlBhcmFtZXRlclN0cnVjdHVyZXMuYnlOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVwbHlFcnJvcihuZXcgbWVzc2FnZXNfMS5SZXNwb25zZUVycm9yKG1lc3NhZ2VzXzEuRXJyb3JDb2Rlcy5JbnZhbGlkUGFyYW1zLCBgUmVxdWVzdCAke3JlcXVlc3RNZXNzYWdlLm1ldGhvZH0gZGVmaW5lcyBwYXJhbWV0ZXJzIGJ5IG5hbWUgYnV0IHJlY2VpdmVkIHBhcmFtZXRlcnMgYnkgcG9zaXRpb25gKSwgcmVxdWVzdE1lc3NhZ2UubWV0aG9kLCBzdGFydFRpbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXJSZXN1bHQgPSByZXF1ZXN0SGFuZGxlciguLi5yZXF1ZXN0TWVzc2FnZS5wYXJhbXMsIGNhbmNlbGxhdGlvblNvdXJjZS50b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSAhPT0gdW5kZWZpbmVkICYmIHR5cGUucGFyYW1ldGVyU3RydWN0dXJlcyA9PT0gbWVzc2FnZXNfMS5QYXJhbWV0ZXJTdHJ1Y3R1cmVzLmJ5UG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXBseUVycm9yKG5ldyBtZXNzYWdlc18xLlJlc3BvbnNlRXJyb3IobWVzc2FnZXNfMS5FcnJvckNvZGVzLkludmFsaWRQYXJhbXMsIGBSZXF1ZXN0ICR7cmVxdWVzdE1lc3NhZ2UubWV0aG9kfSBkZWZpbmVzIHBhcmFtZXRlcnMgYnkgcG9zaXRpb24gYnV0IHJlY2VpdmVkIHBhcmFtZXRlcnMgYnkgbmFtZWApLCByZXF1ZXN0TWVzc2FnZS5tZXRob2QsIHN0YXJ0VGltZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlclJlc3VsdCA9IHJlcXVlc3RIYW5kbGVyKHJlcXVlc3RNZXNzYWdlLnBhcmFtcywgY2FuY2VsbGF0aW9uU291cmNlLnRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzdGFyUmVxdWVzdEhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlclJlc3VsdCA9IHN0YXJSZXF1ZXN0SGFuZGxlcihyZXF1ZXN0TWVzc2FnZS5tZXRob2QsIHJlcXVlc3RNZXNzYWdlLnBhcmFtcywgY2FuY2VsbGF0aW9uU291cmNlLnRva2VuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvbWlzZSA9IGhhbmRsZXJSZXN1bHQ7XG4gICAgICAgICAgICAgICAgaWYgKCFoYW5kbGVyUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3RUb2tlbnMuZGVsZXRlKHRva2VuS2V5KTtcbiAgICAgICAgICAgICAgICAgICAgcmVwbHlTdWNjZXNzKGhhbmRsZXJSZXN1bHQsIHJlcXVlc3RNZXNzYWdlLm1ldGhvZCwgc3RhcnRUaW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocHJvbWlzZS50aGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb21pc2UudGhlbigocmVzdWx0T3JFcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdFRva2Vucy5kZWxldGUodG9rZW5LZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVwbHkocmVzdWx0T3JFcnJvciwgcmVxdWVzdE1lc3NhZ2UubWV0aG9kLCBzdGFydFRpbWUpO1xuICAgICAgICAgICAgICAgICAgICB9LCBlcnJvciA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0VG9rZW5zLmRlbGV0ZSh0b2tlbktleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBtZXNzYWdlc18xLlJlc3BvbnNlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXBseUVycm9yKGVycm9yLCByZXF1ZXN0TWVzc2FnZS5tZXRob2QsIHN0YXJ0VGltZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChlcnJvciAmJiBJcy5zdHJpbmcoZXJyb3IubWVzc2FnZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXBseUVycm9yKG5ldyBtZXNzYWdlc18xLlJlc3BvbnNlRXJyb3IobWVzc2FnZXNfMS5FcnJvckNvZGVzLkludGVybmFsRXJyb3IsIGBSZXF1ZXN0ICR7cmVxdWVzdE1lc3NhZ2UubWV0aG9kfSBmYWlsZWQgd2l0aCBtZXNzYWdlOiAke2Vycm9yLm1lc3NhZ2V9YCksIHJlcXVlc3RNZXNzYWdlLm1ldGhvZCwgc3RhcnRUaW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcGx5RXJyb3IobmV3IG1lc3NhZ2VzXzEuUmVzcG9uc2VFcnJvcihtZXNzYWdlc18xLkVycm9yQ29kZXMuSW50ZXJuYWxFcnJvciwgYFJlcXVlc3QgJHtyZXF1ZXN0TWVzc2FnZS5tZXRob2R9IGZhaWxlZCB1bmV4cGVjdGVkbHkgd2l0aG91dCBwcm92aWRpbmcgYW55IGRldGFpbHMuYCksIHJlcXVlc3RNZXNzYWdlLm1ldGhvZCwgc3RhcnRUaW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0VG9rZW5zLmRlbGV0ZSh0b2tlbktleSk7XG4gICAgICAgICAgICAgICAgICAgIHJlcGx5KGhhbmRsZXJSZXN1bHQsIHJlcXVlc3RNZXNzYWdlLm1ldGhvZCwgc3RhcnRUaW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0VG9rZW5zLmRlbGV0ZSh0b2tlbktleSk7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgbWVzc2FnZXNfMS5SZXNwb25zZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcGx5KGVycm9yLCByZXF1ZXN0TWVzc2FnZS5tZXRob2QsIHN0YXJ0VGltZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGVycm9yICYmIElzLnN0cmluZyhlcnJvci5tZXNzYWdlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXBseUVycm9yKG5ldyBtZXNzYWdlc18xLlJlc3BvbnNlRXJyb3IobWVzc2FnZXNfMS5FcnJvckNvZGVzLkludGVybmFsRXJyb3IsIGBSZXF1ZXN0ICR7cmVxdWVzdE1lc3NhZ2UubWV0aG9kfSBmYWlsZWQgd2l0aCBtZXNzYWdlOiAke2Vycm9yLm1lc3NhZ2V9YCksIHJlcXVlc3RNZXNzYWdlLm1ldGhvZCwgc3RhcnRUaW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcGx5RXJyb3IobmV3IG1lc3NhZ2VzXzEuUmVzcG9uc2VFcnJvcihtZXNzYWdlc18xLkVycm9yQ29kZXMuSW50ZXJuYWxFcnJvciwgYFJlcXVlc3QgJHtyZXF1ZXN0TWVzc2FnZS5tZXRob2R9IGZhaWxlZCB1bmV4cGVjdGVkbHkgd2l0aG91dCBwcm92aWRpbmcgYW55IGRldGFpbHMuYCksIHJlcXVlc3RNZXNzYWdlLm1ldGhvZCwgc3RhcnRUaW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXBseUVycm9yKG5ldyBtZXNzYWdlc18xLlJlc3BvbnNlRXJyb3IobWVzc2FnZXNfMS5FcnJvckNvZGVzLk1ldGhvZE5vdEZvdW5kLCBgVW5oYW5kbGVkIG1ldGhvZCAke3JlcXVlc3RNZXNzYWdlLm1ldGhvZH1gKSwgcmVxdWVzdE1lc3NhZ2UubWV0aG9kLCBzdGFydFRpbWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhbmRsZVJlc3BvbnNlKHJlc3BvbnNlTWVzc2FnZSkge1xuICAgICAgICBpZiAoaXNEaXNwb3NlZCgpKSB7XG4gICAgICAgICAgICAvLyBTZWUgaGFuZGxlIHJlcXVlc3QuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3BvbnNlTWVzc2FnZS5pZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlTWVzc2FnZS5lcnJvcikge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihgUmVjZWl2ZWQgcmVzcG9uc2UgbWVzc2FnZSB3aXRob3V0IGlkOiBFcnJvciBpczogXFxuJHtKU09OLnN0cmluZ2lmeShyZXNwb25zZU1lc3NhZ2UuZXJyb3IsIHVuZGVmaW5lZCwgNCl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoYFJlY2VpdmVkIHJlc3BvbnNlIG1lc3NhZ2Ugd2l0aG91dCBpZC4gTm8gZnVydGhlciBlcnJvciBpbmZvcm1hdGlvbiBwcm92aWRlZC5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IHJlc3BvbnNlTWVzc2FnZS5pZDtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlUHJvbWlzZSA9IHJlc3BvbnNlUHJvbWlzZXMuZ2V0KGtleSk7XG4gICAgICAgICAgICB0cmFjZVJlY2VpdmVkUmVzcG9uc2UocmVzcG9uc2VNZXNzYWdlLCByZXNwb25zZVByb21pc2UpO1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlUHJvbWlzZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2VQcm9taXNlcy5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2VNZXNzYWdlLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IHJlc3BvbnNlTWVzc2FnZS5lcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlUHJvbWlzZS5yZWplY3QobmV3IG1lc3NhZ2VzXzEuUmVzcG9uc2VFcnJvcihlcnJvci5jb2RlLCBlcnJvci5tZXNzYWdlLCBlcnJvci5kYXRhKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocmVzcG9uc2VNZXNzYWdlLnJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZVByb21pc2UucmVzb2x2ZShyZXNwb25zZU1lc3NhZ2UucmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU2hvdWxkIG5ldmVyIGhhcHBlbi4nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yLm1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihgUmVzcG9uc2UgaGFuZGxlciAnJHtyZXNwb25zZVByb21pc2UubWV0aG9kfScgZmFpbGVkIHdpdGggbWVzc2FnZTogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGBSZXNwb25zZSBoYW5kbGVyICcke3Jlc3BvbnNlUHJvbWlzZS5tZXRob2R9JyBmYWlsZWQgdW5leHBlY3RlZGx5LmApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhbmRsZU5vdGlmaWNhdGlvbihtZXNzYWdlKSB7XG4gICAgICAgIGlmIChpc0Rpc3Bvc2VkKCkpIHtcbiAgICAgICAgICAgIC8vIFNlZSBoYW5kbGUgcmVxdWVzdC5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdHlwZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IG5vdGlmaWNhdGlvbkhhbmRsZXI7XG4gICAgICAgIGlmIChtZXNzYWdlLm1ldGhvZCA9PT0gQ2FuY2VsTm90aWZpY2F0aW9uLnR5cGUubWV0aG9kKSB7XG4gICAgICAgICAgICBjb25zdCBjYW5jZWxJZCA9IG1lc3NhZ2UucGFyYW1zLmlkO1xuICAgICAgICAgICAga25vd25DYW5jZWxlZFJlcXVlc3RzLmRlbGV0ZShjYW5jZWxJZCk7XG4gICAgICAgICAgICB0cmFjZVJlY2VpdmVkTm90aWZpY2F0aW9uKG1lc3NhZ2UpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IG5vdGlmaWNhdGlvbkhhbmRsZXJzLmdldChtZXNzYWdlLm1ldGhvZCk7XG4gICAgICAgICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIG5vdGlmaWNhdGlvbkhhbmRsZXIgPSBlbGVtZW50LmhhbmRsZXI7XG4gICAgICAgICAgICAgICAgdHlwZSA9IGVsZW1lbnQudHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobm90aWZpY2F0aW9uSGFuZGxlciB8fCBzdGFyTm90aWZpY2F0aW9uSGFuZGxlcikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0cmFjZVJlY2VpdmVkTm90aWZpY2F0aW9uKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIGlmIChub3RpZmljYXRpb25IYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLnBhcmFtcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUubnVtYmVyT2ZQYXJhbXMgIT09IDAgJiYgdHlwZS5wYXJhbWV0ZXJTdHJ1Y3R1cmVzICE9PSBtZXNzYWdlc18xLlBhcmFtZXRlclN0cnVjdHVyZXMuYnlOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihgTm90aWZpY2F0aW9uICR7bWVzc2FnZS5tZXRob2R9IGRlZmluZXMgJHt0eXBlLm51bWJlck9mUGFyYW1zfSBwYXJhbXMgYnV0IHJlY2VpdmVkIG5vbmUuYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbm90aWZpY2F0aW9uSGFuZGxlcigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkobWVzc2FnZS5wYXJhbXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGVyZSBhcmUgSlNPTi1SUEMgbGlicmFyaWVzIHRoYXQgc2VuZCBwcm9ncmVzcyBtZXNzYWdlIGFzIHBvc2l0aW9uYWwgcGFyYW1zIGFsdGhvdWdoXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzcGVjaWZpZWQgYXMgbmFtZWQuIFNvIGNvbnZlcnQgdGhlbSBpZiB0aGlzIGlzIHRoZSBjYXNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyYW1zID0gbWVzc2FnZS5wYXJhbXM7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWVzc2FnZS5tZXRob2QgPT09IFByb2dyZXNzTm90aWZpY2F0aW9uLnR5cGUubWV0aG9kICYmIHBhcmFtcy5sZW5ndGggPT09IDIgJiYgUHJvZ3Jlc3NUb2tlbi5pcyhwYXJhbXNbMF0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm90aWZpY2F0aW9uSGFuZGxlcih7IHRva2VuOiBwYXJhbXNbMF0sIHZhbHVlOiBwYXJhbXNbMV0gfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlLnBhcmFtZXRlclN0cnVjdHVyZXMgPT09IG1lc3NhZ2VzXzEuUGFyYW1ldGVyU3RydWN0dXJlcy5ieU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihgTm90aWZpY2F0aW9uICR7bWVzc2FnZS5tZXRob2R9IGRlZmluZXMgcGFyYW1ldGVycyBieSBuYW1lIGJ1dCByZWNlaXZlZCBwYXJhbWV0ZXJzIGJ5IHBvc2l0aW9uYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUubnVtYmVyT2ZQYXJhbXMgIT09IG1lc3NhZ2UucGFyYW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGBOb3RpZmljYXRpb24gJHttZXNzYWdlLm1ldGhvZH0gZGVmaW5lcyAke3R5cGUubnVtYmVyT2ZQYXJhbXN9IHBhcmFtcyBidXQgcmVjZWl2ZWQgJHtwYXJhbXMubGVuZ3RofSBhcmd1bWVudHNgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3RpZmljYXRpb25IYW5kbGVyKC4uLnBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSAhPT0gdW5kZWZpbmVkICYmIHR5cGUucGFyYW1ldGVyU3RydWN0dXJlcyA9PT0gbWVzc2FnZXNfMS5QYXJhbWV0ZXJTdHJ1Y3R1cmVzLmJ5UG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoYE5vdGlmaWNhdGlvbiAke21lc3NhZ2UubWV0aG9kfSBkZWZpbmVzIHBhcmFtZXRlcnMgYnkgcG9zaXRpb24gYnV0IHJlY2VpdmVkIHBhcmFtZXRlcnMgYnkgbmFtZWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbm90aWZpY2F0aW9uSGFuZGxlcihtZXNzYWdlLnBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc3Rhck5vdGlmaWNhdGlvbkhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgc3Rhck5vdGlmaWNhdGlvbkhhbmRsZXIobWVzc2FnZS5tZXRob2QsIG1lc3NhZ2UucGFyYW1zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IubWVzc2FnZSkge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoYE5vdGlmaWNhdGlvbiBoYW5kbGVyICcke21lc3NhZ2UubWV0aG9kfScgZmFpbGVkIHdpdGggbWVzc2FnZTogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGBOb3RpZmljYXRpb24gaGFuZGxlciAnJHttZXNzYWdlLm1ldGhvZH0nIGZhaWxlZCB1bmV4cGVjdGVkbHkuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdW5oYW5kbGVkTm90aWZpY2F0aW9uRW1pdHRlci5maXJlKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhbmRsZUludmFsaWRNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKCFtZXNzYWdlKSB7XG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoJ1JlY2VpdmVkIGVtcHR5IG1lc3NhZ2UuJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbG9nZ2VyLmVycm9yKGBSZWNlaXZlZCBtZXNzYWdlIHdoaWNoIGlzIG5laXRoZXIgYSByZXNwb25zZSBub3IgYSBub3RpZmljYXRpb24gbWVzc2FnZTpcXG4ke0pTT04uc3RyaW5naWZ5KG1lc3NhZ2UsIG51bGwsIDQpfWApO1xuICAgICAgICAvLyBUZXN0IHdoZXRoZXIgd2UgZmluZCBhbiBpZCB0byByZWplY3QgdGhlIHByb21pc2VcbiAgICAgICAgY29uc3QgcmVzcG9uc2VNZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgaWYgKElzLnN0cmluZyhyZXNwb25zZU1lc3NhZ2UuaWQpIHx8IElzLm51bWJlcihyZXNwb25zZU1lc3NhZ2UuaWQpKSB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSByZXNwb25zZU1lc3NhZ2UuaWQ7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZUhhbmRsZXIgPSByZXNwb25zZVByb21pc2VzLmdldChrZXkpO1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlSGFuZGxlcikge1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlSGFuZGxlci5yZWplY3QobmV3IEVycm9yKCdUaGUgcmVjZWl2ZWQgcmVzcG9uc2UgaGFzIG5laXRoZXIgYSByZXN1bHQgbm9yIGFuIGVycm9yIHByb3BlcnR5LicpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBzdHJpbmdpZnlUcmFjZShwYXJhbXMpIHtcbiAgICAgICAgaWYgKHBhcmFtcyA9PT0gdW5kZWZpbmVkIHx8IHBhcmFtcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHRyYWNlKSB7XG4gICAgICAgICAgICBjYXNlIFRyYWNlLlZlcmJvc2U6XG4gICAgICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHBhcmFtcywgbnVsbCwgNCk7XG4gICAgICAgICAgICBjYXNlIFRyYWNlLkNvbXBhY3Q6XG4gICAgICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHBhcmFtcyk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdHJhY2VTZW5kaW5nUmVxdWVzdChtZXNzYWdlKSB7XG4gICAgICAgIGlmICh0cmFjZSA9PT0gVHJhY2UuT2ZmIHx8ICF0cmFjZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHJhY2VGb3JtYXQgPT09IFRyYWNlRm9ybWF0LlRleHQpIHtcbiAgICAgICAgICAgIGxldCBkYXRhID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKCh0cmFjZSA9PT0gVHJhY2UuVmVyYm9zZSB8fCB0cmFjZSA9PT0gVHJhY2UuQ29tcGFjdCkgJiYgbWVzc2FnZS5wYXJhbXMpIHtcbiAgICAgICAgICAgICAgICBkYXRhID0gYFBhcmFtczogJHtzdHJpbmdpZnlUcmFjZShtZXNzYWdlLnBhcmFtcyl9XFxuXFxuYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyYWNlci5sb2coYFNlbmRpbmcgcmVxdWVzdCAnJHttZXNzYWdlLm1ldGhvZH0gLSAoJHttZXNzYWdlLmlkfSknLmAsIGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbG9nTFNQTWVzc2FnZSgnc2VuZC1yZXF1ZXN0JywgbWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdHJhY2VTZW5kaW5nTm90aWZpY2F0aW9uKG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKHRyYWNlID09PSBUcmFjZS5PZmYgfHwgIXRyYWNlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0cmFjZUZvcm1hdCA9PT0gVHJhY2VGb3JtYXQuVGV4dCkge1xuICAgICAgICAgICAgbGV0IGRhdGEgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAodHJhY2UgPT09IFRyYWNlLlZlcmJvc2UgfHwgdHJhY2UgPT09IFRyYWNlLkNvbXBhY3QpIHtcbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZS5wYXJhbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGBQYXJhbXM6ICR7c3RyaW5naWZ5VHJhY2UobWVzc2FnZS5wYXJhbXMpfVxcblxcbmA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0gJ05vIHBhcmFtZXRlcnMgcHJvdmlkZWQuXFxuXFxuJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmFjZXIubG9nKGBTZW5kaW5nIG5vdGlmaWNhdGlvbiAnJHttZXNzYWdlLm1ldGhvZH0nLmAsIGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbG9nTFNQTWVzc2FnZSgnc2VuZC1ub3RpZmljYXRpb24nLCBtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB0cmFjZVNlbmRpbmdSZXNwb25zZShtZXNzYWdlLCBtZXRob2QsIHN0YXJ0VGltZSkge1xuICAgICAgICBpZiAodHJhY2UgPT09IFRyYWNlLk9mZiB8fCAhdHJhY2VyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyYWNlRm9ybWF0ID09PSBUcmFjZUZvcm1hdC5UZXh0KSB7XG4gICAgICAgICAgICBsZXQgZGF0YSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmICh0cmFjZSA9PT0gVHJhY2UuVmVyYm9zZSB8fCB0cmFjZSA9PT0gVHJhY2UuQ29tcGFjdCkge1xuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLmVycm9yICYmIG1lc3NhZ2UuZXJyb3IuZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0gYEVycm9yIGRhdGE6ICR7c3RyaW5naWZ5VHJhY2UobWVzc2FnZS5lcnJvci5kYXRhKX1cXG5cXG5gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UucmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gYFJlc3VsdDogJHtzdHJpbmdpZnlUcmFjZShtZXNzYWdlLnJlc3VsdCl9XFxuXFxuYDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChtZXNzYWdlLmVycm9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSAnTm8gcmVzdWx0IHJldHVybmVkLlxcblxcbic7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmFjZXIubG9nKGBTZW5kaW5nIHJlc3BvbnNlICcke21ldGhvZH0gLSAoJHttZXNzYWdlLmlkfSknLiBQcm9jZXNzaW5nIHJlcXVlc3QgdG9vayAke0RhdGUubm93KCkgLSBzdGFydFRpbWV9bXNgLCBkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxvZ0xTUE1lc3NhZ2UoJ3NlbmQtcmVzcG9uc2UnLCBtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB0cmFjZVJlY2VpdmVkUmVxdWVzdChtZXNzYWdlKSB7XG4gICAgICAgIGlmICh0cmFjZSA9PT0gVHJhY2UuT2ZmIHx8ICF0cmFjZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHJhY2VGb3JtYXQgPT09IFRyYWNlRm9ybWF0LlRleHQpIHtcbiAgICAgICAgICAgIGxldCBkYXRhID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKCh0cmFjZSA9PT0gVHJhY2UuVmVyYm9zZSB8fCB0cmFjZSA9PT0gVHJhY2UuQ29tcGFjdCkgJiYgbWVzc2FnZS5wYXJhbXMpIHtcbiAgICAgICAgICAgICAgICBkYXRhID0gYFBhcmFtczogJHtzdHJpbmdpZnlUcmFjZShtZXNzYWdlLnBhcmFtcyl9XFxuXFxuYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyYWNlci5sb2coYFJlY2VpdmVkIHJlcXVlc3QgJyR7bWVzc2FnZS5tZXRob2R9IC0gKCR7bWVzc2FnZS5pZH0pJy5gLCBkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxvZ0xTUE1lc3NhZ2UoJ3JlY2VpdmUtcmVxdWVzdCcsIG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRyYWNlUmVjZWl2ZWROb3RpZmljYXRpb24obWVzc2FnZSkge1xuICAgICAgICBpZiAodHJhY2UgPT09IFRyYWNlLk9mZiB8fCAhdHJhY2VyIHx8IG1lc3NhZ2UubWV0aG9kID09PSBMb2dUcmFjZU5vdGlmaWNhdGlvbi50eXBlLm1ldGhvZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0cmFjZUZvcm1hdCA9PT0gVHJhY2VGb3JtYXQuVGV4dCkge1xuICAgICAgICAgICAgbGV0IGRhdGEgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAodHJhY2UgPT09IFRyYWNlLlZlcmJvc2UgfHwgdHJhY2UgPT09IFRyYWNlLkNvbXBhY3QpIHtcbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZS5wYXJhbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGBQYXJhbXM6ICR7c3RyaW5naWZ5VHJhY2UobWVzc2FnZS5wYXJhbXMpfVxcblxcbmA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0gJ05vIHBhcmFtZXRlcnMgcHJvdmlkZWQuXFxuXFxuJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmFjZXIubG9nKGBSZWNlaXZlZCBub3RpZmljYXRpb24gJyR7bWVzc2FnZS5tZXRob2R9Jy5gLCBkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxvZ0xTUE1lc3NhZ2UoJ3JlY2VpdmUtbm90aWZpY2F0aW9uJywgbWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdHJhY2VSZWNlaXZlZFJlc3BvbnNlKG1lc3NhZ2UsIHJlc3BvbnNlUHJvbWlzZSkge1xuICAgICAgICBpZiAodHJhY2UgPT09IFRyYWNlLk9mZiB8fCAhdHJhY2VyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyYWNlRm9ybWF0ID09PSBUcmFjZUZvcm1hdC5UZXh0KSB7XG4gICAgICAgICAgICBsZXQgZGF0YSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmICh0cmFjZSA9PT0gVHJhY2UuVmVyYm9zZSB8fCB0cmFjZSA9PT0gVHJhY2UuQ29tcGFjdCkge1xuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLmVycm9yICYmIG1lc3NhZ2UuZXJyb3IuZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0gYEVycm9yIGRhdGE6ICR7c3RyaW5naWZ5VHJhY2UobWVzc2FnZS5lcnJvci5kYXRhKX1cXG5cXG5gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UucmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gYFJlc3VsdDogJHtzdHJpbmdpZnlUcmFjZShtZXNzYWdlLnJlc3VsdCl9XFxuXFxuYDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChtZXNzYWdlLmVycm9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSAnTm8gcmVzdWx0IHJldHVybmVkLlxcblxcbic7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzcG9uc2VQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBtZXNzYWdlLmVycm9yID8gYCBSZXF1ZXN0IGZhaWxlZDogJHttZXNzYWdlLmVycm9yLm1lc3NhZ2V9ICgke21lc3NhZ2UuZXJyb3IuY29kZX0pLmAgOiAnJztcbiAgICAgICAgICAgICAgICB0cmFjZXIubG9nKGBSZWNlaXZlZCByZXNwb25zZSAnJHtyZXNwb25zZVByb21pc2UubWV0aG9kfSAtICgke21lc3NhZ2UuaWR9KScgaW4gJHtEYXRlLm5vdygpIC0gcmVzcG9uc2VQcm9taXNlLnRpbWVyU3RhcnR9bXMuJHtlcnJvcn1gLCBkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRyYWNlci5sb2coYFJlY2VpdmVkIHJlc3BvbnNlICR7bWVzc2FnZS5pZH0gd2l0aG91dCBhY3RpdmUgcmVzcG9uc2UgcHJvbWlzZS5gLCBkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxvZ0xTUE1lc3NhZ2UoJ3JlY2VpdmUtcmVzcG9uc2UnLCBtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBsb2dMU1BNZXNzYWdlKHR5cGUsIG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKCF0cmFjZXIgfHwgdHJhY2UgPT09IFRyYWNlLk9mZikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxzcE1lc3NhZ2UgPSB7XG4gICAgICAgICAgICBpc0xTUE1lc3NhZ2U6IHRydWUsXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKVxuICAgICAgICB9O1xuICAgICAgICB0cmFjZXIubG9nKGxzcE1lc3NhZ2UpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0aHJvd0lmQ2xvc2VkT3JEaXNwb3NlZCgpIHtcbiAgICAgICAgaWYgKGlzQ2xvc2VkKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBDb25uZWN0aW9uRXJyb3IoQ29ubmVjdGlvbkVycm9ycy5DbG9zZWQsICdDb25uZWN0aW9uIGlzIGNsb3NlZC4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNEaXNwb3NlZCgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQ29ubmVjdGlvbkVycm9yKENvbm5lY3Rpb25FcnJvcnMuRGlzcG9zZWQsICdDb25uZWN0aW9uIGlzIGRpc3Bvc2VkLicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRocm93SWZMaXN0ZW5pbmcoKSB7XG4gICAgICAgIGlmIChpc0xpc3RlbmluZygpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQ29ubmVjdGlvbkVycm9yKENvbm5lY3Rpb25FcnJvcnMuQWxyZWFkeUxpc3RlbmluZywgJ0Nvbm5lY3Rpb24gaXMgYWxyZWFkeSBsaXN0ZW5pbmcnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB0aHJvd0lmTm90TGlzdGVuaW5nKCkge1xuICAgICAgICBpZiAoIWlzTGlzdGVuaW5nKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FsbCBsaXN0ZW4oKSBmaXJzdC4nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB1bmRlZmluZWRUb051bGwocGFyYW0pIHtcbiAgICAgICAgaWYgKHBhcmFtID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHBhcmFtO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIG51bGxUb1VuZGVmaW5lZChwYXJhbSkge1xuICAgICAgICBpZiAocGFyYW0gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyYW07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gaXNOYW1lZFBhcmFtKHBhcmFtKSB7XG4gICAgICAgIHJldHVybiBwYXJhbSAhPT0gdW5kZWZpbmVkICYmIHBhcmFtICE9PSBudWxsICYmICFBcnJheS5pc0FycmF5KHBhcmFtKSAmJiB0eXBlb2YgcGFyYW0gPT09ICdvYmplY3QnO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21wdXRlU2luZ2xlUGFyYW0ocGFyYW1ldGVyU3RydWN0dXJlcywgcGFyYW0pIHtcbiAgICAgICAgc3dpdGNoIChwYXJhbWV0ZXJTdHJ1Y3R1cmVzKSB7XG4gICAgICAgICAgICBjYXNlIG1lc3NhZ2VzXzEuUGFyYW1ldGVyU3RydWN0dXJlcy5hdXRvOlxuICAgICAgICAgICAgICAgIGlmIChpc05hbWVkUGFyYW0ocGFyYW0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsVG9VbmRlZmluZWQocGFyYW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFt1bmRlZmluZWRUb051bGwocGFyYW0pXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIG1lc3NhZ2VzXzEuUGFyYW1ldGVyU3RydWN0dXJlcy5ieU5hbWU6XG4gICAgICAgICAgICAgICAgaWYgKCFpc05hbWVkUGFyYW0ocGFyYW0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUmVjZWl2ZWQgcGFyYW1ldGVycyBieSBuYW1lIGJ1dCBwYXJhbSBpcyBub3QgYW4gb2JqZWN0IGxpdGVyYWwuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsVG9VbmRlZmluZWQocGFyYW0pO1xuICAgICAgICAgICAgY2FzZSBtZXNzYWdlc18xLlBhcmFtZXRlclN0cnVjdHVyZXMuYnlQb3NpdGlvbjpcbiAgICAgICAgICAgICAgICByZXR1cm4gW3VuZGVmaW5lZFRvTnVsbChwYXJhbSldO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gcGFyYW1ldGVyIHN0cnVjdHVyZSAke3BhcmFtZXRlclN0cnVjdHVyZXMudG9TdHJpbmcoKX1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjb21wdXRlTWVzc2FnZVBhcmFtcyh0eXBlLCBwYXJhbXMpIHtcbiAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgY29uc3QgbnVtYmVyT2ZQYXJhbXMgPSB0eXBlLm51bWJlck9mUGFyYW1zO1xuICAgICAgICBzd2l0Y2ggKG51bWJlck9mUGFyYW1zKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGNvbXB1dGVTaW5nbGVQYXJhbSh0eXBlLnBhcmFtZXRlclN0cnVjdHVyZXMsIHBhcmFtc1swXSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyYW1zLmxlbmd0aCAmJiBpIDwgbnVtYmVyT2ZQYXJhbXM7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh1bmRlZmluZWRUb051bGwocGFyYW1zW2ldKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwYXJhbXMubGVuZ3RoIDwgbnVtYmVyT2ZQYXJhbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IHBhcmFtcy5sZW5ndGg7IGkgPCBudW1iZXJPZlBhcmFtczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBjb25zdCBjb25uZWN0aW9uID0ge1xuICAgICAgICBzZW5kTm90aWZpY2F0aW9uOiAodHlwZSwgLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgdGhyb3dJZkNsb3NlZE9yRGlzcG9zZWQoKTtcbiAgICAgICAgICAgIGxldCBtZXRob2Q7XG4gICAgICAgICAgICBsZXQgbWVzc2FnZVBhcmFtcztcbiAgICAgICAgICAgIGlmIChJcy5zdHJpbmcodHlwZSkpIHtcbiAgICAgICAgICAgICAgICBtZXRob2QgPSB0eXBlO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpcnN0ID0gYXJnc1swXTtcbiAgICAgICAgICAgICAgICBsZXQgcGFyYW1TdGFydCA9IDA7XG4gICAgICAgICAgICAgICAgbGV0IHBhcmFtZXRlclN0cnVjdHVyZXMgPSBtZXNzYWdlc18xLlBhcmFtZXRlclN0cnVjdHVyZXMuYXV0bztcbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZXNfMS5QYXJhbWV0ZXJTdHJ1Y3R1cmVzLmlzKGZpcnN0KSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJhbVN0YXJ0ID0gMTtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1ldGVyU3RydWN0dXJlcyA9IGZpcnN0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgcGFyYW1FbmQgPSBhcmdzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBjb25zdCBudW1iZXJPZlBhcmFtcyA9IHBhcmFtRW5kIC0gcGFyYW1TdGFydDtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG51bWJlck9mUGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VQYXJhbXMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZVBhcmFtcyA9IGNvbXB1dGVTaW5nbGVQYXJhbShwYXJhbWV0ZXJTdHJ1Y3R1cmVzLCBhcmdzW3BhcmFtU3RhcnRdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtZXRlclN0cnVjdHVyZXMgPT09IG1lc3NhZ2VzXzEuUGFyYW1ldGVyU3RydWN0dXJlcy5ieU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFJlY2VpdmVkICR7bnVtYmVyT2ZQYXJhbXN9IHBhcmFtZXRlcnMgZm9yICdieSBOYW1lJyBub3RpZmljYXRpb24gcGFyYW1ldGVyIHN0cnVjdHVyZS5gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VQYXJhbXMgPSBhcmdzLnNsaWNlKHBhcmFtU3RhcnQsIHBhcmFtRW5kKS5tYXAodmFsdWUgPT4gdW5kZWZpbmVkVG9OdWxsKHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJhbXMgPSBhcmdzO1xuICAgICAgICAgICAgICAgIG1ldGhvZCA9IHR5cGUubWV0aG9kO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2VQYXJhbXMgPSBjb21wdXRlTWVzc2FnZVBhcmFtcyh0eXBlLCBwYXJhbXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgbm90aWZpY2F0aW9uTWVzc2FnZSA9IHtcbiAgICAgICAgICAgICAgICBqc29ucnBjOiB2ZXJzaW9uLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgICAgICAgICAgIHBhcmFtczogbWVzc2FnZVBhcmFtc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRyYWNlU2VuZGluZ05vdGlmaWNhdGlvbihub3RpZmljYXRpb25NZXNzYWdlKTtcbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlV3JpdGVyLndyaXRlKG5vdGlmaWNhdGlvbk1lc3NhZ2UpLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihgU2VuZGluZyBub3RpZmljYXRpb24gZmFpbGVkLmApO1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uTm90aWZpY2F0aW9uOiAodHlwZSwgaGFuZGxlcikgPT4ge1xuICAgICAgICAgICAgdGhyb3dJZkNsb3NlZE9yRGlzcG9zZWQoKTtcbiAgICAgICAgICAgIGxldCBtZXRob2Q7XG4gICAgICAgICAgICBpZiAoSXMuZnVuYyh0eXBlKSkge1xuICAgICAgICAgICAgICAgIHN0YXJOb3RpZmljYXRpb25IYW5kbGVyID0gdHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoSXMuc3RyaW5nKHR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZCA9IHR5cGU7XG4gICAgICAgICAgICAgICAgICAgIG5vdGlmaWNhdGlvbkhhbmRsZXJzLnNldCh0eXBlLCB7IHR5cGU6IHVuZGVmaW5lZCwgaGFuZGxlciB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZCA9IHR5cGUubWV0aG9kO1xuICAgICAgICAgICAgICAgICAgICBub3RpZmljYXRpb25IYW5kbGVycy5zZXQodHlwZS5tZXRob2QsIHsgdHlwZSwgaGFuZGxlciB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGRpc3Bvc2U6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1ldGhvZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub3RpZmljYXRpb25IYW5kbGVycy5kZWxldGUobWV0aG9kKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJOb3RpZmljYXRpb25IYW5kbGVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgb25Qcm9ncmVzczogKF90eXBlLCB0b2tlbiwgaGFuZGxlcikgPT4ge1xuICAgICAgICAgICAgaWYgKHByb2dyZXNzSGFuZGxlcnMuaGFzKHRva2VuKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUHJvZ3Jlc3MgaGFuZGxlciBmb3IgdG9rZW4gJHt0b2tlbn0gYWxyZWFkeSByZWdpc3RlcmVkYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcm9ncmVzc0hhbmRsZXJzLnNldCh0b2tlbiwgaGFuZGxlcik7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGRpc3Bvc2U6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcHJvZ3Jlc3NIYW5kbGVycy5kZWxldGUodG9rZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIHNlbmRQcm9ncmVzczogKF90eXBlLCB0b2tlbiwgdmFsdWUpID0+IHtcbiAgICAgICAgICAgIC8vIFRoaXMgc2hvdWxkIG5vdCBhd2FpdCBidXQgc2ltcGxlIHJldHVybiB0byBlbnN1cmUgdGhhdCB3ZSBkb24ndCBoYXZlIGFub3RoZXJcbiAgICAgICAgICAgIC8vIGFzeW5jIHNjaGVkdWxpbmcuIE90aGVyd2lzZSBvbmUgc2VuZCBjb3VsZCBvdmVydGFrZSBhbm90aGVyIHNlbmQuXG4gICAgICAgICAgICByZXR1cm4gY29ubmVjdGlvbi5zZW5kTm90aWZpY2F0aW9uKFByb2dyZXNzTm90aWZpY2F0aW9uLnR5cGUsIHsgdG9rZW4sIHZhbHVlIH0pO1xuICAgICAgICB9LFxuICAgICAgICBvblVuaGFuZGxlZFByb2dyZXNzOiB1bmhhbmRsZWRQcm9ncmVzc0VtaXR0ZXIuZXZlbnQsXG4gICAgICAgIHNlbmRSZXF1ZXN0OiAodHlwZSwgLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgdGhyb3dJZkNsb3NlZE9yRGlzcG9zZWQoKTtcbiAgICAgICAgICAgIHRocm93SWZOb3RMaXN0ZW5pbmcoKTtcbiAgICAgICAgICAgIGxldCBtZXRob2Q7XG4gICAgICAgICAgICBsZXQgbWVzc2FnZVBhcmFtcztcbiAgICAgICAgICAgIGxldCB0b2tlbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmIChJcy5zdHJpbmcodHlwZSkpIHtcbiAgICAgICAgICAgICAgICBtZXRob2QgPSB0eXBlO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpcnN0ID0gYXJnc1swXTtcbiAgICAgICAgICAgICAgICBjb25zdCBsYXN0ID0gYXJnc1thcmdzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgIGxldCBwYXJhbVN0YXJ0ID0gMDtcbiAgICAgICAgICAgICAgICBsZXQgcGFyYW1ldGVyU3RydWN0dXJlcyA9IG1lc3NhZ2VzXzEuUGFyYW1ldGVyU3RydWN0dXJlcy5hdXRvO1xuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlc18xLlBhcmFtZXRlclN0cnVjdHVyZXMuaXMoZmlyc3QpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtU3RhcnQgPSAxO1xuICAgICAgICAgICAgICAgICAgICBwYXJhbWV0ZXJTdHJ1Y3R1cmVzID0gZmlyc3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBwYXJhbUVuZCA9IGFyZ3MubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmIChjYW5jZWxsYXRpb25fMS5DYW5jZWxsYXRpb25Ub2tlbi5pcyhsYXN0KSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJhbUVuZCA9IHBhcmFtRW5kIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSBsYXN0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBudW1iZXJPZlBhcmFtcyA9IHBhcmFtRW5kIC0gcGFyYW1TdGFydDtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG51bWJlck9mUGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VQYXJhbXMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZVBhcmFtcyA9IGNvbXB1dGVTaW5nbGVQYXJhbShwYXJhbWV0ZXJTdHJ1Y3R1cmVzLCBhcmdzW3BhcmFtU3RhcnRdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtZXRlclN0cnVjdHVyZXMgPT09IG1lc3NhZ2VzXzEuUGFyYW1ldGVyU3RydWN0dXJlcy5ieU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFJlY2VpdmVkICR7bnVtYmVyT2ZQYXJhbXN9IHBhcmFtZXRlcnMgZm9yICdieSBOYW1lJyByZXF1ZXN0IHBhcmFtZXRlciBzdHJ1Y3R1cmUuYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlUGFyYW1zID0gYXJncy5zbGljZShwYXJhbVN0YXJ0LCBwYXJhbUVuZCkubWFwKHZhbHVlID0+IHVuZGVmaW5lZFRvTnVsbCh2YWx1ZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyYW1zID0gYXJncztcbiAgICAgICAgICAgICAgICBtZXRob2QgPSB0eXBlLm1ldGhvZDtcbiAgICAgICAgICAgICAgICBtZXNzYWdlUGFyYW1zID0gY29tcHV0ZU1lc3NhZ2VQYXJhbXModHlwZSwgcGFyYW1zKTtcbiAgICAgICAgICAgICAgICBjb25zdCBudW1iZXJPZlBhcmFtcyA9IHR5cGUubnVtYmVyT2ZQYXJhbXM7XG4gICAgICAgICAgICAgICAgdG9rZW4gPSBjYW5jZWxsYXRpb25fMS5DYW5jZWxsYXRpb25Ub2tlbi5pcyhwYXJhbXNbbnVtYmVyT2ZQYXJhbXNdKSA/IHBhcmFtc1tudW1iZXJPZlBhcmFtc10gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBpZCA9IHNlcXVlbmNlTnVtYmVyKys7XG4gICAgICAgICAgICBsZXQgZGlzcG9zYWJsZTtcbiAgICAgICAgICAgIGlmICh0b2tlbikge1xuICAgICAgICAgICAgICAgIGRpc3Bvc2FibGUgPSB0b2tlbi5vbkNhbmNlbGxhdGlvblJlcXVlc3RlZCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHAgPSBjYW5jZWxsYXRpb25TdHJhdGVneS5zZW5kZXIuc2VuZENhbmNlbGxhdGlvbihjb25uZWN0aW9uLCBpZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coYFJlY2VpdmVkIG5vIHByb21pc2UgZnJvbSBjYW5jZWxsYXRpb24gc3RyYXRlZ3kgd2hlbiBjYW5jZWxsaW5nIGlkICR7aWR9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcC5jYXRjaCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhgU2VuZGluZyBjYW5jZWxsYXRpb24gbWVzc2FnZXMgZm9yIGlkICR7aWR9IGZhaWxlZGApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3RNZXNzYWdlID0ge1xuICAgICAgICAgICAgICAgIGpzb25ycGM6IHZlcnNpb24sXG4gICAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgICAgICAgICAgIHBhcmFtczogbWVzc2FnZVBhcmFtc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRyYWNlU2VuZGluZ1JlcXVlc3QocmVxdWVzdE1lc3NhZ2UpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjYW5jZWxsYXRpb25TdHJhdGVneS5zZW5kZXIuZW5hYmxlQ2FuY2VsbGF0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgY2FuY2VsbGF0aW9uU3RyYXRlZ3kuc2VuZGVyLmVuYWJsZUNhbmNlbGxhdGlvbihyZXF1ZXN0TWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoYXN5bmMgKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc29sdmVXaXRoQ2xlYW51cCA9IChyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUocik7XG4gICAgICAgICAgICAgICAgICAgIGNhbmNlbGxhdGlvblN0cmF0ZWd5LnNlbmRlci5jbGVhbnVwKGlkKTtcbiAgICAgICAgICAgICAgICAgICAgZGlzcG9zYWJsZT8uZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY29uc3QgcmVqZWN0V2l0aENsZWFudXAgPSAocikgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZWplY3Qocik7XG4gICAgICAgICAgICAgICAgICAgIGNhbmNlbGxhdGlvblN0cmF0ZWd5LnNlbmRlci5jbGVhbnVwKGlkKTtcbiAgICAgICAgICAgICAgICAgICAgZGlzcG9zYWJsZT8uZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VQcm9taXNlID0geyBtZXRob2Q6IG1ldGhvZCwgdGltZXJTdGFydDogRGF0ZS5ub3coKSwgcmVzb2x2ZTogcmVzb2x2ZVdpdGhDbGVhbnVwLCByZWplY3Q6IHJlamVjdFdpdGhDbGVhbnVwIH07XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgbWVzc2FnZVdyaXRlci53cml0ZShyZXF1ZXN0TWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlUHJvbWlzZXMuc2V0KGlkLCByZXNwb25zZVByb21pc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGBTZW5kaW5nIHJlcXVlc3QgZmFpbGVkLmApO1xuICAgICAgICAgICAgICAgICAgICAvLyBXcml0aW5nIHRoZSBtZXNzYWdlIGZhaWxlZC4gU28gd2UgbmVlZCB0byByZWplY3QgdGhlIHByb21pc2UuXG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlUHJvbWlzZS5yZWplY3QobmV3IG1lc3NhZ2VzXzEuUmVzcG9uc2VFcnJvcihtZXNzYWdlc18xLkVycm9yQ29kZXMuTWVzc2FnZVdyaXRlRXJyb3IsIGVycm9yLm1lc3NhZ2UgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gcmVhc29uJykpO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgb25SZXF1ZXN0OiAodHlwZSwgaGFuZGxlcikgPT4ge1xuICAgICAgICAgICAgdGhyb3dJZkNsb3NlZE9yRGlzcG9zZWQoKTtcbiAgICAgICAgICAgIGxldCBtZXRob2QgPSBudWxsO1xuICAgICAgICAgICAgaWYgKFN0YXJSZXF1ZXN0SGFuZGxlci5pcyh0eXBlKSkge1xuICAgICAgICAgICAgICAgIG1ldGhvZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBzdGFyUmVxdWVzdEhhbmRsZXIgPSB0eXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoSXMuc3RyaW5nKHR5cGUpKSB7XG4gICAgICAgICAgICAgICAgbWV0aG9kID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoaGFuZGxlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZCA9IHR5cGU7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3RIYW5kbGVycy5zZXQodHlwZSwgeyBoYW5kbGVyOiBoYW5kbGVyLCB0eXBlOiB1bmRlZmluZWQgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhbmRsZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2QgPSB0eXBlLm1ldGhvZDtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdEhhbmRsZXJzLnNldCh0eXBlLm1ldGhvZCwgeyB0eXBlLCBoYW5kbGVyIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZGlzcG9zZTogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAobWV0aG9kID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG1ldGhvZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0SGFuZGxlcnMuZGVsZXRlKG1ldGhvZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFyUmVxdWVzdEhhbmRsZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBoYXNQZW5kaW5nUmVzcG9uc2U6ICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZVByb21pc2VzLnNpemUgPiAwO1xuICAgICAgICB9LFxuICAgICAgICB0cmFjZTogYXN5bmMgKF92YWx1ZSwgX3RyYWNlciwgc2VuZE5vdGlmaWNhdGlvbk9yVHJhY2VPcHRpb25zKSA9PiB7XG4gICAgICAgICAgICBsZXQgX3NlbmROb3RpZmljYXRpb24gPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCBfdHJhY2VGb3JtYXQgPSBUcmFjZUZvcm1hdC5UZXh0O1xuICAgICAgICAgICAgaWYgKHNlbmROb3RpZmljYXRpb25PclRyYWNlT3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKElzLmJvb2xlYW4oc2VuZE5vdGlmaWNhdGlvbk9yVHJhY2VPcHRpb25zKSkge1xuICAgICAgICAgICAgICAgICAgICBfc2VuZE5vdGlmaWNhdGlvbiA9IHNlbmROb3RpZmljYXRpb25PclRyYWNlT3B0aW9ucztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIF9zZW5kTm90aWZpY2F0aW9uID0gc2VuZE5vdGlmaWNhdGlvbk9yVHJhY2VPcHRpb25zLnNlbmROb3RpZmljYXRpb24gfHwgZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIF90cmFjZUZvcm1hdCA9IHNlbmROb3RpZmljYXRpb25PclRyYWNlT3B0aW9ucy50cmFjZUZvcm1hdCB8fCBUcmFjZUZvcm1hdC5UZXh0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyYWNlID0gX3ZhbHVlO1xuICAgICAgICAgICAgdHJhY2VGb3JtYXQgPSBfdHJhY2VGb3JtYXQ7XG4gICAgICAgICAgICBpZiAodHJhY2UgPT09IFRyYWNlLk9mZikge1xuICAgICAgICAgICAgICAgIHRyYWNlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRyYWNlciA9IF90cmFjZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoX3NlbmROb3RpZmljYXRpb24gJiYgIWlzQ2xvc2VkKCkgJiYgIWlzRGlzcG9zZWQoKSkge1xuICAgICAgICAgICAgICAgIGF3YWl0IGNvbm5lY3Rpb24uc2VuZE5vdGlmaWNhdGlvbihTZXRUcmFjZU5vdGlmaWNhdGlvbi50eXBlLCB7IHZhbHVlOiBUcmFjZS50b1N0cmluZyhfdmFsdWUpIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBvbkVycm9yOiBlcnJvckVtaXR0ZXIuZXZlbnQsXG4gICAgICAgIG9uQ2xvc2U6IGNsb3NlRW1pdHRlci5ldmVudCxcbiAgICAgICAgb25VbmhhbmRsZWROb3RpZmljYXRpb246IHVuaGFuZGxlZE5vdGlmaWNhdGlvbkVtaXR0ZXIuZXZlbnQsXG4gICAgICAgIG9uRGlzcG9zZTogZGlzcG9zZUVtaXR0ZXIuZXZlbnQsXG4gICAgICAgIGVuZDogKCkgPT4ge1xuICAgICAgICAgICAgbWVzc2FnZVdyaXRlci5lbmQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZGlzcG9zZTogKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGlzRGlzcG9zZWQoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0YXRlID0gQ29ubmVjdGlvblN0YXRlLkRpc3Bvc2VkO1xuICAgICAgICAgICAgZGlzcG9zZUVtaXR0ZXIuZmlyZSh1bmRlZmluZWQpO1xuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgbWVzc2FnZXNfMS5SZXNwb25zZUVycm9yKG1lc3NhZ2VzXzEuRXJyb3JDb2Rlcy5QZW5kaW5nUmVzcG9uc2VSZWplY3RlZCwgJ1BlbmRpbmcgcmVzcG9uc2UgcmVqZWN0ZWQgc2luY2UgY29ubmVjdGlvbiBnb3QgZGlzcG9zZWQnKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcHJvbWlzZSBvZiByZXNwb25zZVByb21pc2VzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzcG9uc2VQcm9taXNlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIHJlcXVlc3RUb2tlbnMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICBrbm93bkNhbmNlbGVkUmVxdWVzdHMgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICBtZXNzYWdlUXVldWUgPSBuZXcgbGlua2VkTWFwXzEuTGlua2VkTWFwKCk7XG4gICAgICAgICAgICAvLyBUZXN0IGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICAgICAgICAgICAgaWYgKElzLmZ1bmMobWVzc2FnZVdyaXRlci5kaXNwb3NlKSkge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2VXcml0ZXIuZGlzcG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKElzLmZ1bmMobWVzc2FnZVJlYWRlci5kaXNwb3NlKSkge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2VSZWFkZXIuZGlzcG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBsaXN0ZW46ICgpID0+IHtcbiAgICAgICAgICAgIHRocm93SWZDbG9zZWRPckRpc3Bvc2VkKCk7XG4gICAgICAgICAgICB0aHJvd0lmTGlzdGVuaW5nKCk7XG4gICAgICAgICAgICBzdGF0ZSA9IENvbm5lY3Rpb25TdGF0ZS5MaXN0ZW5pbmc7XG4gICAgICAgICAgICBtZXNzYWdlUmVhZGVyLmxpc3RlbihjYWxsYmFjayk7XG4gICAgICAgIH0sXG4gICAgICAgIGluc3BlY3Q6ICgpID0+IHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgICAoMCwgcmFsXzEuZGVmYXVsdCkoKS5jb25zb2xlLmxvZygnaW5zcGVjdCcpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25uZWN0aW9uLm9uTm90aWZpY2F0aW9uKExvZ1RyYWNlTm90aWZpY2F0aW9uLnR5cGUsIChwYXJhbXMpID0+IHtcbiAgICAgICAgaWYgKHRyYWNlID09PSBUcmFjZS5PZmYgfHwgIXRyYWNlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZlcmJvc2UgPSB0cmFjZSA9PT0gVHJhY2UuVmVyYm9zZSB8fCB0cmFjZSA9PT0gVHJhY2UuQ29tcGFjdDtcbiAgICAgICAgdHJhY2VyLmxvZyhwYXJhbXMubWVzc2FnZSwgdmVyYm9zZSA/IHBhcmFtcy52ZXJib3NlIDogdW5kZWZpbmVkKTtcbiAgICB9KTtcbiAgICBjb25uZWN0aW9uLm9uTm90aWZpY2F0aW9uKFByb2dyZXNzTm90aWZpY2F0aW9uLnR5cGUsIChwYXJhbXMpID0+IHtcbiAgICAgICAgY29uc3QgaGFuZGxlciA9IHByb2dyZXNzSGFuZGxlcnMuZ2V0KHBhcmFtcy50b2tlbik7XG4gICAgICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICAgICAgICBoYW5kbGVyKHBhcmFtcy52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB1bmhhbmRsZWRQcm9ncmVzc0VtaXR0ZXIuZmlyZShwYXJhbXMpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGNvbm5lY3Rpb247XG59XG5leHBvcnRzLmNyZWF0ZU1lc3NhZ2VDb25uZWN0aW9uID0gY3JlYXRlTWVzc2FnZUNvbm5lY3Rpb247XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDg4NDQ6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5EaXNwb3NhYmxlID0gdm9pZCAwO1xudmFyIERpc3Bvc2FibGU7XG4oZnVuY3Rpb24gKERpc3Bvc2FibGUpIHtcbiAgICBmdW5jdGlvbiBjcmVhdGUoZnVuYykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGlzcG9zZTogZnVuY1xuICAgICAgICB9O1xuICAgIH1cbiAgICBEaXNwb3NhYmxlLmNyZWF0ZSA9IGNyZWF0ZTtcbn0pKERpc3Bvc2FibGUgPSBleHBvcnRzLkRpc3Bvc2FibGUgfHwgKGV4cG9ydHMuRGlzcG9zYWJsZSA9IHt9KSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDI0Nzk6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuRW1pdHRlciA9IGV4cG9ydHMuRXZlbnQgPSB2b2lkIDA7XG5jb25zdCByYWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNTA5MSk7XG52YXIgRXZlbnQ7XG4oZnVuY3Rpb24gKEV2ZW50KSB7XG4gICAgY29uc3QgX2Rpc3Bvc2FibGUgPSB7IGRpc3Bvc2UoKSB7IH0gfTtcbiAgICBFdmVudC5Ob25lID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gX2Rpc3Bvc2FibGU7IH07XG59KShFdmVudCA9IGV4cG9ydHMuRXZlbnQgfHwgKGV4cG9ydHMuRXZlbnQgPSB7fSkpO1xuY2xhc3MgQ2FsbGJhY2tMaXN0IHtcbiAgICBhZGQoY2FsbGJhY2ssIGNvbnRleHQgPSBudWxsLCBidWNrZXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9jYWxsYmFja3MpIHtcbiAgICAgICAgICAgIHRoaXMuX2NhbGxiYWNrcyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dHMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgICAgIHRoaXMuX2NvbnRleHRzLnB1c2goY29udGV4dCk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGJ1Y2tldCkpIHtcbiAgICAgICAgICAgIGJ1Y2tldC5wdXNoKHsgZGlzcG9zZTogKCkgPT4gdGhpcy5yZW1vdmUoY2FsbGJhY2ssIGNvbnRleHQpIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlbW92ZShjYWxsYmFjaywgY29udGV4dCA9IG51bGwpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9jYWxsYmFja3MpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZm91bmRDYWxsYmFja1dpdGhEaWZmZXJlbnRDb250ZXh0ID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSB0aGlzLl9jYWxsYmFja3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jYWxsYmFja3NbaV0gPT09IGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2NvbnRleHRzW2ldID09PSBjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNhbGxiYWNrICYgY29udGV4dCBtYXRjaCA9PiByZW1vdmUgaXRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FsbGJhY2tzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29udGV4dHMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmb3VuZENhbGxiYWNrV2l0aERpZmZlcmVudENvbnRleHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZm91bmRDYWxsYmFja1dpdGhEaWZmZXJlbnRDb250ZXh0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1doZW4gYWRkaW5nIGEgbGlzdGVuZXIgd2l0aCBhIGNvbnRleHQsIHlvdSBzaG91bGQgcmVtb3ZlIGl0IHdpdGggdGhlIHNhbWUgY29udGV4dCcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGludm9rZSguLi5hcmdzKSB7XG4gICAgICAgIGlmICghdGhpcy5fY2FsbGJhY2tzKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmV0ID0gW10sIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcy5zbGljZSgwKSwgY29udGV4dHMgPSB0aGlzLl9jb250ZXh0cy5zbGljZSgwKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXQucHVzaChjYWxsYmFja3NbaV0uYXBwbHkoY29udGV4dHNbaV0sIGFyZ3MpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgICAgICAgICAoMCwgcmFsXzEuZGVmYXVsdCkoKS5jb25zb2xlLmVycm9yKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIGlzRW1wdHkoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5fY2FsbGJhY2tzIHx8IHRoaXMuX2NhbGxiYWNrcy5sZW5ndGggPT09IDA7XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIHRoaXMuX2NhbGxiYWNrcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fY29udGV4dHMgPSB1bmRlZmluZWQ7XG4gICAgfVxufVxuY2xhc3MgRW1pdHRlciB7XG4gICAgY29uc3RydWN0b3IoX29wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5fb3B0aW9ucyA9IF9vcHRpb25zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGb3IgdGhlIHB1YmxpYyB0byBhbGxvdyB0byBzdWJzY3JpYmVcbiAgICAgKiB0byBldmVudHMgZnJvbSB0aGlzIEVtaXR0ZXJcbiAgICAgKi9cbiAgICBnZXQgZXZlbnQoKSB7XG4gICAgICAgIGlmICghdGhpcy5fZXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50ID0gKGxpc3RlbmVyLCB0aGlzQXJncywgZGlzcG9zYWJsZXMpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2NhbGxiYWNrcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYWxsYmFja3MgPSBuZXcgQ2FsbGJhY2tMaXN0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9vcHRpb25zICYmIHRoaXMuX29wdGlvbnMub25GaXJzdExpc3RlbmVyQWRkICYmIHRoaXMuX2NhbGxiYWNrcy5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fb3B0aW9ucy5vbkZpcnN0TGlzdGVuZXJBZGQodGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2NhbGxiYWNrcy5hZGQobGlzdGVuZXIsIHRoaXNBcmdzKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3Bvc2U6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5fY2FsbGJhY2tzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGlzcG9zYWJsZSBpcyBkaXNwb3NlZCBhZnRlciBlbWl0dGVyIGlzIGRpc3Bvc2VkLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NhbGxiYWNrcy5yZW1vdmUobGlzdGVuZXIsIHRoaXNBcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5kaXNwb3NlID0gRW1pdHRlci5fbm9vcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9vcHRpb25zICYmIHRoaXMuX29wdGlvbnMub25MYXN0TGlzdGVuZXJSZW1vdmUgJiYgdGhpcy5fY2FsbGJhY2tzLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX29wdGlvbnMub25MYXN0TGlzdGVuZXJSZW1vdmUodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRpc3Bvc2FibGVzKSkge1xuICAgICAgICAgICAgICAgICAgICBkaXNwb3NhYmxlcy5wdXNoKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9ldmVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVG8gYmUga2VwdCBwcml2YXRlIHRvIGZpcmUgYW4gZXZlbnQgdG9cbiAgICAgKiBzdWJzY3JpYmVyc1xuICAgICAqL1xuICAgIGZpcmUoZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2NhbGxiYWNrcykge1xuICAgICAgICAgICAgdGhpcy5fY2FsbGJhY2tzLmludm9rZS5jYWxsKHRoaXMuX2NhbGxiYWNrcywgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIGlmICh0aGlzLl9jYWxsYmFja3MpIHtcbiAgICAgICAgICAgIHRoaXMuX2NhbGxiYWNrcy5kaXNwb3NlKCk7XG4gICAgICAgICAgICB0aGlzLl9jYWxsYmFja3MgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkVtaXR0ZXIgPSBFbWl0dGVyO1xuRW1pdHRlci5fbm9vcCA9IGZ1bmN0aW9uICgpIHsgfTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNjYxODpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMpID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5zdHJpbmdBcnJheSA9IGV4cG9ydHMuYXJyYXkgPSBleHBvcnRzLmZ1bmMgPSBleHBvcnRzLmVycm9yID0gZXhwb3J0cy5udW1iZXIgPSBleHBvcnRzLnN0cmluZyA9IGV4cG9ydHMuYm9vbGVhbiA9IHZvaWQgMDtcbmZ1bmN0aW9uIGJvb2xlYW4odmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IHRydWUgfHwgdmFsdWUgPT09IGZhbHNlO1xufVxuZXhwb3J0cy5ib29sZWFuID0gYm9vbGVhbjtcbmZ1bmN0aW9uIHN0cmluZyh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8IHZhbHVlIGluc3RhbmNlb2YgU3RyaW5nO1xufVxuZXhwb3J0cy5zdHJpbmcgPSBzdHJpbmc7XG5mdW5jdGlvbiBudW1iZXIodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyB8fCB2YWx1ZSBpbnN0YW5jZW9mIE51bWJlcjtcbn1cbmV4cG9ydHMubnVtYmVyID0gbnVtYmVyO1xuZnVuY3Rpb24gZXJyb3IodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBFcnJvcjtcbn1cbmV4cG9ydHMuZXJyb3IgPSBlcnJvcjtcbmZ1bmN0aW9uIGZ1bmModmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nO1xufVxuZXhwb3J0cy5mdW5jID0gZnVuYztcbmZ1bmN0aW9uIGFycmF5KHZhbHVlKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpO1xufVxuZXhwb3J0cy5hcnJheSA9IGFycmF5O1xuZnVuY3Rpb24gc3RyaW5nQXJyYXkodmFsdWUpIHtcbiAgICByZXR1cm4gYXJyYXkodmFsdWUpICYmIHZhbHVlLmV2ZXJ5KGVsZW0gPT4gc3RyaW5nKGVsZW0pKTtcbn1cbmV4cG9ydHMuc3RyaW5nQXJyYXkgPSBzdHJpbmdBcnJheTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMTEwOTpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMpID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xudmFyIF9hO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLkxSVUNhY2hlID0gZXhwb3J0cy5MaW5rZWRNYXAgPSBleHBvcnRzLlRvdWNoID0gdm9pZCAwO1xudmFyIFRvdWNoO1xuKGZ1bmN0aW9uIChUb3VjaCkge1xuICAgIFRvdWNoLk5vbmUgPSAwO1xuICAgIFRvdWNoLkZpcnN0ID0gMTtcbiAgICBUb3VjaC5Bc09sZCA9IFRvdWNoLkZpcnN0O1xuICAgIFRvdWNoLkxhc3QgPSAyO1xuICAgIFRvdWNoLkFzTmV3ID0gVG91Y2guTGFzdDtcbn0pKFRvdWNoID0gZXhwb3J0cy5Ub3VjaCB8fCAoZXhwb3J0cy5Ub3VjaCA9IHt9KSk7XG5jbGFzcyBMaW5rZWRNYXAge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzW19hXSA9ICdMaW5rZWRNYXAnO1xuICAgICAgICB0aGlzLl9tYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX2hlYWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX3RhaWwgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX3NpemUgPSAwO1xuICAgICAgICB0aGlzLl9zdGF0ZSA9IDA7XG4gICAgfVxuICAgIGNsZWFyKCkge1xuICAgICAgICB0aGlzLl9tYXAuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5faGVhZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fdGFpbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fc2l6ZSA9IDA7XG4gICAgICAgIHRoaXMuX3N0YXRlKys7XG4gICAgfVxuICAgIGlzRW1wdHkoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5faGVhZCAmJiAhdGhpcy5fdGFpbDtcbiAgICB9XG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zaXplO1xuICAgIH1cbiAgICBnZXQgZmlyc3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oZWFkPy52YWx1ZTtcbiAgICB9XG4gICAgZ2V0IGxhc3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90YWlsPy52YWx1ZTtcbiAgICB9XG4gICAgaGFzKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWFwLmhhcyhrZXkpO1xuICAgIH1cbiAgICBnZXQoa2V5LCB0b3VjaCA9IFRvdWNoLk5vbmUpIHtcbiAgICAgICAgY29uc3QgaXRlbSA9IHRoaXMuX21hcC5nZXQoa2V5KTtcbiAgICAgICAgaWYgKCFpdGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b3VjaCAhPT0gVG91Y2guTm9uZSkge1xuICAgICAgICAgICAgdGhpcy50b3VjaChpdGVtLCB0b3VjaCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGl0ZW0udmFsdWU7XG4gICAgfVxuICAgIHNldChrZXksIHZhbHVlLCB0b3VjaCA9IFRvdWNoLk5vbmUpIHtcbiAgICAgICAgbGV0IGl0ZW0gPSB0aGlzLl9tYXAuZ2V0KGtleSk7XG4gICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgICBpdGVtLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICBpZiAodG91Y2ggIT09IFRvdWNoLk5vbmUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRvdWNoKGl0ZW0sIHRvdWNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGl0ZW0gPSB7IGtleSwgdmFsdWUsIG5leHQ6IHVuZGVmaW5lZCwgcHJldmlvdXM6IHVuZGVmaW5lZCB9O1xuICAgICAgICAgICAgc3dpdGNoICh0b3VjaCkge1xuICAgICAgICAgICAgICAgIGNhc2UgVG91Y2guTm9uZTpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRJdGVtTGFzdChpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBUb3VjaC5GaXJzdDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRJdGVtRmlyc3QoaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgVG91Y2guTGFzdDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRJdGVtTGFzdChpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRJdGVtTGFzdChpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9tYXAuc2V0KGtleSwgaXRlbSk7XG4gICAgICAgICAgICB0aGlzLl9zaXplKys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRlbGV0ZShrZXkpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5yZW1vdmUoa2V5KTtcbiAgICB9XG4gICAgcmVtb3ZlKGtleSkge1xuICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5fbWFwLmdldChrZXkpO1xuICAgICAgICBpZiAoIWl0ZW0pIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbWFwLmRlbGV0ZShrZXkpO1xuICAgICAgICB0aGlzLnJlbW92ZUl0ZW0oaXRlbSk7XG4gICAgICAgIHRoaXMuX3NpemUtLTtcbiAgICAgICAgcmV0dXJuIGl0ZW0udmFsdWU7XG4gICAgfVxuICAgIHNoaWZ0KCkge1xuICAgICAgICBpZiAoIXRoaXMuX2hlYWQgJiYgIXRoaXMuX3RhaWwpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9oZWFkIHx8ICF0aGlzLl90YWlsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbGlzdCcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzLl9oZWFkO1xuICAgICAgICB0aGlzLl9tYXAuZGVsZXRlKGl0ZW0ua2V5KTtcbiAgICAgICAgdGhpcy5yZW1vdmVJdGVtKGl0ZW0pO1xuICAgICAgICB0aGlzLl9zaXplLS07XG4gICAgICAgIHJldHVybiBpdGVtLnZhbHVlO1xuICAgIH1cbiAgICBmb3JFYWNoKGNhbGxiYWNrZm4sIHRoaXNBcmcpIHtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLl9zdGF0ZTtcbiAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzLl9oZWFkO1xuICAgICAgICB3aGlsZSAoY3VycmVudCkge1xuICAgICAgICAgICAgaWYgKHRoaXNBcmcpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFja2ZuLmJpbmQodGhpc0FyZykoY3VycmVudC52YWx1ZSwgY3VycmVudC5rZXksIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2tmbihjdXJyZW50LnZhbHVlLCBjdXJyZW50LmtleSwgdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fc3RhdGUgIT09IHN0YXRlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBMaW5rZWRNYXAgZ290IG1vZGlmaWVkIGR1cmluZyBpdGVyYXRpb24uYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuICAgICAgICB9XG4gICAgfVxuICAgIGtleXMoKSB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5fc3RhdGU7XG4gICAgICAgIGxldCBjdXJyZW50ID0gdGhpcy5faGVhZDtcbiAgICAgICAgY29uc3QgaXRlcmF0b3IgPSB7XG4gICAgICAgICAgICBbU3ltYm9sLml0ZXJhdG9yXTogKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVyYXRvcjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBuZXh0OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3N0YXRlICE9PSBzdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYExpbmtlZE1hcCBnb3QgbW9kaWZpZWQgZHVyaW5nIGl0ZXJhdGlvbi5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0geyB2YWx1ZTogY3VycmVudC5rZXksIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gaXRlcmF0b3I7XG4gICAgfVxuICAgIHZhbHVlcygpIHtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLl9zdGF0ZTtcbiAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzLl9oZWFkO1xuICAgICAgICBjb25zdCBpdGVyYXRvciA9IHtcbiAgICAgICAgICAgIFtTeW1ib2wuaXRlcmF0b3JdOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZXJhdG9yO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5leHQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fc3RhdGUgIT09IHN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTGlua2VkTWFwIGdvdCBtb2RpZmllZCBkdXJpbmcgaXRlcmF0aW9uLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB7IHZhbHVlOiBjdXJyZW50LnZhbHVlLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yO1xuICAgIH1cbiAgICBlbnRyaWVzKCkge1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuX3N0YXRlO1xuICAgICAgICBsZXQgY3VycmVudCA9IHRoaXMuX2hlYWQ7XG4gICAgICAgIGNvbnN0IGl0ZXJhdG9yID0ge1xuICAgICAgICAgICAgW1N5bWJvbC5pdGVyYXRvcl06ICgpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlcmF0b3I7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbmV4dDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9zdGF0ZSAhPT0gc3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBMaW5rZWRNYXAgZ290IG1vZGlmaWVkIGR1cmluZyBpdGVyYXRpb24uYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHsgdmFsdWU6IFtjdXJyZW50LmtleSwgY3VycmVudC52YWx1ZV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gaXRlcmF0b3I7XG4gICAgfVxuICAgIFsoX2EgPSBTeW1ib2wudG9TdHJpbmdUYWcsIFN5bWJvbC5pdGVyYXRvcildKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbnRyaWVzKCk7XG4gICAgfVxuICAgIHRyaW1PbGQobmV3U2l6ZSkge1xuICAgICAgICBpZiAobmV3U2l6ZSA+PSB0aGlzLnNpemUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmV3U2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjdXJyZW50ID0gdGhpcy5faGVhZDtcbiAgICAgICAgbGV0IGN1cnJlbnRTaXplID0gdGhpcy5zaXplO1xuICAgICAgICB3aGlsZSAoY3VycmVudCAmJiBjdXJyZW50U2l6ZSA+IG5ld1NpemUpIHtcbiAgICAgICAgICAgIHRoaXMuX21hcC5kZWxldGUoY3VycmVudC5rZXkpO1xuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgICAgICAgICAgIGN1cnJlbnRTaXplLS07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faGVhZCA9IGN1cnJlbnQ7XG4gICAgICAgIHRoaXMuX3NpemUgPSBjdXJyZW50U2l6ZTtcbiAgICAgICAgaWYgKGN1cnJlbnQpIHtcbiAgICAgICAgICAgIGN1cnJlbnQucHJldmlvdXMgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc3RhdGUrKztcbiAgICB9XG4gICAgYWRkSXRlbUZpcnN0KGl0ZW0pIHtcbiAgICAgICAgLy8gRmlyc3QgdGltZSBJbnNlcnRcbiAgICAgICAgaWYgKCF0aGlzLl9oZWFkICYmICF0aGlzLl90YWlsKSB7XG4gICAgICAgICAgICB0aGlzLl90YWlsID0gaXRlbTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGhpcy5faGVhZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGxpc3QnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGl0ZW0ubmV4dCA9IHRoaXMuX2hlYWQ7XG4gICAgICAgICAgICB0aGlzLl9oZWFkLnByZXZpb3VzID0gaXRlbTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9oZWFkID0gaXRlbTtcbiAgICAgICAgdGhpcy5fc3RhdGUrKztcbiAgICB9XG4gICAgYWRkSXRlbUxhc3QoaXRlbSkge1xuICAgICAgICAvLyBGaXJzdCB0aW1lIEluc2VydFxuICAgICAgICBpZiAoIXRoaXMuX2hlYWQgJiYgIXRoaXMuX3RhaWwpIHtcbiAgICAgICAgICAgIHRoaXMuX2hlYWQgPSBpdGVtO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCF0aGlzLl90YWlsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbGlzdCcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaXRlbS5wcmV2aW91cyA9IHRoaXMuX3RhaWw7XG4gICAgICAgICAgICB0aGlzLl90YWlsLm5leHQgPSBpdGVtO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3RhaWwgPSBpdGVtO1xuICAgICAgICB0aGlzLl9zdGF0ZSsrO1xuICAgIH1cbiAgICByZW1vdmVJdGVtKGl0ZW0pIHtcbiAgICAgICAgaWYgKGl0ZW0gPT09IHRoaXMuX2hlYWQgJiYgaXRlbSA9PT0gdGhpcy5fdGFpbCkge1xuICAgICAgICAgICAgdGhpcy5faGVhZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuX3RhaWwgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXRlbSA9PT0gdGhpcy5faGVhZCkge1xuICAgICAgICAgICAgLy8gVGhpcyBjYW4gb25seSBoYXBwZW5lZCBpZiBzaXplID09PSAxIHdoaWNoIGlzIGhhbmRsZVxuICAgICAgICAgICAgLy8gYnkgdGhlIGNhc2UgYWJvdmUuXG4gICAgICAgICAgICBpZiAoIWl0ZW0ubmV4dCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBsaXN0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpdGVtLm5leHQucHJldmlvdXMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLl9oZWFkID0gaXRlbS5uZXh0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGl0ZW0gPT09IHRoaXMuX3RhaWwpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgY2FuIG9ubHkgaGFwcGVuZWQgaWYgc2l6ZSA9PT0gMSB3aGljaCBpcyBoYW5kbGVcbiAgICAgICAgICAgIC8vIGJ5IHRoZSBjYXNlIGFib3ZlLlxuICAgICAgICAgICAgaWYgKCFpdGVtLnByZXZpb3VzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGxpc3QnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGl0ZW0ucHJldmlvdXMubmV4dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuX3RhaWwgPSBpdGVtLnByZXZpb3VzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgbmV4dCA9IGl0ZW0ubmV4dDtcbiAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzID0gaXRlbS5wcmV2aW91cztcbiAgICAgICAgICAgIGlmICghbmV4dCB8fCAhcHJldmlvdXMpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbGlzdCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV4dC5wcmV2aW91cyA9IHByZXZpb3VzO1xuICAgICAgICAgICAgcHJldmlvdXMubmV4dCA9IG5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgaXRlbS5uZXh0ID0gdW5kZWZpbmVkO1xuICAgICAgICBpdGVtLnByZXZpb3VzID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9zdGF0ZSsrO1xuICAgIH1cbiAgICB0b3VjaChpdGVtLCB0b3VjaCkge1xuICAgICAgICBpZiAoIXRoaXMuX2hlYWQgfHwgIXRoaXMuX3RhaWwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBsaXN0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCh0b3VjaCAhPT0gVG91Y2guRmlyc3QgJiYgdG91Y2ggIT09IFRvdWNoLkxhc3QpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRvdWNoID09PSBUb3VjaC5GaXJzdCkge1xuICAgICAgICAgICAgaWYgKGl0ZW0gPT09IHRoaXMuX2hlYWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBuZXh0ID0gaXRlbS5uZXh0O1xuICAgICAgICAgICAgY29uc3QgcHJldmlvdXMgPSBpdGVtLnByZXZpb3VzO1xuICAgICAgICAgICAgLy8gVW5saW5rIHRoZSBpdGVtXG4gICAgICAgICAgICBpZiAoaXRlbSA9PT0gdGhpcy5fdGFpbCkge1xuICAgICAgICAgICAgICAgIC8vIHByZXZpb3VzIG11c3QgYmUgZGVmaW5lZCBzaW5jZSBpdGVtIHdhcyBub3QgaGVhZCBidXQgaXMgdGFpbFxuICAgICAgICAgICAgICAgIC8vIFNvIHRoZXJlIGFyZSBtb3JlIHRoYW4gb24gaXRlbSBpbiB0aGUgbWFwXG4gICAgICAgICAgICAgICAgcHJldmlvdXMubmV4dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB0aGlzLl90YWlsID0gcHJldmlvdXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBCb3RoIG5leHQgYW5kIHByZXZpb3VzIGFyZSBub3QgdW5kZWZpbmVkIHNpbmNlIGl0ZW0gd2FzIG5laXRoZXIgaGVhZCBub3IgdGFpbC5cbiAgICAgICAgICAgICAgICBuZXh0LnByZXZpb3VzID0gcHJldmlvdXM7XG4gICAgICAgICAgICAgICAgcHJldmlvdXMubmV4dCA9IG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJbnNlcnQgdGhlIG5vZGUgYXQgaGVhZFxuICAgICAgICAgICAgaXRlbS5wcmV2aW91cyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGl0ZW0ubmV4dCA9IHRoaXMuX2hlYWQ7XG4gICAgICAgICAgICB0aGlzLl9oZWFkLnByZXZpb3VzID0gaXRlbTtcbiAgICAgICAgICAgIHRoaXMuX2hlYWQgPSBpdGVtO1xuICAgICAgICAgICAgdGhpcy5fc3RhdGUrKztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0b3VjaCA9PT0gVG91Y2guTGFzdCkge1xuICAgICAgICAgICAgaWYgKGl0ZW0gPT09IHRoaXMuX3RhaWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBuZXh0ID0gaXRlbS5uZXh0O1xuICAgICAgICAgICAgY29uc3QgcHJldmlvdXMgPSBpdGVtLnByZXZpb3VzO1xuICAgICAgICAgICAgLy8gVW5saW5rIHRoZSBpdGVtLlxuICAgICAgICAgICAgaWYgKGl0ZW0gPT09IHRoaXMuX2hlYWQpIHtcbiAgICAgICAgICAgICAgICAvLyBuZXh0IG11c3QgYmUgZGVmaW5lZCBzaW5jZSBpdGVtIHdhcyBub3QgdGFpbCBidXQgaXMgaGVhZFxuICAgICAgICAgICAgICAgIC8vIFNvIHRoZXJlIGFyZSBtb3JlIHRoYW4gb24gaXRlbSBpbiB0aGUgbWFwXG4gICAgICAgICAgICAgICAgbmV4dC5wcmV2aW91cyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB0aGlzLl9oZWFkID0gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEJvdGggbmV4dCBhbmQgcHJldmlvdXMgYXJlIG5vdCB1bmRlZmluZWQgc2luY2UgaXRlbSB3YXMgbmVpdGhlciBoZWFkIG5vciB0YWlsLlxuICAgICAgICAgICAgICAgIG5leHQucHJldmlvdXMgPSBwcmV2aW91cztcbiAgICAgICAgICAgICAgICBwcmV2aW91cy5uZXh0ID0gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGl0ZW0ubmV4dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGl0ZW0ucHJldmlvdXMgPSB0aGlzLl90YWlsO1xuICAgICAgICAgICAgdGhpcy5fdGFpbC5uZXh0ID0gaXRlbTtcbiAgICAgICAgICAgIHRoaXMuX3RhaWwgPSBpdGVtO1xuICAgICAgICAgICAgdGhpcy5fc3RhdGUrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBbXTtcbiAgICAgICAgdGhpcy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgICAgICBkYXRhLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBmcm9tSlNPTihkYXRhKSB7XG4gICAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgZGF0YSkge1xuICAgICAgICAgICAgdGhpcy5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkxpbmtlZE1hcCA9IExpbmtlZE1hcDtcbmNsYXNzIExSVUNhY2hlIGV4dGVuZHMgTGlua2VkTWFwIHtcbiAgICBjb25zdHJ1Y3RvcihsaW1pdCwgcmF0aW8gPSAxKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX2xpbWl0ID0gbGltaXQ7XG4gICAgICAgIHRoaXMuX3JhdGlvID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgcmF0aW8pLCAxKTtcbiAgICB9XG4gICAgZ2V0IGxpbWl0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGltaXQ7XG4gICAgfVxuICAgIHNldCBsaW1pdChsaW1pdCkge1xuICAgICAgICB0aGlzLl9saW1pdCA9IGxpbWl0O1xuICAgICAgICB0aGlzLmNoZWNrVHJpbSgpO1xuICAgIH1cbiAgICBnZXQgcmF0aW8oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yYXRpbztcbiAgICB9XG4gICAgc2V0IHJhdGlvKHJhdGlvKSB7XG4gICAgICAgIHRoaXMuX3JhdGlvID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgcmF0aW8pLCAxKTtcbiAgICAgICAgdGhpcy5jaGVja1RyaW0oKTtcbiAgICB9XG4gICAgZ2V0KGtleSwgdG91Y2ggPSBUb3VjaC5Bc05ldykge1xuICAgICAgICByZXR1cm4gc3VwZXIuZ2V0KGtleSwgdG91Y2gpO1xuICAgIH1cbiAgICBwZWVrKGtleSkge1xuICAgICAgICByZXR1cm4gc3VwZXIuZ2V0KGtleSwgVG91Y2guTm9uZSk7XG4gICAgfVxuICAgIHNldChrZXksIHZhbHVlKSB7XG4gICAgICAgIHN1cGVyLnNldChrZXksIHZhbHVlLCBUb3VjaC5MYXN0KTtcbiAgICAgICAgdGhpcy5jaGVja1RyaW0oKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGNoZWNrVHJpbSgpIHtcbiAgICAgICAgaWYgKHRoaXMuc2l6ZSA+IHRoaXMuX2xpbWl0KSB7XG4gICAgICAgICAgICB0aGlzLnRyaW1PbGQoTWF0aC5yb3VuZCh0aGlzLl9saW1pdCAqIHRoaXMuX3JhdGlvKSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkxSVUNhY2hlID0gTFJVQ2FjaGU7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDk4MDU6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5BYnN0cmFjdE1lc3NhZ2VCdWZmZXIgPSB2b2lkIDA7XG5jb25zdCBDUiA9IDEzO1xuY29uc3QgTEYgPSAxMDtcbmNvbnN0IENSTEYgPSAnXFxyXFxuJztcbmNsYXNzIEFic3RyYWN0TWVzc2FnZUJ1ZmZlciB7XG4gICAgY29uc3RydWN0b3IoZW5jb2RpbmcgPSAndXRmLTgnKSB7XG4gICAgICAgIHRoaXMuX2VuY29kaW5nID0gZW5jb2Rpbmc7XG4gICAgICAgIHRoaXMuX2NodW5rcyA9IFtdO1xuICAgICAgICB0aGlzLl90b3RhbExlbmd0aCA9IDA7XG4gICAgfVxuICAgIGdldCBlbmNvZGluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VuY29kaW5nO1xuICAgIH1cbiAgICBhcHBlbmQoY2h1bmspIHtcbiAgICAgICAgY29uc3QgdG9BcHBlbmQgPSB0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnID8gdGhpcy5mcm9tU3RyaW5nKGNodW5rLCB0aGlzLl9lbmNvZGluZykgOiBjaHVuaztcbiAgICAgICAgdGhpcy5fY2h1bmtzLnB1c2godG9BcHBlbmQpO1xuICAgICAgICB0aGlzLl90b3RhbExlbmd0aCArPSB0b0FwcGVuZC5ieXRlTGVuZ3RoO1xuICAgIH1cbiAgICB0cnlSZWFkSGVhZGVycyhsb3dlckNhc2VLZXlzID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKHRoaXMuX2NodW5rcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN0YXRlID0gMDtcbiAgICAgICAgbGV0IGNodW5rSW5kZXggPSAwO1xuICAgICAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICAgICAgbGV0IGNodW5rQnl0ZXNSZWFkID0gMDtcbiAgICAgICAgcm93OiB3aGlsZSAoY2h1bmtJbmRleCA8IHRoaXMuX2NodW5rcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IGNodW5rID0gdGhpcy5fY2h1bmtzW2NodW5rSW5kZXhdO1xuICAgICAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIGNvbHVtbjogd2hpbGUgKG9mZnNldCA8IGNodW5rLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gY2h1bmtbb2Zmc2V0XTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgQ1I6XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSAzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBMRjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoc3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IDQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhayByb3c7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9mZnNldCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2h1bmtCeXRlc1JlYWQgKz0gY2h1bmsuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgIGNodW5rSW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUgIT09IDQpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlIGJ1ZmZlciBjb250YWlucyB0aGUgdHdvIENSTEYgYXQgdGhlIGVuZC4gU28gd2Ugd2lsbFxuICAgICAgICAvLyBoYXZlIHR3byBlbXB0eSBsaW5lcyBhZnRlciB0aGUgc3BsaXQgYXQgdGhlIGVuZCBhcyB3ZWxsLlxuICAgICAgICBjb25zdCBidWZmZXIgPSB0aGlzLl9yZWFkKGNodW5rQnl0ZXNSZWFkICsgb2Zmc2V0KTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IE1hcCgpO1xuICAgICAgICBjb25zdCBoZWFkZXJzID0gdGhpcy50b1N0cmluZyhidWZmZXIsICdhc2NpaScpLnNwbGl0KENSTEYpO1xuICAgICAgICBpZiAoaGVhZGVycy5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaGVhZGVycy5sZW5ndGggLSAyOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlciA9IGhlYWRlcnNbaV07XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IGhlYWRlci5pbmRleE9mKCc6Jyk7XG4gICAgICAgICAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNZXNzYWdlIGhlYWRlciBtdXN0IHNlcGFyYXRlIGtleSBhbmQgdmFsdWUgdXNpbmcgOicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qga2V5ID0gaGVhZGVyLnN1YnN0cigwLCBpbmRleCk7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGhlYWRlci5zdWJzdHIoaW5kZXggKyAxKS50cmltKCk7XG4gICAgICAgICAgICByZXN1bHQuc2V0KGxvd2VyQ2FzZUtleXMgPyBrZXkudG9Mb3dlckNhc2UoKSA6IGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHRyeVJlYWRCb2R5KGxlbmd0aCkge1xuICAgICAgICBpZiAodGhpcy5fdG90YWxMZW5ndGggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWQobGVuZ3RoKTtcbiAgICB9XG4gICAgZ2V0IG51bWJlck9mQnl0ZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90b3RhbExlbmd0aDtcbiAgICB9XG4gICAgX3JlYWQoYnl0ZUNvdW50KSB7XG4gICAgICAgIGlmIChieXRlQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVtcHR5QnVmZmVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJ5dGVDb3VudCA+IHRoaXMuX3RvdGFsTGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCByZWFkIHNvIG1hbnkgYnl0ZXMhYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2NodW5rc1swXS5ieXRlTGVuZ3RoID09PSBieXRlQ291bnQpIHtcbiAgICAgICAgICAgIC8vIHN1cGVyIGZhc3QgcGF0aCwgcHJlY2lzZWx5IGZpcnN0IGNodW5rIG11c3QgYmUgcmV0dXJuZWRcbiAgICAgICAgICAgIGNvbnN0IGNodW5rID0gdGhpcy5fY2h1bmtzWzBdO1xuICAgICAgICAgICAgdGhpcy5fY2h1bmtzLnNoaWZ0KCk7XG4gICAgICAgICAgICB0aGlzLl90b3RhbExlbmd0aCAtPSBieXRlQ291bnQ7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hc05hdGl2ZShjaHVuayk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2NodW5rc1swXS5ieXRlTGVuZ3RoID4gYnl0ZUNvdW50KSB7XG4gICAgICAgICAgICAvLyBmYXN0IHBhdGgsIHRoZSByZWFkaW5nIGlzIGVudGlyZWx5IHdpdGhpbiB0aGUgZmlyc3QgY2h1bmtcbiAgICAgICAgICAgIGNvbnN0IGNodW5rID0gdGhpcy5fY2h1bmtzWzBdO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5hc05hdGl2ZShjaHVuaywgYnl0ZUNvdW50KTtcbiAgICAgICAgICAgIHRoaXMuX2NodW5rc1swXSA9IGNodW5rLnNsaWNlKGJ5dGVDb3VudCk7XG4gICAgICAgICAgICB0aGlzLl90b3RhbExlbmd0aCAtPSBieXRlQ291bnQ7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuYWxsb2NOYXRpdmUoYnl0ZUNvdW50KTtcbiAgICAgICAgbGV0IHJlc3VsdE9mZnNldCA9IDA7XG4gICAgICAgIGxldCBjaHVua0luZGV4ID0gMDtcbiAgICAgICAgd2hpbGUgKGJ5dGVDb3VudCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGNodW5rID0gdGhpcy5fY2h1bmtzW2NodW5rSW5kZXhdO1xuICAgICAgICAgICAgaWYgKGNodW5rLmJ5dGVMZW5ndGggPiBieXRlQ291bnQpIHtcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGNodW5rIHdpbGwgc3Vydml2ZVxuICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rUGFydCA9IGNodW5rLnNsaWNlKDAsIGJ5dGVDb3VudCk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnNldChjaHVua1BhcnQsIHJlc3VsdE9mZnNldCk7XG4gICAgICAgICAgICAgICAgcmVzdWx0T2Zmc2V0ICs9IGJ5dGVDb3VudDtcbiAgICAgICAgICAgICAgICB0aGlzLl9jaHVua3NbY2h1bmtJbmRleF0gPSBjaHVuay5zbGljZShieXRlQ291bnQpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3RvdGFsTGVuZ3RoIC09IGJ5dGVDb3VudDtcbiAgICAgICAgICAgICAgICBieXRlQ291bnQgLT0gYnl0ZUNvdW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gdGhpcyBjaHVuayB3aWxsIGJlIGVudGlyZWx5IHJlYWRcbiAgICAgICAgICAgICAgICByZXN1bHQuc2V0KGNodW5rLCByZXN1bHRPZmZzZXQpO1xuICAgICAgICAgICAgICAgIHJlc3VsdE9mZnNldCArPSBjaHVuay5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NodW5rcy5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3RvdGFsTGVuZ3RoIC09IGNodW5rLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgICAgICAgYnl0ZUNvdW50IC09IGNodW5rLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG5leHBvcnRzLkFic3RyYWN0TWVzc2FnZUJ1ZmZlciA9IEFic3RyYWN0TWVzc2FnZUJ1ZmZlcjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNjU2OlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLlJlYWRhYmxlU3RyZWFtTWVzc2FnZVJlYWRlciA9IGV4cG9ydHMuQWJzdHJhY3RNZXNzYWdlUmVhZGVyID0gZXhwb3J0cy5NZXNzYWdlUmVhZGVyID0gdm9pZCAwO1xuY29uc3QgcmFsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUwOTEpO1xuY29uc3QgSXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY2MTgpO1xuY29uc3QgZXZlbnRzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI0NzkpO1xuY29uc3Qgc2VtYXBob3JlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQxOCk7XG52YXIgTWVzc2FnZVJlYWRlcjtcbihmdW5jdGlvbiAoTWVzc2FnZVJlYWRlcikge1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGxldCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJiBJcy5mdW5jKGNhbmRpZGF0ZS5saXN0ZW4pICYmIElzLmZ1bmMoY2FuZGlkYXRlLmRpc3Bvc2UpICYmXG4gICAgICAgICAgICBJcy5mdW5jKGNhbmRpZGF0ZS5vbkVycm9yKSAmJiBJcy5mdW5jKGNhbmRpZGF0ZS5vbkNsb3NlKSAmJiBJcy5mdW5jKGNhbmRpZGF0ZS5vblBhcnRpYWxNZXNzYWdlKTtcbiAgICB9XG4gICAgTWVzc2FnZVJlYWRlci5pcyA9IGlzO1xufSkoTWVzc2FnZVJlYWRlciA9IGV4cG9ydHMuTWVzc2FnZVJlYWRlciB8fCAoZXhwb3J0cy5NZXNzYWdlUmVhZGVyID0ge30pKTtcbmNsYXNzIEFic3RyYWN0TWVzc2FnZVJlYWRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuZXJyb3JFbWl0dGVyID0gbmV3IGV2ZW50c18xLkVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5jbG9zZUVtaXR0ZXIgPSBuZXcgZXZlbnRzXzEuRW1pdHRlcigpO1xuICAgICAgICB0aGlzLnBhcnRpYWxNZXNzYWdlRW1pdHRlciA9IG5ldyBldmVudHNfMS5FbWl0dGVyKCk7XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIHRoaXMuZXJyb3JFbWl0dGVyLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5jbG9zZUVtaXR0ZXIuZGlzcG9zZSgpO1xuICAgIH1cbiAgICBnZXQgb25FcnJvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3JFbWl0dGVyLmV2ZW50O1xuICAgIH1cbiAgICBmaXJlRXJyb3IoZXJyb3IpIHtcbiAgICAgICAgdGhpcy5lcnJvckVtaXR0ZXIuZmlyZSh0aGlzLmFzRXJyb3IoZXJyb3IpKTtcbiAgICB9XG4gICAgZ2V0IG9uQ2xvc2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsb3NlRW1pdHRlci5ldmVudDtcbiAgICB9XG4gICAgZmlyZUNsb3NlKCkge1xuICAgICAgICB0aGlzLmNsb3NlRW1pdHRlci5maXJlKHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIGdldCBvblBhcnRpYWxNZXNzYWdlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJ0aWFsTWVzc2FnZUVtaXR0ZXIuZXZlbnQ7XG4gICAgfVxuICAgIGZpcmVQYXJ0aWFsTWVzc2FnZShpbmZvKSB7XG4gICAgICAgIHRoaXMucGFydGlhbE1lc3NhZ2VFbWl0dGVyLmZpcmUoaW5mbyk7XG4gICAgfVxuICAgIGFzRXJyb3IoZXJyb3IpIHtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoYFJlYWRlciByZWNlaXZlZCBlcnJvci4gUmVhc29uOiAke0lzLnN0cmluZyhlcnJvci5tZXNzYWdlKSA/IGVycm9yLm1lc3NhZ2UgOiAndW5rbm93bid9YCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkFic3RyYWN0TWVzc2FnZVJlYWRlciA9IEFic3RyYWN0TWVzc2FnZVJlYWRlcjtcbnZhciBSZXNvbHZlZE1lc3NhZ2VSZWFkZXJPcHRpb25zO1xuKGZ1bmN0aW9uIChSZXNvbHZlZE1lc3NhZ2VSZWFkZXJPcHRpb25zKSB7XG4gICAgZnVuY3Rpb24gZnJvbU9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICBsZXQgY2hhcnNldDtcbiAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgbGV0IGNvbnRlbnREZWNvZGVyO1xuICAgICAgICBjb25zdCBjb250ZW50RGVjb2RlcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIGxldCBjb250ZW50VHlwZURlY29kZXI7XG4gICAgICAgIGNvbnN0IGNvbnRlbnRUeXBlRGVjb2RlcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjaGFyc2V0ID0gb3B0aW9ucyA/PyAndXRmLTgnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2hhcnNldCA9IG9wdGlvbnMuY2hhcnNldCA/PyAndXRmLTgnO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuY29udGVudERlY29kZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNvbnRlbnREZWNvZGVyID0gb3B0aW9ucy5jb250ZW50RGVjb2RlcjtcbiAgICAgICAgICAgICAgICBjb250ZW50RGVjb2RlcnMuc2V0KGNvbnRlbnREZWNvZGVyLm5hbWUsIGNvbnRlbnREZWNvZGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmNvbnRlbnREZWNvZGVycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBkZWNvZGVyIG9mIG9wdGlvbnMuY29udGVudERlY29kZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnREZWNvZGVycy5zZXQoZGVjb2Rlci5uYW1lLCBkZWNvZGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5jb250ZW50VHlwZURlY29kZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlRGVjb2RlciA9IG9wdGlvbnMuY29udGVudFR5cGVEZWNvZGVyO1xuICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlRGVjb2RlcnMuc2V0KGNvbnRlbnRUeXBlRGVjb2Rlci5uYW1lLCBjb250ZW50VHlwZURlY29kZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuY29udGVudFR5cGVEZWNvZGVycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBkZWNvZGVyIG9mIG9wdGlvbnMuY29udGVudFR5cGVEZWNvZGVycykge1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50VHlwZURlY29kZXJzLnNldChkZWNvZGVyLm5hbWUsIGRlY29kZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udGVudFR5cGVEZWNvZGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnRlbnRUeXBlRGVjb2RlciA9ICgwLCByYWxfMS5kZWZhdWx0KSgpLmFwcGxpY2F0aW9uSnNvbi5kZWNvZGVyO1xuICAgICAgICAgICAgY29udGVudFR5cGVEZWNvZGVycy5zZXQoY29udGVudFR5cGVEZWNvZGVyLm5hbWUsIGNvbnRlbnRUeXBlRGVjb2Rlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgY2hhcnNldCwgY29udGVudERlY29kZXIsIGNvbnRlbnREZWNvZGVycywgY29udGVudFR5cGVEZWNvZGVyLCBjb250ZW50VHlwZURlY29kZXJzIH07XG4gICAgfVxuICAgIFJlc29sdmVkTWVzc2FnZVJlYWRlck9wdGlvbnMuZnJvbU9wdGlvbnMgPSBmcm9tT3B0aW9ucztcbn0pKFJlc29sdmVkTWVzc2FnZVJlYWRlck9wdGlvbnMgfHwgKFJlc29sdmVkTWVzc2FnZVJlYWRlck9wdGlvbnMgPSB7fSkpO1xuY2xhc3MgUmVhZGFibGVTdHJlYW1NZXNzYWdlUmVhZGVyIGV4dGVuZHMgQWJzdHJhY3RNZXNzYWdlUmVhZGVyIHtcbiAgICBjb25zdHJ1Y3RvcihyZWFkYWJsZSwgb3B0aW9ucykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnJlYWRhYmxlID0gcmVhZGFibGU7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IFJlc29sdmVkTWVzc2FnZVJlYWRlck9wdGlvbnMuZnJvbU9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gKDAsIHJhbF8xLmRlZmF1bHQpKCkubWVzc2FnZUJ1ZmZlci5jcmVhdGUodGhpcy5vcHRpb25zLmNoYXJzZXQpO1xuICAgICAgICB0aGlzLl9wYXJ0aWFsTWVzc2FnZVRpbWVvdXQgPSAxMDAwMDtcbiAgICAgICAgdGhpcy5uZXh0TWVzc2FnZUxlbmd0aCA9IC0xO1xuICAgICAgICB0aGlzLm1lc3NhZ2VUb2tlbiA9IDA7XG4gICAgICAgIHRoaXMucmVhZFNlbWFwaG9yZSA9IG5ldyBzZW1hcGhvcmVfMS5TZW1hcGhvcmUoMSk7XG4gICAgfVxuICAgIHNldCBwYXJ0aWFsTWVzc2FnZVRpbWVvdXQodGltZW91dCkge1xuICAgICAgICB0aGlzLl9wYXJ0aWFsTWVzc2FnZVRpbWVvdXQgPSB0aW1lb3V0O1xuICAgIH1cbiAgICBnZXQgcGFydGlhbE1lc3NhZ2VUaW1lb3V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFydGlhbE1lc3NhZ2VUaW1lb3V0O1xuICAgIH1cbiAgICBsaXN0ZW4oY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5uZXh0TWVzc2FnZUxlbmd0aCA9IC0xO1xuICAgICAgICB0aGlzLm1lc3NhZ2VUb2tlbiA9IDA7XG4gICAgICAgIHRoaXMucGFydGlhbE1lc3NhZ2VUaW1lciA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLnJlYWRhYmxlLm9uRGF0YSgoZGF0YSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5vbkRhdGEoZGF0YSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlYWRhYmxlLm9uRXJyb3IoKGVycm9yKSA9PiB0aGlzLmZpcmVFcnJvcihlcnJvcikpO1xuICAgICAgICB0aGlzLnJlYWRhYmxlLm9uQ2xvc2UoKCkgPT4gdGhpcy5maXJlQ2xvc2UoKSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIG9uRGF0YShkYXRhKSB7XG4gICAgICAgIHRoaXMuYnVmZmVyLmFwcGVuZChkYXRhKTtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm5leHRNZXNzYWdlTGVuZ3RoID09PSAtMSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGhlYWRlcnMgPSB0aGlzLmJ1ZmZlci50cnlSZWFkSGVhZGVycyh0cnVlKTtcbiAgICAgICAgICAgICAgICBpZiAoIWhlYWRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBjb250ZW50TGVuZ3RoID0gaGVhZGVycy5nZXQoJ2NvbnRlbnQtbGVuZ3RoJyk7XG4gICAgICAgICAgICAgICAgaWYgKCFjb250ZW50TGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmlyZUVycm9yKG5ldyBFcnJvcignSGVhZGVyIG11c3QgcHJvdmlkZSBhIENvbnRlbnQtTGVuZ3RoIHByb3BlcnR5LicpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBsZW5ndGggPSBwYXJzZUludChjb250ZW50TGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNOYU4obGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpcmVFcnJvcihuZXcgRXJyb3IoJ0NvbnRlbnQtTGVuZ3RoIHZhbHVlIG11c3QgYmUgYSBudW1iZXIuJykpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMubmV4dE1lc3NhZ2VMZW5ndGggPSBsZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gdGhpcy5idWZmZXIudHJ5UmVhZEJvZHkodGhpcy5uZXh0TWVzc2FnZUxlbmd0aCk7XG4gICAgICAgICAgICBpZiAoYm9keSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgLyoqIFdlIGhhdmVuJ3QgcmVjZWl2ZWQgdGhlIGZ1bGwgbWVzc2FnZSB5ZXQuICovXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRQYXJ0aWFsTWVzc2FnZVRpbWVyKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jbGVhclBhcnRpYWxNZXNzYWdlVGltZXIoKTtcbiAgICAgICAgICAgIHRoaXMubmV4dE1lc3NhZ2VMZW5ndGggPSAtMTtcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHdlIGNvbnZlcnQgb25lIHJlY2VpdmVkIG1lc3NhZ2UgYWZ0ZXIgdGhlXG4gICAgICAgICAgICAvLyBvdGhlci4gT3RoZXJ3aXNlIGl0IGNvdWxkIGhhcHBlbiB0aGF0IGEgZGVjb2Rpbmcgb2YgYSBzZWNvbmRcbiAgICAgICAgICAgIC8vIHNtYWxsZXIgbWVzc2FnZSBmaW5pc2hlZCBiZWZvcmUgdGhlIGRlY29kaW5nIG9mIGEgZmlyc3QgbGFyZ2VyXG4gICAgICAgICAgICAvLyBtZXNzYWdlIGFuZCB0aGVuIHdlIHdvdWxkIGRlbGl2ZXIgdGhlIHNlY29uZCBtZXNzYWdlIGZpcnN0LlxuICAgICAgICAgICAgdGhpcy5yZWFkU2VtYXBob3JlLmxvY2soYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJ5dGVzID0gdGhpcy5vcHRpb25zLmNvbnRlbnREZWNvZGVyICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgPyBhd2FpdCB0aGlzLm9wdGlvbnMuY29udGVudERlY29kZXIuZGVjb2RlKGJvZHkpXG4gICAgICAgICAgICAgICAgICAgIDogYm9keTtcbiAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gYXdhaXQgdGhpcy5vcHRpb25zLmNvbnRlbnRUeXBlRGVjb2Rlci5kZWNvZGUoYnl0ZXMsIHRoaXMub3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgdGhpcy5jYWxsYmFjayhtZXNzYWdlKTtcbiAgICAgICAgICAgIH0pLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZmlyZUVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNsZWFyUGFydGlhbE1lc3NhZ2VUaW1lcigpIHtcbiAgICAgICAgaWYgKHRoaXMucGFydGlhbE1lc3NhZ2VUaW1lcikge1xuICAgICAgICAgICAgdGhpcy5wYXJ0aWFsTWVzc2FnZVRpbWVyLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIHRoaXMucGFydGlhbE1lc3NhZ2VUaW1lciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRQYXJ0aWFsTWVzc2FnZVRpbWVyKCkge1xuICAgICAgICB0aGlzLmNsZWFyUGFydGlhbE1lc3NhZ2VUaW1lcigpO1xuICAgICAgICBpZiAodGhpcy5fcGFydGlhbE1lc3NhZ2VUaW1lb3V0IDw9IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBhcnRpYWxNZXNzYWdlVGltZXIgPSAoMCwgcmFsXzEuZGVmYXVsdCkoKS50aW1lci5zZXRUaW1lb3V0KCh0b2tlbiwgdGltZW91dCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5wYXJ0aWFsTWVzc2FnZVRpbWVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKHRva2VuID09PSB0aGlzLm1lc3NhZ2VUb2tlbikge1xuICAgICAgICAgICAgICAgIHRoaXMuZmlyZVBhcnRpYWxNZXNzYWdlKHsgbWVzc2FnZVRva2VuOiB0b2tlbiwgd2FpdGluZ1RpbWU6IHRpbWVvdXQgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRQYXJ0aWFsTWVzc2FnZVRpbWVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMuX3BhcnRpYWxNZXNzYWdlVGltZW91dCwgdGhpcy5tZXNzYWdlVG9rZW4sIHRoaXMuX3BhcnRpYWxNZXNzYWdlVGltZW91dCk7XG4gICAgfVxufVxuZXhwb3J0cy5SZWFkYWJsZVN0cmVhbU1lc3NhZ2VSZWFkZXIgPSBSZWFkYWJsZVN0cmVhbU1lc3NhZ2VSZWFkZXI7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDkwMzY6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuV3JpdGVhYmxlU3RyZWFtTWVzc2FnZVdyaXRlciA9IGV4cG9ydHMuQWJzdHJhY3RNZXNzYWdlV3JpdGVyID0gZXhwb3J0cy5NZXNzYWdlV3JpdGVyID0gdm9pZCAwO1xuY29uc3QgcmFsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUwOTEpO1xuY29uc3QgSXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY2MTgpO1xuY29uc3Qgc2VtYXBob3JlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQxOCk7XG5jb25zdCBldmVudHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjQ3OSk7XG5jb25zdCBDb250ZW50TGVuZ3RoID0gJ0NvbnRlbnQtTGVuZ3RoOiAnO1xuY29uc3QgQ1JMRiA9ICdcXHJcXG4nO1xudmFyIE1lc3NhZ2VXcml0ZXI7XG4oZnVuY3Rpb24gKE1lc3NhZ2VXcml0ZXIpIHtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBsZXQgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgJiYgSXMuZnVuYyhjYW5kaWRhdGUuZGlzcG9zZSkgJiYgSXMuZnVuYyhjYW5kaWRhdGUub25DbG9zZSkgJiZcbiAgICAgICAgICAgIElzLmZ1bmMoY2FuZGlkYXRlLm9uRXJyb3IpICYmIElzLmZ1bmMoY2FuZGlkYXRlLndyaXRlKTtcbiAgICB9XG4gICAgTWVzc2FnZVdyaXRlci5pcyA9IGlzO1xufSkoTWVzc2FnZVdyaXRlciA9IGV4cG9ydHMuTWVzc2FnZVdyaXRlciB8fCAoZXhwb3J0cy5NZXNzYWdlV3JpdGVyID0ge30pKTtcbmNsYXNzIEFic3RyYWN0TWVzc2FnZVdyaXRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuZXJyb3JFbWl0dGVyID0gbmV3IGV2ZW50c18xLkVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5jbG9zZUVtaXR0ZXIgPSBuZXcgZXZlbnRzXzEuRW1pdHRlcigpO1xuICAgIH1cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICB0aGlzLmVycm9yRW1pdHRlci5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMuY2xvc2VFbWl0dGVyLmRpc3Bvc2UoKTtcbiAgICB9XG4gICAgZ2V0IG9uRXJyb3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVycm9yRW1pdHRlci5ldmVudDtcbiAgICB9XG4gICAgZmlyZUVycm9yKGVycm9yLCBtZXNzYWdlLCBjb3VudCkge1xuICAgICAgICB0aGlzLmVycm9yRW1pdHRlci5maXJlKFt0aGlzLmFzRXJyb3IoZXJyb3IpLCBtZXNzYWdlLCBjb3VudF0pO1xuICAgIH1cbiAgICBnZXQgb25DbG9zZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvc2VFbWl0dGVyLmV2ZW50O1xuICAgIH1cbiAgICBmaXJlQ2xvc2UoKSB7XG4gICAgICAgIHRoaXMuY2xvc2VFbWl0dGVyLmZpcmUodW5kZWZpbmVkKTtcbiAgICB9XG4gICAgYXNFcnJvcihlcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihgV3JpdGVyIHJlY2VpdmVkIGVycm9yLiBSZWFzb246ICR7SXMuc3RyaW5nKGVycm9yLm1lc3NhZ2UpID8gZXJyb3IubWVzc2FnZSA6ICd1bmtub3duJ31gKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuQWJzdHJhY3RNZXNzYWdlV3JpdGVyID0gQWJzdHJhY3RNZXNzYWdlV3JpdGVyO1xudmFyIFJlc29sdmVkTWVzc2FnZVdyaXRlck9wdGlvbnM7XG4oZnVuY3Rpb24gKFJlc29sdmVkTWVzc2FnZVdyaXRlck9wdGlvbnMpIHtcbiAgICBmdW5jdGlvbiBmcm9tT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4geyBjaGFyc2V0OiBvcHRpb25zID8/ICd1dGYtOCcsIGNvbnRlbnRUeXBlRW5jb2RlcjogKDAsIHJhbF8xLmRlZmF1bHQpKCkuYXBwbGljYXRpb25Kc29uLmVuY29kZXIgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB7IGNoYXJzZXQ6IG9wdGlvbnMuY2hhcnNldCA/PyAndXRmLTgnLCBjb250ZW50RW5jb2Rlcjogb3B0aW9ucy5jb250ZW50RW5jb2RlciwgY29udGVudFR5cGVFbmNvZGVyOiBvcHRpb25zLmNvbnRlbnRUeXBlRW5jb2RlciA/PyAoMCwgcmFsXzEuZGVmYXVsdCkoKS5hcHBsaWNhdGlvbkpzb24uZW5jb2RlciB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIFJlc29sdmVkTWVzc2FnZVdyaXRlck9wdGlvbnMuZnJvbU9wdGlvbnMgPSBmcm9tT3B0aW9ucztcbn0pKFJlc29sdmVkTWVzc2FnZVdyaXRlck9wdGlvbnMgfHwgKFJlc29sdmVkTWVzc2FnZVdyaXRlck9wdGlvbnMgPSB7fSkpO1xuY2xhc3MgV3JpdGVhYmxlU3RyZWFtTWVzc2FnZVdyaXRlciBleHRlbmRzIEFic3RyYWN0TWVzc2FnZVdyaXRlciB7XG4gICAgY29uc3RydWN0b3Iod3JpdGFibGUsIG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy53cml0YWJsZSA9IHdyaXRhYmxlO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBSZXNvbHZlZE1lc3NhZ2VXcml0ZXJPcHRpb25zLmZyb21PcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmVycm9yQ291bnQgPSAwO1xuICAgICAgICB0aGlzLndyaXRlU2VtYXBob3JlID0gbmV3IHNlbWFwaG9yZV8xLlNlbWFwaG9yZSgxKTtcbiAgICAgICAgdGhpcy53cml0YWJsZS5vbkVycm9yKChlcnJvcikgPT4gdGhpcy5maXJlRXJyb3IoZXJyb3IpKTtcbiAgICAgICAgdGhpcy53cml0YWJsZS5vbkNsb3NlKCgpID0+IHRoaXMuZmlyZUNsb3NlKCkpO1xuICAgIH1cbiAgICBhc3luYyB3cml0ZShtc2cpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud3JpdGVTZW1hcGhvcmUubG9jayhhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0gdGhpcy5vcHRpb25zLmNvbnRlbnRUeXBlRW5jb2Rlci5lbmNvZGUobXNnLCB0aGlzLm9wdGlvbnMpLnRoZW4oKGJ1ZmZlcikgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuY29udGVudEVuY29kZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmNvbnRlbnRFbmNvZGVyLmVuY29kZShidWZmZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBwYXlsb2FkLnRoZW4oKGJ1ZmZlcikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGhlYWRlcnMgPSBbXTtcbiAgICAgICAgICAgICAgICBoZWFkZXJzLnB1c2goQ29udGVudExlbmd0aCwgYnVmZmVyLmJ5dGVMZW5ndGgudG9TdHJpbmcoKSwgQ1JMRik7XG4gICAgICAgICAgICAgICAgaGVhZGVycy5wdXNoKENSTEYpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRvV3JpdGUobXNnLCBoZWFkZXJzLCBidWZmZXIpO1xuICAgICAgICAgICAgfSwgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5maXJlRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBkb1dyaXRlKG1zZywgaGVhZGVycywgZGF0YSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy53cml0YWJsZS53cml0ZShoZWFkZXJzLmpvaW4oJycpLCAnYXNjaWknKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndyaXRhYmxlLndyaXRlKGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVFcnJvcihlcnJvciwgbXNnKTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFuZGxlRXJyb3IoZXJyb3IsIG1zZykge1xuICAgICAgICB0aGlzLmVycm9yQ291bnQrKztcbiAgICAgICAgdGhpcy5maXJlRXJyb3IoZXJyb3IsIG1zZywgdGhpcy5lcnJvckNvdW50KTtcbiAgICB9XG4gICAgZW5kKCkge1xuICAgICAgICB0aGlzLndyaXRhYmxlLmVuZCgpO1xuICAgIH1cbn1cbmV4cG9ydHMuV3JpdGVhYmxlU3RyZWFtTWVzc2FnZVdyaXRlciA9IFdyaXRlYWJsZVN0cmVhbU1lc3NhZ2VXcml0ZXI7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDcxNjI6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuTWVzc2FnZSA9IGV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTkgPSBleHBvcnRzLk5vdGlmaWNhdGlvblR5cGU4ID0gZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlNyA9IGV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTYgPSBleHBvcnRzLk5vdGlmaWNhdGlvblR5cGU1ID0gZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlNCA9IGV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTMgPSBleHBvcnRzLk5vdGlmaWNhdGlvblR5cGUyID0gZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlMSA9IGV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTAgPSBleHBvcnRzLk5vdGlmaWNhdGlvblR5cGUgPSBleHBvcnRzLlJlcXVlc3RUeXBlOSA9IGV4cG9ydHMuUmVxdWVzdFR5cGU4ID0gZXhwb3J0cy5SZXF1ZXN0VHlwZTcgPSBleHBvcnRzLlJlcXVlc3RUeXBlNiA9IGV4cG9ydHMuUmVxdWVzdFR5cGU1ID0gZXhwb3J0cy5SZXF1ZXN0VHlwZTQgPSBleHBvcnRzLlJlcXVlc3RUeXBlMyA9IGV4cG9ydHMuUmVxdWVzdFR5cGUyID0gZXhwb3J0cy5SZXF1ZXN0VHlwZTEgPSBleHBvcnRzLlJlcXVlc3RUeXBlID0gZXhwb3J0cy5SZXF1ZXN0VHlwZTAgPSBleHBvcnRzLkFic3RyYWN0TWVzc2FnZVNpZ25hdHVyZSA9IGV4cG9ydHMuUGFyYW1ldGVyU3RydWN0dXJlcyA9IGV4cG9ydHMuUmVzcG9uc2VFcnJvciA9IGV4cG9ydHMuRXJyb3JDb2RlcyA9IHZvaWQgMDtcbmNvbnN0IGlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NjE4KTtcbi8qKlxuICogUHJlZGVmaW5lZCBlcnJvciBjb2Rlcy5cbiAqL1xudmFyIEVycm9yQ29kZXM7XG4oZnVuY3Rpb24gKEVycm9yQ29kZXMpIHtcbiAgICAvLyBEZWZpbmVkIGJ5IEpTT04gUlBDXG4gICAgRXJyb3JDb2Rlcy5QYXJzZUVycm9yID0gLTMyNzAwO1xuICAgIEVycm9yQ29kZXMuSW52YWxpZFJlcXVlc3QgPSAtMzI2MDA7XG4gICAgRXJyb3JDb2Rlcy5NZXRob2ROb3RGb3VuZCA9IC0zMjYwMTtcbiAgICBFcnJvckNvZGVzLkludmFsaWRQYXJhbXMgPSAtMzI2MDI7XG4gICAgRXJyb3JDb2Rlcy5JbnRlcm5hbEVycm9yID0gLTMyNjAzO1xuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgdGhlIHN0YXJ0IHJhbmdlIG9mIEpTT04gUlBDIHJlc2VydmVkIGVycm9yIGNvZGVzLlxuICAgICAqIEl0IGRvZXNuJ3QgZGVub3RlIGEgcmVhbCBlcnJvciBjb2RlLiBObyBhcHBsaWNhdGlvbiBlcnJvciBjb2RlcyBzaG91bGRcbiAgICAgKiBiZSBkZWZpbmVkIGJldHdlZW4gdGhlIHN0YXJ0IGFuZCBlbmQgcmFuZ2UuIEZvciBiYWNrd2FyZHNcbiAgICAgKiBjb21wYXRpYmlsaXR5IHRoZSBgU2VydmVyTm90SW5pdGlhbGl6ZWRgIGFuZCB0aGUgYFVua25vd25FcnJvckNvZGVgXG4gICAgICogYXJlIGxlZnQgaW4gdGhlIHJhbmdlLlxuICAgICAqXG4gICAgICogQHNpbmNlIDMuMTYuMFxuICAgICovXG4gICAgRXJyb3JDb2Rlcy5qc29ucnBjUmVzZXJ2ZWRFcnJvclJhbmdlU3RhcnQgPSAtMzIwOTk7XG4gICAgLyoqIEBkZXByZWNhdGVkIHVzZSAganNvbnJwY1Jlc2VydmVkRXJyb3JSYW5nZVN0YXJ0ICovXG4gICAgRXJyb3JDb2Rlcy5zZXJ2ZXJFcnJvclN0YXJ0ID0gLTMyMDk5O1xuICAgIC8qKlxuICAgICAqIEFuIGVycm9yIG9jY3VycmVkIHdoZW4gd3JpdGUgYSBtZXNzYWdlIHRvIHRoZSB0cmFuc3BvcnQgbGF5ZXIuXG4gICAgICovXG4gICAgRXJyb3JDb2Rlcy5NZXNzYWdlV3JpdGVFcnJvciA9IC0zMjA5OTtcbiAgICAvKipcbiAgICAgKiBBbiBlcnJvciBvY2N1cnJlZCB3aGVuIHJlYWRpbmcgYSBtZXNzYWdlIGZyb20gdGhlIHRyYW5zcG9ydCBsYXllci5cbiAgICAgKi9cbiAgICBFcnJvckNvZGVzLk1lc3NhZ2VSZWFkRXJyb3IgPSAtMzIwOTg7XG4gICAgLyoqXG4gICAgICogVGhlIGNvbm5lY3Rpb24gZ290IGRpc3Bvc2VkIG9yIGxvc3QgYW5kIGFsbCBwZW5kaW5nIHJlc3BvbnNlcyBnb3RcbiAgICAgKiByZWplY3RlZC5cbiAgICAgKi9cbiAgICBFcnJvckNvZGVzLlBlbmRpbmdSZXNwb25zZVJlamVjdGVkID0gLTMyMDk3O1xuICAgIC8qKlxuICAgICAqIFRoZSBjb25uZWN0aW9uIGlzIGluYWN0aXZlIGFuZCBhIHVzZSBvZiBpdCBmYWlsZWQuXG4gICAgICovXG4gICAgRXJyb3JDb2Rlcy5Db25uZWN0aW9uSW5hY3RpdmUgPSAtMzIwOTY7XG4gICAgLyoqXG4gICAgICogRXJyb3IgY29kZSBpbmRpY2F0aW5nIHRoYXQgYSBzZXJ2ZXIgcmVjZWl2ZWQgYSBub3RpZmljYXRpb24gb3JcbiAgICAgKiByZXF1ZXN0IGJlZm9yZSB0aGUgc2VydmVyIGhhcyByZWNlaXZlZCB0aGUgYGluaXRpYWxpemVgIHJlcXVlc3QuXG4gICAgICovXG4gICAgRXJyb3JDb2Rlcy5TZXJ2ZXJOb3RJbml0aWFsaXplZCA9IC0zMjAwMjtcbiAgICBFcnJvckNvZGVzLlVua25vd25FcnJvckNvZGUgPSAtMzIwMDE7XG4gICAgLyoqXG4gICAgICogVGhpcyBpcyB0aGUgZW5kIHJhbmdlIG9mIEpTT04gUlBDIHJlc2VydmVkIGVycm9yIGNvZGVzLlxuICAgICAqIEl0IGRvZXNuJ3QgZGVub3RlIGEgcmVhbCBlcnJvciBjb2RlLlxuICAgICAqXG4gICAgICogQHNpbmNlIDMuMTYuMFxuICAgICovXG4gICAgRXJyb3JDb2Rlcy5qc29ucnBjUmVzZXJ2ZWRFcnJvclJhbmdlRW5kID0gLTMyMDAwO1xuICAgIC8qKiBAZGVwcmVjYXRlZCB1c2UgIGpzb25ycGNSZXNlcnZlZEVycm9yUmFuZ2VFbmQgKi9cbiAgICBFcnJvckNvZGVzLnNlcnZlckVycm9yRW5kID0gLTMyMDAwO1xufSkoRXJyb3JDb2RlcyA9IGV4cG9ydHMuRXJyb3JDb2RlcyB8fCAoZXhwb3J0cy5FcnJvckNvZGVzID0ge30pKTtcbi8qKlxuICogQW4gZXJyb3Igb2JqZWN0IHJldHVybiBpbiBhIHJlc3BvbnNlIGluIGNhc2UgYSByZXF1ZXN0XG4gKiBoYXMgZmFpbGVkLlxuICovXG5jbGFzcyBSZXNwb25zZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGNvZGUsIG1lc3NhZ2UsIGRhdGEpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMuY29kZSA9IGlzLm51bWJlcihjb2RlKSA/IGNvZGUgOiBFcnJvckNvZGVzLlVua25vd25FcnJvckNvZGU7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBSZXNwb25zZUVycm9yLnByb3RvdHlwZSk7XG4gICAgfVxuICAgIHRvSnNvbigpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICAgICAgY29kZTogdGhpcy5jb2RlLFxuICAgICAgICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLmRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzdWx0LmRhdGEgPSB0aGlzLmRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG5leHBvcnRzLlJlc3BvbnNlRXJyb3IgPSBSZXNwb25zZUVycm9yO1xuY2xhc3MgUGFyYW1ldGVyU3RydWN0dXJlcyB7XG4gICAgY29uc3RydWN0b3Ioa2luZCkge1xuICAgICAgICB0aGlzLmtpbmQgPSBraW5kO1xuICAgIH1cbiAgICBzdGF0aWMgaXModmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSBQYXJhbWV0ZXJTdHJ1Y3R1cmVzLmF1dG8gfHwgdmFsdWUgPT09IFBhcmFtZXRlclN0cnVjdHVyZXMuYnlOYW1lIHx8IHZhbHVlID09PSBQYXJhbWV0ZXJTdHJ1Y3R1cmVzLmJ5UG9zaXRpb247XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5raW5kO1xuICAgIH1cbn1cbmV4cG9ydHMuUGFyYW1ldGVyU3RydWN0dXJlcyA9IFBhcmFtZXRlclN0cnVjdHVyZXM7XG4vKipcbiAqIFRoZSBwYXJhbWV0ZXIgc3RydWN0dXJlIGlzIGF1dG9tYXRpY2FsbHkgaW5mZXJyZWQgb24gdGhlIG51bWJlciBvZiBwYXJhbWV0ZXJzXG4gKiBhbmQgdGhlIHBhcmFtZXRlciB0eXBlIGluIGNhc2Ugb2YgYSBzaW5nbGUgcGFyYW0uXG4gKi9cblBhcmFtZXRlclN0cnVjdHVyZXMuYXV0byA9IG5ldyBQYXJhbWV0ZXJTdHJ1Y3R1cmVzKCdhdXRvJyk7XG4vKipcbiAqIEZvcmNlcyBgYnlQb3NpdGlvbmAgcGFyYW1ldGVyIHN0cnVjdHVyZS4gVGhpcyBpcyB1c2VmdWwgaWYgeW91IGhhdmUgYSBzaW5nbGVcbiAqIHBhcmFtZXRlciB3aGljaCBoYXMgYSBsaXRlcmFsIHR5cGUuXG4gKi9cblBhcmFtZXRlclN0cnVjdHVyZXMuYnlQb3NpdGlvbiA9IG5ldyBQYXJhbWV0ZXJTdHJ1Y3R1cmVzKCdieVBvc2l0aW9uJyk7XG4vKipcbiAqIEZvcmNlcyBgYnlOYW1lYCBwYXJhbWV0ZXIgc3RydWN0dXJlLiBUaGlzIGlzIG9ubHkgdXNlZnVsIHdoZW4gaGF2aW5nIGEgc2luZ2xlXG4gKiBwYXJhbWV0ZXIuIFRoZSBsaWJyYXJ5IHdpbGwgcmVwb3J0IGVycm9ycyBpZiB1c2VkIHdpdGggYSBkaWZmZXJlbnQgbnVtYmVyIG9mXG4gKiBwYXJhbWV0ZXJzLlxuICovXG5QYXJhbWV0ZXJTdHJ1Y3R1cmVzLmJ5TmFtZSA9IG5ldyBQYXJhbWV0ZXJTdHJ1Y3R1cmVzKCdieU5hbWUnKTtcbi8qKlxuICogQW4gYWJzdHJhY3QgaW1wbGVtZW50YXRpb24gb2YgYSBNZXNzYWdlVHlwZS5cbiAqL1xuY2xhc3MgQWJzdHJhY3RNZXNzYWdlU2lnbmF0dXJlIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRob2QsIG51bWJlck9mUGFyYW1zKSB7XG4gICAgICAgIHRoaXMubWV0aG9kID0gbWV0aG9kO1xuICAgICAgICB0aGlzLm51bWJlck9mUGFyYW1zID0gbnVtYmVyT2ZQYXJhbXM7XG4gICAgfVxuICAgIGdldCBwYXJhbWV0ZXJTdHJ1Y3R1cmVzKCkge1xuICAgICAgICByZXR1cm4gUGFyYW1ldGVyU3RydWN0dXJlcy5hdXRvO1xuICAgIH1cbn1cbmV4cG9ydHMuQWJzdHJhY3RNZXNzYWdlU2lnbmF0dXJlID0gQWJzdHJhY3RNZXNzYWdlU2lnbmF0dXJlO1xuLyoqXG4gKiBDbGFzc2VzIHRvIHR5cGUgcmVxdWVzdCByZXNwb25zZSBwYWlyc1xuICovXG5jbGFzcyBSZXF1ZXN0VHlwZTAgZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCkge1xuICAgICAgICBzdXBlcihtZXRob2QsIDApO1xuICAgIH1cbn1cbmV4cG9ydHMuUmVxdWVzdFR5cGUwID0gUmVxdWVzdFR5cGUwO1xuY2xhc3MgUmVxdWVzdFR5cGUgZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCwgX3BhcmFtZXRlclN0cnVjdHVyZXMgPSBQYXJhbWV0ZXJTdHJ1Y3R1cmVzLmF1dG8pIHtcbiAgICAgICAgc3VwZXIobWV0aG9kLCAxKTtcbiAgICAgICAgdGhpcy5fcGFyYW1ldGVyU3RydWN0dXJlcyA9IF9wYXJhbWV0ZXJTdHJ1Y3R1cmVzO1xuICAgIH1cbiAgICBnZXQgcGFyYW1ldGVyU3RydWN0dXJlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmFtZXRlclN0cnVjdHVyZXM7XG4gICAgfVxufVxuZXhwb3J0cy5SZXF1ZXN0VHlwZSA9IFJlcXVlc3RUeXBlO1xuY2xhc3MgUmVxdWVzdFR5cGUxIGV4dGVuZHMgQWJzdHJhY3RNZXNzYWdlU2lnbmF0dXJlIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRob2QsIF9wYXJhbWV0ZXJTdHJ1Y3R1cmVzID0gUGFyYW1ldGVyU3RydWN0dXJlcy5hdXRvKSB7XG4gICAgICAgIHN1cGVyKG1ldGhvZCwgMSk7XG4gICAgICAgIHRoaXMuX3BhcmFtZXRlclN0cnVjdHVyZXMgPSBfcGFyYW1ldGVyU3RydWN0dXJlcztcbiAgICB9XG4gICAgZ2V0IHBhcmFtZXRlclN0cnVjdHVyZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJhbWV0ZXJTdHJ1Y3R1cmVzO1xuICAgIH1cbn1cbmV4cG9ydHMuUmVxdWVzdFR5cGUxID0gUmVxdWVzdFR5cGUxO1xuY2xhc3MgUmVxdWVzdFR5cGUyIGV4dGVuZHMgQWJzdHJhY3RNZXNzYWdlU2lnbmF0dXJlIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRob2QpIHtcbiAgICAgICAgc3VwZXIobWV0aG9kLCAyKTtcbiAgICB9XG59XG5leHBvcnRzLlJlcXVlc3RUeXBlMiA9IFJlcXVlc3RUeXBlMjtcbmNsYXNzIFJlcXVlc3RUeXBlMyBleHRlbmRzIEFic3RyYWN0TWVzc2FnZVNpZ25hdHVyZSB7XG4gICAgY29uc3RydWN0b3IobWV0aG9kKSB7XG4gICAgICAgIHN1cGVyKG1ldGhvZCwgMyk7XG4gICAgfVxufVxuZXhwb3J0cy5SZXF1ZXN0VHlwZTMgPSBSZXF1ZXN0VHlwZTM7XG5jbGFzcyBSZXF1ZXN0VHlwZTQgZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCkge1xuICAgICAgICBzdXBlcihtZXRob2QsIDQpO1xuICAgIH1cbn1cbmV4cG9ydHMuUmVxdWVzdFR5cGU0ID0gUmVxdWVzdFR5cGU0O1xuY2xhc3MgUmVxdWVzdFR5cGU1IGV4dGVuZHMgQWJzdHJhY3RNZXNzYWdlU2lnbmF0dXJlIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRob2QpIHtcbiAgICAgICAgc3VwZXIobWV0aG9kLCA1KTtcbiAgICB9XG59XG5leHBvcnRzLlJlcXVlc3RUeXBlNSA9IFJlcXVlc3RUeXBlNTtcbmNsYXNzIFJlcXVlc3RUeXBlNiBleHRlbmRzIEFic3RyYWN0TWVzc2FnZVNpZ25hdHVyZSB7XG4gICAgY29uc3RydWN0b3IobWV0aG9kKSB7XG4gICAgICAgIHN1cGVyKG1ldGhvZCwgNik7XG4gICAgfVxufVxuZXhwb3J0cy5SZXF1ZXN0VHlwZTYgPSBSZXF1ZXN0VHlwZTY7XG5jbGFzcyBSZXF1ZXN0VHlwZTcgZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCkge1xuICAgICAgICBzdXBlcihtZXRob2QsIDcpO1xuICAgIH1cbn1cbmV4cG9ydHMuUmVxdWVzdFR5cGU3ID0gUmVxdWVzdFR5cGU3O1xuY2xhc3MgUmVxdWVzdFR5cGU4IGV4dGVuZHMgQWJzdHJhY3RNZXNzYWdlU2lnbmF0dXJlIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRob2QpIHtcbiAgICAgICAgc3VwZXIobWV0aG9kLCA4KTtcbiAgICB9XG59XG5leHBvcnRzLlJlcXVlc3RUeXBlOCA9IFJlcXVlc3RUeXBlODtcbmNsYXNzIFJlcXVlc3RUeXBlOSBleHRlbmRzIEFic3RyYWN0TWVzc2FnZVNpZ25hdHVyZSB7XG4gICAgY29uc3RydWN0b3IobWV0aG9kKSB7XG4gICAgICAgIHN1cGVyKG1ldGhvZCwgOSk7XG4gICAgfVxufVxuZXhwb3J0cy5SZXF1ZXN0VHlwZTkgPSBSZXF1ZXN0VHlwZTk7XG5jbGFzcyBOb3RpZmljYXRpb25UeXBlIGV4dGVuZHMgQWJzdHJhY3RNZXNzYWdlU2lnbmF0dXJlIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRob2QsIF9wYXJhbWV0ZXJTdHJ1Y3R1cmVzID0gUGFyYW1ldGVyU3RydWN0dXJlcy5hdXRvKSB7XG4gICAgICAgIHN1cGVyKG1ldGhvZCwgMSk7XG4gICAgICAgIHRoaXMuX3BhcmFtZXRlclN0cnVjdHVyZXMgPSBfcGFyYW1ldGVyU3RydWN0dXJlcztcbiAgICB9XG4gICAgZ2V0IHBhcmFtZXRlclN0cnVjdHVyZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJhbWV0ZXJTdHJ1Y3R1cmVzO1xuICAgIH1cbn1cbmV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZSA9IE5vdGlmaWNhdGlvblR5cGU7XG5jbGFzcyBOb3RpZmljYXRpb25UeXBlMCBleHRlbmRzIEFic3RyYWN0TWVzc2FnZVNpZ25hdHVyZSB7XG4gICAgY29uc3RydWN0b3IobWV0aG9kKSB7XG4gICAgICAgIHN1cGVyKG1ldGhvZCwgMCk7XG4gICAgfVxufVxuZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlMCA9IE5vdGlmaWNhdGlvblR5cGUwO1xuY2xhc3MgTm90aWZpY2F0aW9uVHlwZTEgZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCwgX3BhcmFtZXRlclN0cnVjdHVyZXMgPSBQYXJhbWV0ZXJTdHJ1Y3R1cmVzLmF1dG8pIHtcbiAgICAgICAgc3VwZXIobWV0aG9kLCAxKTtcbiAgICAgICAgdGhpcy5fcGFyYW1ldGVyU3RydWN0dXJlcyA9IF9wYXJhbWV0ZXJTdHJ1Y3R1cmVzO1xuICAgIH1cbiAgICBnZXQgcGFyYW1ldGVyU3RydWN0dXJlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmFtZXRlclN0cnVjdHVyZXM7XG4gICAgfVxufVxuZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlMSA9IE5vdGlmaWNhdGlvblR5cGUxO1xuY2xhc3MgTm90aWZpY2F0aW9uVHlwZTIgZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCkge1xuICAgICAgICBzdXBlcihtZXRob2QsIDIpO1xuICAgIH1cbn1cbmV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTIgPSBOb3RpZmljYXRpb25UeXBlMjtcbmNsYXNzIE5vdGlmaWNhdGlvblR5cGUzIGV4dGVuZHMgQWJzdHJhY3RNZXNzYWdlU2lnbmF0dXJlIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRob2QpIHtcbiAgICAgICAgc3VwZXIobWV0aG9kLCAzKTtcbiAgICB9XG59XG5leHBvcnRzLk5vdGlmaWNhdGlvblR5cGUzID0gTm90aWZpY2F0aW9uVHlwZTM7XG5jbGFzcyBOb3RpZmljYXRpb25UeXBlNCBleHRlbmRzIEFic3RyYWN0TWVzc2FnZVNpZ25hdHVyZSB7XG4gICAgY29uc3RydWN0b3IobWV0aG9kKSB7XG4gICAgICAgIHN1cGVyKG1ldGhvZCwgNCk7XG4gICAgfVxufVxuZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlNCA9IE5vdGlmaWNhdGlvblR5cGU0O1xuY2xhc3MgTm90aWZpY2F0aW9uVHlwZTUgZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCkge1xuICAgICAgICBzdXBlcihtZXRob2QsIDUpO1xuICAgIH1cbn1cbmV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTUgPSBOb3RpZmljYXRpb25UeXBlNTtcbmNsYXNzIE5vdGlmaWNhdGlvblR5cGU2IGV4dGVuZHMgQWJzdHJhY3RNZXNzYWdlU2lnbmF0dXJlIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRob2QpIHtcbiAgICAgICAgc3VwZXIobWV0aG9kLCA2KTtcbiAgICB9XG59XG5leHBvcnRzLk5vdGlmaWNhdGlvblR5cGU2ID0gTm90aWZpY2F0aW9uVHlwZTY7XG5jbGFzcyBOb3RpZmljYXRpb25UeXBlNyBleHRlbmRzIEFic3RyYWN0TWVzc2FnZVNpZ25hdHVyZSB7XG4gICAgY29uc3RydWN0b3IobWV0aG9kKSB7XG4gICAgICAgIHN1cGVyKG1ldGhvZCwgNyk7XG4gICAgfVxufVxuZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlNyA9IE5vdGlmaWNhdGlvblR5cGU3O1xuY2xhc3MgTm90aWZpY2F0aW9uVHlwZTggZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCkge1xuICAgICAgICBzdXBlcihtZXRob2QsIDgpO1xuICAgIH1cbn1cbmV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTggPSBOb3RpZmljYXRpb25UeXBlODtcbmNsYXNzIE5vdGlmaWNhdGlvblR5cGU5IGV4dGVuZHMgQWJzdHJhY3RNZXNzYWdlU2lnbmF0dXJlIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRob2QpIHtcbiAgICAgICAgc3VwZXIobWV0aG9kLCA5KTtcbiAgICB9XG59XG5leHBvcnRzLk5vdGlmaWNhdGlvblR5cGU5ID0gTm90aWZpY2F0aW9uVHlwZTk7XG52YXIgTWVzc2FnZTtcbihmdW5jdGlvbiAoTWVzc2FnZSkge1xuICAgIC8qKlxuICAgICAqIFRlc3RzIGlmIHRoZSBnaXZlbiBtZXNzYWdlIGlzIGEgcmVxdWVzdCBtZXNzYWdlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNSZXF1ZXN0KG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gbWVzc2FnZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJiBpcy5zdHJpbmcoY2FuZGlkYXRlLm1ldGhvZCkgJiYgKGlzLnN0cmluZyhjYW5kaWRhdGUuaWQpIHx8IGlzLm51bWJlcihjYW5kaWRhdGUuaWQpKTtcbiAgICB9XG4gICAgTWVzc2FnZS5pc1JlcXVlc3QgPSBpc1JlcXVlc3Q7XG4gICAgLyoqXG4gICAgICogVGVzdHMgaWYgdGhlIGdpdmVuIG1lc3NhZ2UgaXMgYSBub3RpZmljYXRpb24gbWVzc2FnZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTm90aWZpY2F0aW9uKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gbWVzc2FnZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJiBpcy5zdHJpbmcoY2FuZGlkYXRlLm1ldGhvZCkgJiYgbWVzc2FnZS5pZCA9PT0gdm9pZCAwO1xuICAgIH1cbiAgICBNZXNzYWdlLmlzTm90aWZpY2F0aW9uID0gaXNOb3RpZmljYXRpb247XG4gICAgLyoqXG4gICAgICogVGVzdHMgaWYgdGhlIGdpdmVuIG1lc3NhZ2UgaXMgYSByZXNwb25zZSBtZXNzYWdlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNSZXNwb25zZShtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IG1lc3NhZ2U7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgJiYgKGNhbmRpZGF0ZS5yZXN1bHQgIT09IHZvaWQgMCB8fCAhIWNhbmRpZGF0ZS5lcnJvcikgJiYgKGlzLnN0cmluZyhjYW5kaWRhdGUuaWQpIHx8IGlzLm51bWJlcihjYW5kaWRhdGUuaWQpIHx8IGNhbmRpZGF0ZS5pZCA9PT0gbnVsbCk7XG4gICAgfVxuICAgIE1lc3NhZ2UuaXNSZXNwb25zZSA9IGlzUmVzcG9uc2U7XG59KShNZXNzYWdlID0gZXhwb3J0cy5NZXNzYWdlIHx8IChleHBvcnRzLk1lc3NhZ2UgPSB7fSkpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA1MDkxOlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5sZXQgX3JhbDtcbmZ1bmN0aW9uIFJBTCgpIHtcbiAgICBpZiAoX3JhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gcnVudGltZSBhYnN0cmFjdGlvbiBsYXllciBpbnN0YWxsZWRgKTtcbiAgICB9XG4gICAgcmV0dXJuIF9yYWw7XG59XG4oZnVuY3Rpb24gKFJBTCkge1xuICAgIGZ1bmN0aW9uIGluc3RhbGwocmFsKSB7XG4gICAgICAgIGlmIChyYWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBydW50aW1lIGFic3RyYWN0aW9uIGxheWVyIHByb3ZpZGVkYCk7XG4gICAgICAgIH1cbiAgICAgICAgX3JhbCA9IHJhbDtcbiAgICB9XG4gICAgUkFMLmluc3RhbGwgPSBpbnN0YWxsO1xufSkoUkFMIHx8IChSQUwgPSB7fSkpO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBSQUw7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDQxODpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5TZW1hcGhvcmUgPSB2b2lkIDA7XG5jb25zdCByYWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNTA5MSk7XG5jbGFzcyBTZW1hcGhvcmUge1xuICAgIGNvbnN0cnVjdG9yKGNhcGFjaXR5ID0gMSkge1xuICAgICAgICBpZiAoY2FwYWNpdHkgPD0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYXBhY2l0eSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY2FwYWNpdHkgPSBjYXBhY2l0eTtcbiAgICAgICAgdGhpcy5fYWN0aXZlID0gMDtcbiAgICAgICAgdGhpcy5fd2FpdGluZyA9IFtdO1xuICAgIH1cbiAgICBsb2NrKHRodW5rKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLl93YWl0aW5nLnB1c2goeyB0aHVuaywgcmVzb2x2ZSwgcmVqZWN0IH0pO1xuICAgICAgICAgICAgdGhpcy5ydW5OZXh0KCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXQgYWN0aXZlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWN0aXZlO1xuICAgIH1cbiAgICBydW5OZXh0KCkge1xuICAgICAgICBpZiAodGhpcy5fd2FpdGluZy5sZW5ndGggPT09IDAgfHwgdGhpcy5fYWN0aXZlID09PSB0aGlzLl9jYXBhY2l0eSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgICgwLCByYWxfMS5kZWZhdWx0KSgpLnRpbWVyLnNldEltbWVkaWF0ZSgoKSA9PiB0aGlzLmRvUnVuTmV4dCgpKTtcbiAgICB9XG4gICAgZG9SdW5OZXh0KCkge1xuICAgICAgICBpZiAodGhpcy5fd2FpdGluZy5sZW5ndGggPT09IDAgfHwgdGhpcy5fYWN0aXZlID09PSB0aGlzLl9jYXBhY2l0eSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5leHQgPSB0aGlzLl93YWl0aW5nLnNoaWZ0KCk7XG4gICAgICAgIHRoaXMuX2FjdGl2ZSsrO1xuICAgICAgICBpZiAodGhpcy5fYWN0aXZlID4gdGhpcy5fY2FwYWNpdHkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVG8gbWFueSB0aHVua3MgYWN0aXZlYCk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IG5leHQudGh1bmsoKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnRoZW4oKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FjdGl2ZS0tO1xuICAgICAgICAgICAgICAgICAgICBuZXh0LnJlc29sdmUodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJ1bk5leHQoKTtcbiAgICAgICAgICAgICAgICB9LCAoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FjdGl2ZS0tO1xuICAgICAgICAgICAgICAgICAgICBuZXh0LnJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJ1bk5leHQoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FjdGl2ZS0tO1xuICAgICAgICAgICAgICAgIG5leHQucmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgIHRoaXMucnVuTmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuX2FjdGl2ZS0tO1xuICAgICAgICAgICAgbmV4dC5yZWplY3QoZXJyKTtcbiAgICAgICAgICAgIHRoaXMucnVuTmV4dCgpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5TZW1hcGhvcmUgPSBTZW1hcGhvcmU7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDM0ODk6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuU2hhcmVkQXJyYXlSZWNlaXZlclN0cmF0ZWd5ID0gZXhwb3J0cy5TaGFyZWRBcnJheVNlbmRlclN0cmF0ZWd5ID0gdm9pZCAwO1xuY29uc3QgY2FuY2VsbGF0aW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY5NTcpO1xudmFyIENhbmNlbGxhdGlvblN0YXRlO1xuKGZ1bmN0aW9uIChDYW5jZWxsYXRpb25TdGF0ZSkge1xuICAgIENhbmNlbGxhdGlvblN0YXRlLkNvbnRpbnVlID0gMDtcbiAgICBDYW5jZWxsYXRpb25TdGF0ZS5DYW5jZWxsZWQgPSAxO1xufSkoQ2FuY2VsbGF0aW9uU3RhdGUgfHwgKENhbmNlbGxhdGlvblN0YXRlID0ge30pKTtcbmNsYXNzIFNoYXJlZEFycmF5U2VuZGVyU3RyYXRlZ3kge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmJ1ZmZlcnMgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIGVuYWJsZUNhbmNlbGxhdGlvbihyZXF1ZXN0KSB7XG4gICAgICAgIGlmIChyZXF1ZXN0LmlkID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYnVmZmVyID0gbmV3IFNoYXJlZEFycmF5QnVmZmVyKDQpO1xuICAgICAgICBjb25zdCBkYXRhID0gbmV3IEludDMyQXJyYXkoYnVmZmVyLCAwLCAxKTtcbiAgICAgICAgZGF0YVswXSA9IENhbmNlbGxhdGlvblN0YXRlLkNvbnRpbnVlO1xuICAgICAgICB0aGlzLmJ1ZmZlcnMuc2V0KHJlcXVlc3QuaWQsIGJ1ZmZlcik7XG4gICAgICAgIHJlcXVlc3QuJGNhbmNlbGxhdGlvbkRhdGEgPSBidWZmZXI7XG4gICAgfVxuICAgIGFzeW5jIHNlbmRDYW5jZWxsYXRpb24oX2Nvbm4sIGlkKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IHRoaXMuYnVmZmVycy5nZXQoaWQpO1xuICAgICAgICBpZiAoYnVmZmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkYXRhID0gbmV3IEludDMyQXJyYXkoYnVmZmVyLCAwLCAxKTtcbiAgICAgICAgQXRvbWljcy5zdG9yZShkYXRhLCAwLCBDYW5jZWxsYXRpb25TdGF0ZS5DYW5jZWxsZWQpO1xuICAgIH1cbiAgICBjbGVhbnVwKGlkKSB7XG4gICAgICAgIHRoaXMuYnVmZmVycy5kZWxldGUoaWQpO1xuICAgIH1cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICB0aGlzLmJ1ZmZlcnMuY2xlYXIoKTtcbiAgICB9XG59XG5leHBvcnRzLlNoYXJlZEFycmF5U2VuZGVyU3RyYXRlZ3kgPSBTaGFyZWRBcnJheVNlbmRlclN0cmF0ZWd5O1xuY2xhc3MgU2hhcmVkQXJyYXlCdWZmZXJDYW5jZWxsYXRpb25Ub2tlbiB7XG4gICAgY29uc3RydWN0b3IoYnVmZmVyKSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IG5ldyBJbnQzMkFycmF5KGJ1ZmZlciwgMCwgMSk7XG4gICAgfVxuICAgIGdldCBpc0NhbmNlbGxhdGlvblJlcXVlc3RlZCgpIHtcbiAgICAgICAgcmV0dXJuIEF0b21pY3MubG9hZCh0aGlzLmRhdGEsIDApID09PSBDYW5jZWxsYXRpb25TdGF0ZS5DYW5jZWxsZWQ7XG4gICAgfVxuICAgIGdldCBvbkNhbmNlbGxhdGlvblJlcXVlc3RlZCgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5jZWxsYXRpb24gb3ZlciBTaGFyZWRBcnJheUJ1ZmZlciBkb2Vzbid0IHN1cHBvcnQgY2FuY2VsbGF0aW9uIGV2ZW50c2ApO1xuICAgIH1cbn1cbmNsYXNzIFNoYXJlZEFycmF5QnVmZmVyQ2FuY2VsbGF0aW9uVG9rZW5Tb3VyY2Uge1xuICAgIGNvbnN0cnVjdG9yKGJ1ZmZlcikge1xuICAgICAgICB0aGlzLnRva2VuID0gbmV3IFNoYXJlZEFycmF5QnVmZmVyQ2FuY2VsbGF0aW9uVG9rZW4oYnVmZmVyKTtcbiAgICB9XG4gICAgY2FuY2VsKCkge1xuICAgIH1cbiAgICBkaXNwb3NlKCkge1xuICAgIH1cbn1cbmNsYXNzIFNoYXJlZEFycmF5UmVjZWl2ZXJTdHJhdGVneSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMua2luZCA9ICdyZXF1ZXN0JztcbiAgICB9XG4gICAgY3JlYXRlQ2FuY2VsbGF0aW9uVG9rZW5Tb3VyY2UocmVxdWVzdCkge1xuICAgICAgICBjb25zdCBidWZmZXIgPSByZXF1ZXN0LiRjYW5jZWxsYXRpb25EYXRhO1xuICAgICAgICBpZiAoYnVmZmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgY2FuY2VsbGF0aW9uXzEuQ2FuY2VsbGF0aW9uVG9rZW5Tb3VyY2UoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFNoYXJlZEFycmF5QnVmZmVyQ2FuY2VsbGF0aW9uVG9rZW5Tb3VyY2UoYnVmZmVyKTtcbiAgICB9XG59XG5leHBvcnRzLlNoYXJlZEFycmF5UmVjZWl2ZXJTdHJhdGVneSA9IFNoYXJlZEFycmF5UmVjZWl2ZXJTdHJhdGVneTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gODcxMzpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXG5tb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oNTUwMSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyA1NTAxOlxuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5jcmVhdGVQcm90b2NvbENvbm5lY3Rpb24gPSB2b2lkIDA7XG5jb25zdCBicm93c2VyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkyMDgpO1xuX19leHBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oOTIwOCksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oMzE0NyksIGV4cG9ydHMpO1xuZnVuY3Rpb24gY3JlYXRlUHJvdG9jb2xDb25uZWN0aW9uKHJlYWRlciwgd3JpdGVyLCBsb2dnZXIsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gKDAsIGJyb3dzZXJfMS5jcmVhdGVNZXNzYWdlQ29ubmVjdGlvbikocmVhZGVyLCB3cml0ZXIsIGxvZ2dlciwgb3B0aW9ucyk7XG59XG5leHBvcnRzLmNyZWF0ZVByb3RvY29sQ29ubmVjdGlvbiA9IGNyZWF0ZVByb3RvY29sQ29ubmVjdGlvbjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMzE0Nzpcbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuTFNQRXJyb3JDb2RlcyA9IGV4cG9ydHMuY3JlYXRlUHJvdG9jb2xDb25uZWN0aW9uID0gdm9pZCAwO1xuX19leHBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oOTExMCksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oNzcxNyksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oODQzMSksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oMTgxNSksIGV4cG9ydHMpO1xudmFyIGNvbm5lY3Rpb25fMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjkxKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNyZWF0ZVByb3RvY29sQ29ubmVjdGlvblwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbm5lY3Rpb25fMS5jcmVhdGVQcm90b2NvbENvbm5lY3Rpb247IH0gfSkpO1xudmFyIExTUEVycm9yQ29kZXM7XG4oZnVuY3Rpb24gKExTUEVycm9yQ29kZXMpIHtcbiAgICAvKipcbiAgICAqIFRoaXMgaXMgdGhlIHN0YXJ0IHJhbmdlIG9mIExTUCByZXNlcnZlZCBlcnJvciBjb2Rlcy5cbiAgICAqIEl0IGRvZXNuJ3QgZGVub3RlIGEgcmVhbCBlcnJvciBjb2RlLlxuICAgICpcbiAgICAqIEBzaW5jZSAzLjE2LjBcbiAgICAqL1xuICAgIExTUEVycm9yQ29kZXMubHNwUmVzZXJ2ZWRFcnJvclJhbmdlU3RhcnQgPSAtMzI4OTk7XG4gICAgLyoqXG4gICAgICogQSByZXF1ZXN0IGZhaWxlZCBidXQgaXQgd2FzIHN5bnRhY3RpY2FsbHkgY29ycmVjdCwgZS5nIHRoZVxuICAgICAqIG1ldGhvZCBuYW1lIHdhcyBrbm93biBhbmQgdGhlIHBhcmFtZXRlcnMgd2VyZSB2YWxpZC4gVGhlIGVycm9yXG4gICAgICogbWVzc2FnZSBzaG91bGQgY29udGFpbiBodW1hbiByZWFkYWJsZSBpbmZvcm1hdGlvbiBhYm91dCB3aHlcbiAgICAgKiB0aGUgcmVxdWVzdCBmYWlsZWQuXG4gICAgICpcbiAgICAgKiBAc2luY2UgMy4xNy4wXG4gICAgICovXG4gICAgTFNQRXJyb3JDb2Rlcy5SZXF1ZXN0RmFpbGVkID0gLTMyODAzO1xuICAgIC8qKlxuICAgICAqIFRoZSBzZXJ2ZXIgY2FuY2VsbGVkIHRoZSByZXF1ZXN0LiBUaGlzIGVycm9yIGNvZGUgc2hvdWxkXG4gICAgICogb25seSBiZSB1c2VkIGZvciByZXF1ZXN0cyB0aGF0IGV4cGxpY2l0bHkgc3VwcG9ydCBiZWluZ1xuICAgICAqIHNlcnZlciBjYW5jZWxsYWJsZS5cbiAgICAgKlxuICAgICAqIEBzaW5jZSAzLjE3LjBcbiAgICAgKi9cbiAgICBMU1BFcnJvckNvZGVzLlNlcnZlckNhbmNlbGxlZCA9IC0zMjgwMjtcbiAgICAvKipcbiAgICAgKiBUaGUgc2VydmVyIGRldGVjdGVkIHRoYXQgdGhlIGNvbnRlbnQgb2YgYSBkb2N1bWVudCBnb3RcbiAgICAgKiBtb2RpZmllZCBvdXRzaWRlIG5vcm1hbCBjb25kaXRpb25zLiBBIHNlcnZlciBzaG91bGRcbiAgICAgKiBOT1Qgc2VuZCB0aGlzIGVycm9yIGNvZGUgaWYgaXQgZGV0ZWN0cyBhIGNvbnRlbnQgY2hhbmdlXG4gICAgICogaW4gaXQgdW5wcm9jZXNzZWQgbWVzc2FnZXMuIFRoZSByZXN1bHQgZXZlbiBjb21wdXRlZFxuICAgICAqIG9uIGFuIG9sZGVyIHN0YXRlIG1pZ2h0IHN0aWxsIGJlIHVzZWZ1bCBmb3IgdGhlIGNsaWVudC5cbiAgICAgKlxuICAgICAqIElmIGEgY2xpZW50IGRlY2lkZXMgdGhhdCBhIHJlc3VsdCBpcyBub3Qgb2YgYW55IHVzZSBhbnltb3JlXG4gICAgICogdGhlIGNsaWVudCBzaG91bGQgY2FuY2VsIHRoZSByZXF1ZXN0LlxuICAgICAqL1xuICAgIExTUEVycm9yQ29kZXMuQ29udGVudE1vZGlmaWVkID0gLTMyODAxO1xuICAgIC8qKlxuICAgICAqIFRoZSBjbGllbnQgaGFzIGNhbmNlbGVkIGEgcmVxdWVzdCBhbmQgYSBzZXJ2ZXIgYXMgZGV0ZWN0ZWRcbiAgICAgKiB0aGUgY2FuY2VsLlxuICAgICAqL1xuICAgIExTUEVycm9yQ29kZXMuUmVxdWVzdENhbmNlbGxlZCA9IC0zMjgwMDtcbiAgICAvKipcbiAgICAqIFRoaXMgaXMgdGhlIGVuZCByYW5nZSBvZiBMU1AgcmVzZXJ2ZWQgZXJyb3IgY29kZXMuXG4gICAgKiBJdCBkb2Vzbid0IGRlbm90ZSBhIHJlYWwgZXJyb3IgY29kZS5cbiAgICAqXG4gICAgKiBAc2luY2UgMy4xNi4wXG4gICAgKi9cbiAgICBMU1BFcnJvckNvZGVzLmxzcFJlc2VydmVkRXJyb3JSYW5nZUVuZCA9IC0zMjgwMDtcbn0pKExTUEVycm9yQ29kZXMgPSBleHBvcnRzLkxTUEVycm9yQ29kZXMgfHwgKGV4cG9ydHMuTFNQRXJyb3JDb2RlcyA9IHt9KSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDI5MTpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5jcmVhdGVQcm90b2NvbENvbm5lY3Rpb24gPSB2b2lkIDA7XG5jb25zdCB2c2NvZGVfanNvbnJwY18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MTEwKTtcbmZ1bmN0aW9uIGNyZWF0ZVByb3RvY29sQ29ubmVjdGlvbihpbnB1dCwgb3V0cHV0LCBsb2dnZXIsIG9wdGlvbnMpIHtcbiAgICBpZiAodnNjb2RlX2pzb25ycGNfMS5Db25uZWN0aW9uU3RyYXRlZ3kuaXMob3B0aW9ucykpIHtcbiAgICAgICAgb3B0aW9ucyA9IHsgY29ubmVjdGlvblN0cmF0ZWd5OiBvcHRpb25zIH07XG4gICAgfVxuICAgIHJldHVybiAoMCwgdnNjb2RlX2pzb25ycGNfMS5jcmVhdGVNZXNzYWdlQ29ubmVjdGlvbikoaW5wdXQsIG91dHB1dCwgbG9nZ2VyLCBvcHRpb25zKTtcbn1cbmV4cG9ydHMuY3JlYXRlUHJvdG9jb2xDb25uZWN0aW9uID0gY3JlYXRlUHJvdG9jb2xDb25uZWN0aW9uO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA4NDMxOlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLlByb3RvY29sTm90aWZpY2F0aW9uVHlwZSA9IGV4cG9ydHMuUHJvdG9jb2xOb3RpZmljYXRpb25UeXBlMCA9IGV4cG9ydHMuUHJvdG9jb2xSZXF1ZXN0VHlwZSA9IGV4cG9ydHMuUHJvdG9jb2xSZXF1ZXN0VHlwZTAgPSBleHBvcnRzLlJlZ2lzdHJhdGlvblR5cGUgPSBleHBvcnRzLk1lc3NhZ2VEaXJlY3Rpb24gPSB2b2lkIDA7XG5jb25zdCB2c2NvZGVfanNvbnJwY18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MTEwKTtcbnZhciBNZXNzYWdlRGlyZWN0aW9uO1xuKGZ1bmN0aW9uIChNZXNzYWdlRGlyZWN0aW9uKSB7XG4gICAgTWVzc2FnZURpcmVjdGlvbltcImNsaWVudFRvU2VydmVyXCJdID0gXCJjbGllbnRUb1NlcnZlclwiO1xuICAgIE1lc3NhZ2VEaXJlY3Rpb25bXCJzZXJ2ZXJUb0NsaWVudFwiXSA9IFwic2VydmVyVG9DbGllbnRcIjtcbiAgICBNZXNzYWdlRGlyZWN0aW9uW1wiYm90aFwiXSA9IFwiYm90aFwiO1xufSkoTWVzc2FnZURpcmVjdGlvbiA9IGV4cG9ydHMuTWVzc2FnZURpcmVjdGlvbiB8fCAoZXhwb3J0cy5NZXNzYWdlRGlyZWN0aW9uID0ge30pKTtcbmNsYXNzIFJlZ2lzdHJhdGlvblR5cGUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCkge1xuICAgICAgICB0aGlzLm1ldGhvZCA9IG1ldGhvZDtcbiAgICB9XG59XG5leHBvcnRzLlJlZ2lzdHJhdGlvblR5cGUgPSBSZWdpc3RyYXRpb25UeXBlO1xuY2xhc3MgUHJvdG9jb2xSZXF1ZXN0VHlwZTAgZXh0ZW5kcyB2c2NvZGVfanNvbnJwY18xLlJlcXVlc3RUeXBlMCB7XG4gICAgY29uc3RydWN0b3IobWV0aG9kKSB7XG4gICAgICAgIHN1cGVyKG1ldGhvZCk7XG4gICAgfVxufVxuZXhwb3J0cy5Qcm90b2NvbFJlcXVlc3RUeXBlMCA9IFByb3RvY29sUmVxdWVzdFR5cGUwO1xuY2xhc3MgUHJvdG9jb2xSZXF1ZXN0VHlwZSBleHRlbmRzIHZzY29kZV9qc29ucnBjXzEuUmVxdWVzdFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCkge1xuICAgICAgICBzdXBlcihtZXRob2QsIHZzY29kZV9qc29ucnBjXzEuUGFyYW1ldGVyU3RydWN0dXJlcy5ieU5hbWUpO1xuICAgIH1cbn1cbmV4cG9ydHMuUHJvdG9jb2xSZXF1ZXN0VHlwZSA9IFByb3RvY29sUmVxdWVzdFR5cGU7XG5jbGFzcyBQcm90b2NvbE5vdGlmaWNhdGlvblR5cGUwIGV4dGVuZHMgdnNjb2RlX2pzb25ycGNfMS5Ob3RpZmljYXRpb25UeXBlMCB7XG4gICAgY29uc3RydWN0b3IobWV0aG9kKSB7XG4gICAgICAgIHN1cGVyKG1ldGhvZCk7XG4gICAgfVxufVxuZXhwb3J0cy5Qcm90b2NvbE5vdGlmaWNhdGlvblR5cGUwID0gUHJvdG9jb2xOb3RpZmljYXRpb25UeXBlMDtcbmNsYXNzIFByb3RvY29sTm90aWZpY2F0aW9uVHlwZSBleHRlbmRzIHZzY29kZV9qc29ucnBjXzEuTm90aWZpY2F0aW9uVHlwZSB7XG4gICAgY29uc3RydWN0b3IobWV0aG9kKSB7XG4gICAgICAgIHN1cGVyKG1ldGhvZCwgdnNjb2RlX2pzb25ycGNfMS5QYXJhbWV0ZXJTdHJ1Y3R1cmVzLmJ5TmFtZSk7XG4gICAgfVxufVxuZXhwb3J0cy5Qcm90b2NvbE5vdGlmaWNhdGlvblR5cGUgPSBQcm90b2NvbE5vdGlmaWNhdGlvblR5cGU7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDc2MDI6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBUeXBlRm94LCBNaWNyb3NvZnQgYW5kIG90aGVycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5DYWxsSGllcmFyY2h5T3V0Z29pbmdDYWxsc1JlcXVlc3QgPSBleHBvcnRzLkNhbGxIaWVyYXJjaHlJbmNvbWluZ0NhbGxzUmVxdWVzdCA9IGV4cG9ydHMuQ2FsbEhpZXJhcmNoeVByZXBhcmVSZXF1ZXN0ID0gdm9pZCAwO1xuY29uc3QgbWVzc2FnZXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oODQzMSk7XG4vKipcbiAqIEEgcmVxdWVzdCB0byByZXN1bHQgYSBgQ2FsbEhpZXJhcmNoeUl0ZW1gIGluIGEgZG9jdW1lbnQgYXQgYSBnaXZlbiBwb3NpdGlvbi5cbiAqIENhbiBiZSB1c2VkIGFzIGFuIGlucHV0IHRvIGFuIGluY29taW5nIG9yIG91dGdvaW5nIGNhbGwgaGllcmFyY2h5LlxuICpcbiAqIEBzaW5jZSAzLjE2LjBcbiAqL1xudmFyIENhbGxIaWVyYXJjaHlQcmVwYXJlUmVxdWVzdDtcbihmdW5jdGlvbiAoQ2FsbEhpZXJhcmNoeVByZXBhcmVSZXF1ZXN0KSB7XG4gICAgQ2FsbEhpZXJhcmNoeVByZXBhcmVSZXF1ZXN0Lm1ldGhvZCA9ICd0ZXh0RG9jdW1lbnQvcHJlcGFyZUNhbGxIaWVyYXJjaHknO1xuICAgIENhbGxIaWVyYXJjaHlQcmVwYXJlUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIENhbGxIaWVyYXJjaHlQcmVwYXJlUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShDYWxsSGllcmFyY2h5UHJlcGFyZVJlcXVlc3QubWV0aG9kKTtcbn0pKENhbGxIaWVyYXJjaHlQcmVwYXJlUmVxdWVzdCA9IGV4cG9ydHMuQ2FsbEhpZXJhcmNoeVByZXBhcmVSZXF1ZXN0IHx8IChleHBvcnRzLkNhbGxIaWVyYXJjaHlQcmVwYXJlUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIEEgcmVxdWVzdCB0byByZXNvbHZlIHRoZSBpbmNvbWluZyBjYWxscyBmb3IgYSBnaXZlbiBgQ2FsbEhpZXJhcmNoeUl0ZW1gLlxuICpcbiAqIEBzaW5jZSAzLjE2LjBcbiAqL1xudmFyIENhbGxIaWVyYXJjaHlJbmNvbWluZ0NhbGxzUmVxdWVzdDtcbihmdW5jdGlvbiAoQ2FsbEhpZXJhcmNoeUluY29taW5nQ2FsbHNSZXF1ZXN0KSB7XG4gICAgQ2FsbEhpZXJhcmNoeUluY29taW5nQ2FsbHNSZXF1ZXN0Lm1ldGhvZCA9ICdjYWxsSGllcmFyY2h5L2luY29taW5nQ2FsbHMnO1xuICAgIENhbGxIaWVyYXJjaHlJbmNvbWluZ0NhbGxzUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIENhbGxIaWVyYXJjaHlJbmNvbWluZ0NhbGxzUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShDYWxsSGllcmFyY2h5SW5jb21pbmdDYWxsc1JlcXVlc3QubWV0aG9kKTtcbn0pKENhbGxIaWVyYXJjaHlJbmNvbWluZ0NhbGxzUmVxdWVzdCA9IGV4cG9ydHMuQ2FsbEhpZXJhcmNoeUluY29taW5nQ2FsbHNSZXF1ZXN0IHx8IChleHBvcnRzLkNhbGxIaWVyYXJjaHlJbmNvbWluZ0NhbGxzUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIEEgcmVxdWVzdCB0byByZXNvbHZlIHRoZSBvdXRnb2luZyBjYWxscyBmb3IgYSBnaXZlbiBgQ2FsbEhpZXJhcmNoeUl0ZW1gLlxuICpcbiAqIEBzaW5jZSAzLjE2LjBcbiAqL1xudmFyIENhbGxIaWVyYXJjaHlPdXRnb2luZ0NhbGxzUmVxdWVzdDtcbihmdW5jdGlvbiAoQ2FsbEhpZXJhcmNoeU91dGdvaW5nQ2FsbHNSZXF1ZXN0KSB7XG4gICAgQ2FsbEhpZXJhcmNoeU91dGdvaW5nQ2FsbHNSZXF1ZXN0Lm1ldGhvZCA9ICdjYWxsSGllcmFyY2h5L291dGdvaW5nQ2FsbHMnO1xuICAgIENhbGxIaWVyYXJjaHlPdXRnb2luZ0NhbGxzUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIENhbGxIaWVyYXJjaHlPdXRnb2luZ0NhbGxzUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShDYWxsSGllcmFyY2h5T3V0Z29pbmdDYWxsc1JlcXVlc3QubWV0aG9kKTtcbn0pKENhbGxIaWVyYXJjaHlPdXRnb2luZ0NhbGxzUmVxdWVzdCA9IGV4cG9ydHMuQ2FsbEhpZXJhcmNoeU91dGdvaW5nQ2FsbHNSZXF1ZXN0IHx8IChleHBvcnRzLkNhbGxIaWVyYXJjaHlPdXRnb2luZ0NhbGxzUmVxdWVzdCA9IHt9KSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDM3NDc6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuQ29sb3JQcmVzZW50YXRpb25SZXF1ZXN0ID0gZXhwb3J0cy5Eb2N1bWVudENvbG9yUmVxdWVzdCA9IHZvaWQgMDtcbmNvbnN0IG1lc3NhZ2VzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg0MzEpO1xuLyoqXG4gKiBBIHJlcXVlc3QgdG8gbGlzdCBhbGwgY29sb3Igc3ltYm9scyBmb3VuZCBpbiBhIGdpdmVuIHRleHQgZG9jdW1lbnQuIFRoZSByZXF1ZXN0J3NcbiAqIHBhcmFtZXRlciBpcyBvZiB0eXBlIHtAbGluayBEb2N1bWVudENvbG9yUGFyYW1zfSB0aGVcbiAqIHJlc3BvbnNlIGlzIG9mIHR5cGUge0BsaW5rIENvbG9ySW5mb3JtYXRpb24gQ29sb3JJbmZvcm1hdGlvbltdfSBvciBhIFRoZW5hYmxlXG4gKiB0aGF0IHJlc29sdmVzIHRvIHN1Y2guXG4gKi9cbnZhciBEb2N1bWVudENvbG9yUmVxdWVzdDtcbihmdW5jdGlvbiAoRG9jdW1lbnRDb2xvclJlcXVlc3QpIHtcbiAgICBEb2N1bWVudENvbG9yUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L2RvY3VtZW50Q29sb3InO1xuICAgIERvY3VtZW50Q29sb3JSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgRG9jdW1lbnRDb2xvclJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoRG9jdW1lbnRDb2xvclJlcXVlc3QubWV0aG9kKTtcbn0pKERvY3VtZW50Q29sb3JSZXF1ZXN0ID0gZXhwb3J0cy5Eb2N1bWVudENvbG9yUmVxdWVzdCB8fCAoZXhwb3J0cy5Eb2N1bWVudENvbG9yUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIEEgcmVxdWVzdCB0byBsaXN0IGFsbCBwcmVzZW50YXRpb24gZm9yIGEgY29sb3IuIFRoZSByZXF1ZXN0J3NcbiAqIHBhcmFtZXRlciBpcyBvZiB0eXBlIHtAbGluayBDb2xvclByZXNlbnRhdGlvblBhcmFtc30gdGhlXG4gKiByZXNwb25zZSBpcyBvZiB0eXBlIHtAbGluayBDb2xvckluZm9ybWF0aW9uIENvbG9ySW5mb3JtYXRpb25bXX0gb3IgYSBUaGVuYWJsZVxuICogdGhhdCByZXNvbHZlcyB0byBzdWNoLlxuICovXG52YXIgQ29sb3JQcmVzZW50YXRpb25SZXF1ZXN0O1xuKGZ1bmN0aW9uIChDb2xvclByZXNlbnRhdGlvblJlcXVlc3QpIHtcbiAgICBDb2xvclByZXNlbnRhdGlvblJlcXVlc3QubWV0aG9kID0gJ3RleHREb2N1bWVudC9jb2xvclByZXNlbnRhdGlvbic7XG4gICAgQ29sb3JQcmVzZW50YXRpb25SZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgQ29sb3JQcmVzZW50YXRpb25SZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKENvbG9yUHJlc2VudGF0aW9uUmVxdWVzdC5tZXRob2QpO1xufSkoQ29sb3JQcmVzZW50YXRpb25SZXF1ZXN0ID0gZXhwb3J0cy5Db2xvclByZXNlbnRhdGlvblJlcXVlc3QgfHwgKGV4cG9ydHMuQ29sb3JQcmVzZW50YXRpb25SZXF1ZXN0ID0ge30pKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNzYzOTpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5Db25maWd1cmF0aW9uUmVxdWVzdCA9IHZvaWQgMDtcbmNvbnN0IG1lc3NhZ2VzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg0MzEpO1xuLy8tLS0tIEdldCBDb25maWd1cmF0aW9uIHJlcXVlc3QgLS0tLVxuLyoqXG4gKiBUaGUgJ3dvcmtzcGFjZS9jb25maWd1cmF0aW9uJyByZXF1ZXN0IGlzIHNlbnQgZnJvbSB0aGUgc2VydmVyIHRvIHRoZSBjbGllbnQgdG8gZmV0Y2ggYSBjZXJ0YWluXG4gKiBjb25maWd1cmF0aW9uIHNldHRpbmcuXG4gKlxuICogVGhpcyBwdWxsIG1vZGVsIHJlcGxhY2VzIHRoZSBvbGQgcHVzaCBtb2RlbCB3ZXJlIHRoZSBjbGllbnQgc2lnbmFsZWQgY29uZmlndXJhdGlvbiBjaGFuZ2UgdmlhIGFuXG4gKiBldmVudC4gSWYgdGhlIHNlcnZlciBzdGlsbCBuZWVkcyB0byByZWFjdCB0byBjb25maWd1cmF0aW9uIGNoYW5nZXMgKHNpbmNlIHRoZSBzZXJ2ZXIgY2FjaGVzIHRoZVxuICogcmVzdWx0IG9mIGB3b3Jrc3BhY2UvY29uZmlndXJhdGlvbmAgcmVxdWVzdHMpIHRoZSBzZXJ2ZXIgc2hvdWxkIHJlZ2lzdGVyIGZvciBhbiBlbXB0eSBjb25maWd1cmF0aW9uXG4gKiBjaGFuZ2UgZXZlbnQgYW5kIGVtcHR5IHRoZSBjYWNoZSBpZiBzdWNoIGFuIGV2ZW50IGlzIHJlY2VpdmVkLlxuICovXG52YXIgQ29uZmlndXJhdGlvblJlcXVlc3Q7XG4oZnVuY3Rpb24gKENvbmZpZ3VyYXRpb25SZXF1ZXN0KSB7XG4gICAgQ29uZmlndXJhdGlvblJlcXVlc3QubWV0aG9kID0gJ3dvcmtzcGFjZS9jb25maWd1cmF0aW9uJztcbiAgICBDb25maWd1cmF0aW9uUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLnNlcnZlclRvQ2xpZW50O1xuICAgIENvbmZpZ3VyYXRpb25SZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKENvbmZpZ3VyYXRpb25SZXF1ZXN0Lm1ldGhvZCk7XG59KShDb25maWd1cmF0aW9uUmVxdWVzdCA9IGV4cG9ydHMuQ29uZmlndXJhdGlvblJlcXVlc3QgfHwgKGV4cG9ydHMuQ29uZmlndXJhdGlvblJlcXVlc3QgPSB7fSkpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA1NTgxOlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLkRlY2xhcmF0aW9uUmVxdWVzdCA9IHZvaWQgMDtcbmNvbnN0IG1lc3NhZ2VzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg0MzEpO1xuLy8gQHRzLWlnbm9yZTogdG8gYXZvaWQgaW5saW5pbmcgTG9jYXRpb25MaW5rIGFzIGR5bmFtaWMgaW1wb3J0XG5sZXQgX19ub0R5bmFtaWNJbXBvcnQ7XG4vKipcbiAqIEEgcmVxdWVzdCB0byByZXNvbHZlIHRoZSB0eXBlIGRlZmluaXRpb24gbG9jYXRpb25zIG9mIGEgc3ltYm9sIGF0IGEgZ2l2ZW4gdGV4dFxuICogZG9jdW1lbnQgcG9zaXRpb24uIFRoZSByZXF1ZXN0J3MgcGFyYW1ldGVyIGlzIG9mIHR5cGUgW1RleHREb2N1bWVudFBvc2l0aW9uUGFyYW1zXVxuICogKCNUZXh0RG9jdW1lbnRQb3NpdGlvblBhcmFtcykgdGhlIHJlc3BvbnNlIGlzIG9mIHR5cGUge0BsaW5rIERlY2xhcmF0aW9ufVxuICogb3IgYSB0eXBlZCBhcnJheSBvZiB7QGxpbmsgRGVjbGFyYXRpb25MaW5rfSBvciBhIFRoZW5hYmxlIHRoYXQgcmVzb2x2ZXNcbiAqIHRvIHN1Y2guXG4gKi9cbnZhciBEZWNsYXJhdGlvblJlcXVlc3Q7XG4oZnVuY3Rpb24gKERlY2xhcmF0aW9uUmVxdWVzdCkge1xuICAgIERlY2xhcmF0aW9uUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L2RlY2xhcmF0aW9uJztcbiAgICBEZWNsYXJhdGlvblJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBEZWNsYXJhdGlvblJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoRGVjbGFyYXRpb25SZXF1ZXN0Lm1ldGhvZCk7XG59KShEZWNsYXJhdGlvblJlcXVlc3QgPSBleHBvcnRzLkRlY2xhcmF0aW9uUmVxdWVzdCB8fCAoZXhwb3J0cy5EZWNsYXJhdGlvblJlcXVlc3QgPSB7fSkpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAxNDk0OlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLkRpYWdub3N0aWNSZWZyZXNoUmVxdWVzdCA9IGV4cG9ydHMuV29ya3NwYWNlRGlhZ25vc3RpY1JlcXVlc3QgPSBleHBvcnRzLkRvY3VtZW50RGlhZ25vc3RpY1JlcXVlc3QgPSBleHBvcnRzLkRvY3VtZW50RGlhZ25vc3RpY1JlcG9ydEtpbmQgPSBleHBvcnRzLkRpYWdub3N0aWNTZXJ2ZXJDYW5jZWxsYXRpb25EYXRhID0gdm9pZCAwO1xuY29uc3QgdnNjb2RlX2pzb25ycGNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oOTExMCk7XG5jb25zdCBJcyA9IF9fd2VicGFja19yZXF1aXJlX18oODYzMyk7XG5jb25zdCBtZXNzYWdlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NDMxKTtcbi8qKlxuICogQHNpbmNlIDMuMTcuMFxuICovXG52YXIgRGlhZ25vc3RpY1NlcnZlckNhbmNlbGxhdGlvbkRhdGE7XG4oZnVuY3Rpb24gKERpYWdub3N0aWNTZXJ2ZXJDYW5jZWxsYXRpb25EYXRhKSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgJiYgSXMuYm9vbGVhbihjYW5kaWRhdGUucmV0cmlnZ2VyUmVxdWVzdCk7XG4gICAgfVxuICAgIERpYWdub3N0aWNTZXJ2ZXJDYW5jZWxsYXRpb25EYXRhLmlzID0gaXM7XG59KShEaWFnbm9zdGljU2VydmVyQ2FuY2VsbGF0aW9uRGF0YSA9IGV4cG9ydHMuRGlhZ25vc3RpY1NlcnZlckNhbmNlbGxhdGlvbkRhdGEgfHwgKGV4cG9ydHMuRGlhZ25vc3RpY1NlcnZlckNhbmNlbGxhdGlvbkRhdGEgPSB7fSkpO1xuLyoqXG4gKiBUaGUgZG9jdW1lbnQgZGlhZ25vc3RpYyByZXBvcnQga2luZHMuXG4gKlxuICogQHNpbmNlIDMuMTcuMFxuICovXG52YXIgRG9jdW1lbnREaWFnbm9zdGljUmVwb3J0S2luZDtcbihmdW5jdGlvbiAoRG9jdW1lbnREaWFnbm9zdGljUmVwb3J0S2luZCkge1xuICAgIC8qKlxuICAgICAqIEEgZGlhZ25vc3RpYyByZXBvcnQgd2l0aCBhIGZ1bGxcbiAgICAgKiBzZXQgb2YgcHJvYmxlbXMuXG4gICAgICovXG4gICAgRG9jdW1lbnREaWFnbm9zdGljUmVwb3J0S2luZC5GdWxsID0gJ2Z1bGwnO1xuICAgIC8qKlxuICAgICAqIEEgcmVwb3J0IGluZGljYXRpbmcgdGhhdCB0aGUgbGFzdFxuICAgICAqIHJldHVybmVkIHJlcG9ydCBpcyBzdGlsbCBhY2N1cmF0ZS5cbiAgICAgKi9cbiAgICBEb2N1bWVudERpYWdub3N0aWNSZXBvcnRLaW5kLlVuY2hhbmdlZCA9ICd1bmNoYW5nZWQnO1xufSkoRG9jdW1lbnREaWFnbm9zdGljUmVwb3J0S2luZCA9IGV4cG9ydHMuRG9jdW1lbnREaWFnbm9zdGljUmVwb3J0S2luZCB8fCAoZXhwb3J0cy5Eb2N1bWVudERpYWdub3N0aWNSZXBvcnRLaW5kID0ge30pKTtcbi8qKlxuICogVGhlIGRvY3VtZW50IGRpYWdub3N0aWMgcmVxdWVzdCBkZWZpbml0aW9uLlxuICpcbiAqIEBzaW5jZSAzLjE3LjBcbiAqL1xudmFyIERvY3VtZW50RGlhZ25vc3RpY1JlcXVlc3Q7XG4oZnVuY3Rpb24gKERvY3VtZW50RGlhZ25vc3RpY1JlcXVlc3QpIHtcbiAgICBEb2N1bWVudERpYWdub3N0aWNSZXF1ZXN0Lm1ldGhvZCA9ICd0ZXh0RG9jdW1lbnQvZGlhZ25vc3RpYyc7XG4gICAgRG9jdW1lbnREaWFnbm9zdGljUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIERvY3VtZW50RGlhZ25vc3RpY1JlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoRG9jdW1lbnREaWFnbm9zdGljUmVxdWVzdC5tZXRob2QpO1xuICAgIERvY3VtZW50RGlhZ25vc3RpY1JlcXVlc3QucGFydGlhbFJlc3VsdCA9IG5ldyB2c2NvZGVfanNvbnJwY18xLlByb2dyZXNzVHlwZSgpO1xufSkoRG9jdW1lbnREaWFnbm9zdGljUmVxdWVzdCA9IGV4cG9ydHMuRG9jdW1lbnREaWFnbm9zdGljUmVxdWVzdCB8fCAoZXhwb3J0cy5Eb2N1bWVudERpYWdub3N0aWNSZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogVGhlIHdvcmtzcGFjZSBkaWFnbm9zdGljIHJlcXVlc3QgZGVmaW5pdGlvbi5cbiAqXG4gKiBAc2luY2UgMy4xNy4wXG4gKi9cbnZhciBXb3Jrc3BhY2VEaWFnbm9zdGljUmVxdWVzdDtcbihmdW5jdGlvbiAoV29ya3NwYWNlRGlhZ25vc3RpY1JlcXVlc3QpIHtcbiAgICBXb3Jrc3BhY2VEaWFnbm9zdGljUmVxdWVzdC5tZXRob2QgPSAnd29ya3NwYWNlL2RpYWdub3N0aWMnO1xuICAgIFdvcmtzcGFjZURpYWdub3N0aWNSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgV29ya3NwYWNlRGlhZ25vc3RpY1JlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoV29ya3NwYWNlRGlhZ25vc3RpY1JlcXVlc3QubWV0aG9kKTtcbiAgICBXb3Jrc3BhY2VEaWFnbm9zdGljUmVxdWVzdC5wYXJ0aWFsUmVzdWx0ID0gbmV3IHZzY29kZV9qc29ucnBjXzEuUHJvZ3Jlc3NUeXBlKCk7XG59KShXb3Jrc3BhY2VEaWFnbm9zdGljUmVxdWVzdCA9IGV4cG9ydHMuV29ya3NwYWNlRGlhZ25vc3RpY1JlcXVlc3QgfHwgKGV4cG9ydHMuV29ya3NwYWNlRGlhZ25vc3RpY1JlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBUaGUgZGlhZ25vc3RpYyByZWZyZXNoIHJlcXVlc3QgZGVmaW5pdGlvbi5cbiAqXG4gKiBAc2luY2UgMy4xNy4wXG4gKi9cbnZhciBEaWFnbm9zdGljUmVmcmVzaFJlcXVlc3Q7XG4oZnVuY3Rpb24gKERpYWdub3N0aWNSZWZyZXNoUmVxdWVzdCkge1xuICAgIERpYWdub3N0aWNSZWZyZXNoUmVxdWVzdC5tZXRob2QgPSBgd29ya3NwYWNlL2RpYWdub3N0aWMvcmVmcmVzaGA7XG4gICAgRGlhZ25vc3RpY1JlZnJlc2hSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uc2VydmVyVG9DbGllbnQ7XG4gICAgRGlhZ25vc3RpY1JlZnJlc2hSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlMChEaWFnbm9zdGljUmVmcmVzaFJlcXVlc3QubWV0aG9kKTtcbn0pKERpYWdub3N0aWNSZWZyZXNoUmVxdWVzdCA9IGV4cG9ydHMuRGlhZ25vc3RpY1JlZnJlc2hSZXF1ZXN0IHx8IChleHBvcnRzLkRpYWdub3N0aWNSZWZyZXNoUmVxdWVzdCA9IHt9KSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDQ3ODE6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuV2lsbERlbGV0ZUZpbGVzUmVxdWVzdCA9IGV4cG9ydHMuRGlkRGVsZXRlRmlsZXNOb3RpZmljYXRpb24gPSBleHBvcnRzLkRpZFJlbmFtZUZpbGVzTm90aWZpY2F0aW9uID0gZXhwb3J0cy5XaWxsUmVuYW1lRmlsZXNSZXF1ZXN0ID0gZXhwb3J0cy5EaWRDcmVhdGVGaWxlc05vdGlmaWNhdGlvbiA9IGV4cG9ydHMuV2lsbENyZWF0ZUZpbGVzUmVxdWVzdCA9IGV4cG9ydHMuRmlsZU9wZXJhdGlvblBhdHRlcm5LaW5kID0gdm9pZCAwO1xuY29uc3QgbWVzc2FnZXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oODQzMSk7XG4vKipcbiAqIEEgcGF0dGVybiBraW5kIGRlc2NyaWJpbmcgaWYgYSBnbG9iIHBhdHRlcm4gbWF0Y2hlcyBhIGZpbGUgYSBmb2xkZXIgb3JcbiAqIGJvdGguXG4gKlxuICogQHNpbmNlIDMuMTYuMFxuICovXG52YXIgRmlsZU9wZXJhdGlvblBhdHRlcm5LaW5kO1xuKGZ1bmN0aW9uIChGaWxlT3BlcmF0aW9uUGF0dGVybktpbmQpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgcGF0dGVybiBtYXRjaGVzIGEgZmlsZSBvbmx5LlxuICAgICAqL1xuICAgIEZpbGVPcGVyYXRpb25QYXR0ZXJuS2luZC5maWxlID0gJ2ZpbGUnO1xuICAgIC8qKlxuICAgICAqIFRoZSBwYXR0ZXJuIG1hdGNoZXMgYSBmb2xkZXIgb25seS5cbiAgICAgKi9cbiAgICBGaWxlT3BlcmF0aW9uUGF0dGVybktpbmQuZm9sZGVyID0gJ2ZvbGRlcic7XG59KShGaWxlT3BlcmF0aW9uUGF0dGVybktpbmQgPSBleHBvcnRzLkZpbGVPcGVyYXRpb25QYXR0ZXJuS2luZCB8fCAoZXhwb3J0cy5GaWxlT3BlcmF0aW9uUGF0dGVybktpbmQgPSB7fSkpO1xuLyoqXG4gKiBUaGUgd2lsbCBjcmVhdGUgZmlsZXMgcmVxdWVzdCBpcyBzZW50IGZyb20gdGhlIGNsaWVudCB0byB0aGUgc2VydmVyIGJlZm9yZSBmaWxlcyBhcmUgYWN0dWFsbHlcbiAqIGNyZWF0ZWQgYXMgbG9uZyBhcyB0aGUgY3JlYXRpb24gaXMgdHJpZ2dlcmVkIGZyb20gd2l0aGluIHRoZSBjbGllbnQuXG4gKlxuICogVGhlIHJlcXVlc3QgY2FuIHJldHVybiBhIGBXb3Jrc3BhY2VFZGl0YCB3aGljaCB3aWxsIGJlIGFwcGxpZWQgdG8gd29ya3NwYWNlIGJlZm9yZSB0aGVcbiAqIGZpbGVzIGFyZSBjcmVhdGVkLiBIZW5jZSB0aGUgYFdvcmtzcGFjZUVkaXRgIGNhbiBub3QgbWFuaXB1bGF0ZSB0aGUgY29udGVudCBvZiB0aGUgZmlsZVxuICogdG8gYmUgY3JlYXRlZC5cbiAqXG4gKiBAc2luY2UgMy4xNi4wXG4gKi9cbnZhciBXaWxsQ3JlYXRlRmlsZXNSZXF1ZXN0O1xuKGZ1bmN0aW9uIChXaWxsQ3JlYXRlRmlsZXNSZXF1ZXN0KSB7XG4gICAgV2lsbENyZWF0ZUZpbGVzUmVxdWVzdC5tZXRob2QgPSAnd29ya3NwYWNlL3dpbGxDcmVhdGVGaWxlcyc7XG4gICAgV2lsbENyZWF0ZUZpbGVzUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIFdpbGxDcmVhdGVGaWxlc1JlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoV2lsbENyZWF0ZUZpbGVzUmVxdWVzdC5tZXRob2QpO1xufSkoV2lsbENyZWF0ZUZpbGVzUmVxdWVzdCA9IGV4cG9ydHMuV2lsbENyZWF0ZUZpbGVzUmVxdWVzdCB8fCAoZXhwb3J0cy5XaWxsQ3JlYXRlRmlsZXNSZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogVGhlIGRpZCBjcmVhdGUgZmlsZXMgbm90aWZpY2F0aW9uIGlzIHNlbnQgZnJvbSB0aGUgY2xpZW50IHRvIHRoZSBzZXJ2ZXIgd2hlblxuICogZmlsZXMgd2VyZSBjcmVhdGVkIGZyb20gd2l0aGluIHRoZSBjbGllbnQuXG4gKlxuICogQHNpbmNlIDMuMTYuMFxuICovXG52YXIgRGlkQ3JlYXRlRmlsZXNOb3RpZmljYXRpb247XG4oZnVuY3Rpb24gKERpZENyZWF0ZUZpbGVzTm90aWZpY2F0aW9uKSB7XG4gICAgRGlkQ3JlYXRlRmlsZXNOb3RpZmljYXRpb24ubWV0aG9kID0gJ3dvcmtzcGFjZS9kaWRDcmVhdGVGaWxlcyc7XG4gICAgRGlkQ3JlYXRlRmlsZXNOb3RpZmljYXRpb24ubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBEaWRDcmVhdGVGaWxlc05vdGlmaWNhdGlvbi50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xOb3RpZmljYXRpb25UeXBlKERpZENyZWF0ZUZpbGVzTm90aWZpY2F0aW9uLm1ldGhvZCk7XG59KShEaWRDcmVhdGVGaWxlc05vdGlmaWNhdGlvbiA9IGV4cG9ydHMuRGlkQ3JlYXRlRmlsZXNOb3RpZmljYXRpb24gfHwgKGV4cG9ydHMuRGlkQ3JlYXRlRmlsZXNOb3RpZmljYXRpb24gPSB7fSkpO1xuLyoqXG4gKiBUaGUgd2lsbCByZW5hbWUgZmlsZXMgcmVxdWVzdCBpcyBzZW50IGZyb20gdGhlIGNsaWVudCB0byB0aGUgc2VydmVyIGJlZm9yZSBmaWxlcyBhcmUgYWN0dWFsbHlcbiAqIHJlbmFtZWQgYXMgbG9uZyBhcyB0aGUgcmVuYW1lIGlzIHRyaWdnZXJlZCBmcm9tIHdpdGhpbiB0aGUgY2xpZW50LlxuICpcbiAqIEBzaW5jZSAzLjE2LjBcbiAqL1xudmFyIFdpbGxSZW5hbWVGaWxlc1JlcXVlc3Q7XG4oZnVuY3Rpb24gKFdpbGxSZW5hbWVGaWxlc1JlcXVlc3QpIHtcbiAgICBXaWxsUmVuYW1lRmlsZXNSZXF1ZXN0Lm1ldGhvZCA9ICd3b3Jrc3BhY2Uvd2lsbFJlbmFtZUZpbGVzJztcbiAgICBXaWxsUmVuYW1lRmlsZXNSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgV2lsbFJlbmFtZUZpbGVzUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShXaWxsUmVuYW1lRmlsZXNSZXF1ZXN0Lm1ldGhvZCk7XG59KShXaWxsUmVuYW1lRmlsZXNSZXF1ZXN0ID0gZXhwb3J0cy5XaWxsUmVuYW1lRmlsZXNSZXF1ZXN0IHx8IChleHBvcnRzLldpbGxSZW5hbWVGaWxlc1JlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBUaGUgZGlkIHJlbmFtZSBmaWxlcyBub3RpZmljYXRpb24gaXMgc2VudCBmcm9tIHRoZSBjbGllbnQgdG8gdGhlIHNlcnZlciB3aGVuXG4gKiBmaWxlcyB3ZXJlIHJlbmFtZWQgZnJvbSB3aXRoaW4gdGhlIGNsaWVudC5cbiAqXG4gKiBAc2luY2UgMy4xNi4wXG4gKi9cbnZhciBEaWRSZW5hbWVGaWxlc05vdGlmaWNhdGlvbjtcbihmdW5jdGlvbiAoRGlkUmVuYW1lRmlsZXNOb3RpZmljYXRpb24pIHtcbiAgICBEaWRSZW5hbWVGaWxlc05vdGlmaWNhdGlvbi5tZXRob2QgPSAnd29ya3NwYWNlL2RpZFJlbmFtZUZpbGVzJztcbiAgICBEaWRSZW5hbWVGaWxlc05vdGlmaWNhdGlvbi5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIERpZFJlbmFtZUZpbGVzTm90aWZpY2F0aW9uLnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbE5vdGlmaWNhdGlvblR5cGUoRGlkUmVuYW1lRmlsZXNOb3RpZmljYXRpb24ubWV0aG9kKTtcbn0pKERpZFJlbmFtZUZpbGVzTm90aWZpY2F0aW9uID0gZXhwb3J0cy5EaWRSZW5hbWVGaWxlc05vdGlmaWNhdGlvbiB8fCAoZXhwb3J0cy5EaWRSZW5hbWVGaWxlc05vdGlmaWNhdGlvbiA9IHt9KSk7XG4vKipcbiAqIFRoZSB3aWxsIGRlbGV0ZSBmaWxlcyByZXF1ZXN0IGlzIHNlbnQgZnJvbSB0aGUgY2xpZW50IHRvIHRoZSBzZXJ2ZXIgYmVmb3JlIGZpbGVzIGFyZSBhY3R1YWxseVxuICogZGVsZXRlZCBhcyBsb25nIGFzIHRoZSBkZWxldGlvbiBpcyB0cmlnZ2VyZWQgZnJvbSB3aXRoaW4gdGhlIGNsaWVudC5cbiAqXG4gKiBAc2luY2UgMy4xNi4wXG4gKi9cbnZhciBEaWREZWxldGVGaWxlc05vdGlmaWNhdGlvbjtcbihmdW5jdGlvbiAoRGlkRGVsZXRlRmlsZXNOb3RpZmljYXRpb24pIHtcbiAgICBEaWREZWxldGVGaWxlc05vdGlmaWNhdGlvbi5tZXRob2QgPSAnd29ya3NwYWNlL2RpZERlbGV0ZUZpbGVzJztcbiAgICBEaWREZWxldGVGaWxlc05vdGlmaWNhdGlvbi5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIERpZERlbGV0ZUZpbGVzTm90aWZpY2F0aW9uLnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbE5vdGlmaWNhdGlvblR5cGUoRGlkRGVsZXRlRmlsZXNOb3RpZmljYXRpb24ubWV0aG9kKTtcbn0pKERpZERlbGV0ZUZpbGVzTm90aWZpY2F0aW9uID0gZXhwb3J0cy5EaWREZWxldGVGaWxlc05vdGlmaWNhdGlvbiB8fCAoZXhwb3J0cy5EaWREZWxldGVGaWxlc05vdGlmaWNhdGlvbiA9IHt9KSk7XG4vKipcbiAqIFRoZSBkaWQgZGVsZXRlIGZpbGVzIG5vdGlmaWNhdGlvbiBpcyBzZW50IGZyb20gdGhlIGNsaWVudCB0byB0aGUgc2VydmVyIHdoZW5cbiAqIGZpbGVzIHdlcmUgZGVsZXRlZCBmcm9tIHdpdGhpbiB0aGUgY2xpZW50LlxuICpcbiAqIEBzaW5jZSAzLjE2LjBcbiAqL1xudmFyIFdpbGxEZWxldGVGaWxlc1JlcXVlc3Q7XG4oZnVuY3Rpb24gKFdpbGxEZWxldGVGaWxlc1JlcXVlc3QpIHtcbiAgICBXaWxsRGVsZXRlRmlsZXNSZXF1ZXN0Lm1ldGhvZCA9ICd3b3Jrc3BhY2Uvd2lsbERlbGV0ZUZpbGVzJztcbiAgICBXaWxsRGVsZXRlRmlsZXNSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgV2lsbERlbGV0ZUZpbGVzUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShXaWxsRGVsZXRlRmlsZXNSZXF1ZXN0Lm1ldGhvZCk7XG59KShXaWxsRGVsZXRlRmlsZXNSZXF1ZXN0ID0gZXhwb3J0cy5XaWxsRGVsZXRlRmlsZXNSZXF1ZXN0IHx8IChleHBvcnRzLldpbGxEZWxldGVGaWxlc1JlcXVlc3QgPSB7fSkpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAxMjAzOlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuRm9sZGluZ1JhbmdlUmVxdWVzdCA9IHZvaWQgMDtcbmNvbnN0IG1lc3NhZ2VzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg0MzEpO1xuLyoqXG4gKiBBIHJlcXVlc3QgdG8gcHJvdmlkZSBmb2xkaW5nIHJhbmdlcyBpbiBhIGRvY3VtZW50LiBUaGUgcmVxdWVzdCdzXG4gKiBwYXJhbWV0ZXIgaXMgb2YgdHlwZSB7QGxpbmsgRm9sZGluZ1JhbmdlUGFyYW1zfSwgdGhlXG4gKiByZXNwb25zZSBpcyBvZiB0eXBlIHtAbGluayBGb2xkaW5nUmFuZ2VMaXN0fSBvciBhIFRoZW5hYmxlXG4gKiB0aGF0IHJlc29sdmVzIHRvIHN1Y2guXG4gKi9cbnZhciBGb2xkaW5nUmFuZ2VSZXF1ZXN0O1xuKGZ1bmN0aW9uIChGb2xkaW5nUmFuZ2VSZXF1ZXN0KSB7XG4gICAgRm9sZGluZ1JhbmdlUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L2ZvbGRpbmdSYW5nZSc7XG4gICAgRm9sZGluZ1JhbmdlUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIEZvbGRpbmdSYW5nZVJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoRm9sZGluZ1JhbmdlUmVxdWVzdC5tZXRob2QpO1xufSkoRm9sZGluZ1JhbmdlUmVxdWVzdCA9IGV4cG9ydHMuRm9sZGluZ1JhbmdlUmVxdWVzdCB8fCAoZXhwb3J0cy5Gb2xkaW5nUmFuZ2VSZXF1ZXN0ID0ge30pKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNzI4Nzpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5JbXBsZW1lbnRhdGlvblJlcXVlc3QgPSB2b2lkIDA7XG5jb25zdCBtZXNzYWdlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NDMxKTtcbi8vIEB0cy1pZ25vcmU6IHRvIGF2b2lkIGlubGluaW5nIExvY2F0aW9uTGluayBhcyBkeW5hbWljIGltcG9ydFxubGV0IF9fbm9EeW5hbWljSW1wb3J0O1xuLyoqXG4gKiBBIHJlcXVlc3QgdG8gcmVzb2x2ZSB0aGUgaW1wbGVtZW50YXRpb24gbG9jYXRpb25zIG9mIGEgc3ltYm9sIGF0IGEgZ2l2ZW4gdGV4dFxuICogZG9jdW1lbnQgcG9zaXRpb24uIFRoZSByZXF1ZXN0J3MgcGFyYW1ldGVyIGlzIG9mIHR5cGUgW1RleHREb2N1bWVudFBvc2l0aW9uUGFyYW1zXVxuICogKCNUZXh0RG9jdW1lbnRQb3NpdGlvblBhcmFtcykgdGhlIHJlc3BvbnNlIGlzIG9mIHR5cGUge0BsaW5rIERlZmluaXRpb259IG9yIGFcbiAqIFRoZW5hYmxlIHRoYXQgcmVzb2x2ZXMgdG8gc3VjaC5cbiAqL1xudmFyIEltcGxlbWVudGF0aW9uUmVxdWVzdDtcbihmdW5jdGlvbiAoSW1wbGVtZW50YXRpb25SZXF1ZXN0KSB7XG4gICAgSW1wbGVtZW50YXRpb25SZXF1ZXN0Lm1ldGhvZCA9ICd0ZXh0RG9jdW1lbnQvaW1wbGVtZW50YXRpb24nO1xuICAgIEltcGxlbWVudGF0aW9uUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIEltcGxlbWVudGF0aW9uUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShJbXBsZW1lbnRhdGlvblJlcXVlc3QubWV0aG9kKTtcbn0pKEltcGxlbWVudGF0aW9uUmVxdWVzdCA9IGV4cG9ydHMuSW1wbGVtZW50YXRpb25SZXF1ZXN0IHx8IChleHBvcnRzLkltcGxlbWVudGF0aW9uUmVxdWVzdCA9IHt9KSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDkzODM6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5JbmxheUhpbnRSZWZyZXNoUmVxdWVzdCA9IGV4cG9ydHMuSW5sYXlIaW50UmVzb2x2ZVJlcXVlc3QgPSBleHBvcnRzLklubGF5SGludFJlcXVlc3QgPSB2b2lkIDA7XG5jb25zdCBtZXNzYWdlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NDMxKTtcbi8qKlxuICogQSByZXF1ZXN0IHRvIHByb3ZpZGUgaW5sYXkgaGludHMgaW4gYSBkb2N1bWVudC4gVGhlIHJlcXVlc3QncyBwYXJhbWV0ZXIgaXMgb2ZcbiAqIHR5cGUge0BsaW5rIElubGF5SGludHNQYXJhbXN9LCB0aGUgcmVzcG9uc2UgaXMgb2YgdHlwZVxuICoge0BsaW5rIElubGF5SGludCBJbmxheUhpbnRbXX0gb3IgYSBUaGVuYWJsZSB0aGF0IHJlc29sdmVzIHRvIHN1Y2guXG4gKlxuICogQHNpbmNlIDMuMTcuMFxuICovXG52YXIgSW5sYXlIaW50UmVxdWVzdDtcbihmdW5jdGlvbiAoSW5sYXlIaW50UmVxdWVzdCkge1xuICAgIElubGF5SGludFJlcXVlc3QubWV0aG9kID0gJ3RleHREb2N1bWVudC9pbmxheUhpbnQnO1xuICAgIElubGF5SGludFJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBJbmxheUhpbnRSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKElubGF5SGludFJlcXVlc3QubWV0aG9kKTtcbn0pKElubGF5SGludFJlcXVlc3QgPSBleHBvcnRzLklubGF5SGludFJlcXVlc3QgfHwgKGV4cG9ydHMuSW5sYXlIaW50UmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIEEgcmVxdWVzdCB0byByZXNvbHZlIGFkZGl0aW9uYWwgcHJvcGVydGllcyBmb3IgYW4gaW5sYXkgaGludC5cbiAqIFRoZSByZXF1ZXN0J3MgcGFyYW1ldGVyIGlzIG9mIHR5cGUge0BsaW5rIElubGF5SGludH0sIHRoZSByZXNwb25zZSBpc1xuICogb2YgdHlwZSB7QGxpbmsgSW5sYXlIaW50fSBvciBhIFRoZW5hYmxlIHRoYXQgcmVzb2x2ZXMgdG8gc3VjaC5cbiAqXG4gKiBAc2luY2UgMy4xNy4wXG4gKi9cbnZhciBJbmxheUhpbnRSZXNvbHZlUmVxdWVzdDtcbihmdW5jdGlvbiAoSW5sYXlIaW50UmVzb2x2ZVJlcXVlc3QpIHtcbiAgICBJbmxheUhpbnRSZXNvbHZlUmVxdWVzdC5tZXRob2QgPSAnaW5sYXlIaW50L3Jlc29sdmUnO1xuICAgIElubGF5SGludFJlc29sdmVSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgSW5sYXlIaW50UmVzb2x2ZVJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoSW5sYXlIaW50UmVzb2x2ZVJlcXVlc3QubWV0aG9kKTtcbn0pKElubGF5SGludFJlc29sdmVSZXF1ZXN0ID0gZXhwb3J0cy5JbmxheUhpbnRSZXNvbHZlUmVxdWVzdCB8fCAoZXhwb3J0cy5JbmxheUhpbnRSZXNvbHZlUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIEBzaW5jZSAzLjE3LjBcbiAqL1xudmFyIElubGF5SGludFJlZnJlc2hSZXF1ZXN0O1xuKGZ1bmN0aW9uIChJbmxheUhpbnRSZWZyZXNoUmVxdWVzdCkge1xuICAgIElubGF5SGludFJlZnJlc2hSZXF1ZXN0Lm1ldGhvZCA9IGB3b3Jrc3BhY2UvaW5sYXlIaW50L3JlZnJlc2hgO1xuICAgIElubGF5SGludFJlZnJlc2hSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uc2VydmVyVG9DbGllbnQ7XG4gICAgSW5sYXlIaW50UmVmcmVzaFJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUwKElubGF5SGludFJlZnJlc2hSZXF1ZXN0Lm1ldGhvZCk7XG59KShJbmxheUhpbnRSZWZyZXNoUmVxdWVzdCA9IGV4cG9ydHMuSW5sYXlIaW50UmVmcmVzaFJlcXVlc3QgfHwgKGV4cG9ydHMuSW5sYXlIaW50UmVmcmVzaFJlcXVlc3QgPSB7fSkpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAzNDkxOlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuSW5saW5lVmFsdWVSZWZyZXNoUmVxdWVzdCA9IGV4cG9ydHMuSW5saW5lVmFsdWVSZXF1ZXN0ID0gdm9pZCAwO1xuY29uc3QgbWVzc2FnZXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oODQzMSk7XG4vKipcbiAqIEEgcmVxdWVzdCB0byBwcm92aWRlIGlubGluZSB2YWx1ZXMgaW4gYSBkb2N1bWVudC4gVGhlIHJlcXVlc3QncyBwYXJhbWV0ZXIgaXMgb2ZcbiAqIHR5cGUge0BsaW5rIElubGluZVZhbHVlUGFyYW1zfSwgdGhlIHJlc3BvbnNlIGlzIG9mIHR5cGVcbiAqIHtAbGluayBJbmxpbmVWYWx1ZSBJbmxpbmVWYWx1ZVtdfSBvciBhIFRoZW5hYmxlIHRoYXQgcmVzb2x2ZXMgdG8gc3VjaC5cbiAqXG4gKiBAc2luY2UgMy4xNy4wXG4gKi9cbnZhciBJbmxpbmVWYWx1ZVJlcXVlc3Q7XG4oZnVuY3Rpb24gKElubGluZVZhbHVlUmVxdWVzdCkge1xuICAgIElubGluZVZhbHVlUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L2lubGluZVZhbHVlJztcbiAgICBJbmxpbmVWYWx1ZVJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBJbmxpbmVWYWx1ZVJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoSW5saW5lVmFsdWVSZXF1ZXN0Lm1ldGhvZCk7XG59KShJbmxpbmVWYWx1ZVJlcXVlc3QgPSBleHBvcnRzLklubGluZVZhbHVlUmVxdWVzdCB8fCAoZXhwb3J0cy5JbmxpbmVWYWx1ZVJlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBAc2luY2UgMy4xNy4wXG4gKi9cbnZhciBJbmxpbmVWYWx1ZVJlZnJlc2hSZXF1ZXN0O1xuKGZ1bmN0aW9uIChJbmxpbmVWYWx1ZVJlZnJlc2hSZXF1ZXN0KSB7XG4gICAgSW5saW5lVmFsdWVSZWZyZXNoUmVxdWVzdC5tZXRob2QgPSBgd29ya3NwYWNlL2lubGluZVZhbHVlL3JlZnJlc2hgO1xuICAgIElubGluZVZhbHVlUmVmcmVzaFJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5zZXJ2ZXJUb0NsaWVudDtcbiAgICBJbmxpbmVWYWx1ZVJlZnJlc2hSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlMChJbmxpbmVWYWx1ZVJlZnJlc2hSZXF1ZXN0Lm1ldGhvZCk7XG59KShJbmxpbmVWYWx1ZVJlZnJlc2hSZXF1ZXN0ID0gZXhwb3J0cy5JbmxpbmVWYWx1ZVJlZnJlc2hSZXF1ZXN0IHx8IChleHBvcnRzLklubGluZVZhbHVlUmVmcmVzaFJlcXVlc3QgPSB7fSkpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAxODE1OlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLldvcmtzcGFjZVN5bWJvbFJlcXVlc3QgPSBleHBvcnRzLkNvZGVBY3Rpb25SZXNvbHZlUmVxdWVzdCA9IGV4cG9ydHMuQ29kZUFjdGlvblJlcXVlc3QgPSBleHBvcnRzLkRvY3VtZW50U3ltYm9sUmVxdWVzdCA9IGV4cG9ydHMuRG9jdW1lbnRIaWdobGlnaHRSZXF1ZXN0ID0gZXhwb3J0cy5SZWZlcmVuY2VzUmVxdWVzdCA9IGV4cG9ydHMuRGVmaW5pdGlvblJlcXVlc3QgPSBleHBvcnRzLlNpZ25hdHVyZUhlbHBSZXF1ZXN0ID0gZXhwb3J0cy5TaWduYXR1cmVIZWxwVHJpZ2dlcktpbmQgPSBleHBvcnRzLkhvdmVyUmVxdWVzdCA9IGV4cG9ydHMuQ29tcGxldGlvblJlc29sdmVSZXF1ZXN0ID0gZXhwb3J0cy5Db21wbGV0aW9uUmVxdWVzdCA9IGV4cG9ydHMuQ29tcGxldGlvblRyaWdnZXJLaW5kID0gZXhwb3J0cy5QdWJsaXNoRGlhZ25vc3RpY3NOb3RpZmljYXRpb24gPSBleHBvcnRzLldhdGNoS2luZCA9IGV4cG9ydHMuUmVsYXRpdmVQYXR0ZXJuID0gZXhwb3J0cy5GaWxlQ2hhbmdlVHlwZSA9IGV4cG9ydHMuRGlkQ2hhbmdlV2F0Y2hlZEZpbGVzTm90aWZpY2F0aW9uID0gZXhwb3J0cy5XaWxsU2F2ZVRleHREb2N1bWVudFdhaXRVbnRpbFJlcXVlc3QgPSBleHBvcnRzLldpbGxTYXZlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uID0gZXhwb3J0cy5UZXh0RG9jdW1lbnRTYXZlUmVhc29uID0gZXhwb3J0cy5EaWRTYXZlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uID0gZXhwb3J0cy5EaWRDbG9zZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuRGlkQ2hhbmdlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uID0gZXhwb3J0cy5UZXh0RG9jdW1lbnRDb250ZW50Q2hhbmdlRXZlbnQgPSBleHBvcnRzLkRpZE9wZW5UZXh0RG9jdW1lbnROb3RpZmljYXRpb24gPSBleHBvcnRzLlRleHREb2N1bWVudFN5bmNLaW5kID0gZXhwb3J0cy5UZWxlbWV0cnlFdmVudE5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuTG9nTWVzc2FnZU5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuU2hvd01lc3NhZ2VSZXF1ZXN0ID0gZXhwb3J0cy5TaG93TWVzc2FnZU5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuTWVzc2FnZVR5cGUgPSBleHBvcnRzLkRpZENoYW5nZUNvbmZpZ3VyYXRpb25Ob3RpZmljYXRpb24gPSBleHBvcnRzLkV4aXROb3RpZmljYXRpb24gPSBleHBvcnRzLlNodXRkb3duUmVxdWVzdCA9IGV4cG9ydHMuSW5pdGlhbGl6ZWROb3RpZmljYXRpb24gPSBleHBvcnRzLkluaXRpYWxpemVFcnJvckNvZGVzID0gZXhwb3J0cy5Jbml0aWFsaXplUmVxdWVzdCA9IGV4cG9ydHMuV29ya0RvbmVQcm9ncmVzc09wdGlvbnMgPSBleHBvcnRzLlRleHREb2N1bWVudFJlZ2lzdHJhdGlvbk9wdGlvbnMgPSBleHBvcnRzLlN0YXRpY1JlZ2lzdHJhdGlvbk9wdGlvbnMgPSBleHBvcnRzLlBvc2l0aW9uRW5jb2RpbmdLaW5kID0gZXhwb3J0cy5GYWlsdXJlSGFuZGxpbmdLaW5kID0gZXhwb3J0cy5SZXNvdXJjZU9wZXJhdGlvbktpbmQgPSBleHBvcnRzLlVucmVnaXN0cmF0aW9uUmVxdWVzdCA9IGV4cG9ydHMuUmVnaXN0cmF0aW9uUmVxdWVzdCA9IGV4cG9ydHMuRG9jdW1lbnRTZWxlY3RvciA9IGV4cG9ydHMuTm90ZWJvb2tDZWxsVGV4dERvY3VtZW50RmlsdGVyID0gZXhwb3J0cy5Ob3RlYm9va0RvY3VtZW50RmlsdGVyID0gZXhwb3J0cy5UZXh0RG9jdW1lbnRGaWx0ZXIgPSB2b2lkIDA7XG5leHBvcnRzLlR5cGVIaWVyYXJjaHlTdWJ0eXBlc1JlcXVlc3QgPSBleHBvcnRzLlR5cGVIaWVyYXJjaHlQcmVwYXJlUmVxdWVzdCA9IGV4cG9ydHMuTW9uaWtlclJlcXVlc3QgPSBleHBvcnRzLk1vbmlrZXJLaW5kID0gZXhwb3J0cy5VbmlxdWVuZXNzTGV2ZWwgPSBleHBvcnRzLldpbGxEZWxldGVGaWxlc1JlcXVlc3QgPSBleHBvcnRzLkRpZERlbGV0ZUZpbGVzTm90aWZpY2F0aW9uID0gZXhwb3J0cy5XaWxsUmVuYW1lRmlsZXNSZXF1ZXN0ID0gZXhwb3J0cy5EaWRSZW5hbWVGaWxlc05vdGlmaWNhdGlvbiA9IGV4cG9ydHMuV2lsbENyZWF0ZUZpbGVzUmVxdWVzdCA9IGV4cG9ydHMuRGlkQ3JlYXRlRmlsZXNOb3RpZmljYXRpb24gPSBleHBvcnRzLkZpbGVPcGVyYXRpb25QYXR0ZXJuS2luZCA9IGV4cG9ydHMuTGlua2VkRWRpdGluZ1JhbmdlUmVxdWVzdCA9IGV4cG9ydHMuU2hvd0RvY3VtZW50UmVxdWVzdCA9IGV4cG9ydHMuU2VtYW50aWNUb2tlbnNSZWdpc3RyYXRpb25UeXBlID0gZXhwb3J0cy5TZW1hbnRpY1Rva2Vuc1JlZnJlc2hSZXF1ZXN0ID0gZXhwb3J0cy5TZW1hbnRpY1Rva2Vuc1JhbmdlUmVxdWVzdCA9IGV4cG9ydHMuU2VtYW50aWNUb2tlbnNEZWx0YVJlcXVlc3QgPSBleHBvcnRzLlNlbWFudGljVG9rZW5zUmVxdWVzdCA9IGV4cG9ydHMuVG9rZW5Gb3JtYXQgPSBleHBvcnRzLkNhbGxIaWVyYXJjaHlQcmVwYXJlUmVxdWVzdCA9IGV4cG9ydHMuQ2FsbEhpZXJhcmNoeU91dGdvaW5nQ2FsbHNSZXF1ZXN0ID0gZXhwb3J0cy5DYWxsSGllcmFyY2h5SW5jb21pbmdDYWxsc1JlcXVlc3QgPSBleHBvcnRzLldvcmtEb25lUHJvZ3Jlc3NDYW5jZWxOb3RpZmljYXRpb24gPSBleHBvcnRzLldvcmtEb25lUHJvZ3Jlc3NDcmVhdGVSZXF1ZXN0ID0gZXhwb3J0cy5Xb3JrRG9uZVByb2dyZXNzID0gZXhwb3J0cy5TZWxlY3Rpb25SYW5nZVJlcXVlc3QgPSBleHBvcnRzLkRlY2xhcmF0aW9uUmVxdWVzdCA9IGV4cG9ydHMuRm9sZGluZ1JhbmdlUmVxdWVzdCA9IGV4cG9ydHMuQ29sb3JQcmVzZW50YXRpb25SZXF1ZXN0ID0gZXhwb3J0cy5Eb2N1bWVudENvbG9yUmVxdWVzdCA9IGV4cG9ydHMuQ29uZmlndXJhdGlvblJlcXVlc3QgPSBleHBvcnRzLkRpZENoYW5nZVdvcmtzcGFjZUZvbGRlcnNOb3RpZmljYXRpb24gPSBleHBvcnRzLldvcmtzcGFjZUZvbGRlcnNSZXF1ZXN0ID0gZXhwb3J0cy5UeXBlRGVmaW5pdGlvblJlcXVlc3QgPSBleHBvcnRzLkltcGxlbWVudGF0aW9uUmVxdWVzdCA9IGV4cG9ydHMuQXBwbHlXb3Jrc3BhY2VFZGl0UmVxdWVzdCA9IGV4cG9ydHMuRXhlY3V0ZUNvbW1hbmRSZXF1ZXN0ID0gZXhwb3J0cy5QcmVwYXJlUmVuYW1lUmVxdWVzdCA9IGV4cG9ydHMuUmVuYW1lUmVxdWVzdCA9IGV4cG9ydHMuUHJlcGFyZVN1cHBvcnREZWZhdWx0QmVoYXZpb3IgPSBleHBvcnRzLkRvY3VtZW50T25UeXBlRm9ybWF0dGluZ1JlcXVlc3QgPSBleHBvcnRzLkRvY3VtZW50UmFuZ2VGb3JtYXR0aW5nUmVxdWVzdCA9IGV4cG9ydHMuRG9jdW1lbnRGb3JtYXR0aW5nUmVxdWVzdCA9IGV4cG9ydHMuRG9jdW1lbnRMaW5rUmVzb2x2ZVJlcXVlc3QgPSBleHBvcnRzLkRvY3VtZW50TGlua1JlcXVlc3QgPSBleHBvcnRzLkNvZGVMZW5zUmVmcmVzaFJlcXVlc3QgPSBleHBvcnRzLkNvZGVMZW5zUmVzb2x2ZVJlcXVlc3QgPSBleHBvcnRzLkNvZGVMZW5zUmVxdWVzdCA9IGV4cG9ydHMuV29ya3NwYWNlU3ltYm9sUmVzb2x2ZVJlcXVlc3QgPSB2b2lkIDA7XG5leHBvcnRzLkRpZENsb3NlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuRGlkU2F2ZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24gPSBleHBvcnRzLkRpZENoYW5nZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24gPSBleHBvcnRzLk5vdGVib29rQ2VsbEFycmF5Q2hhbmdlID0gZXhwb3J0cy5EaWRPcGVuTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuTm90ZWJvb2tEb2N1bWVudFN5bmNSZWdpc3RyYXRpb25UeXBlID0gZXhwb3J0cy5Ob3RlYm9va0RvY3VtZW50ID0gZXhwb3J0cy5Ob3RlYm9va0NlbGwgPSBleHBvcnRzLkV4ZWN1dGlvblN1bW1hcnkgPSBleHBvcnRzLk5vdGVib29rQ2VsbEtpbmQgPSBleHBvcnRzLkRpYWdub3N0aWNSZWZyZXNoUmVxdWVzdCA9IGV4cG9ydHMuV29ya3NwYWNlRGlhZ25vc3RpY1JlcXVlc3QgPSBleHBvcnRzLkRvY3VtZW50RGlhZ25vc3RpY1JlcXVlc3QgPSBleHBvcnRzLkRvY3VtZW50RGlhZ25vc3RpY1JlcG9ydEtpbmQgPSBleHBvcnRzLkRpYWdub3N0aWNTZXJ2ZXJDYW5jZWxsYXRpb25EYXRhID0gZXhwb3J0cy5JbmxheUhpbnRSZWZyZXNoUmVxdWVzdCA9IGV4cG9ydHMuSW5sYXlIaW50UmVzb2x2ZVJlcXVlc3QgPSBleHBvcnRzLklubGF5SGludFJlcXVlc3QgPSBleHBvcnRzLklubGluZVZhbHVlUmVmcmVzaFJlcXVlc3QgPSBleHBvcnRzLklubGluZVZhbHVlUmVxdWVzdCA9IGV4cG9ydHMuVHlwZUhpZXJhcmNoeVN1cGVydHlwZXNSZXF1ZXN0ID0gdm9pZCAwO1xuY29uc3QgbWVzc2FnZXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oODQzMSk7XG5jb25zdCB2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfdHlwZXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNzcxNyk7XG5jb25zdCBJcyA9IF9fd2VicGFja19yZXF1aXJlX18oODYzMyk7XG5jb25zdCBwcm90b2NvbF9pbXBsZW1lbnRhdGlvbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3Mjg3KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkltcGxlbWVudGF0aW9uUmVxdWVzdFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX2ltcGxlbWVudGF0aW9uXzEuSW1wbGVtZW50YXRpb25SZXF1ZXN0OyB9IH0pKTtcbmNvbnN0IHByb3RvY29sX3R5cGVEZWZpbml0aW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkyNjQpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVHlwZURlZmluaXRpb25SZXF1ZXN0XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfdHlwZURlZmluaXRpb25fMS5UeXBlRGVmaW5pdGlvblJlcXVlc3Q7IH0gfSkpO1xuY29uc3QgcHJvdG9jb2xfd29ya3NwYWNlRm9sZGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY4NjApO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiV29ya3NwYWNlRm9sZGVyc1JlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF93b3Jrc3BhY2VGb2xkZXJfMS5Xb3Jrc3BhY2VGb2xkZXJzUmVxdWVzdDsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJEaWRDaGFuZ2VXb3Jrc3BhY2VGb2xkZXJzTm90aWZpY2F0aW9uXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfd29ya3NwYWNlRm9sZGVyXzEuRGlkQ2hhbmdlV29ya3NwYWNlRm9sZGVyc05vdGlmaWNhdGlvbjsgfSB9KSk7XG5jb25zdCBwcm90b2NvbF9jb25maWd1cmF0aW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc2MzkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ29uZmlndXJhdGlvblJlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9jb25maWd1cmF0aW9uXzEuQ29uZmlndXJhdGlvblJlcXVlc3Q7IH0gfSkpO1xuY29uc3QgcHJvdG9jb2xfY29sb3JQcm92aWRlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNzQ3KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkRvY3VtZW50Q29sb3JSZXF1ZXN0XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfY29sb3JQcm92aWRlcl8xLkRvY3VtZW50Q29sb3JSZXF1ZXN0OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNvbG9yUHJlc2VudGF0aW9uUmVxdWVzdFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX2NvbG9yUHJvdmlkZXJfMS5Db2xvclByZXNlbnRhdGlvblJlcXVlc3Q7IH0gfSkpO1xuY29uc3QgcHJvdG9jb2xfZm9sZGluZ1JhbmdlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyMDMpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRm9sZGluZ1JhbmdlUmVxdWVzdFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX2ZvbGRpbmdSYW5nZV8xLkZvbGRpbmdSYW5nZVJlcXVlc3Q7IH0gfSkpO1xuY29uc3QgcHJvdG9jb2xfZGVjbGFyYXRpb25fMSA9IF9fd2VicGFja19yZXF1aXJlX18oNTU4MSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJEZWNsYXJhdGlvblJlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9kZWNsYXJhdGlvbl8xLkRlY2xhcmF0aW9uUmVxdWVzdDsgfSB9KSk7XG5jb25zdCBwcm90b2NvbF9zZWxlY3Rpb25SYW5nZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNTMwKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNlbGVjdGlvblJhbmdlUmVxdWVzdFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX3NlbGVjdGlvblJhbmdlXzEuU2VsZWN0aW9uUmFuZ2VSZXF1ZXN0OyB9IH0pKTtcbmNvbnN0IHByb3RvY29sX3Byb2dyZXNzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQxNjYpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiV29ya0RvbmVQcm9ncmVzc1wiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX3Byb2dyZXNzXzEuV29ya0RvbmVQcm9ncmVzczsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJXb3JrRG9uZVByb2dyZXNzQ3JlYXRlUmVxdWVzdFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX3Byb2dyZXNzXzEuV29ya0RvbmVQcm9ncmVzc0NyZWF0ZVJlcXVlc3Q7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiV29ya0RvbmVQcm9ncmVzc0NhbmNlbE5vdGlmaWNhdGlvblwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX3Byb2dyZXNzXzEuV29ya0RvbmVQcm9ncmVzc0NhbmNlbE5vdGlmaWNhdGlvbjsgfSB9KSk7XG5jb25zdCBwcm90b2NvbF9jYWxsSGllcmFyY2h5XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc2MDIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ2FsbEhpZXJhcmNoeUluY29taW5nQ2FsbHNSZXF1ZXN0XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfY2FsbEhpZXJhcmNoeV8xLkNhbGxIaWVyYXJjaHlJbmNvbWluZ0NhbGxzUmVxdWVzdDsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDYWxsSGllcmFyY2h5T3V0Z29pbmdDYWxsc1JlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9jYWxsSGllcmFyY2h5XzEuQ2FsbEhpZXJhcmNoeU91dGdvaW5nQ2FsbHNSZXF1ZXN0OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNhbGxIaWVyYXJjaHlQcmVwYXJlUmVxdWVzdFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX2NhbGxIaWVyYXJjaHlfMS5DYWxsSGllcmFyY2h5UHJlcGFyZVJlcXVlc3Q7IH0gfSkpO1xuY29uc3QgcHJvdG9jb2xfc2VtYW50aWNUb2tlbnNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjA2Nyk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUb2tlbkZvcm1hdFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX3NlbWFudGljVG9rZW5zXzEuVG9rZW5Gb3JtYXQ7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU2VtYW50aWNUb2tlbnNSZXF1ZXN0XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfc2VtYW50aWNUb2tlbnNfMS5TZW1hbnRpY1Rva2Vuc1JlcXVlc3Q7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU2VtYW50aWNUb2tlbnNEZWx0YVJlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9zZW1hbnRpY1Rva2Vuc18xLlNlbWFudGljVG9rZW5zRGVsdGFSZXF1ZXN0OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNlbWFudGljVG9rZW5zUmFuZ2VSZXF1ZXN0XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfc2VtYW50aWNUb2tlbnNfMS5TZW1hbnRpY1Rva2Vuc1JhbmdlUmVxdWVzdDsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTZW1hbnRpY1Rva2Vuc1JlZnJlc2hSZXF1ZXN0XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfc2VtYW50aWNUb2tlbnNfMS5TZW1hbnRpY1Rva2Vuc1JlZnJlc2hSZXF1ZXN0OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNlbWFudGljVG9rZW5zUmVnaXN0cmF0aW9uVHlwZVwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX3NlbWFudGljVG9rZW5zXzEuU2VtYW50aWNUb2tlbnNSZWdpc3RyYXRpb25UeXBlOyB9IH0pKTtcbmNvbnN0IHByb3RvY29sX3Nob3dEb2N1bWVudF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MzMzKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNob3dEb2N1bWVudFJlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9zaG93RG9jdW1lbnRfMS5TaG93RG9jdW1lbnRSZXF1ZXN0OyB9IH0pKTtcbmNvbnN0IHByb3RvY29sX2xpbmtlZEVkaXRpbmdSYW5nZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMjQ5KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkxpbmtlZEVkaXRpbmdSYW5nZVJlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9saW5rZWRFZGl0aW5nUmFuZ2VfMS5MaW5rZWRFZGl0aW5nUmFuZ2VSZXF1ZXN0OyB9IH0pKTtcbmNvbnN0IHByb3RvY29sX2ZpbGVPcGVyYXRpb25zXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ3ODEpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRmlsZU9wZXJhdGlvblBhdHRlcm5LaW5kXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfZmlsZU9wZXJhdGlvbnNfMS5GaWxlT3BlcmF0aW9uUGF0dGVybktpbmQ7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRGlkQ3JlYXRlRmlsZXNOb3RpZmljYXRpb25cIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9maWxlT3BlcmF0aW9uc18xLkRpZENyZWF0ZUZpbGVzTm90aWZpY2F0aW9uOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIldpbGxDcmVhdGVGaWxlc1JlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9maWxlT3BlcmF0aW9uc18xLldpbGxDcmVhdGVGaWxlc1JlcXVlc3Q7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRGlkUmVuYW1lRmlsZXNOb3RpZmljYXRpb25cIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9maWxlT3BlcmF0aW9uc18xLkRpZFJlbmFtZUZpbGVzTm90aWZpY2F0aW9uOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIldpbGxSZW5hbWVGaWxlc1JlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9maWxlT3BlcmF0aW9uc18xLldpbGxSZW5hbWVGaWxlc1JlcXVlc3Q7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRGlkRGVsZXRlRmlsZXNOb3RpZmljYXRpb25cIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9maWxlT3BlcmF0aW9uc18xLkRpZERlbGV0ZUZpbGVzTm90aWZpY2F0aW9uOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIldpbGxEZWxldGVGaWxlc1JlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9maWxlT3BlcmF0aW9uc18xLldpbGxEZWxldGVGaWxlc1JlcXVlc3Q7IH0gfSkpO1xuY29uc3QgcHJvdG9jb2xfbW9uaWtlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3Njg0KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlVuaXF1ZW5lc3NMZXZlbFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX21vbmlrZXJfMS5VbmlxdWVuZXNzTGV2ZWw7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTW9uaWtlcktpbmRcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9tb25pa2VyXzEuTW9uaWtlcktpbmQ7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTW9uaWtlclJlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9tb25pa2VyXzEuTW9uaWtlclJlcXVlc3Q7IH0gfSkpO1xuY29uc3QgcHJvdG9jb2xfdHlwZUhpZXJhcmNoeV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MDYyKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlR5cGVIaWVyYXJjaHlQcmVwYXJlUmVxdWVzdFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX3R5cGVIaWVyYXJjaHlfMS5UeXBlSGllcmFyY2h5UHJlcGFyZVJlcXVlc3Q7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVHlwZUhpZXJhcmNoeVN1YnR5cGVzUmVxdWVzdFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX3R5cGVIaWVyYXJjaHlfMS5UeXBlSGllcmFyY2h5U3VidHlwZXNSZXF1ZXN0OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlR5cGVIaWVyYXJjaHlTdXBlcnR5cGVzUmVxdWVzdFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX3R5cGVIaWVyYXJjaHlfMS5UeXBlSGllcmFyY2h5U3VwZXJ0eXBlc1JlcXVlc3Q7IH0gfSkpO1xuY29uc3QgcHJvdG9jb2xfaW5saW5lVmFsdWVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMzQ5MSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJJbmxpbmVWYWx1ZVJlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9pbmxpbmVWYWx1ZV8xLklubGluZVZhbHVlUmVxdWVzdDsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJJbmxpbmVWYWx1ZVJlZnJlc2hSZXF1ZXN0XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfaW5saW5lVmFsdWVfMS5JbmxpbmVWYWx1ZVJlZnJlc2hSZXF1ZXN0OyB9IH0pKTtcbmNvbnN0IHByb3RvY29sX2lubGF5SGludF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MzgzKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIklubGF5SGludFJlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9pbmxheUhpbnRfMS5JbmxheUhpbnRSZXF1ZXN0OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIklubGF5SGludFJlc29sdmVSZXF1ZXN0XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfaW5sYXlIaW50XzEuSW5sYXlIaW50UmVzb2x2ZVJlcXVlc3Q7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSW5sYXlIaW50UmVmcmVzaFJlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9pbmxheUhpbnRfMS5JbmxheUhpbnRSZWZyZXNoUmVxdWVzdDsgfSB9KSk7XG5jb25zdCBwcm90b2NvbF9kaWFnbm9zdGljXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0OTQpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRGlhZ25vc3RpY1NlcnZlckNhbmNlbGxhdGlvbkRhdGFcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9kaWFnbm9zdGljXzEuRGlhZ25vc3RpY1NlcnZlckNhbmNlbGxhdGlvbkRhdGE7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRG9jdW1lbnREaWFnbm9zdGljUmVwb3J0S2luZFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX2RpYWdub3N0aWNfMS5Eb2N1bWVudERpYWdub3N0aWNSZXBvcnRLaW5kOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkRvY3VtZW50RGlhZ25vc3RpY1JlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9kaWFnbm9zdGljXzEuRG9jdW1lbnREaWFnbm9zdGljUmVxdWVzdDsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJXb3Jrc3BhY2VEaWFnbm9zdGljUmVxdWVzdFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX2RpYWdub3N0aWNfMS5Xb3Jrc3BhY2VEaWFnbm9zdGljUmVxdWVzdDsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJEaWFnbm9zdGljUmVmcmVzaFJlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9kaWFnbm9zdGljXzEuRGlhZ25vc3RpY1JlZnJlc2hSZXF1ZXN0OyB9IH0pKTtcbmNvbnN0IHByb3RvY29sX25vdGVib29rXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ3OTIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTm90ZWJvb2tDZWxsS2luZFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX25vdGVib29rXzEuTm90ZWJvb2tDZWxsS2luZDsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJFeGVjdXRpb25TdW1tYXJ5XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfbm90ZWJvb2tfMS5FeGVjdXRpb25TdW1tYXJ5OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5vdGVib29rQ2VsbFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX25vdGVib29rXzEuTm90ZWJvb2tDZWxsOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5vdGVib29rRG9jdW1lbnRcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9ub3RlYm9va18xLk5vdGVib29rRG9jdW1lbnQ7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTm90ZWJvb2tEb2N1bWVudFN5bmNSZWdpc3RyYXRpb25UeXBlXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfbm90ZWJvb2tfMS5Ob3RlYm9va0RvY3VtZW50U3luY1JlZ2lzdHJhdGlvblR5cGU7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRGlkT3Blbk5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb25cIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9ub3RlYm9va18xLkRpZE9wZW5Ob3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5vdGVib29rQ2VsbEFycmF5Q2hhbmdlXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfbm90ZWJvb2tfMS5Ob3RlYm9va0NlbGxBcnJheUNoYW5nZTsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJEaWRDaGFuZ2VOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfbm90ZWJvb2tfMS5EaWRDaGFuZ2VOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkRpZFNhdmVOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfbm90ZWJvb2tfMS5EaWRTYXZlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbjsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJEaWRDbG9zZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb25cIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9ub3RlYm9va18xLkRpZENsb3NlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbjsgfSB9KSk7XG4vLyBAdHMtaWdub3JlOiB0byBhdm9pZCBpbmxpbmluZyBMb2NhdGlvbkxpbmsgYXMgZHluYW1pYyBpbXBvcnRcbmxldCBfX25vRHluYW1pY0ltcG9ydDtcbi8qKlxuICogVGhlIFRleHREb2N1bWVudEZpbHRlciBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBUZXh0RG9jdW1lbnRGaWx0ZXJ9IGxpdGVyYWxzLlxuICpcbiAqIEBzaW5jZSAzLjE3LjBcbiAqL1xudmFyIFRleHREb2N1bWVudEZpbHRlcjtcbihmdW5jdGlvbiAoVGV4dERvY3VtZW50RmlsdGVyKSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5zdHJpbmcoY2FuZGlkYXRlLmxhbmd1YWdlKSB8fCBJcy5zdHJpbmcoY2FuZGlkYXRlLnNjaGVtZSkgfHwgSXMuc3RyaW5nKGNhbmRpZGF0ZS5wYXR0ZXJuKTtcbiAgICB9XG4gICAgVGV4dERvY3VtZW50RmlsdGVyLmlzID0gaXM7XG59KShUZXh0RG9jdW1lbnRGaWx0ZXIgPSBleHBvcnRzLlRleHREb2N1bWVudEZpbHRlciB8fCAoZXhwb3J0cy5UZXh0RG9jdW1lbnRGaWx0ZXIgPSB7fSkpO1xuLyoqXG4gKiBUaGUgTm90ZWJvb2tEb2N1bWVudEZpbHRlciBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBOb3RlYm9va0RvY3VtZW50RmlsdGVyfSBsaXRlcmFscy5cbiAqXG4gKiBAc2luY2UgMy4xNy4wXG4gKi9cbnZhciBOb3RlYm9va0RvY3VtZW50RmlsdGVyO1xuKGZ1bmN0aW9uIChOb3RlYm9va0RvY3VtZW50RmlsdGVyKSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgKElzLnN0cmluZyhjYW5kaWRhdGUubm90ZWJvb2tUeXBlKSB8fCBJcy5zdHJpbmcoY2FuZGlkYXRlLnNjaGVtZSkgfHwgSXMuc3RyaW5nKGNhbmRpZGF0ZS5wYXR0ZXJuKSk7XG4gICAgfVxuICAgIE5vdGVib29rRG9jdW1lbnRGaWx0ZXIuaXMgPSBpcztcbn0pKE5vdGVib29rRG9jdW1lbnRGaWx0ZXIgPSBleHBvcnRzLk5vdGVib29rRG9jdW1lbnRGaWx0ZXIgfHwgKGV4cG9ydHMuTm90ZWJvb2tEb2N1bWVudEZpbHRlciA9IHt9KSk7XG4vKipcbiAqIFRoZSBOb3RlYm9va0NlbGxUZXh0RG9jdW1lbnRGaWx0ZXIgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgTm90ZWJvb2tDZWxsVGV4dERvY3VtZW50RmlsdGVyfSBsaXRlcmFscy5cbiAqXG4gKiBAc2luY2UgMy4xNy4wXG4gKi9cbnZhciBOb3RlYm9va0NlbGxUZXh0RG9jdW1lbnRGaWx0ZXI7XG4oZnVuY3Rpb24gKE5vdGVib29rQ2VsbFRleHREb2N1bWVudEZpbHRlcikge1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpXG4gICAgICAgICAgICAmJiAoSXMuc3RyaW5nKGNhbmRpZGF0ZS5ub3RlYm9vaykgfHwgTm90ZWJvb2tEb2N1bWVudEZpbHRlci5pcyhjYW5kaWRhdGUubm90ZWJvb2spKVxuICAgICAgICAgICAgJiYgKGNhbmRpZGF0ZS5sYW5ndWFnZSA9PT0gdW5kZWZpbmVkIHx8IElzLnN0cmluZyhjYW5kaWRhdGUubGFuZ3VhZ2UpKTtcbiAgICB9XG4gICAgTm90ZWJvb2tDZWxsVGV4dERvY3VtZW50RmlsdGVyLmlzID0gaXM7XG59KShOb3RlYm9va0NlbGxUZXh0RG9jdW1lbnRGaWx0ZXIgPSBleHBvcnRzLk5vdGVib29rQ2VsbFRleHREb2N1bWVudEZpbHRlciB8fCAoZXhwb3J0cy5Ob3RlYm9va0NlbGxUZXh0RG9jdW1lbnRGaWx0ZXIgPSB7fSkpO1xuLyoqXG4gKiBUaGUgRG9jdW1lbnRTZWxlY3RvciBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBEb2N1bWVudFNlbGVjdG9yfXMuXG4gKi9cbnZhciBEb2N1bWVudFNlbGVjdG9yO1xuKGZ1bmN0aW9uIChEb2N1bWVudFNlbGVjdG9yKSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGVsZW0gb2YgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmICghSXMuc3RyaW5nKGVsZW0pICYmICFUZXh0RG9jdW1lbnRGaWx0ZXIuaXMoZWxlbSkgJiYgIU5vdGVib29rQ2VsbFRleHREb2N1bWVudEZpbHRlci5pcyhlbGVtKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgRG9jdW1lbnRTZWxlY3Rvci5pcyA9IGlzO1xufSkoRG9jdW1lbnRTZWxlY3RvciA9IGV4cG9ydHMuRG9jdW1lbnRTZWxlY3RvciB8fCAoZXhwb3J0cy5Eb2N1bWVudFNlbGVjdG9yID0ge30pKTtcbi8qKlxuICogVGhlIGBjbGllbnQvcmVnaXN0ZXJDYXBhYmlsaXR5YCByZXF1ZXN0IGlzIHNlbnQgZnJvbSB0aGUgc2VydmVyIHRvIHRoZSBjbGllbnQgdG8gcmVnaXN0ZXIgYSBuZXcgY2FwYWJpbGl0eVxuICogaGFuZGxlciBvbiB0aGUgY2xpZW50IHNpZGUuXG4gKi9cbnZhciBSZWdpc3RyYXRpb25SZXF1ZXN0O1xuKGZ1bmN0aW9uIChSZWdpc3RyYXRpb25SZXF1ZXN0KSB7XG4gICAgUmVnaXN0cmF0aW9uUmVxdWVzdC5tZXRob2QgPSAnY2xpZW50L3JlZ2lzdGVyQ2FwYWJpbGl0eSc7XG4gICAgUmVnaXN0cmF0aW9uUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLnNlcnZlclRvQ2xpZW50O1xuICAgIFJlZ2lzdHJhdGlvblJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoUmVnaXN0cmF0aW9uUmVxdWVzdC5tZXRob2QpO1xufSkoUmVnaXN0cmF0aW9uUmVxdWVzdCA9IGV4cG9ydHMuUmVnaXN0cmF0aW9uUmVxdWVzdCB8fCAoZXhwb3J0cy5SZWdpc3RyYXRpb25SZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogVGhlIGBjbGllbnQvdW5yZWdpc3RlckNhcGFiaWxpdHlgIHJlcXVlc3QgaXMgc2VudCBmcm9tIHRoZSBzZXJ2ZXIgdG8gdGhlIGNsaWVudCB0byB1bnJlZ2lzdGVyIGEgcHJldmlvdXNseSByZWdpc3RlcmVkIGNhcGFiaWxpdHlcbiAqIGhhbmRsZXIgb24gdGhlIGNsaWVudCBzaWRlLlxuICovXG52YXIgVW5yZWdpc3RyYXRpb25SZXF1ZXN0O1xuKGZ1bmN0aW9uIChVbnJlZ2lzdHJhdGlvblJlcXVlc3QpIHtcbiAgICBVbnJlZ2lzdHJhdGlvblJlcXVlc3QubWV0aG9kID0gJ2NsaWVudC91bnJlZ2lzdGVyQ2FwYWJpbGl0eSc7XG4gICAgVW5yZWdpc3RyYXRpb25SZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uc2VydmVyVG9DbGllbnQ7XG4gICAgVW5yZWdpc3RyYXRpb25SZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKFVucmVnaXN0cmF0aW9uUmVxdWVzdC5tZXRob2QpO1xufSkoVW5yZWdpc3RyYXRpb25SZXF1ZXN0ID0gZXhwb3J0cy5VbnJlZ2lzdHJhdGlvblJlcXVlc3QgfHwgKGV4cG9ydHMuVW5yZWdpc3RyYXRpb25SZXF1ZXN0ID0ge30pKTtcbnZhciBSZXNvdXJjZU9wZXJhdGlvbktpbmQ7XG4oZnVuY3Rpb24gKFJlc291cmNlT3BlcmF0aW9uS2luZCkge1xuICAgIC8qKlxuICAgICAqIFN1cHBvcnRzIGNyZWF0aW5nIG5ldyBmaWxlcyBhbmQgZm9sZGVycy5cbiAgICAgKi9cbiAgICBSZXNvdXJjZU9wZXJhdGlvbktpbmQuQ3JlYXRlID0gJ2NyZWF0ZSc7XG4gICAgLyoqXG4gICAgICogU3VwcG9ydHMgcmVuYW1pbmcgZXhpc3RpbmcgZmlsZXMgYW5kIGZvbGRlcnMuXG4gICAgICovXG4gICAgUmVzb3VyY2VPcGVyYXRpb25LaW5kLlJlbmFtZSA9ICdyZW5hbWUnO1xuICAgIC8qKlxuICAgICAqIFN1cHBvcnRzIGRlbGV0aW5nIGV4aXN0aW5nIGZpbGVzIGFuZCBmb2xkZXJzLlxuICAgICAqL1xuICAgIFJlc291cmNlT3BlcmF0aW9uS2luZC5EZWxldGUgPSAnZGVsZXRlJztcbn0pKFJlc291cmNlT3BlcmF0aW9uS2luZCA9IGV4cG9ydHMuUmVzb3VyY2VPcGVyYXRpb25LaW5kIHx8IChleHBvcnRzLlJlc291cmNlT3BlcmF0aW9uS2luZCA9IHt9KSk7XG52YXIgRmFpbHVyZUhhbmRsaW5nS2luZDtcbihmdW5jdGlvbiAoRmFpbHVyZUhhbmRsaW5nS2luZCkge1xuICAgIC8qKlxuICAgICAqIEFwcGx5aW5nIHRoZSB3b3Jrc3BhY2UgY2hhbmdlIGlzIHNpbXBseSBhYm9ydGVkIGlmIG9uZSBvZiB0aGUgY2hhbmdlcyBwcm92aWRlZFxuICAgICAqIGZhaWxzLiBBbGwgb3BlcmF0aW9ucyBleGVjdXRlZCBiZWZvcmUgdGhlIGZhaWxpbmcgb3BlcmF0aW9uIHN0YXkgZXhlY3V0ZWQuXG4gICAgICovXG4gICAgRmFpbHVyZUhhbmRsaW5nS2luZC5BYm9ydCA9ICdhYm9ydCc7XG4gICAgLyoqXG4gICAgICogQWxsIG9wZXJhdGlvbnMgYXJlIGV4ZWN1dGVkIHRyYW5zYWN0aW9uYWwuIFRoYXQgbWVhbnMgdGhleSBlaXRoZXIgYWxsXG4gICAgICogc3VjY2VlZCBvciBubyBjaGFuZ2VzIGF0IGFsbCBhcmUgYXBwbGllZCB0byB0aGUgd29ya3NwYWNlLlxuICAgICAqL1xuICAgIEZhaWx1cmVIYW5kbGluZ0tpbmQuVHJhbnNhY3Rpb25hbCA9ICd0cmFuc2FjdGlvbmFsJztcbiAgICAvKipcbiAgICAgKiBJZiB0aGUgd29ya3NwYWNlIGVkaXQgY29udGFpbnMgb25seSB0ZXh0dWFsIGZpbGUgY2hhbmdlcyB0aGV5IGFyZSBleGVjdXRlZCB0cmFuc2FjdGlvbmFsLlxuICAgICAqIElmIHJlc291cmNlIGNoYW5nZXMgKGNyZWF0ZSwgcmVuYW1lIG9yIGRlbGV0ZSBmaWxlKSBhcmUgcGFydCBvZiB0aGUgY2hhbmdlIHRoZSBmYWlsdXJlXG4gICAgICogaGFuZGxpbmcgc3RyYXRlZ3kgaXMgYWJvcnQuXG4gICAgICovXG4gICAgRmFpbHVyZUhhbmRsaW5nS2luZC5UZXh0T25seVRyYW5zYWN0aW9uYWwgPSAndGV4dE9ubHlUcmFuc2FjdGlvbmFsJztcbiAgICAvKipcbiAgICAgKiBUaGUgY2xpZW50IHRyaWVzIHRvIHVuZG8gdGhlIG9wZXJhdGlvbnMgYWxyZWFkeSBleGVjdXRlZC4gQnV0IHRoZXJlIGlzIG5vXG4gICAgICogZ3VhcmFudGVlIHRoYXQgdGhpcyBpcyBzdWNjZWVkaW5nLlxuICAgICAqL1xuICAgIEZhaWx1cmVIYW5kbGluZ0tpbmQuVW5kbyA9ICd1bmRvJztcbn0pKEZhaWx1cmVIYW5kbGluZ0tpbmQgPSBleHBvcnRzLkZhaWx1cmVIYW5kbGluZ0tpbmQgfHwgKGV4cG9ydHMuRmFpbHVyZUhhbmRsaW5nS2luZCA9IHt9KSk7XG4vKipcbiAqIEEgc2V0IG9mIHByZWRlZmluZWQgcG9zaXRpb24gZW5jb2Rpbmcga2luZHMuXG4gKlxuICogQHNpbmNlIDMuMTcuMFxuICovXG52YXIgUG9zaXRpb25FbmNvZGluZ0tpbmQ7XG4oZnVuY3Rpb24gKFBvc2l0aW9uRW5jb2RpbmdLaW5kKSB7XG4gICAgLyoqXG4gICAgICogQ2hhcmFjdGVyIG9mZnNldHMgY291bnQgVVRGLTggY29kZSB1bml0cyAoZS5nLiBieXRlcykuXG4gICAgICovXG4gICAgUG9zaXRpb25FbmNvZGluZ0tpbmQuVVRGOCA9ICd1dGYtOCc7XG4gICAgLyoqXG4gICAgICogQ2hhcmFjdGVyIG9mZnNldHMgY291bnQgVVRGLTE2IGNvZGUgdW5pdHMuXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIHRoZSBkZWZhdWx0IGFuZCBtdXN0IGFsd2F5cyBiZSBzdXBwb3J0ZWRcbiAgICAgKiBieSBzZXJ2ZXJzXG4gICAgICovXG4gICAgUG9zaXRpb25FbmNvZGluZ0tpbmQuVVRGMTYgPSAndXRmLTE2JztcbiAgICAvKipcbiAgICAgKiBDaGFyYWN0ZXIgb2Zmc2V0cyBjb3VudCBVVEYtMzIgY29kZSB1bml0cy5cbiAgICAgKlxuICAgICAqIEltcGxlbWVudGF0aW9uIG5vdGU6IHRoZXNlIGFyZSB0aGUgc2FtZSBhcyBVbmljb2RlIGNvZGVwb2ludHMsXG4gICAgICogc28gdGhpcyBgUG9zaXRpb25FbmNvZGluZ0tpbmRgIG1heSBhbHNvIGJlIHVzZWQgZm9yIGFuXG4gICAgICogZW5jb2RpbmctYWdub3N0aWMgcmVwcmVzZW50YXRpb24gb2YgY2hhcmFjdGVyIG9mZnNldHMuXG4gICAgICovXG4gICAgUG9zaXRpb25FbmNvZGluZ0tpbmQuVVRGMzIgPSAndXRmLTMyJztcbn0pKFBvc2l0aW9uRW5jb2RpbmdLaW5kID0gZXhwb3J0cy5Qb3NpdGlvbkVuY29kaW5nS2luZCB8fCAoZXhwb3J0cy5Qb3NpdGlvbkVuY29kaW5nS2luZCA9IHt9KSk7XG4vKipcbiAqIFRoZSBTdGF0aWNSZWdpc3RyYXRpb25PcHRpb25zIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICoge0BsaW5rIFN0YXRpY1JlZ2lzdHJhdGlvbk9wdGlvbnN9IGxpdGVyYWxzLlxuICovXG52YXIgU3RhdGljUmVnaXN0cmF0aW9uT3B0aW9ucztcbihmdW5jdGlvbiAoU3RhdGljUmVnaXN0cmF0aW9uT3B0aW9ucykge1xuICAgIGZ1bmN0aW9uIGhhc0lkKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICYmIElzLnN0cmluZyhjYW5kaWRhdGUuaWQpICYmIGNhbmRpZGF0ZS5pZC5sZW5ndGggPiAwO1xuICAgIH1cbiAgICBTdGF0aWNSZWdpc3RyYXRpb25PcHRpb25zLmhhc0lkID0gaGFzSWQ7XG59KShTdGF0aWNSZWdpc3RyYXRpb25PcHRpb25zID0gZXhwb3J0cy5TdGF0aWNSZWdpc3RyYXRpb25PcHRpb25zIHx8IChleHBvcnRzLlN0YXRpY1JlZ2lzdHJhdGlvbk9wdGlvbnMgPSB7fSkpO1xuLyoqXG4gKiBUaGUgVGV4dERvY3VtZW50UmVnaXN0cmF0aW9uT3B0aW9ucyBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBUZXh0RG9jdW1lbnRSZWdpc3RyYXRpb25PcHRpb25zfSBsaXRlcmFscy5cbiAqL1xudmFyIFRleHREb2N1bWVudFJlZ2lzdHJhdGlvbk9wdGlvbnM7XG4oZnVuY3Rpb24gKFRleHREb2N1bWVudFJlZ2lzdHJhdGlvbk9wdGlvbnMpIHtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJiAoY2FuZGlkYXRlLmRvY3VtZW50U2VsZWN0b3IgPT09IG51bGwgfHwgRG9jdW1lbnRTZWxlY3Rvci5pcyhjYW5kaWRhdGUuZG9jdW1lbnRTZWxlY3RvcikpO1xuICAgIH1cbiAgICBUZXh0RG9jdW1lbnRSZWdpc3RyYXRpb25PcHRpb25zLmlzID0gaXM7XG59KShUZXh0RG9jdW1lbnRSZWdpc3RyYXRpb25PcHRpb25zID0gZXhwb3J0cy5UZXh0RG9jdW1lbnRSZWdpc3RyYXRpb25PcHRpb25zIHx8IChleHBvcnRzLlRleHREb2N1bWVudFJlZ2lzdHJhdGlvbk9wdGlvbnMgPSB7fSkpO1xuLyoqXG4gKiBUaGUgV29ya0RvbmVQcm9ncmVzc09wdGlvbnMgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgV29ya0RvbmVQcm9ncmVzc09wdGlvbnN9IGxpdGVyYWxzLlxuICovXG52YXIgV29ya0RvbmVQcm9ncmVzc09wdGlvbnM7XG4oZnVuY3Rpb24gKFdvcmtEb25lUHJvZ3Jlc3NPcHRpb25zKSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgKGNhbmRpZGF0ZS53b3JrRG9uZVByb2dyZXNzID09PSB1bmRlZmluZWQgfHwgSXMuYm9vbGVhbihjYW5kaWRhdGUud29ya0RvbmVQcm9ncmVzcykpO1xuICAgIH1cbiAgICBXb3JrRG9uZVByb2dyZXNzT3B0aW9ucy5pcyA9IGlzO1xuICAgIGZ1bmN0aW9uIGhhc1dvcmtEb25lUHJvZ3Jlc3ModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgJiYgSXMuYm9vbGVhbihjYW5kaWRhdGUud29ya0RvbmVQcm9ncmVzcyk7XG4gICAgfVxuICAgIFdvcmtEb25lUHJvZ3Jlc3NPcHRpb25zLmhhc1dvcmtEb25lUHJvZ3Jlc3MgPSBoYXNXb3JrRG9uZVByb2dyZXNzO1xufSkoV29ya0RvbmVQcm9ncmVzc09wdGlvbnMgPSBleHBvcnRzLldvcmtEb25lUHJvZ3Jlc3NPcHRpb25zIHx8IChleHBvcnRzLldvcmtEb25lUHJvZ3Jlc3NPcHRpb25zID0ge30pKTtcbi8qKlxuICogVGhlIGluaXRpYWxpemUgcmVxdWVzdCBpcyBzZW50IGZyb20gdGhlIGNsaWVudCB0byB0aGUgc2VydmVyLlxuICogSXQgaXMgc2VudCBvbmNlIGFzIHRoZSByZXF1ZXN0IGFmdGVyIHN0YXJ0aW5nIHVwIHRoZSBzZXJ2ZXIuXG4gKiBUaGUgcmVxdWVzdHMgcGFyYW1ldGVyIGlzIG9mIHR5cGUge0BsaW5rIEluaXRpYWxpemVQYXJhbXN9XG4gKiB0aGUgcmVzcG9uc2UgaWYgb2YgdHlwZSB7QGxpbmsgSW5pdGlhbGl6ZVJlc3VsdH0gb2YgYSBUaGVuYWJsZSB0aGF0XG4gKiByZXNvbHZlcyB0byBzdWNoLlxuICovXG52YXIgSW5pdGlhbGl6ZVJlcXVlc3Q7XG4oZnVuY3Rpb24gKEluaXRpYWxpemVSZXF1ZXN0KSB7XG4gICAgSW5pdGlhbGl6ZVJlcXVlc3QubWV0aG9kID0gJ2luaXRpYWxpemUnO1xuICAgIEluaXRpYWxpemVSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgSW5pdGlhbGl6ZVJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoSW5pdGlhbGl6ZVJlcXVlc3QubWV0aG9kKTtcbn0pKEluaXRpYWxpemVSZXF1ZXN0ID0gZXhwb3J0cy5Jbml0aWFsaXplUmVxdWVzdCB8fCAoZXhwb3J0cy5Jbml0aWFsaXplUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIEtub3duIGVycm9yIGNvZGVzIGZvciBhbiBgSW5pdGlhbGl6ZUVycm9yQ29kZXNgO1xuICovXG52YXIgSW5pdGlhbGl6ZUVycm9yQ29kZXM7XG4oZnVuY3Rpb24gKEluaXRpYWxpemVFcnJvckNvZGVzKSB7XG4gICAgLyoqXG4gICAgICogSWYgdGhlIHByb3RvY29sIHZlcnNpb24gcHJvdmlkZWQgYnkgdGhlIGNsaWVudCBjYW4ndCBiZSBoYW5kbGVkIGJ5IHRoZSBzZXJ2ZXIuXG4gICAgICpcbiAgICAgKiBAZGVwcmVjYXRlZCBUaGlzIGluaXRpYWxpemUgZXJyb3IgZ290IHJlcGxhY2VkIGJ5IGNsaWVudCBjYXBhYmlsaXRpZXMuIFRoZXJlIGlzXG4gICAgICogbm8gdmVyc2lvbiBoYW5kc2hha2UgaW4gdmVyc2lvbiAzLjB4XG4gICAgICovXG4gICAgSW5pdGlhbGl6ZUVycm9yQ29kZXMudW5rbm93blByb3RvY29sVmVyc2lvbiA9IDE7XG59KShJbml0aWFsaXplRXJyb3JDb2RlcyA9IGV4cG9ydHMuSW5pdGlhbGl6ZUVycm9yQ29kZXMgfHwgKGV4cG9ydHMuSW5pdGlhbGl6ZUVycm9yQ29kZXMgPSB7fSkpO1xuLyoqXG4gKiBUaGUgaW5pdGlhbGl6ZWQgbm90aWZpY2F0aW9uIGlzIHNlbnQgZnJvbSB0aGUgY2xpZW50IHRvIHRoZVxuICogc2VydmVyIGFmdGVyIHRoZSBjbGllbnQgaXMgZnVsbHkgaW5pdGlhbGl6ZWQgYW5kIHRoZSBzZXJ2ZXJcbiAqIGlzIGFsbG93ZWQgdG8gc2VuZCByZXF1ZXN0cyBmcm9tIHRoZSBzZXJ2ZXIgdG8gdGhlIGNsaWVudC5cbiAqL1xudmFyIEluaXRpYWxpemVkTm90aWZpY2F0aW9uO1xuKGZ1bmN0aW9uIChJbml0aWFsaXplZE5vdGlmaWNhdGlvbikge1xuICAgIEluaXRpYWxpemVkTm90aWZpY2F0aW9uLm1ldGhvZCA9ICdpbml0aWFsaXplZCc7XG4gICAgSW5pdGlhbGl6ZWROb3RpZmljYXRpb24ubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBJbml0aWFsaXplZE5vdGlmaWNhdGlvbi50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xOb3RpZmljYXRpb25UeXBlKEluaXRpYWxpemVkTm90aWZpY2F0aW9uLm1ldGhvZCk7XG59KShJbml0aWFsaXplZE5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuSW5pdGlhbGl6ZWROb3RpZmljYXRpb24gfHwgKGV4cG9ydHMuSW5pdGlhbGl6ZWROb3RpZmljYXRpb24gPSB7fSkpO1xuLy8tLS0tIFNodXRkb3duIE1ldGhvZCAtLS0tXG4vKipcbiAqIEEgc2h1dGRvd24gcmVxdWVzdCBpcyBzZW50IGZyb20gdGhlIGNsaWVudCB0byB0aGUgc2VydmVyLlxuICogSXQgaXMgc2VudCBvbmNlIHdoZW4gdGhlIGNsaWVudCBkZWNpZGVzIHRvIHNodXRkb3duIHRoZVxuICogc2VydmVyLiBUaGUgb25seSBub3RpZmljYXRpb24gdGhhdCBpcyBzZW50IGFmdGVyIGEgc2h1dGRvd24gcmVxdWVzdFxuICogaXMgdGhlIGV4aXQgZXZlbnQuXG4gKi9cbnZhciBTaHV0ZG93blJlcXVlc3Q7XG4oZnVuY3Rpb24gKFNodXRkb3duUmVxdWVzdCkge1xuICAgIFNodXRkb3duUmVxdWVzdC5tZXRob2QgPSAnc2h1dGRvd24nO1xuICAgIFNodXRkb3duUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIFNodXRkb3duUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZTAoU2h1dGRvd25SZXF1ZXN0Lm1ldGhvZCk7XG59KShTaHV0ZG93blJlcXVlc3QgPSBleHBvcnRzLlNodXRkb3duUmVxdWVzdCB8fCAoZXhwb3J0cy5TaHV0ZG93blJlcXVlc3QgPSB7fSkpO1xuLy8tLS0tIEV4aXQgTm90aWZpY2F0aW9uIC0tLS1cbi8qKlxuICogVGhlIGV4aXQgZXZlbnQgaXMgc2VudCBmcm9tIHRoZSBjbGllbnQgdG8gdGhlIHNlcnZlciB0b1xuICogYXNrIHRoZSBzZXJ2ZXIgdG8gZXhpdCBpdHMgcHJvY2Vzcy5cbiAqL1xudmFyIEV4aXROb3RpZmljYXRpb247XG4oZnVuY3Rpb24gKEV4aXROb3RpZmljYXRpb24pIHtcbiAgICBFeGl0Tm90aWZpY2F0aW9uLm1ldGhvZCA9ICdleGl0JztcbiAgICBFeGl0Tm90aWZpY2F0aW9uLm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgRXhpdE5vdGlmaWNhdGlvbi50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xOb3RpZmljYXRpb25UeXBlMChFeGl0Tm90aWZpY2F0aW9uLm1ldGhvZCk7XG59KShFeGl0Tm90aWZpY2F0aW9uID0gZXhwb3J0cy5FeGl0Tm90aWZpY2F0aW9uIHx8IChleHBvcnRzLkV4aXROb3RpZmljYXRpb24gPSB7fSkpO1xuLyoqXG4gKiBUaGUgY29uZmlndXJhdGlvbiBjaGFuZ2Ugbm90aWZpY2F0aW9uIGlzIHNlbnQgZnJvbSB0aGUgY2xpZW50IHRvIHRoZSBzZXJ2ZXJcbiAqIHdoZW4gdGhlIGNsaWVudCdzIGNvbmZpZ3VyYXRpb24gaGFzIGNoYW5nZWQuIFRoZSBub3RpZmljYXRpb24gY29udGFpbnNcbiAqIHRoZSBjaGFuZ2VkIGNvbmZpZ3VyYXRpb24gYXMgZGVmaW5lZCBieSB0aGUgbGFuZ3VhZ2UgY2xpZW50LlxuICovXG52YXIgRGlkQ2hhbmdlQ29uZmlndXJhdGlvbk5vdGlmaWNhdGlvbjtcbihmdW5jdGlvbiAoRGlkQ2hhbmdlQ29uZmlndXJhdGlvbk5vdGlmaWNhdGlvbikge1xuICAgIERpZENoYW5nZUNvbmZpZ3VyYXRpb25Ob3RpZmljYXRpb24ubWV0aG9kID0gJ3dvcmtzcGFjZS9kaWRDaGFuZ2VDb25maWd1cmF0aW9uJztcbiAgICBEaWRDaGFuZ2VDb25maWd1cmF0aW9uTm90aWZpY2F0aW9uLm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgRGlkQ2hhbmdlQ29uZmlndXJhdGlvbk5vdGlmaWNhdGlvbi50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xOb3RpZmljYXRpb25UeXBlKERpZENoYW5nZUNvbmZpZ3VyYXRpb25Ob3RpZmljYXRpb24ubWV0aG9kKTtcbn0pKERpZENoYW5nZUNvbmZpZ3VyYXRpb25Ob3RpZmljYXRpb24gPSBleHBvcnRzLkRpZENoYW5nZUNvbmZpZ3VyYXRpb25Ob3RpZmljYXRpb24gfHwgKGV4cG9ydHMuRGlkQ2hhbmdlQ29uZmlndXJhdGlvbk5vdGlmaWNhdGlvbiA9IHt9KSk7XG4vLy0tLS0gTWVzc2FnZSBzaG93IGFuZCBsb2cgbm90aWZpY2F0aW9ucyAtLS0tXG4vKipcbiAqIFRoZSBtZXNzYWdlIHR5cGVcbiAqL1xudmFyIE1lc3NhZ2VUeXBlO1xuKGZ1bmN0aW9uIChNZXNzYWdlVHlwZSkge1xuICAgIC8qKlxuICAgICAqIEFuIGVycm9yIG1lc3NhZ2UuXG4gICAgICovXG4gICAgTWVzc2FnZVR5cGUuRXJyb3IgPSAxO1xuICAgIC8qKlxuICAgICAqIEEgd2FybmluZyBtZXNzYWdlLlxuICAgICAqL1xuICAgIE1lc3NhZ2VUeXBlLldhcm5pbmcgPSAyO1xuICAgIC8qKlxuICAgICAqIEFuIGluZm9ybWF0aW9uIG1lc3NhZ2UuXG4gICAgICovXG4gICAgTWVzc2FnZVR5cGUuSW5mbyA9IDM7XG4gICAgLyoqXG4gICAgICogQSBsb2cgbWVzc2FnZS5cbiAgICAgKi9cbiAgICBNZXNzYWdlVHlwZS5Mb2cgPSA0O1xufSkoTWVzc2FnZVR5cGUgPSBleHBvcnRzLk1lc3NhZ2VUeXBlIHx8IChleHBvcnRzLk1lc3NhZ2VUeXBlID0ge30pKTtcbi8qKlxuICogVGhlIHNob3cgbWVzc2FnZSBub3RpZmljYXRpb24gaXMgc2VudCBmcm9tIGEgc2VydmVyIHRvIGEgY2xpZW50IHRvIGFza1xuICogdGhlIGNsaWVudCB0byBkaXNwbGF5IGEgcGFydGljdWxhciBtZXNzYWdlIGluIHRoZSB1c2VyIGludGVyZmFjZS5cbiAqL1xudmFyIFNob3dNZXNzYWdlTm90aWZpY2F0aW9uO1xuKGZ1bmN0aW9uIChTaG93TWVzc2FnZU5vdGlmaWNhdGlvbikge1xuICAgIFNob3dNZXNzYWdlTm90aWZpY2F0aW9uLm1ldGhvZCA9ICd3aW5kb3cvc2hvd01lc3NhZ2UnO1xuICAgIFNob3dNZXNzYWdlTm90aWZpY2F0aW9uLm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uc2VydmVyVG9DbGllbnQ7XG4gICAgU2hvd01lc3NhZ2VOb3RpZmljYXRpb24udHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sTm90aWZpY2F0aW9uVHlwZShTaG93TWVzc2FnZU5vdGlmaWNhdGlvbi5tZXRob2QpO1xufSkoU2hvd01lc3NhZ2VOb3RpZmljYXRpb24gPSBleHBvcnRzLlNob3dNZXNzYWdlTm90aWZpY2F0aW9uIHx8IChleHBvcnRzLlNob3dNZXNzYWdlTm90aWZpY2F0aW9uID0ge30pKTtcbi8qKlxuICogVGhlIHNob3cgbWVzc2FnZSByZXF1ZXN0IGlzIHNlbnQgZnJvbSB0aGUgc2VydmVyIHRvIHRoZSBjbGllbnQgdG8gc2hvdyBhIG1lc3NhZ2VcbiAqIGFuZCBhIHNldCBvZiBvcHRpb25zIGFjdGlvbnMgdG8gdGhlIHVzZXIuXG4gKi9cbnZhciBTaG93TWVzc2FnZVJlcXVlc3Q7XG4oZnVuY3Rpb24gKFNob3dNZXNzYWdlUmVxdWVzdCkge1xuICAgIFNob3dNZXNzYWdlUmVxdWVzdC5tZXRob2QgPSAnd2luZG93L3Nob3dNZXNzYWdlUmVxdWVzdCc7XG4gICAgU2hvd01lc3NhZ2VSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uc2VydmVyVG9DbGllbnQ7XG4gICAgU2hvd01lc3NhZ2VSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKFNob3dNZXNzYWdlUmVxdWVzdC5tZXRob2QpO1xufSkoU2hvd01lc3NhZ2VSZXF1ZXN0ID0gZXhwb3J0cy5TaG93TWVzc2FnZVJlcXVlc3QgfHwgKGV4cG9ydHMuU2hvd01lc3NhZ2VSZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogVGhlIGxvZyBtZXNzYWdlIG5vdGlmaWNhdGlvbiBpcyBzZW50IGZyb20gdGhlIHNlcnZlciB0byB0aGUgY2xpZW50IHRvIGFza1xuICogdGhlIGNsaWVudCB0byBsb2cgYSBwYXJ0aWN1bGFyIG1lc3NhZ2UuXG4gKi9cbnZhciBMb2dNZXNzYWdlTm90aWZpY2F0aW9uO1xuKGZ1bmN0aW9uIChMb2dNZXNzYWdlTm90aWZpY2F0aW9uKSB7XG4gICAgTG9nTWVzc2FnZU5vdGlmaWNhdGlvbi5tZXRob2QgPSAnd2luZG93L2xvZ01lc3NhZ2UnO1xuICAgIExvZ01lc3NhZ2VOb3RpZmljYXRpb24ubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5zZXJ2ZXJUb0NsaWVudDtcbiAgICBMb2dNZXNzYWdlTm90aWZpY2F0aW9uLnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbE5vdGlmaWNhdGlvblR5cGUoTG9nTWVzc2FnZU5vdGlmaWNhdGlvbi5tZXRob2QpO1xufSkoTG9nTWVzc2FnZU5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuTG9nTWVzc2FnZU5vdGlmaWNhdGlvbiB8fCAoZXhwb3J0cy5Mb2dNZXNzYWdlTm90aWZpY2F0aW9uID0ge30pKTtcbi8vLS0tLSBUZWxlbWV0cnkgbm90aWZpY2F0aW9uXG4vKipcbiAqIFRoZSB0ZWxlbWV0cnkgZXZlbnQgbm90aWZpY2F0aW9uIGlzIHNlbnQgZnJvbSB0aGUgc2VydmVyIHRvIHRoZSBjbGllbnQgdG8gYXNrXG4gKiB0aGUgY2xpZW50IHRvIGxvZyB0ZWxlbWV0cnkgZGF0YS5cbiAqL1xudmFyIFRlbGVtZXRyeUV2ZW50Tm90aWZpY2F0aW9uO1xuKGZ1bmN0aW9uIChUZWxlbWV0cnlFdmVudE5vdGlmaWNhdGlvbikge1xuICAgIFRlbGVtZXRyeUV2ZW50Tm90aWZpY2F0aW9uLm1ldGhvZCA9ICd0ZWxlbWV0cnkvZXZlbnQnO1xuICAgIFRlbGVtZXRyeUV2ZW50Tm90aWZpY2F0aW9uLm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uc2VydmVyVG9DbGllbnQ7XG4gICAgVGVsZW1ldHJ5RXZlbnROb3RpZmljYXRpb24udHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sTm90aWZpY2F0aW9uVHlwZShUZWxlbWV0cnlFdmVudE5vdGlmaWNhdGlvbi5tZXRob2QpO1xufSkoVGVsZW1ldHJ5RXZlbnROb3RpZmljYXRpb24gPSBleHBvcnRzLlRlbGVtZXRyeUV2ZW50Tm90aWZpY2F0aW9uIHx8IChleHBvcnRzLlRlbGVtZXRyeUV2ZW50Tm90aWZpY2F0aW9uID0ge30pKTtcbi8qKlxuICogRGVmaW5lcyBob3cgdGhlIGhvc3QgKGVkaXRvcikgc2hvdWxkIHN5bmNcbiAqIGRvY3VtZW50IGNoYW5nZXMgdG8gdGhlIGxhbmd1YWdlIHNlcnZlci5cbiAqL1xudmFyIFRleHREb2N1bWVudFN5bmNLaW5kO1xuKGZ1bmN0aW9uIChUZXh0RG9jdW1lbnRTeW5jS2luZCkge1xuICAgIC8qKlxuICAgICAqIERvY3VtZW50cyBzaG91bGQgbm90IGJlIHN5bmNlZCBhdCBhbGwuXG4gICAgICovXG4gICAgVGV4dERvY3VtZW50U3luY0tpbmQuTm9uZSA9IDA7XG4gICAgLyoqXG4gICAgICogRG9jdW1lbnRzIGFyZSBzeW5jZWQgYnkgYWx3YXlzIHNlbmRpbmcgdGhlIGZ1bGwgY29udGVudFxuICAgICAqIG9mIHRoZSBkb2N1bWVudC5cbiAgICAgKi9cbiAgICBUZXh0RG9jdW1lbnRTeW5jS2luZC5GdWxsID0gMTtcbiAgICAvKipcbiAgICAgKiBEb2N1bWVudHMgYXJlIHN5bmNlZCBieSBzZW5kaW5nIHRoZSBmdWxsIGNvbnRlbnQgb24gb3Blbi5cbiAgICAgKiBBZnRlciB0aGF0IG9ubHkgaW5jcmVtZW50YWwgdXBkYXRlcyB0byB0aGUgZG9jdW1lbnQgYXJlXG4gICAgICogc2VuZC5cbiAgICAgKi9cbiAgICBUZXh0RG9jdW1lbnRTeW5jS2luZC5JbmNyZW1lbnRhbCA9IDI7XG59KShUZXh0RG9jdW1lbnRTeW5jS2luZCA9IGV4cG9ydHMuVGV4dERvY3VtZW50U3luY0tpbmQgfHwgKGV4cG9ydHMuVGV4dERvY3VtZW50U3luY0tpbmQgPSB7fSkpO1xuLyoqXG4gKiBUaGUgZG9jdW1lbnQgb3BlbiBub3RpZmljYXRpb24gaXMgc2VudCBmcm9tIHRoZSBjbGllbnQgdG8gdGhlIHNlcnZlciB0byBzaWduYWxcbiAqIG5ld2x5IG9wZW5lZCB0ZXh0IGRvY3VtZW50cy4gVGhlIGRvY3VtZW50J3MgdHJ1dGggaXMgbm93IG1hbmFnZWQgYnkgdGhlIGNsaWVudFxuICogYW5kIHRoZSBzZXJ2ZXIgbXVzdCBub3QgdHJ5IHRvIHJlYWQgdGhlIGRvY3VtZW50J3MgdHJ1dGggdXNpbmcgdGhlIGRvY3VtZW50J3NcbiAqIHVyaS4gT3BlbiBpbiB0aGlzIHNlbnNlIG1lYW5zIGl0IGlzIG1hbmFnZWQgYnkgdGhlIGNsaWVudC4gSXQgZG9lc24ndCBuZWNlc3NhcmlseVxuICogbWVhbiB0aGF0IGl0cyBjb250ZW50IGlzIHByZXNlbnRlZCBpbiBhbiBlZGl0b3IuIEFuIG9wZW4gbm90aWZpY2F0aW9uIG11c3Qgbm90XG4gKiBiZSBzZW50IG1vcmUgdGhhbiBvbmNlIHdpdGhvdXQgYSBjb3JyZXNwb25kaW5nIGNsb3NlIG5vdGlmaWNhdGlvbiBzZW5kIGJlZm9yZS5cbiAqIFRoaXMgbWVhbnMgb3BlbiBhbmQgY2xvc2Ugbm90aWZpY2F0aW9uIG11c3QgYmUgYmFsYW5jZWQgYW5kIHRoZSBtYXggb3BlbiBjb3VudFxuICogaXMgb25lLlxuICovXG52YXIgRGlkT3BlblRleHREb2N1bWVudE5vdGlmaWNhdGlvbjtcbihmdW5jdGlvbiAoRGlkT3BlblRleHREb2N1bWVudE5vdGlmaWNhdGlvbikge1xuICAgIERpZE9wZW5UZXh0RG9jdW1lbnROb3RpZmljYXRpb24ubWV0aG9kID0gJ3RleHREb2N1bWVudC9kaWRPcGVuJztcbiAgICBEaWRPcGVuVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uLm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgRGlkT3BlblRleHREb2N1bWVudE5vdGlmaWNhdGlvbi50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xOb3RpZmljYXRpb25UeXBlKERpZE9wZW5UZXh0RG9jdW1lbnROb3RpZmljYXRpb24ubWV0aG9kKTtcbn0pKERpZE9wZW5UZXh0RG9jdW1lbnROb3RpZmljYXRpb24gPSBleHBvcnRzLkRpZE9wZW5UZXh0RG9jdW1lbnROb3RpZmljYXRpb24gfHwgKGV4cG9ydHMuRGlkT3BlblRleHREb2N1bWVudE5vdGlmaWNhdGlvbiA9IHt9KSk7XG52YXIgVGV4dERvY3VtZW50Q29udGVudENoYW5nZUV2ZW50O1xuKGZ1bmN0aW9uIChUZXh0RG9jdW1lbnRDb250ZW50Q2hhbmdlRXZlbnQpIHtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgaW5mb3JtYXRpb24gZGVzY3JpYmVzIGEgZGVsdGEgZXZlbnQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNJbmNyZW1lbnRhbChldmVudCkge1xuICAgICAgICBsZXQgY2FuZGlkYXRlID0gZXZlbnQ7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgIT09IHVuZGVmaW5lZCAmJiBjYW5kaWRhdGUgIT09IG51bGwgJiZcbiAgICAgICAgICAgIHR5cGVvZiBjYW5kaWRhdGUudGV4dCA9PT0gJ3N0cmluZycgJiYgY2FuZGlkYXRlLnJhbmdlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChjYW5kaWRhdGUucmFuZ2VMZW5ndGggPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgY2FuZGlkYXRlLnJhbmdlTGVuZ3RoID09PSAnbnVtYmVyJyk7XG4gICAgfVxuICAgIFRleHREb2N1bWVudENvbnRlbnRDaGFuZ2VFdmVudC5pc0luY3JlbWVudGFsID0gaXNJbmNyZW1lbnRhbDtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgaW5mb3JtYXRpb24gZGVzY3JpYmVzIGEgZnVsbCByZXBsYWNlbWVudCBldmVudC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0Z1bGwoZXZlbnQpIHtcbiAgICAgICAgbGV0IGNhbmRpZGF0ZSA9IGV2ZW50O1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICE9PSB1bmRlZmluZWQgJiYgY2FuZGlkYXRlICE9PSBudWxsICYmXG4gICAgICAgICAgICB0eXBlb2YgY2FuZGlkYXRlLnRleHQgPT09ICdzdHJpbmcnICYmIGNhbmRpZGF0ZS5yYW5nZSA9PT0gdW5kZWZpbmVkICYmIGNhbmRpZGF0ZS5yYW5nZUxlbmd0aCA9PT0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBUZXh0RG9jdW1lbnRDb250ZW50Q2hhbmdlRXZlbnQuaXNGdWxsID0gaXNGdWxsO1xufSkoVGV4dERvY3VtZW50Q29udGVudENoYW5nZUV2ZW50ID0gZXhwb3J0cy5UZXh0RG9jdW1lbnRDb250ZW50Q2hhbmdlRXZlbnQgfHwgKGV4cG9ydHMuVGV4dERvY3VtZW50Q29udGVudENoYW5nZUV2ZW50ID0ge30pKTtcbi8qKlxuICogVGhlIGRvY3VtZW50IGNoYW5nZSBub3RpZmljYXRpb24gaXMgc2VudCBmcm9tIHRoZSBjbGllbnQgdG8gdGhlIHNlcnZlciB0byBzaWduYWxcbiAqIGNoYW5nZXMgdG8gYSB0ZXh0IGRvY3VtZW50LlxuICovXG52YXIgRGlkQ2hhbmdlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uO1xuKGZ1bmN0aW9uIChEaWRDaGFuZ2VUZXh0RG9jdW1lbnROb3RpZmljYXRpb24pIHtcbiAgICBEaWRDaGFuZ2VUZXh0RG9jdW1lbnROb3RpZmljYXRpb24ubWV0aG9kID0gJ3RleHREb2N1bWVudC9kaWRDaGFuZ2UnO1xuICAgIERpZENoYW5nZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbi5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIERpZENoYW5nZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbi50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xOb3RpZmljYXRpb25UeXBlKERpZENoYW5nZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbi5tZXRob2QpO1xufSkoRGlkQ2hhbmdlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uID0gZXhwb3J0cy5EaWRDaGFuZ2VUZXh0RG9jdW1lbnROb3RpZmljYXRpb24gfHwgKGV4cG9ydHMuRGlkQ2hhbmdlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uID0ge30pKTtcbi8qKlxuICogVGhlIGRvY3VtZW50IGNsb3NlIG5vdGlmaWNhdGlvbiBpcyBzZW50IGZyb20gdGhlIGNsaWVudCB0byB0aGUgc2VydmVyIHdoZW5cbiAqIHRoZSBkb2N1bWVudCBnb3QgY2xvc2VkIGluIHRoZSBjbGllbnQuIFRoZSBkb2N1bWVudCdzIHRydXRoIG5vdyBleGlzdHMgd2hlcmVcbiAqIHRoZSBkb2N1bWVudCdzIHVyaSBwb2ludHMgdG8gKGUuZy4gaWYgdGhlIGRvY3VtZW50J3MgdXJpIGlzIGEgZmlsZSB1cmkgdGhlXG4gKiB0cnV0aCBub3cgZXhpc3RzIG9uIGRpc2spLiBBcyB3aXRoIHRoZSBvcGVuIG5vdGlmaWNhdGlvbiB0aGUgY2xvc2Ugbm90aWZpY2F0aW9uXG4gKiBpcyBhYm91dCBtYW5hZ2luZyB0aGUgZG9jdW1lbnQncyBjb250ZW50LiBSZWNlaXZpbmcgYSBjbG9zZSBub3RpZmljYXRpb25cbiAqIGRvZXNuJ3QgbWVhbiB0aGF0IHRoZSBkb2N1bWVudCB3YXMgb3BlbiBpbiBhbiBlZGl0b3IgYmVmb3JlLiBBIGNsb3NlXG4gKiBub3RpZmljYXRpb24gcmVxdWlyZXMgYSBwcmV2aW91cyBvcGVuIG5vdGlmaWNhdGlvbiB0byBiZSBzZW50LlxuICovXG52YXIgRGlkQ2xvc2VUZXh0RG9jdW1lbnROb3RpZmljYXRpb247XG4oZnVuY3Rpb24gKERpZENsb3NlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uKSB7XG4gICAgRGlkQ2xvc2VUZXh0RG9jdW1lbnROb3RpZmljYXRpb24ubWV0aG9kID0gJ3RleHREb2N1bWVudC9kaWRDbG9zZSc7XG4gICAgRGlkQ2xvc2VUZXh0RG9jdW1lbnROb3RpZmljYXRpb24ubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBEaWRDbG9zZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbi50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xOb3RpZmljYXRpb25UeXBlKERpZENsb3NlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uLm1ldGhvZCk7XG59KShEaWRDbG9zZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuRGlkQ2xvc2VUZXh0RG9jdW1lbnROb3RpZmljYXRpb24gfHwgKGV4cG9ydHMuRGlkQ2xvc2VUZXh0RG9jdW1lbnROb3RpZmljYXRpb24gPSB7fSkpO1xuLyoqXG4gKiBUaGUgZG9jdW1lbnQgc2F2ZSBub3RpZmljYXRpb24gaXMgc2VudCBmcm9tIHRoZSBjbGllbnQgdG8gdGhlIHNlcnZlciB3aGVuXG4gKiB0aGUgZG9jdW1lbnQgZ290IHNhdmVkIGluIHRoZSBjbGllbnQuXG4gKi9cbnZhciBEaWRTYXZlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uO1xuKGZ1bmN0aW9uIChEaWRTYXZlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uKSB7XG4gICAgRGlkU2F2ZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbi5tZXRob2QgPSAndGV4dERvY3VtZW50L2RpZFNhdmUnO1xuICAgIERpZFNhdmVUZXh0RG9jdW1lbnROb3RpZmljYXRpb24ubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBEaWRTYXZlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uLnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbE5vdGlmaWNhdGlvblR5cGUoRGlkU2F2ZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbi5tZXRob2QpO1xufSkoRGlkU2F2ZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuRGlkU2F2ZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbiB8fCAoZXhwb3J0cy5EaWRTYXZlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uID0ge30pKTtcbi8qKlxuICogUmVwcmVzZW50cyByZWFzb25zIHdoeSBhIHRleHQgZG9jdW1lbnQgaXMgc2F2ZWQuXG4gKi9cbnZhciBUZXh0RG9jdW1lbnRTYXZlUmVhc29uO1xuKGZ1bmN0aW9uIChUZXh0RG9jdW1lbnRTYXZlUmVhc29uKSB7XG4gICAgLyoqXG4gICAgICogTWFudWFsbHkgdHJpZ2dlcmVkLCBlLmcuIGJ5IHRoZSB1c2VyIHByZXNzaW5nIHNhdmUsIGJ5IHN0YXJ0aW5nIGRlYnVnZ2luZyxcbiAgICAgKiBvciBieSBhbiBBUEkgY2FsbC5cbiAgICAgKi9cbiAgICBUZXh0RG9jdW1lbnRTYXZlUmVhc29uLk1hbnVhbCA9IDE7XG4gICAgLyoqXG4gICAgICogQXV0b21hdGljIGFmdGVyIGEgZGVsYXkuXG4gICAgICovXG4gICAgVGV4dERvY3VtZW50U2F2ZVJlYXNvbi5BZnRlckRlbGF5ID0gMjtcbiAgICAvKipcbiAgICAgKiBXaGVuIHRoZSBlZGl0b3IgbG9zdCBmb2N1cy5cbiAgICAgKi9cbiAgICBUZXh0RG9jdW1lbnRTYXZlUmVhc29uLkZvY3VzT3V0ID0gMztcbn0pKFRleHREb2N1bWVudFNhdmVSZWFzb24gPSBleHBvcnRzLlRleHREb2N1bWVudFNhdmVSZWFzb24gfHwgKGV4cG9ydHMuVGV4dERvY3VtZW50U2F2ZVJlYXNvbiA9IHt9KSk7XG4vKipcbiAqIEEgZG9jdW1lbnQgd2lsbCBzYXZlIG5vdGlmaWNhdGlvbiBpcyBzZW50IGZyb20gdGhlIGNsaWVudCB0byB0aGUgc2VydmVyIGJlZm9yZVxuICogdGhlIGRvY3VtZW50IGlzIGFjdHVhbGx5IHNhdmVkLlxuICovXG52YXIgV2lsbFNhdmVUZXh0RG9jdW1lbnROb3RpZmljYXRpb247XG4oZnVuY3Rpb24gKFdpbGxTYXZlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uKSB7XG4gICAgV2lsbFNhdmVUZXh0RG9jdW1lbnROb3RpZmljYXRpb24ubWV0aG9kID0gJ3RleHREb2N1bWVudC93aWxsU2F2ZSc7XG4gICAgV2lsbFNhdmVUZXh0RG9jdW1lbnROb3RpZmljYXRpb24ubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBXaWxsU2F2ZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbi50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xOb3RpZmljYXRpb25UeXBlKFdpbGxTYXZlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uLm1ldGhvZCk7XG59KShXaWxsU2F2ZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuV2lsbFNhdmVUZXh0RG9jdW1lbnROb3RpZmljYXRpb24gfHwgKGV4cG9ydHMuV2lsbFNhdmVUZXh0RG9jdW1lbnROb3RpZmljYXRpb24gPSB7fSkpO1xuLyoqXG4gKiBBIGRvY3VtZW50IHdpbGwgc2F2ZSByZXF1ZXN0IGlzIHNlbnQgZnJvbSB0aGUgY2xpZW50IHRvIHRoZSBzZXJ2ZXIgYmVmb3JlXG4gKiB0aGUgZG9jdW1lbnQgaXMgYWN0dWFsbHkgc2F2ZWQuIFRoZSByZXF1ZXN0IGNhbiByZXR1cm4gYW4gYXJyYXkgb2YgVGV4dEVkaXRzXG4gKiB3aGljaCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIHRleHQgZG9jdW1lbnQgYmVmb3JlIGl0IGlzIHNhdmVkLiBQbGVhc2Ugbm90ZSB0aGF0XG4gKiBjbGllbnRzIG1pZ2h0IGRyb3AgcmVzdWx0cyBpZiBjb21wdXRpbmcgdGhlIHRleHQgZWRpdHMgdG9vayB0b28gbG9uZyBvciBpZiBhXG4gKiBzZXJ2ZXIgY29uc3RhbnRseSBmYWlscyBvbiB0aGlzIHJlcXVlc3QuIFRoaXMgaXMgZG9uZSB0byBrZWVwIHRoZSBzYXZlIGZhc3QgYW5kXG4gKiByZWxpYWJsZS5cbiAqL1xudmFyIFdpbGxTYXZlVGV4dERvY3VtZW50V2FpdFVudGlsUmVxdWVzdDtcbihmdW5jdGlvbiAoV2lsbFNhdmVUZXh0RG9jdW1lbnRXYWl0VW50aWxSZXF1ZXN0KSB7XG4gICAgV2lsbFNhdmVUZXh0RG9jdW1lbnRXYWl0VW50aWxSZXF1ZXN0Lm1ldGhvZCA9ICd0ZXh0RG9jdW1lbnQvd2lsbFNhdmVXYWl0VW50aWwnO1xuICAgIFdpbGxTYXZlVGV4dERvY3VtZW50V2FpdFVudGlsUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIFdpbGxTYXZlVGV4dERvY3VtZW50V2FpdFVudGlsUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShXaWxsU2F2ZVRleHREb2N1bWVudFdhaXRVbnRpbFJlcXVlc3QubWV0aG9kKTtcbn0pKFdpbGxTYXZlVGV4dERvY3VtZW50V2FpdFVudGlsUmVxdWVzdCA9IGV4cG9ydHMuV2lsbFNhdmVUZXh0RG9jdW1lbnRXYWl0VW50aWxSZXF1ZXN0IHx8IChleHBvcnRzLldpbGxTYXZlVGV4dERvY3VtZW50V2FpdFVudGlsUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIFRoZSB3YXRjaGVkIGZpbGVzIG5vdGlmaWNhdGlvbiBpcyBzZW50IGZyb20gdGhlIGNsaWVudCB0byB0aGUgc2VydmVyIHdoZW5cbiAqIHRoZSBjbGllbnQgZGV0ZWN0cyBjaGFuZ2VzIHRvIGZpbGUgd2F0Y2hlZCBieSB0aGUgbGFuZ3VhZ2UgY2xpZW50LlxuICovXG52YXIgRGlkQ2hhbmdlV2F0Y2hlZEZpbGVzTm90aWZpY2F0aW9uO1xuKGZ1bmN0aW9uIChEaWRDaGFuZ2VXYXRjaGVkRmlsZXNOb3RpZmljYXRpb24pIHtcbiAgICBEaWRDaGFuZ2VXYXRjaGVkRmlsZXNOb3RpZmljYXRpb24ubWV0aG9kID0gJ3dvcmtzcGFjZS9kaWRDaGFuZ2VXYXRjaGVkRmlsZXMnO1xuICAgIERpZENoYW5nZVdhdGNoZWRGaWxlc05vdGlmaWNhdGlvbi5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIERpZENoYW5nZVdhdGNoZWRGaWxlc05vdGlmaWNhdGlvbi50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xOb3RpZmljYXRpb25UeXBlKERpZENoYW5nZVdhdGNoZWRGaWxlc05vdGlmaWNhdGlvbi5tZXRob2QpO1xufSkoRGlkQ2hhbmdlV2F0Y2hlZEZpbGVzTm90aWZpY2F0aW9uID0gZXhwb3J0cy5EaWRDaGFuZ2VXYXRjaGVkRmlsZXNOb3RpZmljYXRpb24gfHwgKGV4cG9ydHMuRGlkQ2hhbmdlV2F0Y2hlZEZpbGVzTm90aWZpY2F0aW9uID0ge30pKTtcbi8qKlxuICogVGhlIGZpbGUgZXZlbnQgdHlwZVxuICovXG52YXIgRmlsZUNoYW5nZVR5cGU7XG4oZnVuY3Rpb24gKEZpbGVDaGFuZ2VUeXBlKSB7XG4gICAgLyoqXG4gICAgICogVGhlIGZpbGUgZ290IGNyZWF0ZWQuXG4gICAgICovXG4gICAgRmlsZUNoYW5nZVR5cGUuQ3JlYXRlZCA9IDE7XG4gICAgLyoqXG4gICAgICogVGhlIGZpbGUgZ290IGNoYW5nZWQuXG4gICAgICovXG4gICAgRmlsZUNoYW5nZVR5cGUuQ2hhbmdlZCA9IDI7XG4gICAgLyoqXG4gICAgICogVGhlIGZpbGUgZ290IGRlbGV0ZWQuXG4gICAgICovXG4gICAgRmlsZUNoYW5nZVR5cGUuRGVsZXRlZCA9IDM7XG59KShGaWxlQ2hhbmdlVHlwZSA9IGV4cG9ydHMuRmlsZUNoYW5nZVR5cGUgfHwgKGV4cG9ydHMuRmlsZUNoYW5nZVR5cGUgPSB7fSkpO1xudmFyIFJlbGF0aXZlUGF0dGVybjtcbihmdW5jdGlvbiAoUmVsYXRpdmVQYXR0ZXJuKSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgKHZzY29kZV9sYW5ndWFnZXNlcnZlcl90eXBlc18xLlVSSS5pcyhjYW5kaWRhdGUuYmFzZVVyaSkgfHwgdnNjb2RlX2xhbmd1YWdlc2VydmVyX3R5cGVzXzEuV29ya3NwYWNlRm9sZGVyLmlzKGNhbmRpZGF0ZS5iYXNlVXJpKSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS5wYXR0ZXJuKTtcbiAgICB9XG4gICAgUmVsYXRpdmVQYXR0ZXJuLmlzID0gaXM7XG59KShSZWxhdGl2ZVBhdHRlcm4gPSBleHBvcnRzLlJlbGF0aXZlUGF0dGVybiB8fCAoZXhwb3J0cy5SZWxhdGl2ZVBhdHRlcm4gPSB7fSkpO1xudmFyIFdhdGNoS2luZDtcbihmdW5jdGlvbiAoV2F0Y2hLaW5kKSB7XG4gICAgLyoqXG4gICAgICogSW50ZXJlc3RlZCBpbiBjcmVhdGUgZXZlbnRzLlxuICAgICAqL1xuICAgIFdhdGNoS2luZC5DcmVhdGUgPSAxO1xuICAgIC8qKlxuICAgICAqIEludGVyZXN0ZWQgaW4gY2hhbmdlIGV2ZW50c1xuICAgICAqL1xuICAgIFdhdGNoS2luZC5DaGFuZ2UgPSAyO1xuICAgIC8qKlxuICAgICAqIEludGVyZXN0ZWQgaW4gZGVsZXRlIGV2ZW50c1xuICAgICAqL1xuICAgIFdhdGNoS2luZC5EZWxldGUgPSA0O1xufSkoV2F0Y2hLaW5kID0gZXhwb3J0cy5XYXRjaEtpbmQgfHwgKGV4cG9ydHMuV2F0Y2hLaW5kID0ge30pKTtcbi8qKlxuICogRGlhZ25vc3RpY3Mgbm90aWZpY2F0aW9uIGFyZSBzZW50IGZyb20gdGhlIHNlcnZlciB0byB0aGUgY2xpZW50IHRvIHNpZ25hbFxuICogcmVzdWx0cyBvZiB2YWxpZGF0aW9uIHJ1bnMuXG4gKi9cbnZhciBQdWJsaXNoRGlhZ25vc3RpY3NOb3RpZmljYXRpb247XG4oZnVuY3Rpb24gKFB1Ymxpc2hEaWFnbm9zdGljc05vdGlmaWNhdGlvbikge1xuICAgIFB1Ymxpc2hEaWFnbm9zdGljc05vdGlmaWNhdGlvbi5tZXRob2QgPSAndGV4dERvY3VtZW50L3B1Ymxpc2hEaWFnbm9zdGljcyc7XG4gICAgUHVibGlzaERpYWdub3N0aWNzTm90aWZpY2F0aW9uLm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uc2VydmVyVG9DbGllbnQ7XG4gICAgUHVibGlzaERpYWdub3N0aWNzTm90aWZpY2F0aW9uLnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbE5vdGlmaWNhdGlvblR5cGUoUHVibGlzaERpYWdub3N0aWNzTm90aWZpY2F0aW9uLm1ldGhvZCk7XG59KShQdWJsaXNoRGlhZ25vc3RpY3NOb3RpZmljYXRpb24gPSBleHBvcnRzLlB1Ymxpc2hEaWFnbm9zdGljc05vdGlmaWNhdGlvbiB8fCAoZXhwb3J0cy5QdWJsaXNoRGlhZ25vc3RpY3NOb3RpZmljYXRpb24gPSB7fSkpO1xuLyoqXG4gKiBIb3cgYSBjb21wbGV0aW9uIHdhcyB0cmlnZ2VyZWRcbiAqL1xudmFyIENvbXBsZXRpb25UcmlnZ2VyS2luZDtcbihmdW5jdGlvbiAoQ29tcGxldGlvblRyaWdnZXJLaW5kKSB7XG4gICAgLyoqXG4gICAgICogQ29tcGxldGlvbiB3YXMgdHJpZ2dlcmVkIGJ5IHR5cGluZyBhbiBpZGVudGlmaWVyICgyNHg3IGNvZGVcbiAgICAgKiBjb21wbGV0ZSksIG1hbnVhbCBpbnZvY2F0aW9uIChlLmcgQ3RybCtTcGFjZSkgb3IgdmlhIEFQSS5cbiAgICAgKi9cbiAgICBDb21wbGV0aW9uVHJpZ2dlcktpbmQuSW52b2tlZCA9IDE7XG4gICAgLyoqXG4gICAgICogQ29tcGxldGlvbiB3YXMgdHJpZ2dlcmVkIGJ5IGEgdHJpZ2dlciBjaGFyYWN0ZXIgc3BlY2lmaWVkIGJ5XG4gICAgICogdGhlIGB0cmlnZ2VyQ2hhcmFjdGVyc2AgcHJvcGVydGllcyBvZiB0aGUgYENvbXBsZXRpb25SZWdpc3RyYXRpb25PcHRpb25zYC5cbiAgICAgKi9cbiAgICBDb21wbGV0aW9uVHJpZ2dlcktpbmQuVHJpZ2dlckNoYXJhY3RlciA9IDI7XG4gICAgLyoqXG4gICAgICogQ29tcGxldGlvbiB3YXMgcmUtdHJpZ2dlcmVkIGFzIGN1cnJlbnQgY29tcGxldGlvbiBsaXN0IGlzIGluY29tcGxldGVcbiAgICAgKi9cbiAgICBDb21wbGV0aW9uVHJpZ2dlcktpbmQuVHJpZ2dlckZvckluY29tcGxldGVDb21wbGV0aW9ucyA9IDM7XG59KShDb21wbGV0aW9uVHJpZ2dlcktpbmQgPSBleHBvcnRzLkNvbXBsZXRpb25UcmlnZ2VyS2luZCB8fCAoZXhwb3J0cy5Db21wbGV0aW9uVHJpZ2dlcktpbmQgPSB7fSkpO1xuLyoqXG4gKiBSZXF1ZXN0IHRvIHJlcXVlc3QgY29tcGxldGlvbiBhdCBhIGdpdmVuIHRleHQgZG9jdW1lbnQgcG9zaXRpb24uIFRoZSByZXF1ZXN0J3NcbiAqIHBhcmFtZXRlciBpcyBvZiB0eXBlIHtAbGluayBUZXh0RG9jdW1lbnRQb3NpdGlvbn0gdGhlIHJlc3BvbnNlXG4gKiBpcyBvZiB0eXBlIHtAbGluayBDb21wbGV0aW9uSXRlbSBDb21wbGV0aW9uSXRlbVtdfSBvciB7QGxpbmsgQ29tcGxldGlvbkxpc3R9XG4gKiBvciBhIFRoZW5hYmxlIHRoYXQgcmVzb2x2ZXMgdG8gc3VjaC5cbiAqXG4gKiBUaGUgcmVxdWVzdCBjYW4gZGVsYXkgdGhlIGNvbXB1dGF0aW9uIG9mIHRoZSB7QGxpbmsgQ29tcGxldGlvbkl0ZW0uZGV0YWlsIGBkZXRhaWxgfVxuICogYW5kIHtAbGluayBDb21wbGV0aW9uSXRlbS5kb2N1bWVudGF0aW9uIGBkb2N1bWVudGF0aW9uYH0gcHJvcGVydGllcyB0byB0aGUgYGNvbXBsZXRpb25JdGVtL3Jlc29sdmVgXG4gKiByZXF1ZXN0LiBIb3dldmVyLCBwcm9wZXJ0aWVzIHRoYXQgYXJlIG5lZWRlZCBmb3IgdGhlIGluaXRpYWwgc29ydGluZyBhbmQgZmlsdGVyaW5nLCBsaWtlIGBzb3J0VGV4dGAsXG4gKiBgZmlsdGVyVGV4dGAsIGBpbnNlcnRUZXh0YCwgYW5kIGB0ZXh0RWRpdGAsIG11c3Qgbm90IGJlIGNoYW5nZWQgZHVyaW5nIHJlc29sdmUuXG4gKi9cbnZhciBDb21wbGV0aW9uUmVxdWVzdDtcbihmdW5jdGlvbiAoQ29tcGxldGlvblJlcXVlc3QpIHtcbiAgICBDb21wbGV0aW9uUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L2NvbXBsZXRpb24nO1xuICAgIENvbXBsZXRpb25SZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgQ29tcGxldGlvblJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoQ29tcGxldGlvblJlcXVlc3QubWV0aG9kKTtcbn0pKENvbXBsZXRpb25SZXF1ZXN0ID0gZXhwb3J0cy5Db21wbGV0aW9uUmVxdWVzdCB8fCAoZXhwb3J0cy5Db21wbGV0aW9uUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIFJlcXVlc3QgdG8gcmVzb2x2ZSBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIGZvciBhIGdpdmVuIGNvbXBsZXRpb24gaXRlbS5UaGUgcmVxdWVzdCdzXG4gKiBwYXJhbWV0ZXIgaXMgb2YgdHlwZSB7QGxpbmsgQ29tcGxldGlvbkl0ZW19IHRoZSByZXNwb25zZVxuICogaXMgb2YgdHlwZSB7QGxpbmsgQ29tcGxldGlvbkl0ZW19IG9yIGEgVGhlbmFibGUgdGhhdCByZXNvbHZlcyB0byBzdWNoLlxuICovXG52YXIgQ29tcGxldGlvblJlc29sdmVSZXF1ZXN0O1xuKGZ1bmN0aW9uIChDb21wbGV0aW9uUmVzb2x2ZVJlcXVlc3QpIHtcbiAgICBDb21wbGV0aW9uUmVzb2x2ZVJlcXVlc3QubWV0aG9kID0gJ2NvbXBsZXRpb25JdGVtL3Jlc29sdmUnO1xuICAgIENvbXBsZXRpb25SZXNvbHZlUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIENvbXBsZXRpb25SZXNvbHZlUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShDb21wbGV0aW9uUmVzb2x2ZVJlcXVlc3QubWV0aG9kKTtcbn0pKENvbXBsZXRpb25SZXNvbHZlUmVxdWVzdCA9IGV4cG9ydHMuQ29tcGxldGlvblJlc29sdmVSZXF1ZXN0IHx8IChleHBvcnRzLkNvbXBsZXRpb25SZXNvbHZlUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIFJlcXVlc3QgdG8gcmVxdWVzdCBob3ZlciBpbmZvcm1hdGlvbiBhdCBhIGdpdmVuIHRleHQgZG9jdW1lbnQgcG9zaXRpb24uIFRoZSByZXF1ZXN0J3NcbiAqIHBhcmFtZXRlciBpcyBvZiB0eXBlIHtAbGluayBUZXh0RG9jdW1lbnRQb3NpdGlvbn0gdGhlIHJlc3BvbnNlIGlzIG9mXG4gKiB0eXBlIHtAbGluayBIb3Zlcn0gb3IgYSBUaGVuYWJsZSB0aGF0IHJlc29sdmVzIHRvIHN1Y2guXG4gKi9cbnZhciBIb3ZlclJlcXVlc3Q7XG4oZnVuY3Rpb24gKEhvdmVyUmVxdWVzdCkge1xuICAgIEhvdmVyUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L2hvdmVyJztcbiAgICBIb3ZlclJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBIb3ZlclJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoSG92ZXJSZXF1ZXN0Lm1ldGhvZCk7XG59KShIb3ZlclJlcXVlc3QgPSBleHBvcnRzLkhvdmVyUmVxdWVzdCB8fCAoZXhwb3J0cy5Ib3ZlclJlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBIb3cgYSBzaWduYXR1cmUgaGVscCB3YXMgdHJpZ2dlcmVkLlxuICpcbiAqIEBzaW5jZSAzLjE1LjBcbiAqL1xudmFyIFNpZ25hdHVyZUhlbHBUcmlnZ2VyS2luZDtcbihmdW5jdGlvbiAoU2lnbmF0dXJlSGVscFRyaWdnZXJLaW5kKSB7XG4gICAgLyoqXG4gICAgICogU2lnbmF0dXJlIGhlbHAgd2FzIGludm9rZWQgbWFudWFsbHkgYnkgdGhlIHVzZXIgb3IgYnkgYSBjb21tYW5kLlxuICAgICAqL1xuICAgIFNpZ25hdHVyZUhlbHBUcmlnZ2VyS2luZC5JbnZva2VkID0gMTtcbiAgICAvKipcbiAgICAgKiBTaWduYXR1cmUgaGVscCB3YXMgdHJpZ2dlcmVkIGJ5IGEgdHJpZ2dlciBjaGFyYWN0ZXIuXG4gICAgICovXG4gICAgU2lnbmF0dXJlSGVscFRyaWdnZXJLaW5kLlRyaWdnZXJDaGFyYWN0ZXIgPSAyO1xuICAgIC8qKlxuICAgICAqIFNpZ25hdHVyZSBoZWxwIHdhcyB0cmlnZ2VyZWQgYnkgdGhlIGN1cnNvciBtb3Zpbmcgb3IgYnkgdGhlIGRvY3VtZW50IGNvbnRlbnQgY2hhbmdpbmcuXG4gICAgICovXG4gICAgU2lnbmF0dXJlSGVscFRyaWdnZXJLaW5kLkNvbnRlbnRDaGFuZ2UgPSAzO1xufSkoU2lnbmF0dXJlSGVscFRyaWdnZXJLaW5kID0gZXhwb3J0cy5TaWduYXR1cmVIZWxwVHJpZ2dlcktpbmQgfHwgKGV4cG9ydHMuU2lnbmF0dXJlSGVscFRyaWdnZXJLaW5kID0ge30pKTtcbnZhciBTaWduYXR1cmVIZWxwUmVxdWVzdDtcbihmdW5jdGlvbiAoU2lnbmF0dXJlSGVscFJlcXVlc3QpIHtcbiAgICBTaWduYXR1cmVIZWxwUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L3NpZ25hdHVyZUhlbHAnO1xuICAgIFNpZ25hdHVyZUhlbHBSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgU2lnbmF0dXJlSGVscFJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoU2lnbmF0dXJlSGVscFJlcXVlc3QubWV0aG9kKTtcbn0pKFNpZ25hdHVyZUhlbHBSZXF1ZXN0ID0gZXhwb3J0cy5TaWduYXR1cmVIZWxwUmVxdWVzdCB8fCAoZXhwb3J0cy5TaWduYXR1cmVIZWxwUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIEEgcmVxdWVzdCB0byByZXNvbHZlIHRoZSBkZWZpbml0aW9uIGxvY2F0aW9uIG9mIGEgc3ltYm9sIGF0IGEgZ2l2ZW4gdGV4dFxuICogZG9jdW1lbnQgcG9zaXRpb24uIFRoZSByZXF1ZXN0J3MgcGFyYW1ldGVyIGlzIG9mIHR5cGUgW1RleHREb2N1bWVudFBvc2l0aW9uXVxuICogKCNUZXh0RG9jdW1lbnRQb3NpdGlvbikgdGhlIHJlc3BvbnNlIGlzIG9mIGVpdGhlciB0eXBlIHtAbGluayBEZWZpbml0aW9ufVxuICogb3IgYSB0eXBlZCBhcnJheSBvZiB7QGxpbmsgRGVmaW5pdGlvbkxpbmt9IG9yIGEgVGhlbmFibGUgdGhhdCByZXNvbHZlc1xuICogdG8gc3VjaC5cbiAqL1xudmFyIERlZmluaXRpb25SZXF1ZXN0O1xuKGZ1bmN0aW9uIChEZWZpbml0aW9uUmVxdWVzdCkge1xuICAgIERlZmluaXRpb25SZXF1ZXN0Lm1ldGhvZCA9ICd0ZXh0RG9jdW1lbnQvZGVmaW5pdGlvbic7XG4gICAgRGVmaW5pdGlvblJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBEZWZpbml0aW9uUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShEZWZpbml0aW9uUmVxdWVzdC5tZXRob2QpO1xufSkoRGVmaW5pdGlvblJlcXVlc3QgPSBleHBvcnRzLkRlZmluaXRpb25SZXF1ZXN0IHx8IChleHBvcnRzLkRlZmluaXRpb25SZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogQSByZXF1ZXN0IHRvIHJlc29sdmUgcHJvamVjdC13aWRlIHJlZmVyZW5jZXMgZm9yIHRoZSBzeW1ib2wgZGVub3RlZFxuICogYnkgdGhlIGdpdmVuIHRleHQgZG9jdW1lbnQgcG9zaXRpb24uIFRoZSByZXF1ZXN0J3MgcGFyYW1ldGVyIGlzIG9mXG4gKiB0eXBlIHtAbGluayBSZWZlcmVuY2VQYXJhbXN9IHRoZSByZXNwb25zZSBpcyBvZiB0eXBlXG4gKiB7QGxpbmsgTG9jYXRpb24gTG9jYXRpb25bXX0gb3IgYSBUaGVuYWJsZSB0aGF0IHJlc29sdmVzIHRvIHN1Y2guXG4gKi9cbnZhciBSZWZlcmVuY2VzUmVxdWVzdDtcbihmdW5jdGlvbiAoUmVmZXJlbmNlc1JlcXVlc3QpIHtcbiAgICBSZWZlcmVuY2VzUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L3JlZmVyZW5jZXMnO1xuICAgIFJlZmVyZW5jZXNSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgUmVmZXJlbmNlc1JlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoUmVmZXJlbmNlc1JlcXVlc3QubWV0aG9kKTtcbn0pKFJlZmVyZW5jZXNSZXF1ZXN0ID0gZXhwb3J0cy5SZWZlcmVuY2VzUmVxdWVzdCB8fCAoZXhwb3J0cy5SZWZlcmVuY2VzUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIFJlcXVlc3QgdG8gcmVzb2x2ZSBhIHtAbGluayBEb2N1bWVudEhpZ2hsaWdodH0gZm9yIGEgZ2l2ZW5cbiAqIHRleHQgZG9jdW1lbnQgcG9zaXRpb24uIFRoZSByZXF1ZXN0J3MgcGFyYW1ldGVyIGlzIG9mIHR5cGUgW1RleHREb2N1bWVudFBvc2l0aW9uXVxuICogKCNUZXh0RG9jdW1lbnRQb3NpdGlvbikgdGhlIHJlcXVlc3QgcmVzcG9uc2UgaXMgb2YgdHlwZSBbRG9jdW1lbnRIaWdobGlnaHRbXV1cbiAqICgjRG9jdW1lbnRIaWdobGlnaHQpIG9yIGEgVGhlbmFibGUgdGhhdCByZXNvbHZlcyB0byBzdWNoLlxuICovXG52YXIgRG9jdW1lbnRIaWdobGlnaHRSZXF1ZXN0O1xuKGZ1bmN0aW9uIChEb2N1bWVudEhpZ2hsaWdodFJlcXVlc3QpIHtcbiAgICBEb2N1bWVudEhpZ2hsaWdodFJlcXVlc3QubWV0aG9kID0gJ3RleHREb2N1bWVudC9kb2N1bWVudEhpZ2hsaWdodCc7XG4gICAgRG9jdW1lbnRIaWdobGlnaHRSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgRG9jdW1lbnRIaWdobGlnaHRSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKERvY3VtZW50SGlnaGxpZ2h0UmVxdWVzdC5tZXRob2QpO1xufSkoRG9jdW1lbnRIaWdobGlnaHRSZXF1ZXN0ID0gZXhwb3J0cy5Eb2N1bWVudEhpZ2hsaWdodFJlcXVlc3QgfHwgKGV4cG9ydHMuRG9jdW1lbnRIaWdobGlnaHRSZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogQSByZXF1ZXN0IHRvIGxpc3QgYWxsIHN5bWJvbHMgZm91bmQgaW4gYSBnaXZlbiB0ZXh0IGRvY3VtZW50LiBUaGUgcmVxdWVzdCdzXG4gKiBwYXJhbWV0ZXIgaXMgb2YgdHlwZSB7QGxpbmsgVGV4dERvY3VtZW50SWRlbnRpZmllcn0gdGhlXG4gKiByZXNwb25zZSBpcyBvZiB0eXBlIHtAbGluayBTeW1ib2xJbmZvcm1hdGlvbiBTeW1ib2xJbmZvcm1hdGlvbltdfSBvciBhIFRoZW5hYmxlXG4gKiB0aGF0IHJlc29sdmVzIHRvIHN1Y2guXG4gKi9cbnZhciBEb2N1bWVudFN5bWJvbFJlcXVlc3Q7XG4oZnVuY3Rpb24gKERvY3VtZW50U3ltYm9sUmVxdWVzdCkge1xuICAgIERvY3VtZW50U3ltYm9sUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L2RvY3VtZW50U3ltYm9sJztcbiAgICBEb2N1bWVudFN5bWJvbFJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBEb2N1bWVudFN5bWJvbFJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoRG9jdW1lbnRTeW1ib2xSZXF1ZXN0Lm1ldGhvZCk7XG59KShEb2N1bWVudFN5bWJvbFJlcXVlc3QgPSBleHBvcnRzLkRvY3VtZW50U3ltYm9sUmVxdWVzdCB8fCAoZXhwb3J0cy5Eb2N1bWVudFN5bWJvbFJlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBBIHJlcXVlc3QgdG8gcHJvdmlkZSBjb21tYW5kcyBmb3IgdGhlIGdpdmVuIHRleHQgZG9jdW1lbnQgYW5kIHJhbmdlLlxuICovXG52YXIgQ29kZUFjdGlvblJlcXVlc3Q7XG4oZnVuY3Rpb24gKENvZGVBY3Rpb25SZXF1ZXN0KSB7XG4gICAgQ29kZUFjdGlvblJlcXVlc3QubWV0aG9kID0gJ3RleHREb2N1bWVudC9jb2RlQWN0aW9uJztcbiAgICBDb2RlQWN0aW9uUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIENvZGVBY3Rpb25SZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKENvZGVBY3Rpb25SZXF1ZXN0Lm1ldGhvZCk7XG59KShDb2RlQWN0aW9uUmVxdWVzdCA9IGV4cG9ydHMuQ29kZUFjdGlvblJlcXVlc3QgfHwgKGV4cG9ydHMuQ29kZUFjdGlvblJlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBSZXF1ZXN0IHRvIHJlc29sdmUgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBmb3IgYSBnaXZlbiBjb2RlIGFjdGlvbi5UaGUgcmVxdWVzdCdzXG4gKiBwYXJhbWV0ZXIgaXMgb2YgdHlwZSB7QGxpbmsgQ29kZUFjdGlvbn0gdGhlIHJlc3BvbnNlXG4gKiBpcyBvZiB0eXBlIHtAbGluayBDb2RlQWN0aW9ufSBvciBhIFRoZW5hYmxlIHRoYXQgcmVzb2x2ZXMgdG8gc3VjaC5cbiAqL1xudmFyIENvZGVBY3Rpb25SZXNvbHZlUmVxdWVzdDtcbihmdW5jdGlvbiAoQ29kZUFjdGlvblJlc29sdmVSZXF1ZXN0KSB7XG4gICAgQ29kZUFjdGlvblJlc29sdmVSZXF1ZXN0Lm1ldGhvZCA9ICdjb2RlQWN0aW9uL3Jlc29sdmUnO1xuICAgIENvZGVBY3Rpb25SZXNvbHZlUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIENvZGVBY3Rpb25SZXNvbHZlUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShDb2RlQWN0aW9uUmVzb2x2ZVJlcXVlc3QubWV0aG9kKTtcbn0pKENvZGVBY3Rpb25SZXNvbHZlUmVxdWVzdCA9IGV4cG9ydHMuQ29kZUFjdGlvblJlc29sdmVSZXF1ZXN0IHx8IChleHBvcnRzLkNvZGVBY3Rpb25SZXNvbHZlUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIEEgcmVxdWVzdCB0byBsaXN0IHByb2plY3Qtd2lkZSBzeW1ib2xzIG1hdGNoaW5nIHRoZSBxdWVyeSBzdHJpbmcgZ2l2ZW5cbiAqIGJ5IHRoZSB7QGxpbmsgV29ya3NwYWNlU3ltYm9sUGFyYW1zfS4gVGhlIHJlc3BvbnNlIGlzXG4gKiBvZiB0eXBlIHtAbGluayBTeW1ib2xJbmZvcm1hdGlvbiBTeW1ib2xJbmZvcm1hdGlvbltdfSBvciBhIFRoZW5hYmxlIHRoYXRcbiAqIHJlc29sdmVzIHRvIHN1Y2guXG4gKlxuICogQHNpbmNlIDMuMTcuMCAtIHN1cHBvcnQgZm9yIFdvcmtzcGFjZVN5bWJvbCBpbiB0aGUgcmV0dXJuZWQgZGF0YS4gQ2xpZW50c1xuICogIG5lZWQgdG8gYWR2ZXJ0aXNlIHN1cHBvcnQgZm9yIFdvcmtzcGFjZVN5bWJvbHMgdmlhIHRoZSBjbGllbnQgY2FwYWJpbGl0eVxuICogIGB3b3Jrc3BhY2Uuc3ltYm9sLnJlc29sdmVTdXBwb3J0YC5cbiAqXG4gKi9cbnZhciBXb3Jrc3BhY2VTeW1ib2xSZXF1ZXN0O1xuKGZ1bmN0aW9uIChXb3Jrc3BhY2VTeW1ib2xSZXF1ZXN0KSB7XG4gICAgV29ya3NwYWNlU3ltYm9sUmVxdWVzdC5tZXRob2QgPSAnd29ya3NwYWNlL3N5bWJvbCc7XG4gICAgV29ya3NwYWNlU3ltYm9sUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIFdvcmtzcGFjZVN5bWJvbFJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoV29ya3NwYWNlU3ltYm9sUmVxdWVzdC5tZXRob2QpO1xufSkoV29ya3NwYWNlU3ltYm9sUmVxdWVzdCA9IGV4cG9ydHMuV29ya3NwYWNlU3ltYm9sUmVxdWVzdCB8fCAoZXhwb3J0cy5Xb3Jrc3BhY2VTeW1ib2xSZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogQSByZXF1ZXN0IHRvIHJlc29sdmUgdGhlIHJhbmdlIGluc2lkZSB0aGUgd29ya3NwYWNlXG4gKiBzeW1ib2wncyBsb2NhdGlvbi5cbiAqXG4gKiBAc2luY2UgMy4xNy4wXG4gKi9cbnZhciBXb3Jrc3BhY2VTeW1ib2xSZXNvbHZlUmVxdWVzdDtcbihmdW5jdGlvbiAoV29ya3NwYWNlU3ltYm9sUmVzb2x2ZVJlcXVlc3QpIHtcbiAgICBXb3Jrc3BhY2VTeW1ib2xSZXNvbHZlUmVxdWVzdC5tZXRob2QgPSAnd29ya3NwYWNlU3ltYm9sL3Jlc29sdmUnO1xuICAgIFdvcmtzcGFjZVN5bWJvbFJlc29sdmVSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgV29ya3NwYWNlU3ltYm9sUmVzb2x2ZVJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoV29ya3NwYWNlU3ltYm9sUmVzb2x2ZVJlcXVlc3QubWV0aG9kKTtcbn0pKFdvcmtzcGFjZVN5bWJvbFJlc29sdmVSZXF1ZXN0ID0gZXhwb3J0cy5Xb3Jrc3BhY2VTeW1ib2xSZXNvbHZlUmVxdWVzdCB8fCAoZXhwb3J0cy5Xb3Jrc3BhY2VTeW1ib2xSZXNvbHZlUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIEEgcmVxdWVzdCB0byBwcm92aWRlIGNvZGUgbGVucyBmb3IgdGhlIGdpdmVuIHRleHQgZG9jdW1lbnQuXG4gKi9cbnZhciBDb2RlTGVuc1JlcXVlc3Q7XG4oZnVuY3Rpb24gKENvZGVMZW5zUmVxdWVzdCkge1xuICAgIENvZGVMZW5zUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L2NvZGVMZW5zJztcbiAgICBDb2RlTGVuc1JlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBDb2RlTGVuc1JlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoQ29kZUxlbnNSZXF1ZXN0Lm1ldGhvZCk7XG59KShDb2RlTGVuc1JlcXVlc3QgPSBleHBvcnRzLkNvZGVMZW5zUmVxdWVzdCB8fCAoZXhwb3J0cy5Db2RlTGVuc1JlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBBIHJlcXVlc3QgdG8gcmVzb2x2ZSBhIGNvbW1hbmQgZm9yIGEgZ2l2ZW4gY29kZSBsZW5zLlxuICovXG52YXIgQ29kZUxlbnNSZXNvbHZlUmVxdWVzdDtcbihmdW5jdGlvbiAoQ29kZUxlbnNSZXNvbHZlUmVxdWVzdCkge1xuICAgIENvZGVMZW5zUmVzb2x2ZVJlcXVlc3QubWV0aG9kID0gJ2NvZGVMZW5zL3Jlc29sdmUnO1xuICAgIENvZGVMZW5zUmVzb2x2ZVJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBDb2RlTGVuc1Jlc29sdmVSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKENvZGVMZW5zUmVzb2x2ZVJlcXVlc3QubWV0aG9kKTtcbn0pKENvZGVMZW5zUmVzb2x2ZVJlcXVlc3QgPSBleHBvcnRzLkNvZGVMZW5zUmVzb2x2ZVJlcXVlc3QgfHwgKGV4cG9ydHMuQ29kZUxlbnNSZXNvbHZlUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIEEgcmVxdWVzdCB0byByZWZyZXNoIGFsbCBjb2RlIGFjdGlvbnNcbiAqXG4gKiBAc2luY2UgMy4xNi4wXG4gKi9cbnZhciBDb2RlTGVuc1JlZnJlc2hSZXF1ZXN0O1xuKGZ1bmN0aW9uIChDb2RlTGVuc1JlZnJlc2hSZXF1ZXN0KSB7XG4gICAgQ29kZUxlbnNSZWZyZXNoUmVxdWVzdC5tZXRob2QgPSBgd29ya3NwYWNlL2NvZGVMZW5zL3JlZnJlc2hgO1xuICAgIENvZGVMZW5zUmVmcmVzaFJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5zZXJ2ZXJUb0NsaWVudDtcbiAgICBDb2RlTGVuc1JlZnJlc2hSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlMChDb2RlTGVuc1JlZnJlc2hSZXF1ZXN0Lm1ldGhvZCk7XG59KShDb2RlTGVuc1JlZnJlc2hSZXF1ZXN0ID0gZXhwb3J0cy5Db2RlTGVuc1JlZnJlc2hSZXF1ZXN0IHx8IChleHBvcnRzLkNvZGVMZW5zUmVmcmVzaFJlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBBIHJlcXVlc3QgdG8gcHJvdmlkZSBkb2N1bWVudCBsaW5rc1xuICovXG52YXIgRG9jdW1lbnRMaW5rUmVxdWVzdDtcbihmdW5jdGlvbiAoRG9jdW1lbnRMaW5rUmVxdWVzdCkge1xuICAgIERvY3VtZW50TGlua1JlcXVlc3QubWV0aG9kID0gJ3RleHREb2N1bWVudC9kb2N1bWVudExpbmsnO1xuICAgIERvY3VtZW50TGlua1JlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBEb2N1bWVudExpbmtSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKERvY3VtZW50TGlua1JlcXVlc3QubWV0aG9kKTtcbn0pKERvY3VtZW50TGlua1JlcXVlc3QgPSBleHBvcnRzLkRvY3VtZW50TGlua1JlcXVlc3QgfHwgKGV4cG9ydHMuRG9jdW1lbnRMaW5rUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIFJlcXVlc3QgdG8gcmVzb2x2ZSBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIGZvciBhIGdpdmVuIGRvY3VtZW50IGxpbmsuIFRoZSByZXF1ZXN0J3NcbiAqIHBhcmFtZXRlciBpcyBvZiB0eXBlIHtAbGluayBEb2N1bWVudExpbmt9IHRoZSByZXNwb25zZVxuICogaXMgb2YgdHlwZSB7QGxpbmsgRG9jdW1lbnRMaW5rfSBvciBhIFRoZW5hYmxlIHRoYXQgcmVzb2x2ZXMgdG8gc3VjaC5cbiAqL1xudmFyIERvY3VtZW50TGlua1Jlc29sdmVSZXF1ZXN0O1xuKGZ1bmN0aW9uIChEb2N1bWVudExpbmtSZXNvbHZlUmVxdWVzdCkge1xuICAgIERvY3VtZW50TGlua1Jlc29sdmVSZXF1ZXN0Lm1ldGhvZCA9ICdkb2N1bWVudExpbmsvcmVzb2x2ZSc7XG4gICAgRG9jdW1lbnRMaW5rUmVzb2x2ZVJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBEb2N1bWVudExpbmtSZXNvbHZlUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShEb2N1bWVudExpbmtSZXNvbHZlUmVxdWVzdC5tZXRob2QpO1xufSkoRG9jdW1lbnRMaW5rUmVzb2x2ZVJlcXVlc3QgPSBleHBvcnRzLkRvY3VtZW50TGlua1Jlc29sdmVSZXF1ZXN0IHx8IChleHBvcnRzLkRvY3VtZW50TGlua1Jlc29sdmVSZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogQSByZXF1ZXN0IHRvIHRvIGZvcm1hdCBhIHdob2xlIGRvY3VtZW50LlxuICovXG52YXIgRG9jdW1lbnRGb3JtYXR0aW5nUmVxdWVzdDtcbihmdW5jdGlvbiAoRG9jdW1lbnRGb3JtYXR0aW5nUmVxdWVzdCkge1xuICAgIERvY3VtZW50Rm9ybWF0dGluZ1JlcXVlc3QubWV0aG9kID0gJ3RleHREb2N1bWVudC9mb3JtYXR0aW5nJztcbiAgICBEb2N1bWVudEZvcm1hdHRpbmdSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgRG9jdW1lbnRGb3JtYXR0aW5nUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShEb2N1bWVudEZvcm1hdHRpbmdSZXF1ZXN0Lm1ldGhvZCk7XG59KShEb2N1bWVudEZvcm1hdHRpbmdSZXF1ZXN0ID0gZXhwb3J0cy5Eb2N1bWVudEZvcm1hdHRpbmdSZXF1ZXN0IHx8IChleHBvcnRzLkRvY3VtZW50Rm9ybWF0dGluZ1JlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBBIHJlcXVlc3QgdG8gdG8gZm9ybWF0IGEgcmFuZ2UgaW4gYSBkb2N1bWVudC5cbiAqL1xudmFyIERvY3VtZW50UmFuZ2VGb3JtYXR0aW5nUmVxdWVzdDtcbihmdW5jdGlvbiAoRG9jdW1lbnRSYW5nZUZvcm1hdHRpbmdSZXF1ZXN0KSB7XG4gICAgRG9jdW1lbnRSYW5nZUZvcm1hdHRpbmdSZXF1ZXN0Lm1ldGhvZCA9ICd0ZXh0RG9jdW1lbnQvcmFuZ2VGb3JtYXR0aW5nJztcbiAgICBEb2N1bWVudFJhbmdlRm9ybWF0dGluZ1JlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBEb2N1bWVudFJhbmdlRm9ybWF0dGluZ1JlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoRG9jdW1lbnRSYW5nZUZvcm1hdHRpbmdSZXF1ZXN0Lm1ldGhvZCk7XG59KShEb2N1bWVudFJhbmdlRm9ybWF0dGluZ1JlcXVlc3QgPSBleHBvcnRzLkRvY3VtZW50UmFuZ2VGb3JtYXR0aW5nUmVxdWVzdCB8fCAoZXhwb3J0cy5Eb2N1bWVudFJhbmdlRm9ybWF0dGluZ1JlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBBIHJlcXVlc3QgdG8gZm9ybWF0IGEgZG9jdW1lbnQgb24gdHlwZS5cbiAqL1xudmFyIERvY3VtZW50T25UeXBlRm9ybWF0dGluZ1JlcXVlc3Q7XG4oZnVuY3Rpb24gKERvY3VtZW50T25UeXBlRm9ybWF0dGluZ1JlcXVlc3QpIHtcbiAgICBEb2N1bWVudE9uVHlwZUZvcm1hdHRpbmdSZXF1ZXN0Lm1ldGhvZCA9ICd0ZXh0RG9jdW1lbnQvb25UeXBlRm9ybWF0dGluZyc7XG4gICAgRG9jdW1lbnRPblR5cGVGb3JtYXR0aW5nUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIERvY3VtZW50T25UeXBlRm9ybWF0dGluZ1JlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoRG9jdW1lbnRPblR5cGVGb3JtYXR0aW5nUmVxdWVzdC5tZXRob2QpO1xufSkoRG9jdW1lbnRPblR5cGVGb3JtYXR0aW5nUmVxdWVzdCA9IGV4cG9ydHMuRG9jdW1lbnRPblR5cGVGb3JtYXR0aW5nUmVxdWVzdCB8fCAoZXhwb3J0cy5Eb2N1bWVudE9uVHlwZUZvcm1hdHRpbmdSZXF1ZXN0ID0ge30pKTtcbi8vLS0tLSBSZW5hbWUgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxudmFyIFByZXBhcmVTdXBwb3J0RGVmYXVsdEJlaGF2aW9yO1xuKGZ1bmN0aW9uIChQcmVwYXJlU3VwcG9ydERlZmF1bHRCZWhhdmlvcikge1xuICAgIC8qKlxuICAgICAqIFRoZSBjbGllbnQncyBkZWZhdWx0IGJlaGF2aW9yIGlzIHRvIHNlbGVjdCB0aGUgaWRlbnRpZmllclxuICAgICAqIGFjY29yZGluZyB0aGUgdG8gbGFuZ3VhZ2UncyBzeW50YXggcnVsZS5cbiAgICAgKi9cbiAgICBQcmVwYXJlU3VwcG9ydERlZmF1bHRCZWhhdmlvci5JZGVudGlmaWVyID0gMTtcbn0pKFByZXBhcmVTdXBwb3J0RGVmYXVsdEJlaGF2aW9yID0gZXhwb3J0cy5QcmVwYXJlU3VwcG9ydERlZmF1bHRCZWhhdmlvciB8fCAoZXhwb3J0cy5QcmVwYXJlU3VwcG9ydERlZmF1bHRCZWhhdmlvciA9IHt9KSk7XG4vKipcbiAqIEEgcmVxdWVzdCB0byByZW5hbWUgYSBzeW1ib2wuXG4gKi9cbnZhciBSZW5hbWVSZXF1ZXN0O1xuKGZ1bmN0aW9uIChSZW5hbWVSZXF1ZXN0KSB7XG4gICAgUmVuYW1lUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L3JlbmFtZSc7XG4gICAgUmVuYW1lUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIFJlbmFtZVJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoUmVuYW1lUmVxdWVzdC5tZXRob2QpO1xufSkoUmVuYW1lUmVxdWVzdCA9IGV4cG9ydHMuUmVuYW1lUmVxdWVzdCB8fCAoZXhwb3J0cy5SZW5hbWVSZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogQSByZXF1ZXN0IHRvIHRlc3QgYW5kIHBlcmZvcm0gdGhlIHNldHVwIG5lY2Vzc2FyeSBmb3IgYSByZW5hbWUuXG4gKlxuICogQHNpbmNlIDMuMTYgLSBzdXBwb3J0IGZvciBkZWZhdWx0IGJlaGF2aW9yXG4gKi9cbnZhciBQcmVwYXJlUmVuYW1lUmVxdWVzdDtcbihmdW5jdGlvbiAoUHJlcGFyZVJlbmFtZVJlcXVlc3QpIHtcbiAgICBQcmVwYXJlUmVuYW1lUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L3ByZXBhcmVSZW5hbWUnO1xuICAgIFByZXBhcmVSZW5hbWVSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgUHJlcGFyZVJlbmFtZVJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoUHJlcGFyZVJlbmFtZVJlcXVlc3QubWV0aG9kKTtcbn0pKFByZXBhcmVSZW5hbWVSZXF1ZXN0ID0gZXhwb3J0cy5QcmVwYXJlUmVuYW1lUmVxdWVzdCB8fCAoZXhwb3J0cy5QcmVwYXJlUmVuYW1lUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIEEgcmVxdWVzdCBzZW5kIGZyb20gdGhlIGNsaWVudCB0byB0aGUgc2VydmVyIHRvIGV4ZWN1dGUgYSBjb21tYW5kLiBUaGUgcmVxdWVzdCBtaWdodCByZXR1cm5cbiAqIGEgd29ya3NwYWNlIGVkaXQgd2hpY2ggdGhlIGNsaWVudCB3aWxsIGFwcGx5IHRvIHRoZSB3b3Jrc3BhY2UuXG4gKi9cbnZhciBFeGVjdXRlQ29tbWFuZFJlcXVlc3Q7XG4oZnVuY3Rpb24gKEV4ZWN1dGVDb21tYW5kUmVxdWVzdCkge1xuICAgIEV4ZWN1dGVDb21tYW5kUmVxdWVzdC5tZXRob2QgPSAnd29ya3NwYWNlL2V4ZWN1dGVDb21tYW5kJztcbiAgICBFeGVjdXRlQ29tbWFuZFJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBFeGVjdXRlQ29tbWFuZFJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoRXhlY3V0ZUNvbW1hbmRSZXF1ZXN0Lm1ldGhvZCk7XG59KShFeGVjdXRlQ29tbWFuZFJlcXVlc3QgPSBleHBvcnRzLkV4ZWN1dGVDb21tYW5kUmVxdWVzdCB8fCAoZXhwb3J0cy5FeGVjdXRlQ29tbWFuZFJlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBBIHJlcXVlc3Qgc2VudCBmcm9tIHRoZSBzZXJ2ZXIgdG8gdGhlIGNsaWVudCB0byBtb2RpZmllZCBjZXJ0YWluIHJlc291cmNlcy5cbiAqL1xudmFyIEFwcGx5V29ya3NwYWNlRWRpdFJlcXVlc3Q7XG4oZnVuY3Rpb24gKEFwcGx5V29ya3NwYWNlRWRpdFJlcXVlc3QpIHtcbiAgICBBcHBseVdvcmtzcGFjZUVkaXRSZXF1ZXN0Lm1ldGhvZCA9ICd3b3Jrc3BhY2UvYXBwbHlFZGl0JztcbiAgICBBcHBseVdvcmtzcGFjZUVkaXRSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uc2VydmVyVG9DbGllbnQ7XG4gICAgQXBwbHlXb3Jrc3BhY2VFZGl0UmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZSgnd29ya3NwYWNlL2FwcGx5RWRpdCcpO1xufSkoQXBwbHlXb3Jrc3BhY2VFZGl0UmVxdWVzdCA9IGV4cG9ydHMuQXBwbHlXb3Jrc3BhY2VFZGl0UmVxdWVzdCB8fCAoZXhwb3J0cy5BcHBseVdvcmtzcGFjZUVkaXRSZXF1ZXN0ID0ge30pKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMjI0OTpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLkxpbmtlZEVkaXRpbmdSYW5nZVJlcXVlc3QgPSB2b2lkIDA7XG5jb25zdCBtZXNzYWdlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NDMxKTtcbi8qKlxuICogQSByZXF1ZXN0IHRvIHByb3ZpZGUgcmFuZ2VzIHRoYXQgY2FuIGJlIGVkaXRlZCB0b2dldGhlci5cbiAqXG4gKiBAc2luY2UgMy4xNi4wXG4gKi9cbnZhciBMaW5rZWRFZGl0aW5nUmFuZ2VSZXF1ZXN0O1xuKGZ1bmN0aW9uIChMaW5rZWRFZGl0aW5nUmFuZ2VSZXF1ZXN0KSB7XG4gICAgTGlua2VkRWRpdGluZ1JhbmdlUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L2xpbmtlZEVkaXRpbmdSYW5nZSc7XG4gICAgTGlua2VkRWRpdGluZ1JhbmdlUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIExpbmtlZEVkaXRpbmdSYW5nZVJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoTGlua2VkRWRpdGluZ1JhbmdlUmVxdWVzdC5tZXRob2QpO1xufSkoTGlua2VkRWRpdGluZ1JhbmdlUmVxdWVzdCA9IGV4cG9ydHMuTGlua2VkRWRpdGluZ1JhbmdlUmVxdWVzdCB8fCAoZXhwb3J0cy5MaW5rZWRFZGl0aW5nUmFuZ2VSZXF1ZXN0ID0ge30pKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNzY4NDpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5Nb25pa2VyUmVxdWVzdCA9IGV4cG9ydHMuTW9uaWtlcktpbmQgPSBleHBvcnRzLlVuaXF1ZW5lc3NMZXZlbCA9IHZvaWQgMDtcbmNvbnN0IG1lc3NhZ2VzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg0MzEpO1xuLyoqXG4gKiBNb25pa2VyIHVuaXF1ZW5lc3MgbGV2ZWwgdG8gZGVmaW5lIHNjb3BlIG9mIHRoZSBtb25pa2VyLlxuICpcbiAqIEBzaW5jZSAzLjE2LjBcbiAqL1xudmFyIFVuaXF1ZW5lc3NMZXZlbDtcbihmdW5jdGlvbiAoVW5pcXVlbmVzc0xldmVsKSB7XG4gICAgLyoqXG4gICAgICogVGhlIG1vbmlrZXIgaXMgb25seSB1bmlxdWUgaW5zaWRlIGEgZG9jdW1lbnRcbiAgICAgKi9cbiAgICBVbmlxdWVuZXNzTGV2ZWwuZG9jdW1lbnQgPSAnZG9jdW1lbnQnO1xuICAgIC8qKlxuICAgICAqIFRoZSBtb25pa2VyIGlzIHVuaXF1ZSBpbnNpZGUgYSBwcm9qZWN0IGZvciB3aGljaCBhIGR1bXAgZ290IGNyZWF0ZWRcbiAgICAgKi9cbiAgICBVbmlxdWVuZXNzTGV2ZWwucHJvamVjdCA9ICdwcm9qZWN0JztcbiAgICAvKipcbiAgICAgKiBUaGUgbW9uaWtlciBpcyB1bmlxdWUgaW5zaWRlIHRoZSBncm91cCB0byB3aGljaCBhIHByb2plY3QgYmVsb25nc1xuICAgICAqL1xuICAgIFVuaXF1ZW5lc3NMZXZlbC5ncm91cCA9ICdncm91cCc7XG4gICAgLyoqXG4gICAgICogVGhlIG1vbmlrZXIgaXMgdW5pcXVlIGluc2lkZSB0aGUgbW9uaWtlciBzY2hlbWUuXG4gICAgICovXG4gICAgVW5pcXVlbmVzc0xldmVsLnNjaGVtZSA9ICdzY2hlbWUnO1xuICAgIC8qKlxuICAgICAqIFRoZSBtb25pa2VyIGlzIGdsb2JhbGx5IHVuaXF1ZVxuICAgICAqL1xuICAgIFVuaXF1ZW5lc3NMZXZlbC5nbG9iYWwgPSAnZ2xvYmFsJztcbn0pKFVuaXF1ZW5lc3NMZXZlbCA9IGV4cG9ydHMuVW5pcXVlbmVzc0xldmVsIHx8IChleHBvcnRzLlVuaXF1ZW5lc3NMZXZlbCA9IHt9KSk7XG4vKipcbiAqIFRoZSBtb25pa2VyIGtpbmQuXG4gKlxuICogQHNpbmNlIDMuMTYuMFxuICovXG52YXIgTW9uaWtlcktpbmQ7XG4oZnVuY3Rpb24gKE1vbmlrZXJLaW5kKSB7XG4gICAgLyoqXG4gICAgICogVGhlIG1vbmlrZXIgcmVwcmVzZW50IGEgc3ltYm9sIHRoYXQgaXMgaW1wb3J0ZWQgaW50byBhIHByb2plY3RcbiAgICAgKi9cbiAgICBNb25pa2VyS2luZC4kaW1wb3J0ID0gJ2ltcG9ydCc7XG4gICAgLyoqXG4gICAgICogVGhlIG1vbmlrZXIgcmVwcmVzZW50cyBhIHN5bWJvbCB0aGF0IGlzIGV4cG9ydGVkIGZyb20gYSBwcm9qZWN0XG4gICAgICovXG4gICAgTW9uaWtlcktpbmQuJGV4cG9ydCA9ICdleHBvcnQnO1xuICAgIC8qKlxuICAgICAqIFRoZSBtb25pa2VyIHJlcHJlc2VudHMgYSBzeW1ib2wgdGhhdCBpcyBsb2NhbCB0byBhIHByb2plY3QgKGUuZy4gYSBsb2NhbFxuICAgICAqIHZhcmlhYmxlIG9mIGEgZnVuY3Rpb24sIGEgY2xhc3Mgbm90IHZpc2libGUgb3V0c2lkZSB0aGUgcHJvamVjdCwgLi4uKVxuICAgICAqL1xuICAgIE1vbmlrZXJLaW5kLmxvY2FsID0gJ2xvY2FsJztcbn0pKE1vbmlrZXJLaW5kID0gZXhwb3J0cy5Nb25pa2VyS2luZCB8fCAoZXhwb3J0cy5Nb25pa2VyS2luZCA9IHt9KSk7XG4vKipcbiAqIEEgcmVxdWVzdCB0byBnZXQgdGhlIG1vbmlrZXIgb2YgYSBzeW1ib2wgYXQgYSBnaXZlbiB0ZXh0IGRvY3VtZW50IHBvc2l0aW9uLlxuICogVGhlIHJlcXVlc3QgcGFyYW1ldGVyIGlzIG9mIHR5cGUge0BsaW5rIFRleHREb2N1bWVudFBvc2l0aW9uUGFyYW1zfS5cbiAqIFRoZSByZXNwb25zZSBpcyBvZiB0eXBlIHtAbGluayBNb25pa2VyIE1vbmlrZXJbXX0gb3IgYG51bGxgLlxuICovXG52YXIgTW9uaWtlclJlcXVlc3Q7XG4oZnVuY3Rpb24gKE1vbmlrZXJSZXF1ZXN0KSB7XG4gICAgTW9uaWtlclJlcXVlc3QubWV0aG9kID0gJ3RleHREb2N1bWVudC9tb25pa2VyJztcbiAgICBNb25pa2VyUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIE1vbmlrZXJSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKE1vbmlrZXJSZXF1ZXN0Lm1ldGhvZCk7XG59KShNb25pa2VyUmVxdWVzdCA9IGV4cG9ydHMuTW9uaWtlclJlcXVlc3QgfHwgKGV4cG9ydHMuTW9uaWtlclJlcXVlc3QgPSB7fSkpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA0NzkyOlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLkRpZENsb3NlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuRGlkU2F2ZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24gPSBleHBvcnRzLkRpZENoYW5nZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24gPSBleHBvcnRzLk5vdGVib29rQ2VsbEFycmF5Q2hhbmdlID0gZXhwb3J0cy5EaWRPcGVuTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuTm90ZWJvb2tEb2N1bWVudFN5bmNSZWdpc3RyYXRpb25UeXBlID0gZXhwb3J0cy5Ob3RlYm9va0RvY3VtZW50ID0gZXhwb3J0cy5Ob3RlYm9va0NlbGwgPSBleHBvcnRzLkV4ZWN1dGlvblN1bW1hcnkgPSBleHBvcnRzLk5vdGVib29rQ2VsbEtpbmQgPSB2b2lkIDA7XG5jb25zdCB2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfdHlwZXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNzcxNyk7XG5jb25zdCBJcyA9IF9fd2VicGFja19yZXF1aXJlX18oODYzMyk7XG5jb25zdCBtZXNzYWdlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NDMxKTtcbi8qKlxuICogQSBub3RlYm9vayBjZWxsIGtpbmQuXG4gKlxuICogQHNpbmNlIDMuMTcuMFxuICovXG52YXIgTm90ZWJvb2tDZWxsS2luZDtcbihmdW5jdGlvbiAoTm90ZWJvb2tDZWxsS2luZCkge1xuICAgIC8qKlxuICAgICAqIEEgbWFya3VwLWNlbGwgaXMgZm9ybWF0dGVkIHNvdXJjZSB0aGF0IGlzIHVzZWQgZm9yIGRpc3BsYXkuXG4gICAgICovXG4gICAgTm90ZWJvb2tDZWxsS2luZC5NYXJrdXAgPSAxO1xuICAgIC8qKlxuICAgICAqIEEgY29kZS1jZWxsIGlzIHNvdXJjZSBjb2RlLlxuICAgICAqL1xuICAgIE5vdGVib29rQ2VsbEtpbmQuQ29kZSA9IDI7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSAxIHx8IHZhbHVlID09PSAyO1xuICAgIH1cbiAgICBOb3RlYm9va0NlbGxLaW5kLmlzID0gaXM7XG59KShOb3RlYm9va0NlbGxLaW5kID0gZXhwb3J0cy5Ob3RlYm9va0NlbGxLaW5kIHx8IChleHBvcnRzLk5vdGVib29rQ2VsbEtpbmQgPSB7fSkpO1xudmFyIEV4ZWN1dGlvblN1bW1hcnk7XG4oZnVuY3Rpb24gKEV4ZWN1dGlvblN1bW1hcnkpIHtcbiAgICBmdW5jdGlvbiBjcmVhdGUoZXhlY3V0aW9uT3JkZXIsIHN1Y2Nlc3MpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0geyBleGVjdXRpb25PcmRlciB9O1xuICAgICAgICBpZiAoc3VjY2VzcyA9PT0gdHJ1ZSB8fCBzdWNjZXNzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmVzdWx0LnN1Y2Nlc3MgPSBzdWNjZXNzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIEV4ZWN1dGlvblN1bW1hcnkuY3JlYXRlID0gY3JlYXRlO1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpICYmIHZzY29kZV9sYW5ndWFnZXNlcnZlcl90eXBlc18xLnVpbnRlZ2VyLmlzKGNhbmRpZGF0ZS5leGVjdXRpb25PcmRlcikgJiYgKGNhbmRpZGF0ZS5zdWNjZXNzID09PSB1bmRlZmluZWQgfHwgSXMuYm9vbGVhbihjYW5kaWRhdGUuc3VjY2VzcykpO1xuICAgIH1cbiAgICBFeGVjdXRpb25TdW1tYXJ5LmlzID0gaXM7XG4gICAgZnVuY3Rpb24gZXF1YWxzKG9uZSwgb3RoZXIpIHtcbiAgICAgICAgaWYgKG9uZSA9PT0gb3RoZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvbmUgPT09IG51bGwgfHwgb25lID09PSB1bmRlZmluZWQgfHwgb3RoZXIgPT09IG51bGwgfHwgb3RoZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvbmUuZXhlY3V0aW9uT3JkZXIgPT09IG90aGVyLmV4ZWN1dGlvbk9yZGVyICYmIG9uZS5zdWNjZXNzID09PSBvdGhlci5zdWNjZXNzO1xuICAgIH1cbiAgICBFeGVjdXRpb25TdW1tYXJ5LmVxdWFscyA9IGVxdWFscztcbn0pKEV4ZWN1dGlvblN1bW1hcnkgPSBleHBvcnRzLkV4ZWN1dGlvblN1bW1hcnkgfHwgKGV4cG9ydHMuRXhlY3V0aW9uU3VtbWFyeSA9IHt9KSk7XG52YXIgTm90ZWJvb2tDZWxsO1xuKGZ1bmN0aW9uIChOb3RlYm9va0NlbGwpIHtcbiAgICBmdW5jdGlvbiBjcmVhdGUoa2luZCwgZG9jdW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHsga2luZCwgZG9jdW1lbnQgfTtcbiAgICB9XG4gICAgTm90ZWJvb2tDZWxsLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKSAmJiBOb3RlYm9va0NlbGxLaW5kLmlzKGNhbmRpZGF0ZS5raW5kKSAmJiB2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfdHlwZXNfMS5Eb2N1bWVudFVyaS5pcyhjYW5kaWRhdGUuZG9jdW1lbnQpICYmXG4gICAgICAgICAgICAoY2FuZGlkYXRlLm1ldGFkYXRhID09PSB1bmRlZmluZWQgfHwgSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUubWV0YWRhdGEpKTtcbiAgICB9XG4gICAgTm90ZWJvb2tDZWxsLmlzID0gaXM7XG4gICAgZnVuY3Rpb24gZGlmZihvbmUsIHR3bykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgU2V0KCk7XG4gICAgICAgIGlmIChvbmUuZG9jdW1lbnQgIT09IHR3by5kb2N1bWVudCkge1xuICAgICAgICAgICAgcmVzdWx0LmFkZCgnZG9jdW1lbnQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25lLmtpbmQgIT09IHR3by5raW5kKSB7XG4gICAgICAgICAgICByZXN1bHQuYWRkKCdraW5kJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uZS5leGVjdXRpb25TdW1tYXJ5ICE9PSB0d28uZXhlY3V0aW9uU3VtbWFyeSkge1xuICAgICAgICAgICAgcmVzdWx0LmFkZCgnZXhlY3V0aW9uU3VtbWFyeScpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgob25lLm1ldGFkYXRhICE9PSB1bmRlZmluZWQgfHwgdHdvLm1ldGFkYXRhICE9PSB1bmRlZmluZWQpICYmICFlcXVhbHNNZXRhZGF0YShvbmUubWV0YWRhdGEsIHR3by5tZXRhZGF0YSkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5hZGQoJ21ldGFkYXRhJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChvbmUuZXhlY3V0aW9uU3VtbWFyeSAhPT0gdW5kZWZpbmVkIHx8IHR3by5leGVjdXRpb25TdW1tYXJ5ICE9PSB1bmRlZmluZWQpICYmICFFeGVjdXRpb25TdW1tYXJ5LmVxdWFscyhvbmUuZXhlY3V0aW9uU3VtbWFyeSwgdHdvLmV4ZWN1dGlvblN1bW1hcnkpKSB7XG4gICAgICAgICAgICByZXN1bHQuYWRkKCdleGVjdXRpb25TdW1tYXJ5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgTm90ZWJvb2tDZWxsLmRpZmYgPSBkaWZmO1xuICAgIGZ1bmN0aW9uIGVxdWFsc01ldGFkYXRhKG9uZSwgb3RoZXIpIHtcbiAgICAgICAgaWYgKG9uZSA9PT0gb3RoZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvbmUgPT09IG51bGwgfHwgb25lID09PSB1bmRlZmluZWQgfHwgb3RoZXIgPT09IG51bGwgfHwgb3RoZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygb25lICE9PSB0eXBlb2Ygb3RoZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG9uZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvbmVBcnJheSA9IEFycmF5LmlzQXJyYXkob25lKTtcbiAgICAgICAgY29uc3Qgb3RoZXJBcnJheSA9IEFycmF5LmlzQXJyYXkob3RoZXIpO1xuICAgICAgICBpZiAob25lQXJyYXkgIT09IG90aGVyQXJyYXkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25lQXJyYXkgJiYgb3RoZXJBcnJheSkge1xuICAgICAgICAgICAgaWYgKG9uZS5sZW5ndGggIT09IG90aGVyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb25lLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFlcXVhbHNNZXRhZGF0YShvbmVbaV0sIG90aGVyW2ldKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChJcy5vYmplY3RMaXRlcmFsKG9uZSkgJiYgSXMub2JqZWN0TGl0ZXJhbChvdGhlcikpIHtcbiAgICAgICAgICAgIGNvbnN0IG9uZUtleXMgPSBPYmplY3Qua2V5cyhvbmUpO1xuICAgICAgICAgICAgY29uc3Qgb3RoZXJLZXlzID0gT2JqZWN0LmtleXMob3RoZXIpO1xuICAgICAgICAgICAgaWYgKG9uZUtleXMubGVuZ3RoICE9PSBvdGhlcktleXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb25lS2V5cy5zb3J0KCk7XG4gICAgICAgICAgICBvdGhlcktleXMuc29ydCgpO1xuICAgICAgICAgICAgaWYgKCFlcXVhbHNNZXRhZGF0YShvbmVLZXlzLCBvdGhlcktleXMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvbmVLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvcCA9IG9uZUtleXNbaV07XG4gICAgICAgICAgICAgICAgaWYgKCFlcXVhbHNNZXRhZGF0YShvbmVbcHJvcF0sIG90aGVyW3Byb3BdKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn0pKE5vdGVib29rQ2VsbCA9IGV4cG9ydHMuTm90ZWJvb2tDZWxsIHx8IChleHBvcnRzLk5vdGVib29rQ2VsbCA9IHt9KSk7XG52YXIgTm90ZWJvb2tEb2N1bWVudDtcbihmdW5jdGlvbiAoTm90ZWJvb2tEb2N1bWVudCkge1xuICAgIGZ1bmN0aW9uIGNyZWF0ZSh1cmksIG5vdGVib29rVHlwZSwgdmVyc2lvbiwgY2VsbHMpIHtcbiAgICAgICAgcmV0dXJuIHsgdXJpLCBub3RlYm9va1R5cGUsIHZlcnNpb24sIGNlbGxzIH07XG4gICAgfVxuICAgIE5vdGVib29rRG9jdW1lbnQuY3JlYXRlID0gY3JlYXRlO1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpICYmIElzLnN0cmluZyhjYW5kaWRhdGUudXJpKSAmJiB2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfdHlwZXNfMS5pbnRlZ2VyLmlzKGNhbmRpZGF0ZS52ZXJzaW9uKSAmJiBJcy50eXBlZEFycmF5KGNhbmRpZGF0ZS5jZWxscywgTm90ZWJvb2tDZWxsLmlzKTtcbiAgICB9XG4gICAgTm90ZWJvb2tEb2N1bWVudC5pcyA9IGlzO1xufSkoTm90ZWJvb2tEb2N1bWVudCA9IGV4cG9ydHMuTm90ZWJvb2tEb2N1bWVudCB8fCAoZXhwb3J0cy5Ob3RlYm9va0RvY3VtZW50ID0ge30pKTtcbnZhciBOb3RlYm9va0RvY3VtZW50U3luY1JlZ2lzdHJhdGlvblR5cGU7XG4oZnVuY3Rpb24gKE5vdGVib29rRG9jdW1lbnRTeW5jUmVnaXN0cmF0aW9uVHlwZSkge1xuICAgIE5vdGVib29rRG9jdW1lbnRTeW5jUmVnaXN0cmF0aW9uVHlwZS5tZXRob2QgPSAnbm90ZWJvb2tEb2N1bWVudC9zeW5jJztcbiAgICBOb3RlYm9va0RvY3VtZW50U3luY1JlZ2lzdHJhdGlvblR5cGUubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBOb3RlYm9va0RvY3VtZW50U3luY1JlZ2lzdHJhdGlvblR5cGUudHlwZSA9IG5ldyBtZXNzYWdlc18xLlJlZ2lzdHJhdGlvblR5cGUoTm90ZWJvb2tEb2N1bWVudFN5bmNSZWdpc3RyYXRpb25UeXBlLm1ldGhvZCk7XG59KShOb3RlYm9va0RvY3VtZW50U3luY1JlZ2lzdHJhdGlvblR5cGUgPSBleHBvcnRzLk5vdGVib29rRG9jdW1lbnRTeW5jUmVnaXN0cmF0aW9uVHlwZSB8fCAoZXhwb3J0cy5Ob3RlYm9va0RvY3VtZW50U3luY1JlZ2lzdHJhdGlvblR5cGUgPSB7fSkpO1xuLyoqXG4gKiBBIG5vdGlmaWNhdGlvbiBzZW50IHdoZW4gYSBub3RlYm9vayBvcGVucy5cbiAqXG4gKiBAc2luY2UgMy4xNy4wXG4gKi9cbnZhciBEaWRPcGVuTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbjtcbihmdW5jdGlvbiAoRGlkT3Blbk5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24pIHtcbiAgICBEaWRPcGVuTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbi5tZXRob2QgPSAnbm90ZWJvb2tEb2N1bWVudC9kaWRPcGVuJztcbiAgICBEaWRPcGVuTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbi5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIERpZE9wZW5Ob3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uLnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbE5vdGlmaWNhdGlvblR5cGUoRGlkT3Blbk5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24ubWV0aG9kKTtcbiAgICBEaWRPcGVuTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbi5yZWdpc3RyYXRpb25NZXRob2QgPSBOb3RlYm9va0RvY3VtZW50U3luY1JlZ2lzdHJhdGlvblR5cGUubWV0aG9kO1xufSkoRGlkT3Blbk5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24gPSBleHBvcnRzLkRpZE9wZW5Ob3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uIHx8IChleHBvcnRzLkRpZE9wZW5Ob3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uID0ge30pKTtcbnZhciBOb3RlYm9va0NlbGxBcnJheUNoYW5nZTtcbihmdW5jdGlvbiAoTm90ZWJvb2tDZWxsQXJyYXlDaGFuZ2UpIHtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKSAmJiB2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfdHlwZXNfMS51aW50ZWdlci5pcyhjYW5kaWRhdGUuc3RhcnQpICYmIHZzY29kZV9sYW5ndWFnZXNlcnZlcl90eXBlc18xLnVpbnRlZ2VyLmlzKGNhbmRpZGF0ZS5kZWxldGVDb3VudCkgJiYgKGNhbmRpZGF0ZS5jZWxscyA9PT0gdW5kZWZpbmVkIHx8IElzLnR5cGVkQXJyYXkoY2FuZGlkYXRlLmNlbGxzLCBOb3RlYm9va0NlbGwuaXMpKTtcbiAgICB9XG4gICAgTm90ZWJvb2tDZWxsQXJyYXlDaGFuZ2UuaXMgPSBpcztcbiAgICBmdW5jdGlvbiBjcmVhdGUoc3RhcnQsIGRlbGV0ZUNvdW50LCBjZWxscykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB7IHN0YXJ0LCBkZWxldGVDb3VudCB9O1xuICAgICAgICBpZiAoY2VsbHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzdWx0LmNlbGxzID0gY2VsbHM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgTm90ZWJvb2tDZWxsQXJyYXlDaGFuZ2UuY3JlYXRlID0gY3JlYXRlO1xufSkoTm90ZWJvb2tDZWxsQXJyYXlDaGFuZ2UgPSBleHBvcnRzLk5vdGVib29rQ2VsbEFycmF5Q2hhbmdlIHx8IChleHBvcnRzLk5vdGVib29rQ2VsbEFycmF5Q2hhbmdlID0ge30pKTtcbnZhciBEaWRDaGFuZ2VOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uO1xuKGZ1bmN0aW9uIChEaWRDaGFuZ2VOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uKSB7XG4gICAgRGlkQ2hhbmdlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbi5tZXRob2QgPSAnbm90ZWJvb2tEb2N1bWVudC9kaWRDaGFuZ2UnO1xuICAgIERpZENoYW5nZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24ubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBEaWRDaGFuZ2VOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uLnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbE5vdGlmaWNhdGlvblR5cGUoRGlkQ2hhbmdlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbi5tZXRob2QpO1xuICAgIERpZENoYW5nZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24ucmVnaXN0cmF0aW9uTWV0aG9kID0gTm90ZWJvb2tEb2N1bWVudFN5bmNSZWdpc3RyYXRpb25UeXBlLm1ldGhvZDtcbn0pKERpZENoYW5nZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24gPSBleHBvcnRzLkRpZENoYW5nZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24gfHwgKGV4cG9ydHMuRGlkQ2hhbmdlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbiA9IHt9KSk7XG4vKipcbiAqIEEgbm90aWZpY2F0aW9uIHNlbnQgd2hlbiBhIG5vdGVib29rIGRvY3VtZW50IGlzIHNhdmVkLlxuICpcbiAqIEBzaW5jZSAzLjE3LjBcbiAqL1xudmFyIERpZFNhdmVOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uO1xuKGZ1bmN0aW9uIChEaWRTYXZlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbikge1xuICAgIERpZFNhdmVOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uLm1ldGhvZCA9ICdub3RlYm9va0RvY3VtZW50L2RpZFNhdmUnO1xuICAgIERpZFNhdmVOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uLm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgRGlkU2F2ZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24udHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sTm90aWZpY2F0aW9uVHlwZShEaWRTYXZlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbi5tZXRob2QpO1xuICAgIERpZFNhdmVOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uLnJlZ2lzdHJhdGlvbk1ldGhvZCA9IE5vdGVib29rRG9jdW1lbnRTeW5jUmVnaXN0cmF0aW9uVHlwZS5tZXRob2Q7XG59KShEaWRTYXZlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuRGlkU2F2ZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24gfHwgKGV4cG9ydHMuRGlkU2F2ZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24gPSB7fSkpO1xuLyoqXG4gKiBBIG5vdGlmaWNhdGlvbiBzZW50IHdoZW4gYSBub3RlYm9vayBjbG9zZXMuXG4gKlxuICogQHNpbmNlIDMuMTcuMFxuICovXG52YXIgRGlkQ2xvc2VOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uO1xuKGZ1bmN0aW9uIChEaWRDbG9zZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24pIHtcbiAgICBEaWRDbG9zZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24ubWV0aG9kID0gJ25vdGVib29rRG9jdW1lbnQvZGlkQ2xvc2UnO1xuICAgIERpZENsb3NlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbi5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIERpZENsb3NlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbi50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xOb3RpZmljYXRpb25UeXBlKERpZENsb3NlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbi5tZXRob2QpO1xuICAgIERpZENsb3NlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbi5yZWdpc3RyYXRpb25NZXRob2QgPSBOb3RlYm9va0RvY3VtZW50U3luY1JlZ2lzdHJhdGlvblR5cGUubWV0aG9kO1xufSkoRGlkQ2xvc2VOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uID0gZXhwb3J0cy5EaWRDbG9zZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24gfHwgKGV4cG9ydHMuRGlkQ2xvc2VOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uID0ge30pKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNDE2Njpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5Xb3JrRG9uZVByb2dyZXNzQ2FuY2VsTm90aWZpY2F0aW9uID0gZXhwb3J0cy5Xb3JrRG9uZVByb2dyZXNzQ3JlYXRlUmVxdWVzdCA9IGV4cG9ydHMuV29ya0RvbmVQcm9ncmVzcyA9IHZvaWQgMDtcbmNvbnN0IHZzY29kZV9qc29ucnBjXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkxMTApO1xuY29uc3QgbWVzc2FnZXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oODQzMSk7XG52YXIgV29ya0RvbmVQcm9ncmVzcztcbihmdW5jdGlvbiAoV29ya0RvbmVQcm9ncmVzcykge1xuICAgIFdvcmtEb25lUHJvZ3Jlc3MudHlwZSA9IG5ldyB2c2NvZGVfanNvbnJwY18xLlByb2dyZXNzVHlwZSgpO1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gV29ya0RvbmVQcm9ncmVzcy50eXBlO1xuICAgIH1cbiAgICBXb3JrRG9uZVByb2dyZXNzLmlzID0gaXM7XG59KShXb3JrRG9uZVByb2dyZXNzID0gZXhwb3J0cy5Xb3JrRG9uZVByb2dyZXNzIHx8IChleHBvcnRzLldvcmtEb25lUHJvZ3Jlc3MgPSB7fSkpO1xuLyoqXG4gKiBUaGUgYHdpbmRvdy93b3JrRG9uZVByb2dyZXNzL2NyZWF0ZWAgcmVxdWVzdCBpcyBzZW50IGZyb20gdGhlIHNlcnZlciB0byB0aGUgY2xpZW50IHRvIGluaXRpYXRlIHByb2dyZXNzXG4gKiByZXBvcnRpbmcgZnJvbSB0aGUgc2VydmVyLlxuICovXG52YXIgV29ya0RvbmVQcm9ncmVzc0NyZWF0ZVJlcXVlc3Q7XG4oZnVuY3Rpb24gKFdvcmtEb25lUHJvZ3Jlc3NDcmVhdGVSZXF1ZXN0KSB7XG4gICAgV29ya0RvbmVQcm9ncmVzc0NyZWF0ZVJlcXVlc3QubWV0aG9kID0gJ3dpbmRvdy93b3JrRG9uZVByb2dyZXNzL2NyZWF0ZSc7XG4gICAgV29ya0RvbmVQcm9ncmVzc0NyZWF0ZVJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5zZXJ2ZXJUb0NsaWVudDtcbiAgICBXb3JrRG9uZVByb2dyZXNzQ3JlYXRlUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShXb3JrRG9uZVByb2dyZXNzQ3JlYXRlUmVxdWVzdC5tZXRob2QpO1xufSkoV29ya0RvbmVQcm9ncmVzc0NyZWF0ZVJlcXVlc3QgPSBleHBvcnRzLldvcmtEb25lUHJvZ3Jlc3NDcmVhdGVSZXF1ZXN0IHx8IChleHBvcnRzLldvcmtEb25lUHJvZ3Jlc3NDcmVhdGVSZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogVGhlIGB3aW5kb3cvd29ya0RvbmVQcm9ncmVzcy9jYW5jZWxgIG5vdGlmaWNhdGlvbiBpcyBzZW50IGZyb20gIHRoZSBjbGllbnQgdG8gdGhlIHNlcnZlciB0byBjYW5jZWwgYSBwcm9ncmVzc1xuICogaW5pdGlhdGVkIG9uIHRoZSBzZXJ2ZXIgc2lkZS5cbiAqL1xudmFyIFdvcmtEb25lUHJvZ3Jlc3NDYW5jZWxOb3RpZmljYXRpb247XG4oZnVuY3Rpb24gKFdvcmtEb25lUHJvZ3Jlc3NDYW5jZWxOb3RpZmljYXRpb24pIHtcbiAgICBXb3JrRG9uZVByb2dyZXNzQ2FuY2VsTm90aWZpY2F0aW9uLm1ldGhvZCA9ICd3aW5kb3cvd29ya0RvbmVQcm9ncmVzcy9jYW5jZWwnO1xuICAgIFdvcmtEb25lUHJvZ3Jlc3NDYW5jZWxOb3RpZmljYXRpb24ubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBXb3JrRG9uZVByb2dyZXNzQ2FuY2VsTm90aWZpY2F0aW9uLnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbE5vdGlmaWNhdGlvblR5cGUoV29ya0RvbmVQcm9ncmVzc0NhbmNlbE5vdGlmaWNhdGlvbi5tZXRob2QpO1xufSkoV29ya0RvbmVQcm9ncmVzc0NhbmNlbE5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuV29ya0RvbmVQcm9ncmVzc0NhbmNlbE5vdGlmaWNhdGlvbiB8fCAoZXhwb3J0cy5Xb3JrRG9uZVByb2dyZXNzQ2FuY2VsTm90aWZpY2F0aW9uID0ge30pKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMTUzMDpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLlNlbGVjdGlvblJhbmdlUmVxdWVzdCA9IHZvaWQgMDtcbmNvbnN0IG1lc3NhZ2VzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg0MzEpO1xuLyoqXG4gKiBBIHJlcXVlc3QgdG8gcHJvdmlkZSBzZWxlY3Rpb24gcmFuZ2VzIGluIGEgZG9jdW1lbnQuIFRoZSByZXF1ZXN0J3NcbiAqIHBhcmFtZXRlciBpcyBvZiB0eXBlIHtAbGluayBTZWxlY3Rpb25SYW5nZVBhcmFtc30sIHRoZVxuICogcmVzcG9uc2UgaXMgb2YgdHlwZSB7QGxpbmsgU2VsZWN0aW9uUmFuZ2UgU2VsZWN0aW9uUmFuZ2VbXX0gb3IgYSBUaGVuYWJsZVxuICogdGhhdCByZXNvbHZlcyB0byBzdWNoLlxuICovXG52YXIgU2VsZWN0aW9uUmFuZ2VSZXF1ZXN0O1xuKGZ1bmN0aW9uIChTZWxlY3Rpb25SYW5nZVJlcXVlc3QpIHtcbiAgICBTZWxlY3Rpb25SYW5nZVJlcXVlc3QubWV0aG9kID0gJ3RleHREb2N1bWVudC9zZWxlY3Rpb25SYW5nZSc7XG4gICAgU2VsZWN0aW9uUmFuZ2VSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgU2VsZWN0aW9uUmFuZ2VSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKFNlbGVjdGlvblJhbmdlUmVxdWVzdC5tZXRob2QpO1xufSkoU2VsZWN0aW9uUmFuZ2VSZXF1ZXN0ID0gZXhwb3J0cy5TZWxlY3Rpb25SYW5nZVJlcXVlc3QgfHwgKGV4cG9ydHMuU2VsZWN0aW9uUmFuZ2VSZXF1ZXN0ID0ge30pKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMjA2Nzpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5TZW1hbnRpY1Rva2Vuc1JlZnJlc2hSZXF1ZXN0ID0gZXhwb3J0cy5TZW1hbnRpY1Rva2Vuc1JhbmdlUmVxdWVzdCA9IGV4cG9ydHMuU2VtYW50aWNUb2tlbnNEZWx0YVJlcXVlc3QgPSBleHBvcnRzLlNlbWFudGljVG9rZW5zUmVxdWVzdCA9IGV4cG9ydHMuU2VtYW50aWNUb2tlbnNSZWdpc3RyYXRpb25UeXBlID0gZXhwb3J0cy5Ub2tlbkZvcm1hdCA9IHZvaWQgMDtcbmNvbnN0IG1lc3NhZ2VzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg0MzEpO1xuLy8tLS0tLS0tICd0ZXh0RG9jdW1lbnQvc2VtYW50aWNUb2tlbnMnIC0tLS0tXG52YXIgVG9rZW5Gb3JtYXQ7XG4oZnVuY3Rpb24gKFRva2VuRm9ybWF0KSB7XG4gICAgVG9rZW5Gb3JtYXQuUmVsYXRpdmUgPSAncmVsYXRpdmUnO1xufSkoVG9rZW5Gb3JtYXQgPSBleHBvcnRzLlRva2VuRm9ybWF0IHx8IChleHBvcnRzLlRva2VuRm9ybWF0ID0ge30pKTtcbnZhciBTZW1hbnRpY1Rva2Vuc1JlZ2lzdHJhdGlvblR5cGU7XG4oZnVuY3Rpb24gKFNlbWFudGljVG9rZW5zUmVnaXN0cmF0aW9uVHlwZSkge1xuICAgIFNlbWFudGljVG9rZW5zUmVnaXN0cmF0aW9uVHlwZS5tZXRob2QgPSAndGV4dERvY3VtZW50L3NlbWFudGljVG9rZW5zJztcbiAgICBTZW1hbnRpY1Rva2Vuc1JlZ2lzdHJhdGlvblR5cGUudHlwZSA9IG5ldyBtZXNzYWdlc18xLlJlZ2lzdHJhdGlvblR5cGUoU2VtYW50aWNUb2tlbnNSZWdpc3RyYXRpb25UeXBlLm1ldGhvZCk7XG59KShTZW1hbnRpY1Rva2Vuc1JlZ2lzdHJhdGlvblR5cGUgPSBleHBvcnRzLlNlbWFudGljVG9rZW5zUmVnaXN0cmF0aW9uVHlwZSB8fCAoZXhwb3J0cy5TZW1hbnRpY1Rva2Vuc1JlZ2lzdHJhdGlvblR5cGUgPSB7fSkpO1xuLyoqXG4gKiBAc2luY2UgMy4xNi4wXG4gKi9cbnZhciBTZW1hbnRpY1Rva2Vuc1JlcXVlc3Q7XG4oZnVuY3Rpb24gKFNlbWFudGljVG9rZW5zUmVxdWVzdCkge1xuICAgIFNlbWFudGljVG9rZW5zUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L3NlbWFudGljVG9rZW5zL2Z1bGwnO1xuICAgIFNlbWFudGljVG9rZW5zUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIFNlbWFudGljVG9rZW5zUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShTZW1hbnRpY1Rva2Vuc1JlcXVlc3QubWV0aG9kKTtcbiAgICBTZW1hbnRpY1Rva2Vuc1JlcXVlc3QucmVnaXN0cmF0aW9uTWV0aG9kID0gU2VtYW50aWNUb2tlbnNSZWdpc3RyYXRpb25UeXBlLm1ldGhvZDtcbn0pKFNlbWFudGljVG9rZW5zUmVxdWVzdCA9IGV4cG9ydHMuU2VtYW50aWNUb2tlbnNSZXF1ZXN0IHx8IChleHBvcnRzLlNlbWFudGljVG9rZW5zUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIEBzaW5jZSAzLjE2LjBcbiAqL1xudmFyIFNlbWFudGljVG9rZW5zRGVsdGFSZXF1ZXN0O1xuKGZ1bmN0aW9uIChTZW1hbnRpY1Rva2Vuc0RlbHRhUmVxdWVzdCkge1xuICAgIFNlbWFudGljVG9rZW5zRGVsdGFSZXF1ZXN0Lm1ldGhvZCA9ICd0ZXh0RG9jdW1lbnQvc2VtYW50aWNUb2tlbnMvZnVsbC9kZWx0YSc7XG4gICAgU2VtYW50aWNUb2tlbnNEZWx0YVJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBTZW1hbnRpY1Rva2Vuc0RlbHRhUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShTZW1hbnRpY1Rva2Vuc0RlbHRhUmVxdWVzdC5tZXRob2QpO1xuICAgIFNlbWFudGljVG9rZW5zRGVsdGFSZXF1ZXN0LnJlZ2lzdHJhdGlvbk1ldGhvZCA9IFNlbWFudGljVG9rZW5zUmVnaXN0cmF0aW9uVHlwZS5tZXRob2Q7XG59KShTZW1hbnRpY1Rva2Vuc0RlbHRhUmVxdWVzdCA9IGV4cG9ydHMuU2VtYW50aWNUb2tlbnNEZWx0YVJlcXVlc3QgfHwgKGV4cG9ydHMuU2VtYW50aWNUb2tlbnNEZWx0YVJlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBAc2luY2UgMy4xNi4wXG4gKi9cbnZhciBTZW1hbnRpY1Rva2Vuc1JhbmdlUmVxdWVzdDtcbihmdW5jdGlvbiAoU2VtYW50aWNUb2tlbnNSYW5nZVJlcXVlc3QpIHtcbiAgICBTZW1hbnRpY1Rva2Vuc1JhbmdlUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L3NlbWFudGljVG9rZW5zL3JhbmdlJztcbiAgICBTZW1hbnRpY1Rva2Vuc1JhbmdlUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIFNlbWFudGljVG9rZW5zUmFuZ2VSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKFNlbWFudGljVG9rZW5zUmFuZ2VSZXF1ZXN0Lm1ldGhvZCk7XG4gICAgU2VtYW50aWNUb2tlbnNSYW5nZVJlcXVlc3QucmVnaXN0cmF0aW9uTWV0aG9kID0gU2VtYW50aWNUb2tlbnNSZWdpc3RyYXRpb25UeXBlLm1ldGhvZDtcbn0pKFNlbWFudGljVG9rZW5zUmFuZ2VSZXF1ZXN0ID0gZXhwb3J0cy5TZW1hbnRpY1Rva2Vuc1JhbmdlUmVxdWVzdCB8fCAoZXhwb3J0cy5TZW1hbnRpY1Rva2Vuc1JhbmdlUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIEBzaW5jZSAzLjE2LjBcbiAqL1xudmFyIFNlbWFudGljVG9rZW5zUmVmcmVzaFJlcXVlc3Q7XG4oZnVuY3Rpb24gKFNlbWFudGljVG9rZW5zUmVmcmVzaFJlcXVlc3QpIHtcbiAgICBTZW1hbnRpY1Rva2Vuc1JlZnJlc2hSZXF1ZXN0Lm1ldGhvZCA9IGB3b3Jrc3BhY2Uvc2VtYW50aWNUb2tlbnMvcmVmcmVzaGA7XG4gICAgU2VtYW50aWNUb2tlbnNSZWZyZXNoUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLnNlcnZlclRvQ2xpZW50O1xuICAgIFNlbWFudGljVG9rZW5zUmVmcmVzaFJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUwKFNlbWFudGljVG9rZW5zUmVmcmVzaFJlcXVlc3QubWV0aG9kKTtcbn0pKFNlbWFudGljVG9rZW5zUmVmcmVzaFJlcXVlc3QgPSBleHBvcnRzLlNlbWFudGljVG9rZW5zUmVmcmVzaFJlcXVlc3QgfHwgKGV4cG9ydHMuU2VtYW50aWNUb2tlbnNSZWZyZXNoUmVxdWVzdCA9IHt9KSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDQzMzM6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuU2hvd0RvY3VtZW50UmVxdWVzdCA9IHZvaWQgMDtcbmNvbnN0IG1lc3NhZ2VzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg0MzEpO1xuLyoqXG4gKiBBIHJlcXVlc3QgdG8gc2hvdyBhIGRvY3VtZW50LiBUaGlzIHJlcXVlc3QgbWlnaHQgb3BlbiBhblxuICogZXh0ZXJuYWwgcHJvZ3JhbSBkZXBlbmRpbmcgb24gdGhlIHZhbHVlIG9mIHRoZSBVUkkgdG8gb3Blbi5cbiAqIEZvciBleGFtcGxlIGEgcmVxdWVzdCB0byBvcGVuIGBodHRwczovL2NvZGUudmlzdWFsc3R1ZGlvLmNvbS9gXG4gKiB3aWxsIHZlcnkgbGlrZWx5IG9wZW4gdGhlIFVSSSBpbiBhIFdFQiBicm93c2VyLlxuICpcbiAqIEBzaW5jZSAzLjE2LjBcbiovXG52YXIgU2hvd0RvY3VtZW50UmVxdWVzdDtcbihmdW5jdGlvbiAoU2hvd0RvY3VtZW50UmVxdWVzdCkge1xuICAgIFNob3dEb2N1bWVudFJlcXVlc3QubWV0aG9kID0gJ3dpbmRvdy9zaG93RG9jdW1lbnQnO1xuICAgIFNob3dEb2N1bWVudFJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5zZXJ2ZXJUb0NsaWVudDtcbiAgICBTaG93RG9jdW1lbnRSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKFNob3dEb2N1bWVudFJlcXVlc3QubWV0aG9kKTtcbn0pKFNob3dEb2N1bWVudFJlcXVlc3QgPSBleHBvcnRzLlNob3dEb2N1bWVudFJlcXVlc3QgfHwgKGV4cG9ydHMuU2hvd0RvY3VtZW50UmVxdWVzdCA9IHt9KSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDkyNjQ6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuVHlwZURlZmluaXRpb25SZXF1ZXN0ID0gdm9pZCAwO1xuY29uc3QgbWVzc2FnZXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oODQzMSk7XG4vLyBAdHMtaWdub3JlOiB0byBhdm9pZCBpbmxpbmluZyBMb2NhdGlvTGluayBhcyBkeW5hbWljIGltcG9ydFxubGV0IF9fbm9EeW5hbWljSW1wb3J0O1xuLyoqXG4gKiBBIHJlcXVlc3QgdG8gcmVzb2x2ZSB0aGUgdHlwZSBkZWZpbml0aW9uIGxvY2F0aW9ucyBvZiBhIHN5bWJvbCBhdCBhIGdpdmVuIHRleHRcbiAqIGRvY3VtZW50IHBvc2l0aW9uLiBUaGUgcmVxdWVzdCdzIHBhcmFtZXRlciBpcyBvZiB0eXBlIFtUZXh0RG9jdW1lbnRQb3NpdGlvblBhcmFtc11cbiAqICgjVGV4dERvY3VtZW50UG9zaXRpb25QYXJhbXMpIHRoZSByZXNwb25zZSBpcyBvZiB0eXBlIHtAbGluayBEZWZpbml0aW9ufSBvciBhXG4gKiBUaGVuYWJsZSB0aGF0IHJlc29sdmVzIHRvIHN1Y2guXG4gKi9cbnZhciBUeXBlRGVmaW5pdGlvblJlcXVlc3Q7XG4oZnVuY3Rpb24gKFR5cGVEZWZpbml0aW9uUmVxdWVzdCkge1xuICAgIFR5cGVEZWZpbml0aW9uUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L3R5cGVEZWZpbml0aW9uJztcbiAgICBUeXBlRGVmaW5pdGlvblJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBUeXBlRGVmaW5pdGlvblJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoVHlwZURlZmluaXRpb25SZXF1ZXN0Lm1ldGhvZCk7XG59KShUeXBlRGVmaW5pdGlvblJlcXVlc3QgPSBleHBvcnRzLlR5cGVEZWZpbml0aW9uUmVxdWVzdCB8fCAoZXhwb3J0cy5UeXBlRGVmaW5pdGlvblJlcXVlc3QgPSB7fSkpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA3MDYyOlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgVHlwZUZveCwgTWljcm9zb2Z0IGFuZCBvdGhlcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuVHlwZUhpZXJhcmNoeVN1YnR5cGVzUmVxdWVzdCA9IGV4cG9ydHMuVHlwZUhpZXJhcmNoeVN1cGVydHlwZXNSZXF1ZXN0ID0gZXhwb3J0cy5UeXBlSGllcmFyY2h5UHJlcGFyZVJlcXVlc3QgPSB2b2lkIDA7XG5jb25zdCBtZXNzYWdlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NDMxKTtcbi8qKlxuICogQSByZXF1ZXN0IHRvIHJlc3VsdCBhIGBUeXBlSGllcmFyY2h5SXRlbWAgaW4gYSBkb2N1bWVudCBhdCBhIGdpdmVuIHBvc2l0aW9uLlxuICogQ2FuIGJlIHVzZWQgYXMgYW4gaW5wdXQgdG8gYSBzdWJ0eXBlcyBvciBzdXBlcnR5cGVzIHR5cGUgaGllcmFyY2h5LlxuICpcbiAqIEBzaW5jZSAzLjE3LjBcbiAqL1xudmFyIFR5cGVIaWVyYXJjaHlQcmVwYXJlUmVxdWVzdDtcbihmdW5jdGlvbiAoVHlwZUhpZXJhcmNoeVByZXBhcmVSZXF1ZXN0KSB7XG4gICAgVHlwZUhpZXJhcmNoeVByZXBhcmVSZXF1ZXN0Lm1ldGhvZCA9ICd0ZXh0RG9jdW1lbnQvcHJlcGFyZVR5cGVIaWVyYXJjaHknO1xuICAgIFR5cGVIaWVyYXJjaHlQcmVwYXJlUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIFR5cGVIaWVyYXJjaHlQcmVwYXJlUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShUeXBlSGllcmFyY2h5UHJlcGFyZVJlcXVlc3QubWV0aG9kKTtcbn0pKFR5cGVIaWVyYXJjaHlQcmVwYXJlUmVxdWVzdCA9IGV4cG9ydHMuVHlwZUhpZXJhcmNoeVByZXBhcmVSZXF1ZXN0IHx8IChleHBvcnRzLlR5cGVIaWVyYXJjaHlQcmVwYXJlUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIEEgcmVxdWVzdCB0byByZXNvbHZlIHRoZSBzdXBlcnR5cGVzIGZvciBhIGdpdmVuIGBUeXBlSGllcmFyY2h5SXRlbWAuXG4gKlxuICogQHNpbmNlIDMuMTcuMFxuICovXG52YXIgVHlwZUhpZXJhcmNoeVN1cGVydHlwZXNSZXF1ZXN0O1xuKGZ1bmN0aW9uIChUeXBlSGllcmFyY2h5U3VwZXJ0eXBlc1JlcXVlc3QpIHtcbiAgICBUeXBlSGllcmFyY2h5U3VwZXJ0eXBlc1JlcXVlc3QubWV0aG9kID0gJ3R5cGVIaWVyYXJjaHkvc3VwZXJ0eXBlcyc7XG4gICAgVHlwZUhpZXJhcmNoeVN1cGVydHlwZXNSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgVHlwZUhpZXJhcmNoeVN1cGVydHlwZXNSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKFR5cGVIaWVyYXJjaHlTdXBlcnR5cGVzUmVxdWVzdC5tZXRob2QpO1xufSkoVHlwZUhpZXJhcmNoeVN1cGVydHlwZXNSZXF1ZXN0ID0gZXhwb3J0cy5UeXBlSGllcmFyY2h5U3VwZXJ0eXBlc1JlcXVlc3QgfHwgKGV4cG9ydHMuVHlwZUhpZXJhcmNoeVN1cGVydHlwZXNSZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogQSByZXF1ZXN0IHRvIHJlc29sdmUgdGhlIHN1YnR5cGVzIGZvciBhIGdpdmVuIGBUeXBlSGllcmFyY2h5SXRlbWAuXG4gKlxuICogQHNpbmNlIDMuMTcuMFxuICovXG52YXIgVHlwZUhpZXJhcmNoeVN1YnR5cGVzUmVxdWVzdDtcbihmdW5jdGlvbiAoVHlwZUhpZXJhcmNoeVN1YnR5cGVzUmVxdWVzdCkge1xuICAgIFR5cGVIaWVyYXJjaHlTdWJ0eXBlc1JlcXVlc3QubWV0aG9kID0gJ3R5cGVIaWVyYXJjaHkvc3VidHlwZXMnO1xuICAgIFR5cGVIaWVyYXJjaHlTdWJ0eXBlc1JlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBUeXBlSGllcmFyY2h5U3VidHlwZXNSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKFR5cGVIaWVyYXJjaHlTdWJ0eXBlc1JlcXVlc3QubWV0aG9kKTtcbn0pKFR5cGVIaWVyYXJjaHlTdWJ0eXBlc1JlcXVlc3QgPSBleHBvcnRzLlR5cGVIaWVyYXJjaHlTdWJ0eXBlc1JlcXVlc3QgfHwgKGV4cG9ydHMuVHlwZUhpZXJhcmNoeVN1YnR5cGVzUmVxdWVzdCA9IHt9KSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDY4NjA6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuRGlkQ2hhbmdlV29ya3NwYWNlRm9sZGVyc05vdGlmaWNhdGlvbiA9IGV4cG9ydHMuV29ya3NwYWNlRm9sZGVyc1JlcXVlc3QgPSB2b2lkIDA7XG5jb25zdCBtZXNzYWdlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NDMxKTtcbi8qKlxuICogVGhlIGB3b3Jrc3BhY2Uvd29ya3NwYWNlRm9sZGVyc2AgaXMgc2VudCBmcm9tIHRoZSBzZXJ2ZXIgdG8gdGhlIGNsaWVudCB0byBmZXRjaCB0aGUgb3BlbiB3b3Jrc3BhY2UgZm9sZGVycy5cbiAqL1xudmFyIFdvcmtzcGFjZUZvbGRlcnNSZXF1ZXN0O1xuKGZ1bmN0aW9uIChXb3Jrc3BhY2VGb2xkZXJzUmVxdWVzdCkge1xuICAgIFdvcmtzcGFjZUZvbGRlcnNSZXF1ZXN0Lm1ldGhvZCA9ICd3b3Jrc3BhY2Uvd29ya3NwYWNlRm9sZGVycyc7XG4gICAgV29ya3NwYWNlRm9sZGVyc1JlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5zZXJ2ZXJUb0NsaWVudDtcbiAgICBXb3Jrc3BhY2VGb2xkZXJzUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZTAoV29ya3NwYWNlRm9sZGVyc1JlcXVlc3QubWV0aG9kKTtcbn0pKFdvcmtzcGFjZUZvbGRlcnNSZXF1ZXN0ID0gZXhwb3J0cy5Xb3Jrc3BhY2VGb2xkZXJzUmVxdWVzdCB8fCAoZXhwb3J0cy5Xb3Jrc3BhY2VGb2xkZXJzUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIFRoZSBgd29ya3NwYWNlL2RpZENoYW5nZVdvcmtzcGFjZUZvbGRlcnNgIG5vdGlmaWNhdGlvbiBpcyBzZW50IGZyb20gdGhlIGNsaWVudCB0byB0aGUgc2VydmVyIHdoZW4gdGhlIHdvcmtzcGFjZVxuICogZm9sZGVyIGNvbmZpZ3VyYXRpb24gY2hhbmdlcy5cbiAqL1xudmFyIERpZENoYW5nZVdvcmtzcGFjZUZvbGRlcnNOb3RpZmljYXRpb247XG4oZnVuY3Rpb24gKERpZENoYW5nZVdvcmtzcGFjZUZvbGRlcnNOb3RpZmljYXRpb24pIHtcbiAgICBEaWRDaGFuZ2VXb3Jrc3BhY2VGb2xkZXJzTm90aWZpY2F0aW9uLm1ldGhvZCA9ICd3b3Jrc3BhY2UvZGlkQ2hhbmdlV29ya3NwYWNlRm9sZGVycyc7XG4gICAgRGlkQ2hhbmdlV29ya3NwYWNlRm9sZGVyc05vdGlmaWNhdGlvbi5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIERpZENoYW5nZVdvcmtzcGFjZUZvbGRlcnNOb3RpZmljYXRpb24udHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sTm90aWZpY2F0aW9uVHlwZShEaWRDaGFuZ2VXb3Jrc3BhY2VGb2xkZXJzTm90aWZpY2F0aW9uLm1ldGhvZCk7XG59KShEaWRDaGFuZ2VXb3Jrc3BhY2VGb2xkZXJzTm90aWZpY2F0aW9uID0gZXhwb3J0cy5EaWRDaGFuZ2VXb3Jrc3BhY2VGb2xkZXJzTm90aWZpY2F0aW9uIHx8IChleHBvcnRzLkRpZENoYW5nZVdvcmtzcGFjZUZvbGRlcnNOb3RpZmljYXRpb24gPSB7fSkpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA4NjMzOlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLm9iamVjdExpdGVyYWwgPSBleHBvcnRzLnR5cGVkQXJyYXkgPSBleHBvcnRzLnN0cmluZ0FycmF5ID0gZXhwb3J0cy5hcnJheSA9IGV4cG9ydHMuZnVuYyA9IGV4cG9ydHMuZXJyb3IgPSBleHBvcnRzLm51bWJlciA9IGV4cG9ydHMuc3RyaW5nID0gZXhwb3J0cy5ib29sZWFuID0gdm9pZCAwO1xuZnVuY3Rpb24gYm9vbGVhbih2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdHJ1ZSB8fCB2YWx1ZSA9PT0gZmFsc2U7XG59XG5leHBvcnRzLmJvb2xlYW4gPSBib29sZWFuO1xuZnVuY3Rpb24gc3RyaW5nKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHwgdmFsdWUgaW5zdGFuY2VvZiBTdHJpbmc7XG59XG5leHBvcnRzLnN0cmluZyA9IHN0cmluZztcbmZ1bmN0aW9uIG51bWJlcih2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInIHx8IHZhbHVlIGluc3RhbmNlb2YgTnVtYmVyO1xufVxuZXhwb3J0cy5udW1iZXIgPSBudW1iZXI7XG5mdW5jdGlvbiBlcnJvcih2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIEVycm9yO1xufVxuZXhwb3J0cy5lcnJvciA9IGVycm9yO1xuZnVuY3Rpb24gZnVuYyh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnRzLmZ1bmMgPSBmdW5jO1xuZnVuY3Rpb24gYXJyYXkodmFsdWUpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSk7XG59XG5leHBvcnRzLmFycmF5ID0gYXJyYXk7XG5mdW5jdGlvbiBzdHJpbmdBcnJheSh2YWx1ZSkge1xuICAgIHJldHVybiBhcnJheSh2YWx1ZSkgJiYgdmFsdWUuZXZlcnkoZWxlbSA9PiBzdHJpbmcoZWxlbSkpO1xufVxuZXhwb3J0cy5zdHJpbmdBcnJheSA9IHN0cmluZ0FycmF5O1xuZnVuY3Rpb24gdHlwZWRBcnJheSh2YWx1ZSwgY2hlY2spIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUuZXZlcnkoY2hlY2spO1xufVxuZXhwb3J0cy50eXBlZEFycmF5ID0gdHlwZWRBcnJheTtcbmZ1bmN0aW9uIG9iamVjdExpdGVyYWwodmFsdWUpIHtcbiAgICAvLyBTdHJpY3RseSBzcGVha2luZyBjbGFzcyBpbnN0YW5jZXMgcGFzcyB0aGlzIGNoZWNrIGFzIHdlbGwuIFNpbmNlIHRoZSBMU1BcbiAgICAvLyBkb2Vzbid0IHVzZSBjbGFzc2VzIHdlIGlnbm9yZSB0aGlzIGZvciBub3cuIElmIHdlIGRvIHdlIG5lZWQgdG8gYWRkIHNvbWV0aGluZ1xuICAgIC8vIGxpa2UgdGhpczogYE9iamVjdC5nZXRQcm90b3R5cGVPZihPYmplY3QuZ2V0UHJvdG90eXBlT2YoeCkpID09PSBudWxsYFxuICAgIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnO1xufVxuZXhwb3J0cy5vYmplY3RMaXRlcmFsID0gb2JqZWN0TGl0ZXJhbDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNzcxNzpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xuLyogaGFybW9ueSBleHBvcnQgKi8gICBBbm5vdGF0ZWRUZXh0RWRpdDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gQW5ub3RhdGVkVGV4dEVkaXQpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBDaGFuZ2VBbm5vdGF0aW9uOiAoKSA9PiAoLyogYmluZGluZyAqLyBDaGFuZ2VBbm5vdGF0aW9uKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgQ2hhbmdlQW5ub3RhdGlvbklkZW50aWZpZXI6ICgpID0+ICgvKiBiaW5kaW5nICovIENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgQ29kZUFjdGlvbjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gQ29kZUFjdGlvbiksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIENvZGVBY3Rpb25Db250ZXh0OiAoKSA9PiAoLyogYmluZGluZyAqLyBDb2RlQWN0aW9uQ29udGV4dCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIENvZGVBY3Rpb25LaW5kOiAoKSA9PiAoLyogYmluZGluZyAqLyBDb2RlQWN0aW9uS2luZCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIENvZGVBY3Rpb25UcmlnZ2VyS2luZDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gQ29kZUFjdGlvblRyaWdnZXJLaW5kKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgQ29kZURlc2NyaXB0aW9uOiAoKSA9PiAoLyogYmluZGluZyAqLyBDb2RlRGVzY3JpcHRpb24pLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBDb2RlTGVuczogKCkgPT4gKC8qIGJpbmRpbmcgKi8gQ29kZUxlbnMpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBDb2xvcjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gQ29sb3IpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBDb2xvckluZm9ybWF0aW9uOiAoKSA9PiAoLyogYmluZGluZyAqLyBDb2xvckluZm9ybWF0aW9uKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgQ29sb3JQcmVzZW50YXRpb246ICgpID0+ICgvKiBiaW5kaW5nICovIENvbG9yUHJlc2VudGF0aW9uKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgQ29tbWFuZDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gQ29tbWFuZCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIENvbXBsZXRpb25JdGVtOiAoKSA9PiAoLyogYmluZGluZyAqLyBDb21wbGV0aW9uSXRlbSksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIENvbXBsZXRpb25JdGVtS2luZDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gQ29tcGxldGlvbkl0ZW1LaW5kKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgQ29tcGxldGlvbkl0ZW1MYWJlbERldGFpbHM6ICgpID0+ICgvKiBiaW5kaW5nICovIENvbXBsZXRpb25JdGVtTGFiZWxEZXRhaWxzKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgQ29tcGxldGlvbkl0ZW1UYWc6ICgpID0+ICgvKiBiaW5kaW5nICovIENvbXBsZXRpb25JdGVtVGFnKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgQ29tcGxldGlvbkxpc3Q6ICgpID0+ICgvKiBiaW5kaW5nICovIENvbXBsZXRpb25MaXN0KSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgQ3JlYXRlRmlsZTogKCkgPT4gKC8qIGJpbmRpbmcgKi8gQ3JlYXRlRmlsZSksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIERlbGV0ZUZpbGU6ICgpID0+ICgvKiBiaW5kaW5nICovIERlbGV0ZUZpbGUpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBEaWFnbm9zdGljOiAoKSA9PiAoLyogYmluZGluZyAqLyBEaWFnbm9zdGljKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgRGlhZ25vc3RpY1JlbGF0ZWRJbmZvcm1hdGlvbjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gRGlhZ25vc3RpY1JlbGF0ZWRJbmZvcm1hdGlvbiksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIERpYWdub3N0aWNTZXZlcml0eTogKCkgPT4gKC8qIGJpbmRpbmcgKi8gRGlhZ25vc3RpY1NldmVyaXR5KSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgRGlhZ25vc3RpY1RhZzogKCkgPT4gKC8qIGJpbmRpbmcgKi8gRGlhZ25vc3RpY1RhZyksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIERvY3VtZW50SGlnaGxpZ2h0OiAoKSA9PiAoLyogYmluZGluZyAqLyBEb2N1bWVudEhpZ2hsaWdodCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIERvY3VtZW50SGlnaGxpZ2h0S2luZDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gRG9jdW1lbnRIaWdobGlnaHRLaW5kKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgRG9jdW1lbnRMaW5rOiAoKSA9PiAoLyogYmluZGluZyAqLyBEb2N1bWVudExpbmspLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBEb2N1bWVudFN5bWJvbDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gRG9jdW1lbnRTeW1ib2wpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBEb2N1bWVudFVyaTogKCkgPT4gKC8qIGJpbmRpbmcgKi8gRG9jdW1lbnRVcmkpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBFT0w6ICgpID0+ICgvKiBiaW5kaW5nICovIEVPTCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIEZvbGRpbmdSYW5nZTogKCkgPT4gKC8qIGJpbmRpbmcgKi8gRm9sZGluZ1JhbmdlKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgRm9sZGluZ1JhbmdlS2luZDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gRm9sZGluZ1JhbmdlS2luZCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIEZvcm1hdHRpbmdPcHRpb25zOiAoKSA9PiAoLyogYmluZGluZyAqLyBGb3JtYXR0aW5nT3B0aW9ucyksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIEhvdmVyOiAoKSA9PiAoLyogYmluZGluZyAqLyBIb3ZlciksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIElubGF5SGludDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gSW5sYXlIaW50KSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgSW5sYXlIaW50S2luZDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gSW5sYXlIaW50S2luZCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIElubGF5SGludExhYmVsUGFydDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gSW5sYXlIaW50TGFiZWxQYXJ0KSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgSW5saW5lVmFsdWVDb250ZXh0OiAoKSA9PiAoLyogYmluZGluZyAqLyBJbmxpbmVWYWx1ZUNvbnRleHQpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBJbmxpbmVWYWx1ZUV2YWx1YXRhYmxlRXhwcmVzc2lvbjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gSW5saW5lVmFsdWVFdmFsdWF0YWJsZUV4cHJlc3Npb24pLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBJbmxpbmVWYWx1ZVRleHQ6ICgpID0+ICgvKiBiaW5kaW5nICovIElubGluZVZhbHVlVGV4dCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIElubGluZVZhbHVlVmFyaWFibGVMb29rdXA6ICgpID0+ICgvKiBiaW5kaW5nICovIElubGluZVZhbHVlVmFyaWFibGVMb29rdXApLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBJbnNlcnRSZXBsYWNlRWRpdDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gSW5zZXJ0UmVwbGFjZUVkaXQpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBJbnNlcnRUZXh0Rm9ybWF0OiAoKSA9PiAoLyogYmluZGluZyAqLyBJbnNlcnRUZXh0Rm9ybWF0KSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgSW5zZXJ0VGV4dE1vZGU6ICgpID0+ICgvKiBiaW5kaW5nICovIEluc2VydFRleHRNb2RlKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgTG9jYXRpb246ICgpID0+ICgvKiBiaW5kaW5nICovIExvY2F0aW9uKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgTG9jYXRpb25MaW5rOiAoKSA9PiAoLyogYmluZGluZyAqLyBMb2NhdGlvbkxpbmspLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBNYXJrZWRTdHJpbmc6ICgpID0+ICgvKiBiaW5kaW5nICovIE1hcmtlZFN0cmluZyksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIE1hcmt1cENvbnRlbnQ6ICgpID0+ICgvKiBiaW5kaW5nICovIE1hcmt1cENvbnRlbnQpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBNYXJrdXBLaW5kOiAoKSA9PiAoLyogYmluZGluZyAqLyBNYXJrdXBLaW5kKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgT3B0aW9uYWxWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyOiAoKSA9PiAoLyogYmluZGluZyAqLyBPcHRpb25hbFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBQYXJhbWV0ZXJJbmZvcm1hdGlvbjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gUGFyYW1ldGVySW5mb3JtYXRpb24pLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBQb3NpdGlvbjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gUG9zaXRpb24pLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBSYW5nZTogKCkgPT4gKC8qIGJpbmRpbmcgKi8gUmFuZ2UpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBSZW5hbWVGaWxlOiAoKSA9PiAoLyogYmluZGluZyAqLyBSZW5hbWVGaWxlKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgU2VsZWN0aW9uUmFuZ2U6ICgpID0+ICgvKiBiaW5kaW5nICovIFNlbGVjdGlvblJhbmdlKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgU2VtYW50aWNUb2tlbk1vZGlmaWVyczogKCkgPT4gKC8qIGJpbmRpbmcgKi8gU2VtYW50aWNUb2tlbk1vZGlmaWVycyksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFNlbWFudGljVG9rZW5UeXBlczogKCkgPT4gKC8qIGJpbmRpbmcgKi8gU2VtYW50aWNUb2tlblR5cGVzKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgU2VtYW50aWNUb2tlbnM6ICgpID0+ICgvKiBiaW5kaW5nICovIFNlbWFudGljVG9rZW5zKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgU2lnbmF0dXJlSW5mb3JtYXRpb246ICgpID0+ICgvKiBiaW5kaW5nICovIFNpZ25hdHVyZUluZm9ybWF0aW9uKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgU3ltYm9sSW5mb3JtYXRpb246ICgpID0+ICgvKiBiaW5kaW5nICovIFN5bWJvbEluZm9ybWF0aW9uKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgU3ltYm9sS2luZDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gU3ltYm9sS2luZCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFN5bWJvbFRhZzogKCkgPT4gKC8qIGJpbmRpbmcgKi8gU3ltYm9sVGFnKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgVGV4dERvY3VtZW50OiAoKSA9PiAoLyogYmluZGluZyAqLyBUZXh0RG9jdW1lbnQpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBUZXh0RG9jdW1lbnRFZGl0OiAoKSA9PiAoLyogYmluZGluZyAqLyBUZXh0RG9jdW1lbnRFZGl0KSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgVGV4dERvY3VtZW50SWRlbnRpZmllcjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gVGV4dERvY3VtZW50SWRlbnRpZmllciksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFRleHREb2N1bWVudEl0ZW06ICgpID0+ICgvKiBiaW5kaW5nICovIFRleHREb2N1bWVudEl0ZW0pLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBUZXh0RWRpdDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gVGV4dEVkaXQpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBVUkk6ICgpID0+ICgvKiBiaW5kaW5nICovIFVSSSksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXI6ICgpID0+ICgvKiBiaW5kaW5nICovIFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBXb3Jrc3BhY2VDaGFuZ2U6ICgpID0+ICgvKiBiaW5kaW5nICovIFdvcmtzcGFjZUNoYW5nZSksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFdvcmtzcGFjZUVkaXQ6ICgpID0+ICgvKiBiaW5kaW5nICovIFdvcmtzcGFjZUVkaXQpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBXb3Jrc3BhY2VGb2xkZXI6ICgpID0+ICgvKiBiaW5kaW5nICovIFdvcmtzcGFjZUZvbGRlciksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFdvcmtzcGFjZVN5bWJvbDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gV29ya3NwYWNlU3ltYm9sKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgaW50ZWdlcjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gaW50ZWdlciksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIHVpbnRlZ2VyOiAoKSA9PiAoLyogYmluZGluZyAqLyB1aW50ZWdlcilcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG52YXIgRG9jdW1lbnRVcmk7XG4oZnVuY3Rpb24gKERvY3VtZW50VXJpKSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZyc7XG4gICAgfVxuICAgIERvY3VtZW50VXJpLmlzID0gaXM7XG59KShEb2N1bWVudFVyaSB8fCAoRG9jdW1lbnRVcmkgPSB7fSkpO1xudmFyIFVSSTtcbihmdW5jdGlvbiAoVVJJKSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZyc7XG4gICAgfVxuICAgIFVSSS5pcyA9IGlzO1xufSkoVVJJIHx8IChVUkkgPSB7fSkpO1xudmFyIGludGVnZXI7XG4oZnVuY3Rpb24gKGludGVnZXIpIHtcbiAgICBpbnRlZ2VyLk1JTl9WQUxVRSA9IC0yMTQ3NDgzNjQ4O1xuICAgIGludGVnZXIuTUFYX1ZBTFVFID0gMjE0NzQ4MzY0NztcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiBpbnRlZ2VyLk1JTl9WQUxVRSA8PSB2YWx1ZSAmJiB2YWx1ZSA8PSBpbnRlZ2VyLk1BWF9WQUxVRTtcbiAgICB9XG4gICAgaW50ZWdlci5pcyA9IGlzO1xufSkoaW50ZWdlciB8fCAoaW50ZWdlciA9IHt9KSk7XG52YXIgdWludGVnZXI7XG4oZnVuY3Rpb24gKHVpbnRlZ2VyKSB7XG4gICAgdWludGVnZXIuTUlOX1ZBTFVFID0gMDtcbiAgICB1aW50ZWdlci5NQVhfVkFMVUUgPSAyMTQ3NDgzNjQ3O1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIHVpbnRlZ2VyLk1JTl9WQUxVRSA8PSB2YWx1ZSAmJiB2YWx1ZSA8PSB1aW50ZWdlci5NQVhfVkFMVUU7XG4gICAgfVxuICAgIHVpbnRlZ2VyLmlzID0gaXM7XG59KSh1aW50ZWdlciB8fCAodWludGVnZXIgPSB7fSkpO1xuLyoqXG4gKiBUaGUgUG9zaXRpb24gbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgUG9zaXRpb259IGxpdGVyYWxzLlxuICovXG52YXIgUG9zaXRpb247XG4oZnVuY3Rpb24gKFBvc2l0aW9uKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBQb3NpdGlvbiBsaXRlcmFsIGZyb20gdGhlIGdpdmVuIGxpbmUgYW5kIGNoYXJhY3Rlci5cbiAgICAgKiBAcGFyYW0gbGluZSBUaGUgcG9zaXRpb24ncyBsaW5lLlxuICAgICAqIEBwYXJhbSBjaGFyYWN0ZXIgVGhlIHBvc2l0aW9uJ3MgY2hhcmFjdGVyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShsaW5lLCBjaGFyYWN0ZXIpIHtcbiAgICAgICAgaWYgKGxpbmUgPT09IE51bWJlci5NQVhfVkFMVUUpIHtcbiAgICAgICAgICAgIGxpbmUgPSB1aW50ZWdlci5NQVhfVkFMVUU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYXJhY3RlciA9PT0gTnVtYmVyLk1BWF9WQUxVRSkge1xuICAgICAgICAgICAgY2hhcmFjdGVyID0gdWludGVnZXIuTUFYX1ZBTFVFO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGxpbmU6IGxpbmUsIGNoYXJhY3RlcjogY2hhcmFjdGVyIH07XG4gICAgfVxuICAgIFBvc2l0aW9uLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbGl0ZXJhbCBjb25mb3JtcyB0byB0aGUge0BsaW5rIFBvc2l0aW9ufSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpICYmIElzLnVpbnRlZ2VyKGNhbmRpZGF0ZS5saW5lKSAmJiBJcy51aW50ZWdlcihjYW5kaWRhdGUuY2hhcmFjdGVyKTtcbiAgICB9XG4gICAgUG9zaXRpb24uaXMgPSBpcztcbn0pKFBvc2l0aW9uIHx8IChQb3NpdGlvbiA9IHt9KSk7XG4vKipcbiAqIFRoZSBSYW5nZSBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBSYW5nZX0gbGl0ZXJhbHMuXG4gKi9cbnZhciBSYW5nZTtcbihmdW5jdGlvbiAoUmFuZ2UpIHtcbiAgICBmdW5jdGlvbiBjcmVhdGUob25lLCB0d28sIHRocmVlLCBmb3VyKSB7XG4gICAgICAgIGlmIChJcy51aW50ZWdlcihvbmUpICYmIElzLnVpbnRlZ2VyKHR3bykgJiYgSXMudWludGVnZXIodGhyZWUpICYmIElzLnVpbnRlZ2VyKGZvdXIpKSB7XG4gICAgICAgICAgICByZXR1cm4geyBzdGFydDogUG9zaXRpb24uY3JlYXRlKG9uZSwgdHdvKSwgZW5kOiBQb3NpdGlvbi5jcmVhdGUodGhyZWUsIGZvdXIpIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoUG9zaXRpb24uaXMob25lKSAmJiBQb3NpdGlvbi5pcyh0d28pKSB7XG4gICAgICAgICAgICByZXR1cm4geyBzdGFydDogb25lLCBlbmQ6IHR3byB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmFuZ2UjY3JlYXRlIGNhbGxlZCB3aXRoIGludmFsaWQgYXJndW1lbnRzW1wiLmNvbmNhdChvbmUsIFwiLCBcIikuY29uY2F0KHR3bywgXCIsIFwiKS5jb25jYXQodGhyZWUsIFwiLCBcIikuY29uY2F0KGZvdXIsIFwiXVwiKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgUmFuZ2UuY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgUmFuZ2V9IGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgUG9zaXRpb24uaXMoY2FuZGlkYXRlLnN0YXJ0KSAmJiBQb3NpdGlvbi5pcyhjYW5kaWRhdGUuZW5kKTtcbiAgICB9XG4gICAgUmFuZ2UuaXMgPSBpcztcbn0pKFJhbmdlIHx8IChSYW5nZSA9IHt9KSk7XG4vKipcbiAqIFRoZSBMb2NhdGlvbiBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBMb2NhdGlvbn0gbGl0ZXJhbHMuXG4gKi9cbnZhciBMb2NhdGlvbjtcbihmdW5jdGlvbiAoTG9jYXRpb24pIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgTG9jYXRpb24gbGl0ZXJhbC5cbiAgICAgKiBAcGFyYW0gdXJpIFRoZSBsb2NhdGlvbidzIHVyaS5cbiAgICAgKiBAcGFyYW0gcmFuZ2UgVGhlIGxvY2F0aW9uJ3MgcmFuZ2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHVyaSwgcmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIHsgdXJpOiB1cmksIHJhbmdlOiByYW5nZSB9O1xuICAgIH1cbiAgICBMb2NhdGlvbi5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBMb2NhdGlvbn0gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKSAmJiBSYW5nZS5pcyhjYW5kaWRhdGUucmFuZ2UpICYmIChJcy5zdHJpbmcoY2FuZGlkYXRlLnVyaSkgfHwgSXMudW5kZWZpbmVkKGNhbmRpZGF0ZS51cmkpKTtcbiAgICB9XG4gICAgTG9jYXRpb24uaXMgPSBpcztcbn0pKExvY2F0aW9uIHx8IChMb2NhdGlvbiA9IHt9KSk7XG4vKipcbiAqIFRoZSBMb2NhdGlvbkxpbmsgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgTG9jYXRpb25MaW5rfSBsaXRlcmFscy5cbiAqL1xudmFyIExvY2F0aW9uTGluaztcbihmdW5jdGlvbiAoTG9jYXRpb25MaW5rKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIExvY2F0aW9uTGluayBsaXRlcmFsLlxuICAgICAqIEBwYXJhbSB0YXJnZXRVcmkgVGhlIGRlZmluaXRpb24ncyB1cmkuXG4gICAgICogQHBhcmFtIHRhcmdldFJhbmdlIFRoZSBmdWxsIHJhbmdlIG9mIHRoZSBkZWZpbml0aW9uLlxuICAgICAqIEBwYXJhbSB0YXJnZXRTZWxlY3Rpb25SYW5nZSBUaGUgc3BhbiBvZiB0aGUgc3ltYm9sIGRlZmluaXRpb24gYXQgdGhlIHRhcmdldC5cbiAgICAgKiBAcGFyYW0gb3JpZ2luU2VsZWN0aW9uUmFuZ2UgVGhlIHNwYW4gb2YgdGhlIHN5bWJvbCBiZWluZyBkZWZpbmVkIGluIHRoZSBvcmlnaW5hdGluZyBzb3VyY2UgZmlsZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUodGFyZ2V0VXJpLCB0YXJnZXRSYW5nZSwgdGFyZ2V0U2VsZWN0aW9uUmFuZ2UsIG9yaWdpblNlbGVjdGlvblJhbmdlKSB7XG4gICAgICAgIHJldHVybiB7IHRhcmdldFVyaTogdGFyZ2V0VXJpLCB0YXJnZXRSYW5nZTogdGFyZ2V0UmFuZ2UsIHRhcmdldFNlbGVjdGlvblJhbmdlOiB0YXJnZXRTZWxlY3Rpb25SYW5nZSwgb3JpZ2luU2VsZWN0aW9uUmFuZ2U6IG9yaWdpblNlbGVjdGlvblJhbmdlIH07XG4gICAgfVxuICAgIExvY2F0aW9uTGluay5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBMb2NhdGlvbkxpbmt9IGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgUmFuZ2UuaXMoY2FuZGlkYXRlLnRhcmdldFJhbmdlKSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLnRhcmdldFVyaSlcbiAgICAgICAgICAgICYmIFJhbmdlLmlzKGNhbmRpZGF0ZS50YXJnZXRTZWxlY3Rpb25SYW5nZSlcbiAgICAgICAgICAgICYmIChSYW5nZS5pcyhjYW5kaWRhdGUub3JpZ2luU2VsZWN0aW9uUmFuZ2UpIHx8IElzLnVuZGVmaW5lZChjYW5kaWRhdGUub3JpZ2luU2VsZWN0aW9uUmFuZ2UpKTtcbiAgICB9XG4gICAgTG9jYXRpb25MaW5rLmlzID0gaXM7XG59KShMb2NhdGlvbkxpbmsgfHwgKExvY2F0aW9uTGluayA9IHt9KSk7XG4vKipcbiAqIFRoZSBDb2xvciBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBDb2xvcn0gbGl0ZXJhbHMuXG4gKi9cbnZhciBDb2xvcjtcbihmdW5jdGlvbiAoQ29sb3IpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IENvbG9yIGxpdGVyYWwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHJlZCwgZ3JlZW4sIGJsdWUsIGFscGhhKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZWQ6IHJlZCxcbiAgICAgICAgICAgIGdyZWVuOiBncmVlbixcbiAgICAgICAgICAgIGJsdWU6IGJsdWUsXG4gICAgICAgICAgICBhbHBoYTogYWxwaGEsXG4gICAgICAgIH07XG4gICAgfVxuICAgIENvbG9yLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbGl0ZXJhbCBjb25mb3JtcyB0byB0aGUge0BsaW5rIENvbG9yfSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpICYmIElzLm51bWJlclJhbmdlKGNhbmRpZGF0ZS5yZWQsIDAsIDEpXG4gICAgICAgICAgICAmJiBJcy5udW1iZXJSYW5nZShjYW5kaWRhdGUuZ3JlZW4sIDAsIDEpXG4gICAgICAgICAgICAmJiBJcy5udW1iZXJSYW5nZShjYW5kaWRhdGUuYmx1ZSwgMCwgMSlcbiAgICAgICAgICAgICYmIElzLm51bWJlclJhbmdlKGNhbmRpZGF0ZS5hbHBoYSwgMCwgMSk7XG4gICAgfVxuICAgIENvbG9yLmlzID0gaXM7XG59KShDb2xvciB8fCAoQ29sb3IgPSB7fSkpO1xuLyoqXG4gKiBUaGUgQ29sb3JJbmZvcm1hdGlvbiBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBDb2xvckluZm9ybWF0aW9ufSBsaXRlcmFscy5cbiAqL1xudmFyIENvbG9ySW5mb3JtYXRpb247XG4oZnVuY3Rpb24gKENvbG9ySW5mb3JtYXRpb24pIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IENvbG9ySW5mb3JtYXRpb24gbGl0ZXJhbC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUocmFuZ2UsIGNvbG9yKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByYW5nZTogcmFuZ2UsXG4gICAgICAgICAgICBjb2xvcjogY29sb3IsXG4gICAgICAgIH07XG4gICAgfVxuICAgIENvbG9ySW5mb3JtYXRpb24uY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgQ29sb3JJbmZvcm1hdGlvbn0gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKSAmJiBSYW5nZS5pcyhjYW5kaWRhdGUucmFuZ2UpICYmIENvbG9yLmlzKGNhbmRpZGF0ZS5jb2xvcik7XG4gICAgfVxuICAgIENvbG9ySW5mb3JtYXRpb24uaXMgPSBpcztcbn0pKENvbG9ySW5mb3JtYXRpb24gfHwgKENvbG9ySW5mb3JtYXRpb24gPSB7fSkpO1xuLyoqXG4gKiBUaGUgQ29sb3IgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgQ29sb3JQcmVzZW50YXRpb259IGxpdGVyYWxzLlxuICovXG52YXIgQ29sb3JQcmVzZW50YXRpb247XG4oZnVuY3Rpb24gKENvbG9yUHJlc2VudGF0aW9uKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBDb2xvckluZm9ybWF0aW9uIGxpdGVyYWwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKGxhYmVsLCB0ZXh0RWRpdCwgYWRkaXRpb25hbFRleHRFZGl0cykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGFiZWw6IGxhYmVsLFxuICAgICAgICAgICAgdGV4dEVkaXQ6IHRleHRFZGl0LFxuICAgICAgICAgICAgYWRkaXRpb25hbFRleHRFZGl0czogYWRkaXRpb25hbFRleHRFZGl0cyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgQ29sb3JQcmVzZW50YXRpb24uY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgQ29sb3JJbmZvcm1hdGlvbn0gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLmxhYmVsKVxuICAgICAgICAgICAgJiYgKElzLnVuZGVmaW5lZChjYW5kaWRhdGUudGV4dEVkaXQpIHx8IFRleHRFZGl0LmlzKGNhbmRpZGF0ZSkpXG4gICAgICAgICAgICAmJiAoSXMudW5kZWZpbmVkKGNhbmRpZGF0ZS5hZGRpdGlvbmFsVGV4dEVkaXRzKSB8fCBJcy50eXBlZEFycmF5KGNhbmRpZGF0ZS5hZGRpdGlvbmFsVGV4dEVkaXRzLCBUZXh0RWRpdC5pcykpO1xuICAgIH1cbiAgICBDb2xvclByZXNlbnRhdGlvbi5pcyA9IGlzO1xufSkoQ29sb3JQcmVzZW50YXRpb24gfHwgKENvbG9yUHJlc2VudGF0aW9uID0ge30pKTtcbi8qKlxuICogQSBzZXQgb2YgcHJlZGVmaW5lZCByYW5nZSBraW5kcy5cbiAqL1xudmFyIEZvbGRpbmdSYW5nZUtpbmQ7XG4oZnVuY3Rpb24gKEZvbGRpbmdSYW5nZUtpbmQpIHtcbiAgICAvKipcbiAgICAgKiBGb2xkaW5nIHJhbmdlIGZvciBhIGNvbW1lbnRcbiAgICAgKi9cbiAgICBGb2xkaW5nUmFuZ2VLaW5kLkNvbW1lbnQgPSAnY29tbWVudCc7XG4gICAgLyoqXG4gICAgICogRm9sZGluZyByYW5nZSBmb3IgYW4gaW1wb3J0IG9yIGluY2x1ZGVcbiAgICAgKi9cbiAgICBGb2xkaW5nUmFuZ2VLaW5kLkltcG9ydHMgPSAnaW1wb3J0cyc7XG4gICAgLyoqXG4gICAgICogRm9sZGluZyByYW5nZSBmb3IgYSByZWdpb24gKGUuZy4gYCNyZWdpb25gKVxuICAgICAqL1xuICAgIEZvbGRpbmdSYW5nZUtpbmQuUmVnaW9uID0gJ3JlZ2lvbic7XG59KShGb2xkaW5nUmFuZ2VLaW5kIHx8IChGb2xkaW5nUmFuZ2VLaW5kID0ge30pKTtcbi8qKlxuICogVGhlIGZvbGRpbmcgcmFuZ2UgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgRm9sZGluZ1JhbmdlfSBsaXRlcmFscy5cbiAqL1xudmFyIEZvbGRpbmdSYW5nZTtcbihmdW5jdGlvbiAoRm9sZGluZ1JhbmdlKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBGb2xkaW5nUmFuZ2UgbGl0ZXJhbC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUoc3RhcnRMaW5lLCBlbmRMaW5lLCBzdGFydENoYXJhY3RlciwgZW5kQ2hhcmFjdGVyLCBraW5kLCBjb2xsYXBzZWRUZXh0KSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgICAgICBzdGFydExpbmU6IHN0YXJ0TGluZSxcbiAgICAgICAgICAgIGVuZExpbmU6IGVuZExpbmVcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKElzLmRlZmluZWQoc3RhcnRDaGFyYWN0ZXIpKSB7XG4gICAgICAgICAgICByZXN1bHQuc3RhcnRDaGFyYWN0ZXIgPSBzdGFydENoYXJhY3RlcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoSXMuZGVmaW5lZChlbmRDaGFyYWN0ZXIpKSB7XG4gICAgICAgICAgICByZXN1bHQuZW5kQ2hhcmFjdGVyID0gZW5kQ2hhcmFjdGVyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChJcy5kZWZpbmVkKGtpbmQpKSB7XG4gICAgICAgICAgICByZXN1bHQua2luZCA9IGtpbmQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKElzLmRlZmluZWQoY29sbGFwc2VkVGV4dCkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5jb2xsYXBzZWRUZXh0ID0gY29sbGFwc2VkVGV4dDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBGb2xkaW5nUmFuZ2UuY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgRm9sZGluZ1JhbmdlfSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpICYmIElzLnVpbnRlZ2VyKGNhbmRpZGF0ZS5zdGFydExpbmUpICYmIElzLnVpbnRlZ2VyKGNhbmRpZGF0ZS5zdGFydExpbmUpXG4gICAgICAgICAgICAmJiAoSXMudW5kZWZpbmVkKGNhbmRpZGF0ZS5zdGFydENoYXJhY3RlcikgfHwgSXMudWludGVnZXIoY2FuZGlkYXRlLnN0YXJ0Q2hhcmFjdGVyKSlcbiAgICAgICAgICAgICYmIChJcy51bmRlZmluZWQoY2FuZGlkYXRlLmVuZENoYXJhY3RlcikgfHwgSXMudWludGVnZXIoY2FuZGlkYXRlLmVuZENoYXJhY3RlcikpXG4gICAgICAgICAgICAmJiAoSXMudW5kZWZpbmVkKGNhbmRpZGF0ZS5raW5kKSB8fCBJcy5zdHJpbmcoY2FuZGlkYXRlLmtpbmQpKTtcbiAgICB9XG4gICAgRm9sZGluZ1JhbmdlLmlzID0gaXM7XG59KShGb2xkaW5nUmFuZ2UgfHwgKEZvbGRpbmdSYW5nZSA9IHt9KSk7XG4vKipcbiAqIFRoZSBEaWFnbm9zdGljUmVsYXRlZEluZm9ybWF0aW9uIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICoge0BsaW5rIERpYWdub3N0aWNSZWxhdGVkSW5mb3JtYXRpb259IGxpdGVyYWxzLlxuICovXG52YXIgRGlhZ25vc3RpY1JlbGF0ZWRJbmZvcm1hdGlvbjtcbihmdW5jdGlvbiAoRGlhZ25vc3RpY1JlbGF0ZWRJbmZvcm1hdGlvbikge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgRGlhZ25vc3RpY1JlbGF0ZWRJbmZvcm1hdGlvbiBsaXRlcmFsLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShsb2NhdGlvbiwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbG9jYXRpb246IGxvY2F0aW9uLFxuICAgICAgICAgICAgbWVzc2FnZTogbWVzc2FnZVxuICAgICAgICB9O1xuICAgIH1cbiAgICBEaWFnbm9zdGljUmVsYXRlZEluZm9ybWF0aW9uLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbGl0ZXJhbCBjb25mb3JtcyB0byB0aGUge0BsaW5rIERpYWdub3N0aWNSZWxhdGVkSW5mb3JtYXRpb259IGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5kZWZpbmVkKGNhbmRpZGF0ZSkgJiYgTG9jYXRpb24uaXMoY2FuZGlkYXRlLmxvY2F0aW9uKSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLm1lc3NhZ2UpO1xuICAgIH1cbiAgICBEaWFnbm9zdGljUmVsYXRlZEluZm9ybWF0aW9uLmlzID0gaXM7XG59KShEaWFnbm9zdGljUmVsYXRlZEluZm9ybWF0aW9uIHx8IChEaWFnbm9zdGljUmVsYXRlZEluZm9ybWF0aW9uID0ge30pKTtcbi8qKlxuICogVGhlIGRpYWdub3N0aWMncyBzZXZlcml0eS5cbiAqL1xudmFyIERpYWdub3N0aWNTZXZlcml0eTtcbihmdW5jdGlvbiAoRGlhZ25vc3RpY1NldmVyaXR5KSB7XG4gICAgLyoqXG4gICAgICogUmVwb3J0cyBhbiBlcnJvci5cbiAgICAgKi9cbiAgICBEaWFnbm9zdGljU2V2ZXJpdHkuRXJyb3IgPSAxO1xuICAgIC8qKlxuICAgICAqIFJlcG9ydHMgYSB3YXJuaW5nLlxuICAgICAqL1xuICAgIERpYWdub3N0aWNTZXZlcml0eS5XYXJuaW5nID0gMjtcbiAgICAvKipcbiAgICAgKiBSZXBvcnRzIGFuIGluZm9ybWF0aW9uLlxuICAgICAqL1xuICAgIERpYWdub3N0aWNTZXZlcml0eS5JbmZvcm1hdGlvbiA9IDM7XG4gICAgLyoqXG4gICAgICogUmVwb3J0cyBhIGhpbnQuXG4gICAgICovXG4gICAgRGlhZ25vc3RpY1NldmVyaXR5LkhpbnQgPSA0O1xufSkoRGlhZ25vc3RpY1NldmVyaXR5IHx8IChEaWFnbm9zdGljU2V2ZXJpdHkgPSB7fSkpO1xuLyoqXG4gKiBUaGUgZGlhZ25vc3RpYyB0YWdzLlxuICpcbiAqIEBzaW5jZSAzLjE1LjBcbiAqL1xudmFyIERpYWdub3N0aWNUYWc7XG4oZnVuY3Rpb24gKERpYWdub3N0aWNUYWcpIHtcbiAgICAvKipcbiAgICAgKiBVbnVzZWQgb3IgdW5uZWNlc3NhcnkgY29kZS5cbiAgICAgKlxuICAgICAqIENsaWVudHMgYXJlIGFsbG93ZWQgdG8gcmVuZGVyIGRpYWdub3N0aWNzIHdpdGggdGhpcyB0YWcgZmFkZWQgb3V0IGluc3RlYWQgb2YgaGF2aW5nXG4gICAgICogYW4gZXJyb3Igc3F1aWdnbGUuXG4gICAgICovXG4gICAgRGlhZ25vc3RpY1RhZy5Vbm5lY2Vzc2FyeSA9IDE7XG4gICAgLyoqXG4gICAgICogRGVwcmVjYXRlZCBvciBvYnNvbGV0ZSBjb2RlLlxuICAgICAqXG4gICAgICogQ2xpZW50cyBhcmUgYWxsb3dlZCB0byByZW5kZXJlZCBkaWFnbm9zdGljcyB3aXRoIHRoaXMgdGFnIHN0cmlrZSB0aHJvdWdoLlxuICAgICAqL1xuICAgIERpYWdub3N0aWNUYWcuRGVwcmVjYXRlZCA9IDI7XG59KShEaWFnbm9zdGljVGFnIHx8IChEaWFnbm9zdGljVGFnID0ge30pKTtcbi8qKlxuICogVGhlIENvZGVEZXNjcmlwdGlvbiBuYW1lc3BhY2UgcHJvdmlkZXMgZnVuY3Rpb25zIHRvIGRlYWwgd2l0aCBkZXNjcmlwdGlvbnMgZm9yIGRpYWdub3N0aWMgY29kZXMuXG4gKlxuICogQHNpbmNlIDMuMTYuMFxuICovXG52YXIgQ29kZURlc2NyaXB0aW9uO1xuKGZ1bmN0aW9uIChDb2RlRGVzY3JpcHRpb24pIHtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS5ocmVmKTtcbiAgICB9XG4gICAgQ29kZURlc2NyaXB0aW9uLmlzID0gaXM7XG59KShDb2RlRGVzY3JpcHRpb24gfHwgKENvZGVEZXNjcmlwdGlvbiA9IHt9KSk7XG4vKipcbiAqIFRoZSBEaWFnbm9zdGljIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICoge0BsaW5rIERpYWdub3N0aWN9IGxpdGVyYWxzLlxuICovXG52YXIgRGlhZ25vc3RpYztcbihmdW5jdGlvbiAoRGlhZ25vc3RpYykge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgRGlhZ25vc3RpYyBsaXRlcmFsLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShyYW5nZSwgbWVzc2FnZSwgc2V2ZXJpdHksIGNvZGUsIHNvdXJjZSwgcmVsYXRlZEluZm9ybWF0aW9uKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB7IHJhbmdlOiByYW5nZSwgbWVzc2FnZTogbWVzc2FnZSB9O1xuICAgICAgICBpZiAoSXMuZGVmaW5lZChzZXZlcml0eSkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5zZXZlcml0eSA9IHNldmVyaXR5O1xuICAgICAgICB9XG4gICAgICAgIGlmIChJcy5kZWZpbmVkKGNvZGUpKSB7XG4gICAgICAgICAgICByZXN1bHQuY29kZSA9IGNvZGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKElzLmRlZmluZWQoc291cmNlKSkge1xuICAgICAgICAgICAgcmVzdWx0LnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoSXMuZGVmaW5lZChyZWxhdGVkSW5mb3JtYXRpb24pKSB7XG4gICAgICAgICAgICByZXN1bHQucmVsYXRlZEluZm9ybWF0aW9uID0gcmVsYXRlZEluZm9ybWF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIERpYWdub3N0aWMuY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgRGlhZ25vc3RpY30gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMuZGVmaW5lZChjYW5kaWRhdGUpXG4gICAgICAgICAgICAmJiBSYW5nZS5pcyhjYW5kaWRhdGUucmFuZ2UpXG4gICAgICAgICAgICAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLm1lc3NhZ2UpXG4gICAgICAgICAgICAmJiAoSXMubnVtYmVyKGNhbmRpZGF0ZS5zZXZlcml0eSkgfHwgSXMudW5kZWZpbmVkKGNhbmRpZGF0ZS5zZXZlcml0eSkpXG4gICAgICAgICAgICAmJiAoSXMuaW50ZWdlcihjYW5kaWRhdGUuY29kZSkgfHwgSXMuc3RyaW5nKGNhbmRpZGF0ZS5jb2RlKSB8fCBJcy51bmRlZmluZWQoY2FuZGlkYXRlLmNvZGUpKVxuICAgICAgICAgICAgJiYgKElzLnVuZGVmaW5lZChjYW5kaWRhdGUuY29kZURlc2NyaXB0aW9uKSB8fCAoSXMuc3RyaW5nKChfYSA9IGNhbmRpZGF0ZS5jb2RlRGVzY3JpcHRpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5ocmVmKSkpXG4gICAgICAgICAgICAmJiAoSXMuc3RyaW5nKGNhbmRpZGF0ZS5zb3VyY2UpIHx8IElzLnVuZGVmaW5lZChjYW5kaWRhdGUuc291cmNlKSlcbiAgICAgICAgICAgICYmIChJcy51bmRlZmluZWQoY2FuZGlkYXRlLnJlbGF0ZWRJbmZvcm1hdGlvbikgfHwgSXMudHlwZWRBcnJheShjYW5kaWRhdGUucmVsYXRlZEluZm9ybWF0aW9uLCBEaWFnbm9zdGljUmVsYXRlZEluZm9ybWF0aW9uLmlzKSk7XG4gICAgfVxuICAgIERpYWdub3N0aWMuaXMgPSBpcztcbn0pKERpYWdub3N0aWMgfHwgKERpYWdub3N0aWMgPSB7fSkpO1xuLyoqXG4gKiBUaGUgQ29tbWFuZCBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBDb21tYW5kfSBsaXRlcmFscy5cbiAqL1xudmFyIENvbW1hbmQ7XG4oZnVuY3Rpb24gKENvbW1hbmQpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IENvbW1hbmQgbGl0ZXJhbC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUodGl0bGUsIGNvbW1hbmQpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAyOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2kgLSAyXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3VsdCA9IHsgdGl0bGU6IHRpdGxlLCBjb21tYW5kOiBjb21tYW5kIH07XG4gICAgICAgIGlmIChJcy5kZWZpbmVkKGFyZ3MpICYmIGFyZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmVzdWx0LmFyZ3VtZW50cyA9IGFyZ3M7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgQ29tbWFuZC5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBDb21tYW5kfSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMuZGVmaW5lZChjYW5kaWRhdGUpICYmIElzLnN0cmluZyhjYW5kaWRhdGUudGl0bGUpICYmIElzLnN0cmluZyhjYW5kaWRhdGUuY29tbWFuZCk7XG4gICAgfVxuICAgIENvbW1hbmQuaXMgPSBpcztcbn0pKENvbW1hbmQgfHwgKENvbW1hbmQgPSB7fSkpO1xuLyoqXG4gKiBUaGUgVGV4dEVkaXQgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbiB0byBjcmVhdGUgcmVwbGFjZSxcbiAqIGluc2VydCBhbmQgZGVsZXRlIGVkaXRzIG1vcmUgZWFzaWx5LlxuICovXG52YXIgVGV4dEVkaXQ7XG4oZnVuY3Rpb24gKFRleHRFZGl0KSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHJlcGxhY2UgdGV4dCBlZGl0LlxuICAgICAqIEBwYXJhbSByYW5nZSBUaGUgcmFuZ2Ugb2YgdGV4dCB0byBiZSByZXBsYWNlZC5cbiAgICAgKiBAcGFyYW0gbmV3VGV4dCBUaGUgbmV3IHRleHQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVwbGFjZShyYW5nZSwgbmV3VGV4dCkge1xuICAgICAgICByZXR1cm4geyByYW5nZTogcmFuZ2UsIG5ld1RleHQ6IG5ld1RleHQgfTtcbiAgICB9XG4gICAgVGV4dEVkaXQucmVwbGFjZSA9IHJlcGxhY2U7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBpbnNlcnQgdGV4dCBlZGl0LlxuICAgICAqIEBwYXJhbSBwb3NpdGlvbiBUaGUgcG9zaXRpb24gdG8gaW5zZXJ0IHRoZSB0ZXh0IGF0LlxuICAgICAqIEBwYXJhbSBuZXdUZXh0IFRoZSB0ZXh0IHRvIGJlIGluc2VydGVkLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluc2VydChwb3NpdGlvbiwgbmV3VGV4dCkge1xuICAgICAgICByZXR1cm4geyByYW5nZTogeyBzdGFydDogcG9zaXRpb24sIGVuZDogcG9zaXRpb24gfSwgbmV3VGV4dDogbmV3VGV4dCB9O1xuICAgIH1cbiAgICBUZXh0RWRpdC5pbnNlcnQgPSBpbnNlcnQ7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGRlbGV0ZSB0ZXh0IGVkaXQuXG4gICAgICogQHBhcmFtIHJhbmdlIFRoZSByYW5nZSBvZiB0ZXh0IHRvIGJlIGRlbGV0ZWQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGVsKHJhbmdlKSB7XG4gICAgICAgIHJldHVybiB7IHJhbmdlOiByYW5nZSwgbmV3VGV4dDogJycgfTtcbiAgICB9XG4gICAgVGV4dEVkaXQuZGVsID0gZGVsO1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKVxuICAgICAgICAgICAgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS5uZXdUZXh0KVxuICAgICAgICAgICAgJiYgUmFuZ2UuaXMoY2FuZGlkYXRlLnJhbmdlKTtcbiAgICB9XG4gICAgVGV4dEVkaXQuaXMgPSBpcztcbn0pKFRleHRFZGl0IHx8IChUZXh0RWRpdCA9IHt9KSk7XG52YXIgQ2hhbmdlQW5ub3RhdGlvbjtcbihmdW5jdGlvbiAoQ2hhbmdlQW5ub3RhdGlvbikge1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShsYWJlbCwgbmVlZHNDb25maXJtYXRpb24sIGRlc2NyaXB0aW9uKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB7IGxhYmVsOiBsYWJlbCB9O1xuICAgICAgICBpZiAobmVlZHNDb25maXJtYXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzdWx0Lm5lZWRzQ29uZmlybWF0aW9uID0gbmVlZHNDb25maXJtYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlc2NyaXB0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlc3VsdC5kZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIENoYW5nZUFubm90YXRpb24uY3JlYXRlID0gY3JlYXRlO1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLmxhYmVsKSAmJlxuICAgICAgICAgICAgKElzLmJvb2xlYW4oY2FuZGlkYXRlLm5lZWRzQ29uZmlybWF0aW9uKSB8fCBjYW5kaWRhdGUubmVlZHNDb25maXJtYXRpb24gPT09IHVuZGVmaW5lZCkgJiZcbiAgICAgICAgICAgIChJcy5zdHJpbmcoY2FuZGlkYXRlLmRlc2NyaXB0aW9uKSB8fCBjYW5kaWRhdGUuZGVzY3JpcHRpb24gPT09IHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIENoYW5nZUFubm90YXRpb24uaXMgPSBpcztcbn0pKENoYW5nZUFubm90YXRpb24gfHwgKENoYW5nZUFubm90YXRpb24gPSB7fSkpO1xudmFyIENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyO1xuKGZ1bmN0aW9uIChDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllcikge1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLnN0cmluZyhjYW5kaWRhdGUpO1xuICAgIH1cbiAgICBDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllci5pcyA9IGlzO1xufSkoQ2hhbmdlQW5ub3RhdGlvbklkZW50aWZpZXIgfHwgKENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyID0ge30pKTtcbnZhciBBbm5vdGF0ZWRUZXh0RWRpdDtcbihmdW5jdGlvbiAoQW5ub3RhdGVkVGV4dEVkaXQpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFubm90YXRlZCByZXBsYWNlIHRleHQgZWRpdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSByYW5nZSBUaGUgcmFuZ2Ugb2YgdGV4dCB0byBiZSByZXBsYWNlZC5cbiAgICAgKiBAcGFyYW0gbmV3VGV4dCBUaGUgbmV3IHRleHQuXG4gICAgICogQHBhcmFtIGFubm90YXRpb24gVGhlIGFubm90YXRpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVwbGFjZShyYW5nZSwgbmV3VGV4dCwgYW5ub3RhdGlvbikge1xuICAgICAgICByZXR1cm4geyByYW5nZTogcmFuZ2UsIG5ld1RleHQ6IG5ld1RleHQsIGFubm90YXRpb25JZDogYW5ub3RhdGlvbiB9O1xuICAgIH1cbiAgICBBbm5vdGF0ZWRUZXh0RWRpdC5yZXBsYWNlID0gcmVwbGFjZTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFubm90YXRlZCBpbnNlcnQgdGV4dCBlZGl0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHBvc2l0aW9uIFRoZSBwb3NpdGlvbiB0byBpbnNlcnQgdGhlIHRleHQgYXQuXG4gICAgICogQHBhcmFtIG5ld1RleHQgVGhlIHRleHQgdG8gYmUgaW5zZXJ0ZWQuXG4gICAgICogQHBhcmFtIGFubm90YXRpb24gVGhlIGFubm90YXRpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5zZXJ0KHBvc2l0aW9uLCBuZXdUZXh0LCBhbm5vdGF0aW9uKSB7XG4gICAgICAgIHJldHVybiB7IHJhbmdlOiB7IHN0YXJ0OiBwb3NpdGlvbiwgZW5kOiBwb3NpdGlvbiB9LCBuZXdUZXh0OiBuZXdUZXh0LCBhbm5vdGF0aW9uSWQ6IGFubm90YXRpb24gfTtcbiAgICB9XG4gICAgQW5ub3RhdGVkVGV4dEVkaXQuaW5zZXJ0ID0gaW5zZXJ0O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYW5ub3RhdGVkIGRlbGV0ZSB0ZXh0IGVkaXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcmFuZ2UgVGhlIHJhbmdlIG9mIHRleHQgdG8gYmUgZGVsZXRlZC5cbiAgICAgKiBAcGFyYW0gYW5ub3RhdGlvbiBUaGUgYW5ub3RhdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkZWwocmFuZ2UsIGFubm90YXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHsgcmFuZ2U6IHJhbmdlLCBuZXdUZXh0OiAnJywgYW5ub3RhdGlvbklkOiBhbm5vdGF0aW9uIH07XG4gICAgfVxuICAgIEFubm90YXRlZFRleHRFZGl0LmRlbCA9IGRlbDtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBUZXh0RWRpdC5pcyhjYW5kaWRhdGUpICYmIChDaGFuZ2VBbm5vdGF0aW9uLmlzKGNhbmRpZGF0ZS5hbm5vdGF0aW9uSWQpIHx8IENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyLmlzKGNhbmRpZGF0ZS5hbm5vdGF0aW9uSWQpKTtcbiAgICB9XG4gICAgQW5ub3RhdGVkVGV4dEVkaXQuaXMgPSBpcztcbn0pKEFubm90YXRlZFRleHRFZGl0IHx8IChBbm5vdGF0ZWRUZXh0RWRpdCA9IHt9KSk7XG4vKipcbiAqIFRoZSBUZXh0RG9jdW1lbnRFZGl0IG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb24gdG8gY3JlYXRlXG4gKiBhbiBlZGl0IHRoYXQgbWFuaXB1bGF0ZXMgYSB0ZXh0IGRvY3VtZW50LlxuICovXG52YXIgVGV4dERvY3VtZW50RWRpdDtcbihmdW5jdGlvbiAoVGV4dERvY3VtZW50RWRpdCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgYFRleHREb2N1bWVudEVkaXRgXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHRleHREb2N1bWVudCwgZWRpdHMpIHtcbiAgICAgICAgcmV0dXJuIHsgdGV4dERvY3VtZW50OiB0ZXh0RG9jdW1lbnQsIGVkaXRzOiBlZGl0cyB9O1xuICAgIH1cbiAgICBUZXh0RG9jdW1lbnRFZGl0LmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5kZWZpbmVkKGNhbmRpZGF0ZSlcbiAgICAgICAgICAgICYmIE9wdGlvbmFsVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllci5pcyhjYW5kaWRhdGUudGV4dERvY3VtZW50KVxuICAgICAgICAgICAgJiYgQXJyYXkuaXNBcnJheShjYW5kaWRhdGUuZWRpdHMpO1xuICAgIH1cbiAgICBUZXh0RG9jdW1lbnRFZGl0LmlzID0gaXM7XG59KShUZXh0RG9jdW1lbnRFZGl0IHx8IChUZXh0RG9jdW1lbnRFZGl0ID0ge30pKTtcbnZhciBDcmVhdGVGaWxlO1xuKGZ1bmN0aW9uIChDcmVhdGVGaWxlKSB7XG4gICAgZnVuY3Rpb24gY3JlYXRlKHVyaSwgb3B0aW9ucywgYW5ub3RhdGlvbikge1xuICAgICAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgICAgICAga2luZDogJ2NyZWF0ZScsXG4gICAgICAgICAgICB1cmk6IHVyaVxuICAgICAgICB9O1xuICAgICAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkICYmIChvcHRpb25zLm92ZXJ3cml0ZSAhPT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMuaWdub3JlSWZFeGlzdHMgIT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgfVxuICAgICAgICBpZiAoYW5ub3RhdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXN1bHQuYW5ub3RhdGlvbklkID0gYW5ub3RhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBDcmVhdGVGaWxlLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgJiYgY2FuZGlkYXRlLmtpbmQgPT09ICdjcmVhdGUnICYmIElzLnN0cmluZyhjYW5kaWRhdGUudXJpKSAmJiAoY2FuZGlkYXRlLm9wdGlvbnMgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgKChjYW5kaWRhdGUub3B0aW9ucy5vdmVyd3JpdGUgPT09IHVuZGVmaW5lZCB8fCBJcy5ib29sZWFuKGNhbmRpZGF0ZS5vcHRpb25zLm92ZXJ3cml0ZSkpICYmIChjYW5kaWRhdGUub3B0aW9ucy5pZ25vcmVJZkV4aXN0cyA9PT0gdW5kZWZpbmVkIHx8IElzLmJvb2xlYW4oY2FuZGlkYXRlLm9wdGlvbnMuaWdub3JlSWZFeGlzdHMpKSkpICYmIChjYW5kaWRhdGUuYW5ub3RhdGlvbklkID09PSB1bmRlZmluZWQgfHwgQ2hhbmdlQW5ub3RhdGlvbklkZW50aWZpZXIuaXMoY2FuZGlkYXRlLmFubm90YXRpb25JZCkpO1xuICAgIH1cbiAgICBDcmVhdGVGaWxlLmlzID0gaXM7XG59KShDcmVhdGVGaWxlIHx8IChDcmVhdGVGaWxlID0ge30pKTtcbnZhciBSZW5hbWVGaWxlO1xuKGZ1bmN0aW9uIChSZW5hbWVGaWxlKSB7XG4gICAgZnVuY3Rpb24gY3JlYXRlKG9sZFVyaSwgbmV3VXJpLCBvcHRpb25zLCBhbm5vdGF0aW9uKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgICAgICBraW5kOiAncmVuYW1lJyxcbiAgICAgICAgICAgIG9sZFVyaTogb2xkVXJpLFxuICAgICAgICAgICAgbmV3VXJpOiBuZXdVcmlcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCAmJiAob3B0aW9ucy5vdmVyd3JpdGUgIT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLmlnbm9yZUlmRXhpc3RzICE9PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICByZXN1bHQub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFubm90YXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzdWx0LmFubm90YXRpb25JZCA9IGFubm90YXRpb247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgUmVuYW1lRmlsZS5jcmVhdGUgPSBjcmVhdGU7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICYmIGNhbmRpZGF0ZS5raW5kID09PSAncmVuYW1lJyAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLm9sZFVyaSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS5uZXdVcmkpICYmIChjYW5kaWRhdGUub3B0aW9ucyA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAoKGNhbmRpZGF0ZS5vcHRpb25zLm92ZXJ3cml0ZSA9PT0gdW5kZWZpbmVkIHx8IElzLmJvb2xlYW4oY2FuZGlkYXRlLm9wdGlvbnMub3ZlcndyaXRlKSkgJiYgKGNhbmRpZGF0ZS5vcHRpb25zLmlnbm9yZUlmRXhpc3RzID09PSB1bmRlZmluZWQgfHwgSXMuYm9vbGVhbihjYW5kaWRhdGUub3B0aW9ucy5pZ25vcmVJZkV4aXN0cykpKSkgJiYgKGNhbmRpZGF0ZS5hbm5vdGF0aW9uSWQgPT09IHVuZGVmaW5lZCB8fCBDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllci5pcyhjYW5kaWRhdGUuYW5ub3RhdGlvbklkKSk7XG4gICAgfVxuICAgIFJlbmFtZUZpbGUuaXMgPSBpcztcbn0pKFJlbmFtZUZpbGUgfHwgKFJlbmFtZUZpbGUgPSB7fSkpO1xudmFyIERlbGV0ZUZpbGU7XG4oZnVuY3Rpb24gKERlbGV0ZUZpbGUpIHtcbiAgICBmdW5jdGlvbiBjcmVhdGUodXJpLCBvcHRpb25zLCBhbm5vdGF0aW9uKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgICAgICBraW5kOiAnZGVsZXRlJyxcbiAgICAgICAgICAgIHVyaTogdXJpXG4gICAgICAgIH07XG4gICAgICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQgJiYgKG9wdGlvbnMucmVjdXJzaXZlICE9PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5pZ25vcmVJZk5vdEV4aXN0cyAhPT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAgICAgcmVzdWx0Lm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhbm5vdGF0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlc3VsdC5hbm5vdGF0aW9uSWQgPSBhbm5vdGF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIERlbGV0ZUZpbGUuY3JlYXRlID0gY3JlYXRlO1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJiBjYW5kaWRhdGUua2luZCA9PT0gJ2RlbGV0ZScgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS51cmkpICYmIChjYW5kaWRhdGUub3B0aW9ucyA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAoKGNhbmRpZGF0ZS5vcHRpb25zLnJlY3Vyc2l2ZSA9PT0gdW5kZWZpbmVkIHx8IElzLmJvb2xlYW4oY2FuZGlkYXRlLm9wdGlvbnMucmVjdXJzaXZlKSkgJiYgKGNhbmRpZGF0ZS5vcHRpb25zLmlnbm9yZUlmTm90RXhpc3RzID09PSB1bmRlZmluZWQgfHwgSXMuYm9vbGVhbihjYW5kaWRhdGUub3B0aW9ucy5pZ25vcmVJZk5vdEV4aXN0cykpKSkgJiYgKGNhbmRpZGF0ZS5hbm5vdGF0aW9uSWQgPT09IHVuZGVmaW5lZCB8fCBDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllci5pcyhjYW5kaWRhdGUuYW5ub3RhdGlvbklkKSk7XG4gICAgfVxuICAgIERlbGV0ZUZpbGUuaXMgPSBpcztcbn0pKERlbGV0ZUZpbGUgfHwgKERlbGV0ZUZpbGUgPSB7fSkpO1xudmFyIFdvcmtzcGFjZUVkaXQ7XG4oZnVuY3Rpb24gKFdvcmtzcGFjZUVkaXQpIHtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgJiZcbiAgICAgICAgICAgIChjYW5kaWRhdGUuY2hhbmdlcyAhPT0gdW5kZWZpbmVkIHx8IGNhbmRpZGF0ZS5kb2N1bWVudENoYW5nZXMgIT09IHVuZGVmaW5lZCkgJiZcbiAgICAgICAgICAgIChjYW5kaWRhdGUuZG9jdW1lbnRDaGFuZ2VzID09PSB1bmRlZmluZWQgfHwgY2FuZGlkYXRlLmRvY3VtZW50Q2hhbmdlcy5ldmVyeShmdW5jdGlvbiAoY2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgaWYgKElzLnN0cmluZyhjaGFuZ2Uua2luZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIENyZWF0ZUZpbGUuaXMoY2hhbmdlKSB8fCBSZW5hbWVGaWxlLmlzKGNoYW5nZSkgfHwgRGVsZXRlRmlsZS5pcyhjaGFuZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFRleHREb2N1bWVudEVkaXQuaXMoY2hhbmdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSk7XG4gICAgfVxuICAgIFdvcmtzcGFjZUVkaXQuaXMgPSBpcztcbn0pKFdvcmtzcGFjZUVkaXQgfHwgKFdvcmtzcGFjZUVkaXQgPSB7fSkpO1xudmFyIFRleHRFZGl0Q2hhbmdlSW1wbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUZXh0RWRpdENoYW5nZUltcGwoZWRpdHMsIGNoYW5nZUFubm90YXRpb25zKSB7XG4gICAgICAgIHRoaXMuZWRpdHMgPSBlZGl0cztcbiAgICAgICAgdGhpcy5jaGFuZ2VBbm5vdGF0aW9ucyA9IGNoYW5nZUFubm90YXRpb25zO1xuICAgIH1cbiAgICBUZXh0RWRpdENoYW5nZUltcGwucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uIChwb3NpdGlvbiwgbmV3VGV4dCwgYW5ub3RhdGlvbikge1xuICAgICAgICB2YXIgZWRpdDtcbiAgICAgICAgdmFyIGlkO1xuICAgICAgICBpZiAoYW5ub3RhdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBlZGl0ID0gVGV4dEVkaXQuaW5zZXJ0KHBvc2l0aW9uLCBuZXdUZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllci5pcyhhbm5vdGF0aW9uKSkge1xuICAgICAgICAgICAgaWQgPSBhbm5vdGF0aW9uO1xuICAgICAgICAgICAgZWRpdCA9IEFubm90YXRlZFRleHRFZGl0Lmluc2VydChwb3NpdGlvbiwgbmV3VGV4dCwgYW5ub3RhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmFzc2VydENoYW5nZUFubm90YXRpb25zKHRoaXMuY2hhbmdlQW5ub3RhdGlvbnMpO1xuICAgICAgICAgICAgaWQgPSB0aGlzLmNoYW5nZUFubm90YXRpb25zLm1hbmFnZShhbm5vdGF0aW9uKTtcbiAgICAgICAgICAgIGVkaXQgPSBBbm5vdGF0ZWRUZXh0RWRpdC5pbnNlcnQocG9zaXRpb24sIG5ld1RleHQsIGlkKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVkaXRzLnB1c2goZWRpdCk7XG4gICAgICAgIGlmIChpZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gaWQ7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRleHRFZGl0Q2hhbmdlSW1wbC5wcm90b3R5cGUucmVwbGFjZSA9IGZ1bmN0aW9uIChyYW5nZSwgbmV3VGV4dCwgYW5ub3RhdGlvbikge1xuICAgICAgICB2YXIgZWRpdDtcbiAgICAgICAgdmFyIGlkO1xuICAgICAgICBpZiAoYW5ub3RhdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBlZGl0ID0gVGV4dEVkaXQucmVwbGFjZShyYW5nZSwgbmV3VGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQ2hhbmdlQW5ub3RhdGlvbklkZW50aWZpZXIuaXMoYW5ub3RhdGlvbikpIHtcbiAgICAgICAgICAgIGlkID0gYW5ub3RhdGlvbjtcbiAgICAgICAgICAgIGVkaXQgPSBBbm5vdGF0ZWRUZXh0RWRpdC5yZXBsYWNlKHJhbmdlLCBuZXdUZXh0LCBhbm5vdGF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYXNzZXJ0Q2hhbmdlQW5ub3RhdGlvbnModGhpcy5jaGFuZ2VBbm5vdGF0aW9ucyk7XG4gICAgICAgICAgICBpZCA9IHRoaXMuY2hhbmdlQW5ub3RhdGlvbnMubWFuYWdlKGFubm90YXRpb24pO1xuICAgICAgICAgICAgZWRpdCA9IEFubm90YXRlZFRleHRFZGl0LnJlcGxhY2UocmFuZ2UsIG5ld1RleHQsIGlkKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVkaXRzLnB1c2goZWRpdCk7XG4gICAgICAgIGlmIChpZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gaWQ7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRleHRFZGl0Q2hhbmdlSW1wbC5wcm90b3R5cGUuZGVsZXRlID0gZnVuY3Rpb24gKHJhbmdlLCBhbm5vdGF0aW9uKSB7XG4gICAgICAgIHZhciBlZGl0O1xuICAgICAgICB2YXIgaWQ7XG4gICAgICAgIGlmIChhbm5vdGF0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGVkaXQgPSBUZXh0RWRpdC5kZWwocmFuZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyLmlzKGFubm90YXRpb24pKSB7XG4gICAgICAgICAgICBpZCA9IGFubm90YXRpb247XG4gICAgICAgICAgICBlZGl0ID0gQW5ub3RhdGVkVGV4dEVkaXQuZGVsKHJhbmdlLCBhbm5vdGF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYXNzZXJ0Q2hhbmdlQW5ub3RhdGlvbnModGhpcy5jaGFuZ2VBbm5vdGF0aW9ucyk7XG4gICAgICAgICAgICBpZCA9IHRoaXMuY2hhbmdlQW5ub3RhdGlvbnMubWFuYWdlKGFubm90YXRpb24pO1xuICAgICAgICAgICAgZWRpdCA9IEFubm90YXRlZFRleHRFZGl0LmRlbChyYW5nZSwgaWQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWRpdHMucHVzaChlZGl0KTtcbiAgICAgICAgaWYgKGlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVGV4dEVkaXRDaGFuZ2VJbXBsLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoZWRpdCkge1xuICAgICAgICB0aGlzLmVkaXRzLnB1c2goZWRpdCk7XG4gICAgfTtcbiAgICBUZXh0RWRpdENoYW5nZUltcGwucHJvdG90eXBlLmFsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWRpdHM7XG4gICAgfTtcbiAgICBUZXh0RWRpdENoYW5nZUltcGwucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmVkaXRzLnNwbGljZSgwLCB0aGlzLmVkaXRzLmxlbmd0aCk7XG4gICAgfTtcbiAgICBUZXh0RWRpdENoYW5nZUltcGwucHJvdG90eXBlLmFzc2VydENoYW5nZUFubm90YXRpb25zID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUZXh0IGVkaXQgY2hhbmdlIGlzIG5vdCBjb25maWd1cmVkIHRvIG1hbmFnZSBjaGFuZ2UgYW5ub3RhdGlvbnMuXCIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gVGV4dEVkaXRDaGFuZ2VJbXBsO1xufSgpKTtcbi8qKlxuICogQSBoZWxwZXIgY2xhc3NcbiAqL1xudmFyIENoYW5nZUFubm90YXRpb25zID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENoYW5nZUFubm90YXRpb25zKGFubm90YXRpb25zKSB7XG4gICAgICAgIHRoaXMuX2Fubm90YXRpb25zID0gYW5ub3RhdGlvbnMgPT09IHVuZGVmaW5lZCA/IE9iamVjdC5jcmVhdGUobnVsbCkgOiBhbm5vdGF0aW9ucztcbiAgICAgICAgdGhpcy5fY291bnRlciA9IDA7XG4gICAgICAgIHRoaXMuX3NpemUgPSAwO1xuICAgIH1cbiAgICBDaGFuZ2VBbm5vdGF0aW9ucy5wcm90b3R5cGUuYWxsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYW5ub3RhdGlvbnM7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2hhbmdlQW5ub3RhdGlvbnMucHJvdG90eXBlLCBcInNpemVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zaXplO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgQ2hhbmdlQW5ub3RhdGlvbnMucHJvdG90eXBlLm1hbmFnZSA9IGZ1bmN0aW9uIChpZE9yQW5ub3RhdGlvbiwgYW5ub3RhdGlvbikge1xuICAgICAgICB2YXIgaWQ7XG4gICAgICAgIGlmIChDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllci5pcyhpZE9yQW5ub3RhdGlvbikpIHtcbiAgICAgICAgICAgIGlkID0gaWRPckFubm90YXRpb247XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZCA9IHRoaXMubmV4dElkKCk7XG4gICAgICAgICAgICBhbm5vdGF0aW9uID0gaWRPckFubm90YXRpb247XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2Fubm90YXRpb25zW2lkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJZCBcIi5jb25jYXQoaWQsIFwiIGlzIGFscmVhZHkgaW4gdXNlLlwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFubm90YXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gYW5ub3RhdGlvbiBwcm92aWRlZCBmb3IgaWQgXCIuY29uY2F0KGlkKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYW5ub3RhdGlvbnNbaWRdID0gYW5ub3RhdGlvbjtcbiAgICAgICAgdGhpcy5fc2l6ZSsrO1xuICAgICAgICByZXR1cm4gaWQ7XG4gICAgfTtcbiAgICBDaGFuZ2VBbm5vdGF0aW9ucy5wcm90b3R5cGUubmV4dElkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9jb3VudGVyKys7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb3VudGVyLnRvU3RyaW5nKCk7XG4gICAgfTtcbiAgICByZXR1cm4gQ2hhbmdlQW5ub3RhdGlvbnM7XG59KCkpO1xuLyoqXG4gKiBBIHdvcmtzcGFjZSBjaGFuZ2UgaGVscHMgY29uc3RydWN0aW5nIGNoYW5nZXMgdG8gYSB3b3Jrc3BhY2UuXG4gKi9cbnZhciBXb3Jrc3BhY2VDaGFuZ2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gV29ya3NwYWNlQ2hhbmdlKHdvcmtzcGFjZUVkaXQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fdGV4dEVkaXRDaGFuZ2VzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgaWYgKHdvcmtzcGFjZUVkaXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fd29ya3NwYWNlRWRpdCA9IHdvcmtzcGFjZUVkaXQ7XG4gICAgICAgICAgICBpZiAod29ya3NwYWNlRWRpdC5kb2N1bWVudENoYW5nZXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jaGFuZ2VBbm5vdGF0aW9ucyA9IG5ldyBDaGFuZ2VBbm5vdGF0aW9ucyh3b3Jrc3BhY2VFZGl0LmNoYW5nZUFubm90YXRpb25zKTtcbiAgICAgICAgICAgICAgICB3b3Jrc3BhY2VFZGl0LmNoYW5nZUFubm90YXRpb25zID0gdGhpcy5fY2hhbmdlQW5ub3RhdGlvbnMuYWxsKCk7XG4gICAgICAgICAgICAgICAgd29ya3NwYWNlRWRpdC5kb2N1bWVudENoYW5nZXMuZm9yRWFjaChmdW5jdGlvbiAoY2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChUZXh0RG9jdW1lbnRFZGl0LmlzKGNoYW5nZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ZXh0RWRpdENoYW5nZSA9IG5ldyBUZXh0RWRpdENoYW5nZUltcGwoY2hhbmdlLmVkaXRzLCBfdGhpcy5fY2hhbmdlQW5ub3RhdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3RleHRFZGl0Q2hhbmdlc1tjaGFuZ2UudGV4dERvY3VtZW50LnVyaV0gPSB0ZXh0RWRpdENoYW5nZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAod29ya3NwYWNlRWRpdC5jaGFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMod29ya3NwYWNlRWRpdC5jaGFuZ2VzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRleHRFZGl0Q2hhbmdlID0gbmV3IFRleHRFZGl0Q2hhbmdlSW1wbCh3b3Jrc3BhY2VFZGl0LmNoYW5nZXNba2V5XSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl90ZXh0RWRpdENoYW5nZXNba2V5XSA9IHRleHRFZGl0Q2hhbmdlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fd29ya3NwYWNlRWRpdCA9IHt9O1xuICAgICAgICB9XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXb3Jrc3BhY2VDaGFuZ2UucHJvdG90eXBlLCBcImVkaXRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgdW5kZXJseWluZyB7QGxpbmsgV29ya3NwYWNlRWRpdH0gbGl0ZXJhbFxuICAgICAgICAgKiB1c2UgdG8gYmUgcmV0dXJuZWQgZnJvbSBhIHdvcmtzcGFjZSBlZGl0IG9wZXJhdGlvbiBsaWtlIHJlbmFtZS5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5pbml0RG9jdW1lbnRDaGFuZ2VzKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5fY2hhbmdlQW5ub3RhdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jaGFuZ2VBbm5vdGF0aW9ucy5zaXplID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3dvcmtzcGFjZUVkaXQuY2hhbmdlQW5ub3RhdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl93b3Jrc3BhY2VFZGl0LmNoYW5nZUFubm90YXRpb25zID0gdGhpcy5fY2hhbmdlQW5ub3RhdGlvbnMuYWxsKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dvcmtzcGFjZUVkaXQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBXb3Jrc3BhY2VDaGFuZ2UucHJvdG90eXBlLmdldFRleHRFZGl0Q2hhbmdlID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBpZiAoT3B0aW9uYWxWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyLmlzKGtleSkpIHtcbiAgICAgICAgICAgIHRoaXMuaW5pdERvY3VtZW50Q2hhbmdlcygpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3dvcmtzcGFjZUVkaXQuZG9jdW1lbnRDaGFuZ2VzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dvcmtzcGFjZSBlZGl0IGlzIG5vdCBjb25maWd1cmVkIGZvciBkb2N1bWVudCBjaGFuZ2VzLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHRleHREb2N1bWVudCA9IHsgdXJpOiBrZXkudXJpLCB2ZXJzaW9uOiBrZXkudmVyc2lvbiB9O1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuX3RleHRFZGl0Q2hhbmdlc1t0ZXh0RG9jdW1lbnQudXJpXTtcbiAgICAgICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGVkaXRzID0gW107XG4gICAgICAgICAgICAgICAgdmFyIHRleHREb2N1bWVudEVkaXQgPSB7XG4gICAgICAgICAgICAgICAgICAgIHRleHREb2N1bWVudDogdGV4dERvY3VtZW50LFxuICAgICAgICAgICAgICAgICAgICBlZGl0czogZWRpdHNcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRoaXMuX3dvcmtzcGFjZUVkaXQuZG9jdW1lbnRDaGFuZ2VzLnB1c2godGV4dERvY3VtZW50RWRpdCk7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IFRleHRFZGl0Q2hhbmdlSW1wbChlZGl0cywgdGhpcy5fY2hhbmdlQW5ub3RhdGlvbnMpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3RleHRFZGl0Q2hhbmdlc1t0ZXh0RG9jdW1lbnQudXJpXSA9IHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmluaXRDaGFuZ2VzKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5fd29ya3NwYWNlRWRpdC5jaGFuZ2VzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dvcmtzcGFjZSBlZGl0IGlzIG5vdCBjb25maWd1cmVkIGZvciBub3JtYWwgdGV4dCBlZGl0IGNoYW5nZXMuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5fdGV4dEVkaXRDaGFuZ2VzW2tleV07XG4gICAgICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHZhciBlZGl0cyA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuX3dvcmtzcGFjZUVkaXQuY2hhbmdlc1trZXldID0gZWRpdHM7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IFRleHRFZGl0Q2hhbmdlSW1wbChlZGl0cyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGV4dEVkaXRDaGFuZ2VzW2tleV0gPSByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgfTtcbiAgICBXb3Jrc3BhY2VDaGFuZ2UucHJvdG90eXBlLmluaXREb2N1bWVudENoYW5nZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl93b3Jrc3BhY2VFZGl0LmRvY3VtZW50Q2hhbmdlcyA9PT0gdW5kZWZpbmVkICYmIHRoaXMuX3dvcmtzcGFjZUVkaXQuY2hhbmdlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl9jaGFuZ2VBbm5vdGF0aW9ucyA9IG5ldyBDaGFuZ2VBbm5vdGF0aW9ucygpO1xuICAgICAgICAgICAgdGhpcy5fd29ya3NwYWNlRWRpdC5kb2N1bWVudENoYW5nZXMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX3dvcmtzcGFjZUVkaXQuY2hhbmdlQW5ub3RhdGlvbnMgPSB0aGlzLl9jaGFuZ2VBbm5vdGF0aW9ucy5hbGwoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgV29ya3NwYWNlQ2hhbmdlLnByb3RvdHlwZS5pbml0Q2hhbmdlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3dvcmtzcGFjZUVkaXQuZG9jdW1lbnRDaGFuZ2VzID09PSB1bmRlZmluZWQgJiYgdGhpcy5fd29ya3NwYWNlRWRpdC5jaGFuZ2VzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3dvcmtzcGFjZUVkaXQuY2hhbmdlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFdvcmtzcGFjZUNoYW5nZS5wcm90b3R5cGUuY3JlYXRlRmlsZSA9IGZ1bmN0aW9uICh1cmksIG9wdGlvbnNPckFubm90YXRpb24sIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5pbml0RG9jdW1lbnRDaGFuZ2VzKCk7XG4gICAgICAgIGlmICh0aGlzLl93b3Jrc3BhY2VFZGl0LmRvY3VtZW50Q2hhbmdlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dvcmtzcGFjZSBlZGl0IGlzIG5vdCBjb25maWd1cmVkIGZvciBkb2N1bWVudCBjaGFuZ2VzLicpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhbm5vdGF0aW9uO1xuICAgICAgICBpZiAoQ2hhbmdlQW5ub3RhdGlvbi5pcyhvcHRpb25zT3JBbm5vdGF0aW9uKSB8fCBDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllci5pcyhvcHRpb25zT3JBbm5vdGF0aW9uKSkge1xuICAgICAgICAgICAgYW5ub3RhdGlvbiA9IG9wdGlvbnNPckFubm90YXRpb247XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9uc09yQW5ub3RhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3BlcmF0aW9uO1xuICAgICAgICB2YXIgaWQ7XG4gICAgICAgIGlmIChhbm5vdGF0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbiA9IENyZWF0ZUZpbGUuY3JlYXRlKHVyaSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZCA9IENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyLmlzKGFubm90YXRpb24pID8gYW5ub3RhdGlvbiA6IHRoaXMuX2NoYW5nZUFubm90YXRpb25zLm1hbmFnZShhbm5vdGF0aW9uKTtcbiAgICAgICAgICAgIG9wZXJhdGlvbiA9IENyZWF0ZUZpbGUuY3JlYXRlKHVyaSwgb3B0aW9ucywgaWQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3dvcmtzcGFjZUVkaXQuZG9jdW1lbnRDaGFuZ2VzLnB1c2gob3BlcmF0aW9uKTtcbiAgICAgICAgaWYgKGlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgV29ya3NwYWNlQ2hhbmdlLnByb3RvdHlwZS5yZW5hbWVGaWxlID0gZnVuY3Rpb24gKG9sZFVyaSwgbmV3VXJpLCBvcHRpb25zT3JBbm5vdGF0aW9uLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuaW5pdERvY3VtZW50Q2hhbmdlcygpO1xuICAgICAgICBpZiAodGhpcy5fd29ya3NwYWNlRWRpdC5kb2N1bWVudENoYW5nZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXb3Jrc3BhY2UgZWRpdCBpcyBub3QgY29uZmlndXJlZCBmb3IgZG9jdW1lbnQgY2hhbmdlcy4nKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYW5ub3RhdGlvbjtcbiAgICAgICAgaWYgKENoYW5nZUFubm90YXRpb24uaXMob3B0aW9uc09yQW5ub3RhdGlvbikgfHwgQ2hhbmdlQW5ub3RhdGlvbklkZW50aWZpZXIuaXMob3B0aW9uc09yQW5ub3RhdGlvbikpIHtcbiAgICAgICAgICAgIGFubm90YXRpb24gPSBvcHRpb25zT3JBbm5vdGF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnNPckFubm90YXRpb247XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9wZXJhdGlvbjtcbiAgICAgICAgdmFyIGlkO1xuICAgICAgICBpZiAoYW5ub3RhdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvcGVyYXRpb24gPSBSZW5hbWVGaWxlLmNyZWF0ZShvbGRVcmksIG5ld1VyaSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZCA9IENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyLmlzKGFubm90YXRpb24pID8gYW5ub3RhdGlvbiA6IHRoaXMuX2NoYW5nZUFubm90YXRpb25zLm1hbmFnZShhbm5vdGF0aW9uKTtcbiAgICAgICAgICAgIG9wZXJhdGlvbiA9IFJlbmFtZUZpbGUuY3JlYXRlKG9sZFVyaSwgbmV3VXJpLCBvcHRpb25zLCBpZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fd29ya3NwYWNlRWRpdC5kb2N1bWVudENoYW5nZXMucHVzaChvcGVyYXRpb24pO1xuICAgICAgICBpZiAoaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBXb3Jrc3BhY2VDaGFuZ2UucHJvdG90eXBlLmRlbGV0ZUZpbGUgPSBmdW5jdGlvbiAodXJpLCBvcHRpb25zT3JBbm5vdGF0aW9uLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuaW5pdERvY3VtZW50Q2hhbmdlcygpO1xuICAgICAgICBpZiAodGhpcy5fd29ya3NwYWNlRWRpdC5kb2N1bWVudENoYW5nZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXb3Jrc3BhY2UgZWRpdCBpcyBub3QgY29uZmlndXJlZCBmb3IgZG9jdW1lbnQgY2hhbmdlcy4nKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYW5ub3RhdGlvbjtcbiAgICAgICAgaWYgKENoYW5nZUFubm90YXRpb24uaXMob3B0aW9uc09yQW5ub3RhdGlvbikgfHwgQ2hhbmdlQW5ub3RhdGlvbklkZW50aWZpZXIuaXMob3B0aW9uc09yQW5ub3RhdGlvbikpIHtcbiAgICAgICAgICAgIGFubm90YXRpb24gPSBvcHRpb25zT3JBbm5vdGF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnNPckFubm90YXRpb247XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9wZXJhdGlvbjtcbiAgICAgICAgdmFyIGlkO1xuICAgICAgICBpZiAoYW5ub3RhdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvcGVyYXRpb24gPSBEZWxldGVGaWxlLmNyZWF0ZSh1cmksIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWQgPSBDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllci5pcyhhbm5vdGF0aW9uKSA/IGFubm90YXRpb24gOiB0aGlzLl9jaGFuZ2VBbm5vdGF0aW9ucy5tYW5hZ2UoYW5ub3RhdGlvbik7XG4gICAgICAgICAgICBvcGVyYXRpb24gPSBEZWxldGVGaWxlLmNyZWF0ZSh1cmksIG9wdGlvbnMsIGlkKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl93b3Jrc3BhY2VFZGl0LmRvY3VtZW50Q2hhbmdlcy5wdXNoKG9wZXJhdGlvbik7XG4gICAgICAgIGlmIChpZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gaWQ7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBXb3Jrc3BhY2VDaGFuZ2U7XG59KCkpO1xuXG4vKipcbiAqIFRoZSBUZXh0RG9jdW1lbnRJZGVudGlmaWVyIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICoge0BsaW5rIFRleHREb2N1bWVudElkZW50aWZpZXJ9IGxpdGVyYWxzLlxuICovXG52YXIgVGV4dERvY3VtZW50SWRlbnRpZmllcjtcbihmdW5jdGlvbiAoVGV4dERvY3VtZW50SWRlbnRpZmllcikge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgVGV4dERvY3VtZW50SWRlbnRpZmllciBsaXRlcmFsLlxuICAgICAqIEBwYXJhbSB1cmkgVGhlIGRvY3VtZW50J3MgdXJpLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZSh1cmkpIHtcbiAgICAgICAgcmV0dXJuIHsgdXJpOiB1cmkgfTtcbiAgICB9XG4gICAgVGV4dERvY3VtZW50SWRlbnRpZmllci5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBUZXh0RG9jdW1lbnRJZGVudGlmaWVyfSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMuZGVmaW5lZChjYW5kaWRhdGUpICYmIElzLnN0cmluZyhjYW5kaWRhdGUudXJpKTtcbiAgICB9XG4gICAgVGV4dERvY3VtZW50SWRlbnRpZmllci5pcyA9IGlzO1xufSkoVGV4dERvY3VtZW50SWRlbnRpZmllciB8fCAoVGV4dERvY3VtZW50SWRlbnRpZmllciA9IHt9KSk7XG4vKipcbiAqIFRoZSBWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICoge0BsaW5rIFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXJ9IGxpdGVyYWxzLlxuICovXG52YXIgVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllcjtcbihmdW5jdGlvbiAoVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllcikge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllciBsaXRlcmFsLlxuICAgICAqIEBwYXJhbSB1cmkgVGhlIGRvY3VtZW50J3MgdXJpLlxuICAgICAqIEBwYXJhbSB2ZXJzaW9uIFRoZSBkb2N1bWVudCdzIHZlcnNpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHVyaSwgdmVyc2lvbikge1xuICAgICAgICByZXR1cm4geyB1cmk6IHVyaSwgdmVyc2lvbjogdmVyc2lvbiB9O1xuICAgIH1cbiAgICBWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbGl0ZXJhbCBjb25mb3JtcyB0byB0aGUge0BsaW5rIFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXJ9IGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5kZWZpbmVkKGNhbmRpZGF0ZSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS51cmkpICYmIElzLmludGVnZXIoY2FuZGlkYXRlLnZlcnNpb24pO1xuICAgIH1cbiAgICBWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyLmlzID0gaXM7XG59KShWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyIHx8IChWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyID0ge30pKTtcbi8qKlxuICogVGhlIE9wdGlvbmFsVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllciBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBPcHRpb25hbFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXJ9IGxpdGVyYWxzLlxuICovXG52YXIgT3B0aW9uYWxWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyO1xuKGZ1bmN0aW9uIChPcHRpb25hbFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IE9wdGlvbmFsVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllciBsaXRlcmFsLlxuICAgICAqIEBwYXJhbSB1cmkgVGhlIGRvY3VtZW50J3MgdXJpLlxuICAgICAqIEBwYXJhbSB2ZXJzaW9uIFRoZSBkb2N1bWVudCdzIHZlcnNpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHVyaSwgdmVyc2lvbikge1xuICAgICAgICByZXR1cm4geyB1cmk6IHVyaSwgdmVyc2lvbjogdmVyc2lvbiB9O1xuICAgIH1cbiAgICBPcHRpb25hbFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIuY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgT3B0aW9uYWxWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyfSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMuZGVmaW5lZChjYW5kaWRhdGUpICYmIElzLnN0cmluZyhjYW5kaWRhdGUudXJpKSAmJiAoY2FuZGlkYXRlLnZlcnNpb24gPT09IG51bGwgfHwgSXMuaW50ZWdlcihjYW5kaWRhdGUudmVyc2lvbikpO1xuICAgIH1cbiAgICBPcHRpb25hbFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIuaXMgPSBpcztcbn0pKE9wdGlvbmFsVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllciB8fCAoT3B0aW9uYWxWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyID0ge30pKTtcbi8qKlxuICogVGhlIFRleHREb2N1bWVudEl0ZW0gbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgVGV4dERvY3VtZW50SXRlbX0gbGl0ZXJhbHMuXG4gKi9cbnZhciBUZXh0RG9jdW1lbnRJdGVtO1xuKGZ1bmN0aW9uIChUZXh0RG9jdW1lbnRJdGVtKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBUZXh0RG9jdW1lbnRJdGVtIGxpdGVyYWwuXG4gICAgICogQHBhcmFtIHVyaSBUaGUgZG9jdW1lbnQncyB1cmkuXG4gICAgICogQHBhcmFtIGxhbmd1YWdlSWQgVGhlIGRvY3VtZW50J3MgbGFuZ3VhZ2UgaWRlbnRpZmllci5cbiAgICAgKiBAcGFyYW0gdmVyc2lvbiBUaGUgZG9jdW1lbnQncyB2ZXJzaW9uIG51bWJlci5cbiAgICAgKiBAcGFyYW0gdGV4dCBUaGUgZG9jdW1lbnQncyB0ZXh0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZSh1cmksIGxhbmd1YWdlSWQsIHZlcnNpb24sIHRleHQpIHtcbiAgICAgICAgcmV0dXJuIHsgdXJpOiB1cmksIGxhbmd1YWdlSWQ6IGxhbmd1YWdlSWQsIHZlcnNpb246IHZlcnNpb24sIHRleHQ6IHRleHQgfTtcbiAgICB9XG4gICAgVGV4dERvY3VtZW50SXRlbS5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBUZXh0RG9jdW1lbnRJdGVtfSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMuZGVmaW5lZChjYW5kaWRhdGUpICYmIElzLnN0cmluZyhjYW5kaWRhdGUudXJpKSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLmxhbmd1YWdlSWQpICYmIElzLmludGVnZXIoY2FuZGlkYXRlLnZlcnNpb24pICYmIElzLnN0cmluZyhjYW5kaWRhdGUudGV4dCk7XG4gICAgfVxuICAgIFRleHREb2N1bWVudEl0ZW0uaXMgPSBpcztcbn0pKFRleHREb2N1bWVudEl0ZW0gfHwgKFRleHREb2N1bWVudEl0ZW0gPSB7fSkpO1xuLyoqXG4gKiBEZXNjcmliZXMgdGhlIGNvbnRlbnQgdHlwZSB0aGF0IGEgY2xpZW50IHN1cHBvcnRzIGluIHZhcmlvdXNcbiAqIHJlc3VsdCBsaXRlcmFscyBsaWtlIGBIb3ZlcmAsIGBQYXJhbWV0ZXJJbmZvYCBvciBgQ29tcGxldGlvbkl0ZW1gLlxuICpcbiAqIFBsZWFzZSBub3RlIHRoYXQgYE1hcmt1cEtpbmRzYCBtdXN0IG5vdCBzdGFydCB3aXRoIGEgYCRgLiBUaGlzIGtpbmRzXG4gKiBhcmUgcmVzZXJ2ZWQgZm9yIGludGVybmFsIHVzYWdlLlxuICovXG52YXIgTWFya3VwS2luZDtcbihmdW5jdGlvbiAoTWFya3VwS2luZCkge1xuICAgIC8qKlxuICAgICAqIFBsYWluIHRleHQgaXMgc3VwcG9ydGVkIGFzIGEgY29udGVudCBmb3JtYXRcbiAgICAgKi9cbiAgICBNYXJrdXBLaW5kLlBsYWluVGV4dCA9ICdwbGFpbnRleHQnO1xuICAgIC8qKlxuICAgICAqIE1hcmtkb3duIGlzIHN1cHBvcnRlZCBhcyBhIGNvbnRlbnQgZm9ybWF0XG4gICAgICovXG4gICAgTWFya3VwS2luZC5NYXJrZG93biA9ICdtYXJrZG93bic7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsdWUgb2YgdGhlIHtAbGluayBNYXJrdXBLaW5kfSB0eXBlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSA9PT0gTWFya3VwS2luZC5QbGFpblRleHQgfHwgY2FuZGlkYXRlID09PSBNYXJrdXBLaW5kLk1hcmtkb3duO1xuICAgIH1cbiAgICBNYXJrdXBLaW5kLmlzID0gaXM7XG59KShNYXJrdXBLaW5kIHx8IChNYXJrdXBLaW5kID0ge30pKTtcbnZhciBNYXJrdXBDb250ZW50O1xuKGZ1bmN0aW9uIChNYXJrdXBDb250ZW50KSB7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgTWFya3VwQ29udGVudH0gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLm9iamVjdExpdGVyYWwodmFsdWUpICYmIE1hcmt1cEtpbmQuaXMoY2FuZGlkYXRlLmtpbmQpICYmIElzLnN0cmluZyhjYW5kaWRhdGUudmFsdWUpO1xuICAgIH1cbiAgICBNYXJrdXBDb250ZW50LmlzID0gaXM7XG59KShNYXJrdXBDb250ZW50IHx8IChNYXJrdXBDb250ZW50ID0ge30pKTtcbi8qKlxuICogVGhlIGtpbmQgb2YgYSBjb21wbGV0aW9uIGVudHJ5LlxuICovXG52YXIgQ29tcGxldGlvbkl0ZW1LaW5kO1xuKGZ1bmN0aW9uIChDb21wbGV0aW9uSXRlbUtpbmQpIHtcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuVGV4dCA9IDE7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLk1ldGhvZCA9IDI7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLkZ1bmN0aW9uID0gMztcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuQ29uc3RydWN0b3IgPSA0O1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5GaWVsZCA9IDU7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLlZhcmlhYmxlID0gNjtcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuQ2xhc3MgPSA3O1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5JbnRlcmZhY2UgPSA4O1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5Nb2R1bGUgPSA5O1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5Qcm9wZXJ0eSA9IDEwO1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5Vbml0ID0gMTE7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLlZhbHVlID0gMTI7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLkVudW0gPSAxMztcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuS2V5d29yZCA9IDE0O1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5TbmlwcGV0ID0gMTU7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLkNvbG9yID0gMTY7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLkZpbGUgPSAxNztcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuUmVmZXJlbmNlID0gMTg7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLkZvbGRlciA9IDE5O1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5FbnVtTWVtYmVyID0gMjA7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLkNvbnN0YW50ID0gMjE7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLlN0cnVjdCA9IDIyO1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5FdmVudCA9IDIzO1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5PcGVyYXRvciA9IDI0O1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5UeXBlUGFyYW1ldGVyID0gMjU7XG59KShDb21wbGV0aW9uSXRlbUtpbmQgfHwgKENvbXBsZXRpb25JdGVtS2luZCA9IHt9KSk7XG4vKipcbiAqIERlZmluZXMgd2hldGhlciB0aGUgaW5zZXJ0IHRleHQgaW4gYSBjb21wbGV0aW9uIGl0ZW0gc2hvdWxkIGJlIGludGVycHJldGVkIGFzXG4gKiBwbGFpbiB0ZXh0IG9yIGEgc25pcHBldC5cbiAqL1xudmFyIEluc2VydFRleHRGb3JtYXQ7XG4oZnVuY3Rpb24gKEluc2VydFRleHRGb3JtYXQpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgcHJpbWFyeSB0ZXh0IHRvIGJlIGluc2VydGVkIGlzIHRyZWF0ZWQgYXMgYSBwbGFpbiBzdHJpbmcuXG4gICAgICovXG4gICAgSW5zZXJ0VGV4dEZvcm1hdC5QbGFpblRleHQgPSAxO1xuICAgIC8qKlxuICAgICAqIFRoZSBwcmltYXJ5IHRleHQgdG8gYmUgaW5zZXJ0ZWQgaXMgdHJlYXRlZCBhcyBhIHNuaXBwZXQuXG4gICAgICpcbiAgICAgKiBBIHNuaXBwZXQgY2FuIGRlZmluZSB0YWIgc3RvcHMgYW5kIHBsYWNlaG9sZGVycyB3aXRoIGAkMWAsIGAkMmBcbiAgICAgKiBhbmQgYCR7Mzpmb299YC4gYCQwYCBkZWZpbmVzIHRoZSBmaW5hbCB0YWIgc3RvcCwgaXQgZGVmYXVsdHMgdG9cbiAgICAgKiB0aGUgZW5kIG9mIHRoZSBzbmlwcGV0LiBQbGFjZWhvbGRlcnMgd2l0aCBlcXVhbCBpZGVudGlmaWVycyBhcmUgbGlua2VkLFxuICAgICAqIHRoYXQgaXMgdHlwaW5nIGluIG9uZSB3aWxsIHVwZGF0ZSBvdGhlcnMgdG9vLlxuICAgICAqXG4gICAgICogU2VlIGFsc286IGh0dHBzOi8vbWljcm9zb2Z0LmdpdGh1Yi5pby9sYW5ndWFnZS1zZXJ2ZXItcHJvdG9jb2wvc3BlY2lmaWNhdGlvbnMvc3BlY2lmaWNhdGlvbi1jdXJyZW50LyNzbmlwcGV0X3N5bnRheFxuICAgICAqL1xuICAgIEluc2VydFRleHRGb3JtYXQuU25pcHBldCA9IDI7XG59KShJbnNlcnRUZXh0Rm9ybWF0IHx8IChJbnNlcnRUZXh0Rm9ybWF0ID0ge30pKTtcbi8qKlxuICogQ29tcGxldGlvbiBpdGVtIHRhZ3MgYXJlIGV4dHJhIGFubm90YXRpb25zIHRoYXQgdHdlYWsgdGhlIHJlbmRlcmluZyBvZiBhIGNvbXBsZXRpb25cbiAqIGl0ZW0uXG4gKlxuICogQHNpbmNlIDMuMTUuMFxuICovXG52YXIgQ29tcGxldGlvbkl0ZW1UYWc7XG4oZnVuY3Rpb24gKENvbXBsZXRpb25JdGVtVGFnKSB7XG4gICAgLyoqXG4gICAgICogUmVuZGVyIGEgY29tcGxldGlvbiBhcyBvYnNvbGV0ZSwgdXN1YWxseSB1c2luZyBhIHN0cmlrZS1vdXQuXG4gICAgICovXG4gICAgQ29tcGxldGlvbkl0ZW1UYWcuRGVwcmVjYXRlZCA9IDE7XG59KShDb21wbGV0aW9uSXRlbVRhZyB8fCAoQ29tcGxldGlvbkl0ZW1UYWcgPSB7fSkpO1xuLyoqXG4gKiBUaGUgSW5zZXJ0UmVwbGFjZUVkaXQgbmFtZXNwYWNlIHByb3ZpZGVzIGZ1bmN0aW9ucyB0byBkZWFsIHdpdGggaW5zZXJ0IC8gcmVwbGFjZSBlZGl0cy5cbiAqXG4gKiBAc2luY2UgMy4xNi4wXG4gKi9cbnZhciBJbnNlcnRSZXBsYWNlRWRpdDtcbihmdW5jdGlvbiAoSW5zZXJ0UmVwbGFjZUVkaXQpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluc2VydCAvIHJlcGxhY2UgZWRpdFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShuZXdUZXh0LCBpbnNlcnQsIHJlcGxhY2UpIHtcbiAgICAgICAgcmV0dXJuIHsgbmV3VGV4dDogbmV3VGV4dCwgaW5zZXJ0OiBpbnNlcnQsIHJlcGxhY2U6IHJlcGxhY2UgfTtcbiAgICB9XG4gICAgSW5zZXJ0UmVwbGFjZUVkaXQuY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgSW5zZXJ0UmVwbGFjZUVkaXR9IGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS5uZXdUZXh0KSAmJiBSYW5nZS5pcyhjYW5kaWRhdGUuaW5zZXJ0KSAmJiBSYW5nZS5pcyhjYW5kaWRhdGUucmVwbGFjZSk7XG4gICAgfVxuICAgIEluc2VydFJlcGxhY2VFZGl0LmlzID0gaXM7XG59KShJbnNlcnRSZXBsYWNlRWRpdCB8fCAoSW5zZXJ0UmVwbGFjZUVkaXQgPSB7fSkpO1xuLyoqXG4gKiBIb3cgd2hpdGVzcGFjZSBhbmQgaW5kZW50YXRpb24gaXMgaGFuZGxlZCBkdXJpbmcgY29tcGxldGlvblxuICogaXRlbSBpbnNlcnRpb24uXG4gKlxuICogQHNpbmNlIDMuMTYuMFxuICovXG52YXIgSW5zZXJ0VGV4dE1vZGU7XG4oZnVuY3Rpb24gKEluc2VydFRleHRNb2RlKSB7XG4gICAgLyoqXG4gICAgICogVGhlIGluc2VydGlvbiBvciByZXBsYWNlIHN0cmluZ3MgaXMgdGFrZW4gYXMgaXQgaXMuIElmIHRoZVxuICAgICAqIHZhbHVlIGlzIG11bHRpIGxpbmUgdGhlIGxpbmVzIGJlbG93IHRoZSBjdXJzb3Igd2lsbCBiZVxuICAgICAqIGluc2VydGVkIHVzaW5nIHRoZSBpbmRlbnRhdGlvbiBkZWZpbmVkIGluIHRoZSBzdHJpbmcgdmFsdWUuXG4gICAgICogVGhlIGNsaWVudCB3aWxsIG5vdCBhcHBseSBhbnkga2luZCBvZiBhZGp1c3RtZW50cyB0byB0aGVcbiAgICAgKiBzdHJpbmcuXG4gICAgICovXG4gICAgSW5zZXJ0VGV4dE1vZGUuYXNJcyA9IDE7XG4gICAgLyoqXG4gICAgICogVGhlIGVkaXRvciBhZGp1c3RzIGxlYWRpbmcgd2hpdGVzcGFjZSBvZiBuZXcgbGluZXMgc28gdGhhdFxuICAgICAqIHRoZXkgbWF0Y2ggdGhlIGluZGVudGF0aW9uIHVwIHRvIHRoZSBjdXJzb3Igb2YgdGhlIGxpbmUgZm9yXG4gICAgICogd2hpY2ggdGhlIGl0ZW0gaXMgYWNjZXB0ZWQuXG4gICAgICpcbiAgICAgKiBDb25zaWRlciBhIGxpbmUgbGlrZSB0aGlzOiA8MnRhYnM+PGN1cnNvcj48M3RhYnM+Zm9vLiBBY2NlcHRpbmcgYVxuICAgICAqIG11bHRpIGxpbmUgY29tcGxldGlvbiBpdGVtIGlzIGluZGVudGVkIHVzaW5nIDIgdGFicyBhbmQgYWxsXG4gICAgICogZm9sbG93aW5nIGxpbmVzIGluc2VydGVkIHdpbGwgYmUgaW5kZW50ZWQgdXNpbmcgMiB0YWJzIGFzIHdlbGwuXG4gICAgICovXG4gICAgSW5zZXJ0VGV4dE1vZGUuYWRqdXN0SW5kZW50YXRpb24gPSAyO1xufSkoSW5zZXJ0VGV4dE1vZGUgfHwgKEluc2VydFRleHRNb2RlID0ge30pKTtcbnZhciBDb21wbGV0aW9uSXRlbUxhYmVsRGV0YWlscztcbihmdW5jdGlvbiAoQ29tcGxldGlvbkl0ZW1MYWJlbERldGFpbHMpIHtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgJiYgKElzLnN0cmluZyhjYW5kaWRhdGUuZGV0YWlsKSB8fCBjYW5kaWRhdGUuZGV0YWlsID09PSB1bmRlZmluZWQpICYmXG4gICAgICAgICAgICAoSXMuc3RyaW5nKGNhbmRpZGF0ZS5kZXNjcmlwdGlvbikgfHwgY2FuZGlkYXRlLmRlc2NyaXB0aW9uID09PSB1bmRlZmluZWQpO1xuICAgIH1cbiAgICBDb21wbGV0aW9uSXRlbUxhYmVsRGV0YWlscy5pcyA9IGlzO1xufSkoQ29tcGxldGlvbkl0ZW1MYWJlbERldGFpbHMgfHwgKENvbXBsZXRpb25JdGVtTGFiZWxEZXRhaWxzID0ge30pKTtcbi8qKlxuICogVGhlIENvbXBsZXRpb25JdGVtIG5hbWVzcGFjZSBwcm92aWRlcyBmdW5jdGlvbnMgdG8gZGVhbCB3aXRoXG4gKiBjb21wbGV0aW9uIGl0ZW1zLlxuICovXG52YXIgQ29tcGxldGlvbkl0ZW07XG4oZnVuY3Rpb24gKENvbXBsZXRpb25JdGVtKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgY29tcGxldGlvbiBpdGVtIGFuZCBzZWVkIGl0IHdpdGggYSBsYWJlbC5cbiAgICAgKiBAcGFyYW0gbGFiZWwgVGhlIGNvbXBsZXRpb24gaXRlbSdzIGxhYmVsXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKGxhYmVsKSB7XG4gICAgICAgIHJldHVybiB7IGxhYmVsOiBsYWJlbCB9O1xuICAgIH1cbiAgICBDb21wbGV0aW9uSXRlbS5jcmVhdGUgPSBjcmVhdGU7XG59KShDb21wbGV0aW9uSXRlbSB8fCAoQ29tcGxldGlvbkl0ZW0gPSB7fSkpO1xuLyoqXG4gKiBUaGUgQ29tcGxldGlvbkxpc3QgbmFtZXNwYWNlIHByb3ZpZGVzIGZ1bmN0aW9ucyB0byBkZWFsIHdpdGhcbiAqIGNvbXBsZXRpb24gbGlzdHMuXG4gKi9cbnZhciBDb21wbGV0aW9uTGlzdDtcbihmdW5jdGlvbiAoQ29tcGxldGlvbkxpc3QpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGNvbXBsZXRpb24gbGlzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpdGVtcyBUaGUgY29tcGxldGlvbiBpdGVtcy5cbiAgICAgKiBAcGFyYW0gaXNJbmNvbXBsZXRlIFRoZSBsaXN0IGlzIG5vdCBjb21wbGV0ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUoaXRlbXMsIGlzSW5jb21wbGV0ZSkge1xuICAgICAgICByZXR1cm4geyBpdGVtczogaXRlbXMgPyBpdGVtcyA6IFtdLCBpc0luY29tcGxldGU6ICEhaXNJbmNvbXBsZXRlIH07XG4gICAgfVxuICAgIENvbXBsZXRpb25MaXN0LmNyZWF0ZSA9IGNyZWF0ZTtcbn0pKENvbXBsZXRpb25MaXN0IHx8IChDb21wbGV0aW9uTGlzdCA9IHt9KSk7XG52YXIgTWFya2VkU3RyaW5nO1xuKGZ1bmN0aW9uIChNYXJrZWRTdHJpbmcpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbWFya2VkIHN0cmluZyBmcm9tIHBsYWluIHRleHQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGxhaW5UZXh0IFRoZSBwbGFpbiB0ZXh0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZyb21QbGFpblRleHQocGxhaW5UZXh0KSB7XG4gICAgICAgIHJldHVybiBwbGFpblRleHQucmVwbGFjZSgvW1xcXFxgKl97fVtcXF0oKSMrXFwtLiFdL2csICdcXFxcJCYnKTsgLy8gZXNjYXBlIG1hcmtkb3duIHN5bnRheCB0b2tlbnM6IGh0dHA6Ly9kYXJpbmdmaXJlYmFsbC5uZXQvcHJvamVjdHMvbWFya2Rvd24vc3ludGF4I2JhY2tzbGFzaFxuICAgIH1cbiAgICBNYXJrZWRTdHJpbmcuZnJvbVBsYWluVGV4dCA9IGZyb21QbGFpblRleHQ7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgTWFya2VkU3RyaW5nfSB0eXBlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLnN0cmluZyhjYW5kaWRhdGUpIHx8IChJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS5sYW5ndWFnZSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS52YWx1ZSkpO1xuICAgIH1cbiAgICBNYXJrZWRTdHJpbmcuaXMgPSBpcztcbn0pKE1hcmtlZFN0cmluZyB8fCAoTWFya2VkU3RyaW5nID0ge30pKTtcbnZhciBIb3ZlcjtcbihmdW5jdGlvbiAoSG92ZXIpIHtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gdmFsdWUgY29uZm9ybXMgdG8gdGhlIHtAbGluayBIb3Zlcn0gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuICEhY2FuZGlkYXRlICYmIElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKSAmJiAoTWFya3VwQ29udGVudC5pcyhjYW5kaWRhdGUuY29udGVudHMpIHx8XG4gICAgICAgICAgICBNYXJrZWRTdHJpbmcuaXMoY2FuZGlkYXRlLmNvbnRlbnRzKSB8fFxuICAgICAgICAgICAgSXMudHlwZWRBcnJheShjYW5kaWRhdGUuY29udGVudHMsIE1hcmtlZFN0cmluZy5pcykpICYmICh2YWx1ZS5yYW5nZSA9PT0gdW5kZWZpbmVkIHx8IFJhbmdlLmlzKHZhbHVlLnJhbmdlKSk7XG4gICAgfVxuICAgIEhvdmVyLmlzID0gaXM7XG59KShIb3ZlciB8fCAoSG92ZXIgPSB7fSkpO1xuLyoqXG4gKiBUaGUgUGFyYW1ldGVySW5mb3JtYXRpb24gbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgUGFyYW1ldGVySW5mb3JtYXRpb259IGxpdGVyYWxzLlxuICovXG52YXIgUGFyYW1ldGVySW5mb3JtYXRpb247XG4oZnVuY3Rpb24gKFBhcmFtZXRlckluZm9ybWF0aW9uKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBwYXJhbWV0ZXIgaW5mb3JtYXRpb24gbGl0ZXJhbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBsYWJlbCBBIGxhYmVsIHN0cmluZy5cbiAgICAgKiBAcGFyYW0gZG9jdW1lbnRhdGlvbiBBIGRvYyBzdHJpbmcuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKGxhYmVsLCBkb2N1bWVudGF0aW9uKSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudGF0aW9uID8geyBsYWJlbDogbGFiZWwsIGRvY3VtZW50YXRpb246IGRvY3VtZW50YXRpb24gfSA6IHsgbGFiZWw6IGxhYmVsIH07XG4gICAgfVxuICAgIFBhcmFtZXRlckluZm9ybWF0aW9uLmNyZWF0ZSA9IGNyZWF0ZTtcbn0pKFBhcmFtZXRlckluZm9ybWF0aW9uIHx8IChQYXJhbWV0ZXJJbmZvcm1hdGlvbiA9IHt9KSk7XG4vKipcbiAqIFRoZSBTaWduYXR1cmVJbmZvcm1hdGlvbiBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBTaWduYXR1cmVJbmZvcm1hdGlvbn0gbGl0ZXJhbHMuXG4gKi9cbnZhciBTaWduYXR1cmVJbmZvcm1hdGlvbjtcbihmdW5jdGlvbiAoU2lnbmF0dXJlSW5mb3JtYXRpb24pIHtcbiAgICBmdW5jdGlvbiBjcmVhdGUobGFiZWwsIGRvY3VtZW50YXRpb24pIHtcbiAgICAgICAgdmFyIHBhcmFtZXRlcnMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAyOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHBhcmFtZXRlcnNbX2kgLSAyXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3VsdCA9IHsgbGFiZWw6IGxhYmVsIH07XG4gICAgICAgIGlmIChJcy5kZWZpbmVkKGRvY3VtZW50YXRpb24pKSB7XG4gICAgICAgICAgICByZXN1bHQuZG9jdW1lbnRhdGlvbiA9IGRvY3VtZW50YXRpb247XG4gICAgICAgIH1cbiAgICAgICAgaWYgKElzLmRlZmluZWQocGFyYW1ldGVycykpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wYXJhbWV0ZXJzID0gcGFyYW1ldGVycztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdC5wYXJhbWV0ZXJzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgU2lnbmF0dXJlSW5mb3JtYXRpb24uY3JlYXRlID0gY3JlYXRlO1xufSkoU2lnbmF0dXJlSW5mb3JtYXRpb24gfHwgKFNpZ25hdHVyZUluZm9ybWF0aW9uID0ge30pKTtcbi8qKlxuICogQSBkb2N1bWVudCBoaWdobGlnaHQga2luZC5cbiAqL1xudmFyIERvY3VtZW50SGlnaGxpZ2h0S2luZDtcbihmdW5jdGlvbiAoRG9jdW1lbnRIaWdobGlnaHRLaW5kKSB7XG4gICAgLyoqXG4gICAgICogQSB0ZXh0dWFsIG9jY3VycmVuY2UuXG4gICAgICovXG4gICAgRG9jdW1lbnRIaWdobGlnaHRLaW5kLlRleHQgPSAxO1xuICAgIC8qKlxuICAgICAqIFJlYWQtYWNjZXNzIG9mIGEgc3ltYm9sLCBsaWtlIHJlYWRpbmcgYSB2YXJpYWJsZS5cbiAgICAgKi9cbiAgICBEb2N1bWVudEhpZ2hsaWdodEtpbmQuUmVhZCA9IDI7XG4gICAgLyoqXG4gICAgICogV3JpdGUtYWNjZXNzIG9mIGEgc3ltYm9sLCBsaWtlIHdyaXRpbmcgdG8gYSB2YXJpYWJsZS5cbiAgICAgKi9cbiAgICBEb2N1bWVudEhpZ2hsaWdodEtpbmQuV3JpdGUgPSAzO1xufSkoRG9jdW1lbnRIaWdobGlnaHRLaW5kIHx8IChEb2N1bWVudEhpZ2hsaWdodEtpbmQgPSB7fSkpO1xuLyoqXG4gKiBEb2N1bWVudEhpZ2hsaWdodCBuYW1lc3BhY2UgdG8gcHJvdmlkZSBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICoge0BsaW5rIERvY3VtZW50SGlnaGxpZ2h0fSBsaXRlcmFscy5cbiAqL1xudmFyIERvY3VtZW50SGlnaGxpZ2h0O1xuKGZ1bmN0aW9uIChEb2N1bWVudEhpZ2hsaWdodCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIERvY3VtZW50SGlnaGxpZ2h0IG9iamVjdC5cbiAgICAgKiBAcGFyYW0gcmFuZ2UgVGhlIHJhbmdlIHRoZSBoaWdobGlnaHQgYXBwbGllcyB0by5cbiAgICAgKiBAcGFyYW0ga2luZCBUaGUgaGlnaGxpZ2h0IGtpbmRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUocmFuZ2UsIGtpbmQpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHsgcmFuZ2U6IHJhbmdlIH07XG4gICAgICAgIGlmIChJcy5udW1iZXIoa2luZCkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5raW5kID0ga2luZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBEb2N1bWVudEhpZ2hsaWdodC5jcmVhdGUgPSBjcmVhdGU7XG59KShEb2N1bWVudEhpZ2hsaWdodCB8fCAoRG9jdW1lbnRIaWdobGlnaHQgPSB7fSkpO1xuLyoqXG4gKiBBIHN5bWJvbCBraW5kLlxuICovXG52YXIgU3ltYm9sS2luZDtcbihmdW5jdGlvbiAoU3ltYm9sS2luZCkge1xuICAgIFN5bWJvbEtpbmQuRmlsZSA9IDE7XG4gICAgU3ltYm9sS2luZC5Nb2R1bGUgPSAyO1xuICAgIFN5bWJvbEtpbmQuTmFtZXNwYWNlID0gMztcbiAgICBTeW1ib2xLaW5kLlBhY2thZ2UgPSA0O1xuICAgIFN5bWJvbEtpbmQuQ2xhc3MgPSA1O1xuICAgIFN5bWJvbEtpbmQuTWV0aG9kID0gNjtcbiAgICBTeW1ib2xLaW5kLlByb3BlcnR5ID0gNztcbiAgICBTeW1ib2xLaW5kLkZpZWxkID0gODtcbiAgICBTeW1ib2xLaW5kLkNvbnN0cnVjdG9yID0gOTtcbiAgICBTeW1ib2xLaW5kLkVudW0gPSAxMDtcbiAgICBTeW1ib2xLaW5kLkludGVyZmFjZSA9IDExO1xuICAgIFN5bWJvbEtpbmQuRnVuY3Rpb24gPSAxMjtcbiAgICBTeW1ib2xLaW5kLlZhcmlhYmxlID0gMTM7XG4gICAgU3ltYm9sS2luZC5Db25zdGFudCA9IDE0O1xuICAgIFN5bWJvbEtpbmQuU3RyaW5nID0gMTU7XG4gICAgU3ltYm9sS2luZC5OdW1iZXIgPSAxNjtcbiAgICBTeW1ib2xLaW5kLkJvb2xlYW4gPSAxNztcbiAgICBTeW1ib2xLaW5kLkFycmF5ID0gMTg7XG4gICAgU3ltYm9sS2luZC5PYmplY3QgPSAxOTtcbiAgICBTeW1ib2xLaW5kLktleSA9IDIwO1xuICAgIFN5bWJvbEtpbmQuTnVsbCA9IDIxO1xuICAgIFN5bWJvbEtpbmQuRW51bU1lbWJlciA9IDIyO1xuICAgIFN5bWJvbEtpbmQuU3RydWN0ID0gMjM7XG4gICAgU3ltYm9sS2luZC5FdmVudCA9IDI0O1xuICAgIFN5bWJvbEtpbmQuT3BlcmF0b3IgPSAyNTtcbiAgICBTeW1ib2xLaW5kLlR5cGVQYXJhbWV0ZXIgPSAyNjtcbn0pKFN5bWJvbEtpbmQgfHwgKFN5bWJvbEtpbmQgPSB7fSkpO1xuLyoqXG4gKiBTeW1ib2wgdGFncyBhcmUgZXh0cmEgYW5ub3RhdGlvbnMgdGhhdCB0d2VhayB0aGUgcmVuZGVyaW5nIG9mIGEgc3ltYm9sLlxuICpcbiAqIEBzaW5jZSAzLjE2XG4gKi9cbnZhciBTeW1ib2xUYWc7XG4oZnVuY3Rpb24gKFN5bWJvbFRhZykge1xuICAgIC8qKlxuICAgICAqIFJlbmRlciBhIHN5bWJvbCBhcyBvYnNvbGV0ZSwgdXN1YWxseSB1c2luZyBhIHN0cmlrZS1vdXQuXG4gICAgICovXG4gICAgU3ltYm9sVGFnLkRlcHJlY2F0ZWQgPSAxO1xufSkoU3ltYm9sVGFnIHx8IChTeW1ib2xUYWcgPSB7fSkpO1xudmFyIFN5bWJvbEluZm9ybWF0aW9uO1xuKGZ1bmN0aW9uIChTeW1ib2xJbmZvcm1hdGlvbikge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgc3ltYm9sIGluZm9ybWF0aW9uIGxpdGVyYWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgc3ltYm9sLlxuICAgICAqIEBwYXJhbSBraW5kIFRoZSBraW5kIG9mIHRoZSBzeW1ib2wuXG4gICAgICogQHBhcmFtIHJhbmdlIFRoZSByYW5nZSBvZiB0aGUgbG9jYXRpb24gb2YgdGhlIHN5bWJvbC5cbiAgICAgKiBAcGFyYW0gdXJpIFRoZSByZXNvdXJjZSBvZiB0aGUgbG9jYXRpb24gb2Ygc3ltYm9sLlxuICAgICAqIEBwYXJhbSBjb250YWluZXJOYW1lIFRoZSBuYW1lIG9mIHRoZSBzeW1ib2wgY29udGFpbmluZyB0aGUgc3ltYm9sLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShuYW1lLCBraW5kLCByYW5nZSwgdXJpLCBjb250YWluZXJOYW1lKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAga2luZDoga2luZCxcbiAgICAgICAgICAgIGxvY2F0aW9uOiB7IHVyaTogdXJpLCByYW5nZTogcmFuZ2UgfVxuICAgICAgICB9O1xuICAgICAgICBpZiAoY29udGFpbmVyTmFtZSkge1xuICAgICAgICAgICAgcmVzdWx0LmNvbnRhaW5lck5hbWUgPSBjb250YWluZXJOYW1lO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIFN5bWJvbEluZm9ybWF0aW9uLmNyZWF0ZSA9IGNyZWF0ZTtcbn0pKFN5bWJvbEluZm9ybWF0aW9uIHx8IChTeW1ib2xJbmZvcm1hdGlvbiA9IHt9KSk7XG52YXIgV29ya3NwYWNlU3ltYm9sO1xuKGZ1bmN0aW9uIChXb3Jrc3BhY2VTeW1ib2wpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgd29ya3NwYWNlIHN5bWJvbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBzeW1ib2wuXG4gICAgICogQHBhcmFtIGtpbmQgVGhlIGtpbmQgb2YgdGhlIHN5bWJvbC5cbiAgICAgKiBAcGFyYW0gdXJpIFRoZSByZXNvdXJjZSBvZiB0aGUgbG9jYXRpb24gb2YgdGhlIHN5bWJvbC5cbiAgICAgKiBAcGFyYW0gcmFuZ2UgQW4gb3B0aW9ucyByYW5nZSBvZiB0aGUgbG9jYXRpb24uXG4gICAgICogQHJldHVybnMgQSBXb3Jrc3BhY2VTeW1ib2wuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKG5hbWUsIGtpbmQsIHVyaSwgcmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIHJhbmdlICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8geyBuYW1lOiBuYW1lLCBraW5kOiBraW5kLCBsb2NhdGlvbjogeyB1cmk6IHVyaSwgcmFuZ2U6IHJhbmdlIH0gfVxuICAgICAgICAgICAgOiB7IG5hbWU6IG5hbWUsIGtpbmQ6IGtpbmQsIGxvY2F0aW9uOiB7IHVyaTogdXJpIH0gfTtcbiAgICB9XG4gICAgV29ya3NwYWNlU3ltYm9sLmNyZWF0ZSA9IGNyZWF0ZTtcbn0pKFdvcmtzcGFjZVN5bWJvbCB8fCAoV29ya3NwYWNlU3ltYm9sID0ge30pKTtcbnZhciBEb2N1bWVudFN5bWJvbDtcbihmdW5jdGlvbiAoRG9jdW1lbnRTeW1ib2wpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHN5bWJvbCBpbmZvcm1hdGlvbiBsaXRlcmFsLlxuICAgICAqXG4gICAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIHN5bWJvbC5cbiAgICAgKiBAcGFyYW0gZGV0YWlsIFRoZSBkZXRhaWwgb2YgdGhlIHN5bWJvbC5cbiAgICAgKiBAcGFyYW0ga2luZCBUaGUga2luZCBvZiB0aGUgc3ltYm9sLlxuICAgICAqIEBwYXJhbSByYW5nZSBUaGUgcmFuZ2Ugb2YgdGhlIHN5bWJvbC5cbiAgICAgKiBAcGFyYW0gc2VsZWN0aW9uUmFuZ2UgVGhlIHNlbGVjdGlvblJhbmdlIG9mIHRoZSBzeW1ib2wuXG4gICAgICogQHBhcmFtIGNoaWxkcmVuIENoaWxkcmVuIG9mIHRoZSBzeW1ib2wuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKG5hbWUsIGRldGFpbCwga2luZCwgcmFuZ2UsIHNlbGVjdGlvblJhbmdlLCBjaGlsZHJlbikge1xuICAgICAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgIGRldGFpbDogZGV0YWlsLFxuICAgICAgICAgICAga2luZDoga2luZCxcbiAgICAgICAgICAgIHJhbmdlOiByYW5nZSxcbiAgICAgICAgICAgIHNlbGVjdGlvblJhbmdlOiBzZWxlY3Rpb25SYW5nZVxuICAgICAgICB9O1xuICAgICAgICBpZiAoY2hpbGRyZW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzdWx0LmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgRG9jdW1lbnRTeW1ib2wuY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgRG9jdW1lbnRTeW1ib2x9IGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgJiZcbiAgICAgICAgICAgIElzLnN0cmluZyhjYW5kaWRhdGUubmFtZSkgJiYgSXMubnVtYmVyKGNhbmRpZGF0ZS5raW5kKSAmJlxuICAgICAgICAgICAgUmFuZ2UuaXMoY2FuZGlkYXRlLnJhbmdlKSAmJiBSYW5nZS5pcyhjYW5kaWRhdGUuc2VsZWN0aW9uUmFuZ2UpICYmXG4gICAgICAgICAgICAoY2FuZGlkYXRlLmRldGFpbCA9PT0gdW5kZWZpbmVkIHx8IElzLnN0cmluZyhjYW5kaWRhdGUuZGV0YWlsKSkgJiZcbiAgICAgICAgICAgIChjYW5kaWRhdGUuZGVwcmVjYXRlZCA9PT0gdW5kZWZpbmVkIHx8IElzLmJvb2xlYW4oY2FuZGlkYXRlLmRlcHJlY2F0ZWQpKSAmJlxuICAgICAgICAgICAgKGNhbmRpZGF0ZS5jaGlsZHJlbiA9PT0gdW5kZWZpbmVkIHx8IEFycmF5LmlzQXJyYXkoY2FuZGlkYXRlLmNoaWxkcmVuKSkgJiZcbiAgICAgICAgICAgIChjYW5kaWRhdGUudGFncyA9PT0gdW5kZWZpbmVkIHx8IEFycmF5LmlzQXJyYXkoY2FuZGlkYXRlLnRhZ3MpKTtcbiAgICB9XG4gICAgRG9jdW1lbnRTeW1ib2wuaXMgPSBpcztcbn0pKERvY3VtZW50U3ltYm9sIHx8IChEb2N1bWVudFN5bWJvbCA9IHt9KSk7XG4vKipcbiAqIEEgc2V0IG9mIHByZWRlZmluZWQgY29kZSBhY3Rpb24ga2luZHNcbiAqL1xudmFyIENvZGVBY3Rpb25LaW5kO1xuKGZ1bmN0aW9uIChDb2RlQWN0aW9uS2luZCkge1xuICAgIC8qKlxuICAgICAqIEVtcHR5IGtpbmQuXG4gICAgICovXG4gICAgQ29kZUFjdGlvbktpbmQuRW1wdHkgPSAnJztcbiAgICAvKipcbiAgICAgKiBCYXNlIGtpbmQgZm9yIHF1aWNrZml4IGFjdGlvbnM6ICdxdWlja2ZpeCdcbiAgICAgKi9cbiAgICBDb2RlQWN0aW9uS2luZC5RdWlja0ZpeCA9ICdxdWlja2ZpeCc7XG4gICAgLyoqXG4gICAgICogQmFzZSBraW5kIGZvciByZWZhY3RvcmluZyBhY3Rpb25zOiAncmVmYWN0b3InXG4gICAgICovXG4gICAgQ29kZUFjdGlvbktpbmQuUmVmYWN0b3IgPSAncmVmYWN0b3InO1xuICAgIC8qKlxuICAgICAqIEJhc2Uga2luZCBmb3IgcmVmYWN0b3JpbmcgZXh0cmFjdGlvbiBhY3Rpb25zOiAncmVmYWN0b3IuZXh0cmFjdCdcbiAgICAgKlxuICAgICAqIEV4YW1wbGUgZXh0cmFjdCBhY3Rpb25zOlxuICAgICAqXG4gICAgICogLSBFeHRyYWN0IG1ldGhvZFxuICAgICAqIC0gRXh0cmFjdCBmdW5jdGlvblxuICAgICAqIC0gRXh0cmFjdCB2YXJpYWJsZVxuICAgICAqIC0gRXh0cmFjdCBpbnRlcmZhY2UgZnJvbSBjbGFzc1xuICAgICAqIC0gLi4uXG4gICAgICovXG4gICAgQ29kZUFjdGlvbktpbmQuUmVmYWN0b3JFeHRyYWN0ID0gJ3JlZmFjdG9yLmV4dHJhY3QnO1xuICAgIC8qKlxuICAgICAqIEJhc2Uga2luZCBmb3IgcmVmYWN0b3JpbmcgaW5saW5lIGFjdGlvbnM6ICdyZWZhY3Rvci5pbmxpbmUnXG4gICAgICpcbiAgICAgKiBFeGFtcGxlIGlubGluZSBhY3Rpb25zOlxuICAgICAqXG4gICAgICogLSBJbmxpbmUgZnVuY3Rpb25cbiAgICAgKiAtIElubGluZSB2YXJpYWJsZVxuICAgICAqIC0gSW5saW5lIGNvbnN0YW50XG4gICAgICogLSAuLi5cbiAgICAgKi9cbiAgICBDb2RlQWN0aW9uS2luZC5SZWZhY3RvcklubGluZSA9ICdyZWZhY3Rvci5pbmxpbmUnO1xuICAgIC8qKlxuICAgICAqIEJhc2Uga2luZCBmb3IgcmVmYWN0b3JpbmcgcmV3cml0ZSBhY3Rpb25zOiAncmVmYWN0b3IucmV3cml0ZSdcbiAgICAgKlxuICAgICAqIEV4YW1wbGUgcmV3cml0ZSBhY3Rpb25zOlxuICAgICAqXG4gICAgICogLSBDb252ZXJ0IEphdmFTY3JpcHQgZnVuY3Rpb24gdG8gY2xhc3NcbiAgICAgKiAtIEFkZCBvciByZW1vdmUgcGFyYW1ldGVyXG4gICAgICogLSBFbmNhcHN1bGF0ZSBmaWVsZFxuICAgICAqIC0gTWFrZSBtZXRob2Qgc3RhdGljXG4gICAgICogLSBNb3ZlIG1ldGhvZCB0byBiYXNlIGNsYXNzXG4gICAgICogLSAuLi5cbiAgICAgKi9cbiAgICBDb2RlQWN0aW9uS2luZC5SZWZhY3RvclJld3JpdGUgPSAncmVmYWN0b3IucmV3cml0ZSc7XG4gICAgLyoqXG4gICAgICogQmFzZSBraW5kIGZvciBzb3VyY2UgYWN0aW9uczogYHNvdXJjZWBcbiAgICAgKlxuICAgICAqIFNvdXJjZSBjb2RlIGFjdGlvbnMgYXBwbHkgdG8gdGhlIGVudGlyZSBmaWxlLlxuICAgICAqL1xuICAgIENvZGVBY3Rpb25LaW5kLlNvdXJjZSA9ICdzb3VyY2UnO1xuICAgIC8qKlxuICAgICAqIEJhc2Uga2luZCBmb3IgYW4gb3JnYW5pemUgaW1wb3J0cyBzb3VyY2UgYWN0aW9uOiBgc291cmNlLm9yZ2FuaXplSW1wb3J0c2BcbiAgICAgKi9cbiAgICBDb2RlQWN0aW9uS2luZC5Tb3VyY2VPcmdhbml6ZUltcG9ydHMgPSAnc291cmNlLm9yZ2FuaXplSW1wb3J0cyc7XG4gICAgLyoqXG4gICAgICogQmFzZSBraW5kIGZvciBhdXRvLWZpeCBzb3VyY2UgYWN0aW9uczogYHNvdXJjZS5maXhBbGxgLlxuICAgICAqXG4gICAgICogRml4IGFsbCBhY3Rpb25zIGF1dG9tYXRpY2FsbHkgZml4IGVycm9ycyB0aGF0IGhhdmUgYSBjbGVhciBmaXggdGhhdCBkbyBub3QgcmVxdWlyZSB1c2VyIGlucHV0LlxuICAgICAqIFRoZXkgc2hvdWxkIG5vdCBzdXBwcmVzcyBlcnJvcnMgb3IgcGVyZm9ybSB1bnNhZmUgZml4ZXMgc3VjaCBhcyBnZW5lcmF0aW5nIG5ldyB0eXBlcyBvciBjbGFzc2VzLlxuICAgICAqXG4gICAgICogQHNpbmNlIDMuMTUuMFxuICAgICAqL1xuICAgIENvZGVBY3Rpb25LaW5kLlNvdXJjZUZpeEFsbCA9ICdzb3VyY2UuZml4QWxsJztcbn0pKENvZGVBY3Rpb25LaW5kIHx8IChDb2RlQWN0aW9uS2luZCA9IHt9KSk7XG4vKipcbiAqIFRoZSByZWFzb24gd2h5IGNvZGUgYWN0aW9ucyB3ZXJlIHJlcXVlc3RlZC5cbiAqXG4gKiBAc2luY2UgMy4xNy4wXG4gKi9cbnZhciBDb2RlQWN0aW9uVHJpZ2dlcktpbmQ7XG4oZnVuY3Rpb24gKENvZGVBY3Rpb25UcmlnZ2VyS2luZCkge1xuICAgIC8qKlxuICAgICAqIENvZGUgYWN0aW9ucyB3ZXJlIGV4cGxpY2l0bHkgcmVxdWVzdGVkIGJ5IHRoZSB1c2VyIG9yIGJ5IGFuIGV4dGVuc2lvbi5cbiAgICAgKi9cbiAgICBDb2RlQWN0aW9uVHJpZ2dlcktpbmQuSW52b2tlZCA9IDE7XG4gICAgLyoqXG4gICAgICogQ29kZSBhY3Rpb25zIHdlcmUgcmVxdWVzdGVkIGF1dG9tYXRpY2FsbHkuXG4gICAgICpcbiAgICAgKiBUaGlzIHR5cGljYWxseSBoYXBwZW5zIHdoZW4gY3VycmVudCBzZWxlY3Rpb24gaW4gYSBmaWxlIGNoYW5nZXMsIGJ1dCBjYW5cbiAgICAgKiBhbHNvIGJlIHRyaWdnZXJlZCB3aGVuIGZpbGUgY29udGVudCBjaGFuZ2VzLlxuICAgICAqL1xuICAgIENvZGVBY3Rpb25UcmlnZ2VyS2luZC5BdXRvbWF0aWMgPSAyO1xufSkoQ29kZUFjdGlvblRyaWdnZXJLaW5kIHx8IChDb2RlQWN0aW9uVHJpZ2dlcktpbmQgPSB7fSkpO1xuLyoqXG4gKiBUaGUgQ29kZUFjdGlvbkNvbnRleHQgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgQ29kZUFjdGlvbkNvbnRleHR9IGxpdGVyYWxzLlxuICovXG52YXIgQ29kZUFjdGlvbkNvbnRleHQ7XG4oZnVuY3Rpb24gKENvZGVBY3Rpb25Db250ZXh0KSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBDb2RlQWN0aW9uQ29udGV4dCBsaXRlcmFsLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShkaWFnbm9zdGljcywgb25seSwgdHJpZ2dlcktpbmQpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHsgZGlhZ25vc3RpY3M6IGRpYWdub3N0aWNzIH07XG4gICAgICAgIGlmIChvbmx5ICE9PSB1bmRlZmluZWQgJiYgb25seSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0Lm9ubHkgPSBvbmx5O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0cmlnZ2VyS2luZCAhPT0gdW5kZWZpbmVkICYmIHRyaWdnZXJLaW5kICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQudHJpZ2dlcktpbmQgPSB0cmlnZ2VyS2luZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBDb2RlQWN0aW9uQ29udGV4dC5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBDb2RlQWN0aW9uQ29udGV4dH0gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLmRlZmluZWQoY2FuZGlkYXRlKSAmJiBJcy50eXBlZEFycmF5KGNhbmRpZGF0ZS5kaWFnbm9zdGljcywgRGlhZ25vc3RpYy5pcylcbiAgICAgICAgICAgICYmIChjYW5kaWRhdGUub25seSA9PT0gdW5kZWZpbmVkIHx8IElzLnR5cGVkQXJyYXkoY2FuZGlkYXRlLm9ubHksIElzLnN0cmluZykpXG4gICAgICAgICAgICAmJiAoY2FuZGlkYXRlLnRyaWdnZXJLaW5kID09PSB1bmRlZmluZWQgfHwgY2FuZGlkYXRlLnRyaWdnZXJLaW5kID09PSBDb2RlQWN0aW9uVHJpZ2dlcktpbmQuSW52b2tlZCB8fCBjYW5kaWRhdGUudHJpZ2dlcktpbmQgPT09IENvZGVBY3Rpb25UcmlnZ2VyS2luZC5BdXRvbWF0aWMpO1xuICAgIH1cbiAgICBDb2RlQWN0aW9uQ29udGV4dC5pcyA9IGlzO1xufSkoQ29kZUFjdGlvbkNvbnRleHQgfHwgKENvZGVBY3Rpb25Db250ZXh0ID0ge30pKTtcbnZhciBDb2RlQWN0aW9uO1xuKGZ1bmN0aW9uIChDb2RlQWN0aW9uKSB7XG4gICAgZnVuY3Rpb24gY3JlYXRlKHRpdGxlLCBraW5kT3JDb21tYW5kT3JFZGl0LCBraW5kKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB7IHRpdGxlOiB0aXRsZSB9O1xuICAgICAgICB2YXIgY2hlY2tLaW5kID0gdHJ1ZTtcbiAgICAgICAgaWYgKHR5cGVvZiBraW5kT3JDb21tYW5kT3JFZGl0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY2hlY2tLaW5kID0gZmFsc2U7XG4gICAgICAgICAgICByZXN1bHQua2luZCA9IGtpbmRPckNvbW1hbmRPckVkaXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQ29tbWFuZC5pcyhraW5kT3JDb21tYW5kT3JFZGl0KSkge1xuICAgICAgICAgICAgcmVzdWx0LmNvbW1hbmQgPSBraW5kT3JDb21tYW5kT3JFZGl0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0LmVkaXQgPSBraW5kT3JDb21tYW5kT3JFZGl0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGVja0tpbmQgJiYga2luZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXN1bHQua2luZCA9IGtpbmQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgQ29kZUFjdGlvbi5jcmVhdGUgPSBjcmVhdGU7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICYmIElzLnN0cmluZyhjYW5kaWRhdGUudGl0bGUpICYmXG4gICAgICAgICAgICAoY2FuZGlkYXRlLmRpYWdub3N0aWNzID09PSB1bmRlZmluZWQgfHwgSXMudHlwZWRBcnJheShjYW5kaWRhdGUuZGlhZ25vc3RpY3MsIERpYWdub3N0aWMuaXMpKSAmJlxuICAgICAgICAgICAgKGNhbmRpZGF0ZS5raW5kID09PSB1bmRlZmluZWQgfHwgSXMuc3RyaW5nKGNhbmRpZGF0ZS5raW5kKSkgJiZcbiAgICAgICAgICAgIChjYW5kaWRhdGUuZWRpdCAhPT0gdW5kZWZpbmVkIHx8IGNhbmRpZGF0ZS5jb21tYW5kICE9PSB1bmRlZmluZWQpICYmXG4gICAgICAgICAgICAoY2FuZGlkYXRlLmNvbW1hbmQgPT09IHVuZGVmaW5lZCB8fCBDb21tYW5kLmlzKGNhbmRpZGF0ZS5jb21tYW5kKSkgJiZcbiAgICAgICAgICAgIChjYW5kaWRhdGUuaXNQcmVmZXJyZWQgPT09IHVuZGVmaW5lZCB8fCBJcy5ib29sZWFuKGNhbmRpZGF0ZS5pc1ByZWZlcnJlZCkpICYmXG4gICAgICAgICAgICAoY2FuZGlkYXRlLmVkaXQgPT09IHVuZGVmaW5lZCB8fCBXb3Jrc3BhY2VFZGl0LmlzKGNhbmRpZGF0ZS5lZGl0KSk7XG4gICAgfVxuICAgIENvZGVBY3Rpb24uaXMgPSBpcztcbn0pKENvZGVBY3Rpb24gfHwgKENvZGVBY3Rpb24gPSB7fSkpO1xuLyoqXG4gKiBUaGUgQ29kZUxlbnMgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgQ29kZUxlbnN9IGxpdGVyYWxzLlxuICovXG52YXIgQ29kZUxlbnM7XG4oZnVuY3Rpb24gKENvZGVMZW5zKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBDb2RlTGVucyBsaXRlcmFsLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShyYW5nZSwgZGF0YSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0geyByYW5nZTogcmFuZ2UgfTtcbiAgICAgICAgaWYgKElzLmRlZmluZWQoZGF0YSkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5kYXRhID0gZGF0YTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBDb2RlTGVucy5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBDb2RlTGVuc30gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLmRlZmluZWQoY2FuZGlkYXRlKSAmJiBSYW5nZS5pcyhjYW5kaWRhdGUucmFuZ2UpICYmIChJcy51bmRlZmluZWQoY2FuZGlkYXRlLmNvbW1hbmQpIHx8IENvbW1hbmQuaXMoY2FuZGlkYXRlLmNvbW1hbmQpKTtcbiAgICB9XG4gICAgQ29kZUxlbnMuaXMgPSBpcztcbn0pKENvZGVMZW5zIHx8IChDb2RlTGVucyA9IHt9KSk7XG4vKipcbiAqIFRoZSBGb3JtYXR0aW5nT3B0aW9ucyBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBGb3JtYXR0aW5nT3B0aW9uc30gbGl0ZXJhbHMuXG4gKi9cbnZhciBGb3JtYXR0aW5nT3B0aW9ucztcbihmdW5jdGlvbiAoRm9ybWF0dGluZ09wdGlvbnMpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IEZvcm1hdHRpbmdPcHRpb25zIGxpdGVyYWwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHRhYlNpemUsIGluc2VydFNwYWNlcykge1xuICAgICAgICByZXR1cm4geyB0YWJTaXplOiB0YWJTaXplLCBpbnNlcnRTcGFjZXM6IGluc2VydFNwYWNlcyB9O1xuICAgIH1cbiAgICBGb3JtYXR0aW5nT3B0aW9ucy5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBGb3JtYXR0aW5nT3B0aW9uc30gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLmRlZmluZWQoY2FuZGlkYXRlKSAmJiBJcy51aW50ZWdlcihjYW5kaWRhdGUudGFiU2l6ZSkgJiYgSXMuYm9vbGVhbihjYW5kaWRhdGUuaW5zZXJ0U3BhY2VzKTtcbiAgICB9XG4gICAgRm9ybWF0dGluZ09wdGlvbnMuaXMgPSBpcztcbn0pKEZvcm1hdHRpbmdPcHRpb25zIHx8IChGb3JtYXR0aW5nT3B0aW9ucyA9IHt9KSk7XG4vKipcbiAqIFRoZSBEb2N1bWVudExpbmsgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgRG9jdW1lbnRMaW5rfSBsaXRlcmFscy5cbiAqL1xudmFyIERvY3VtZW50TGluaztcbihmdW5jdGlvbiAoRG9jdW1lbnRMaW5rKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBEb2N1bWVudExpbmsgbGl0ZXJhbC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUocmFuZ2UsIHRhcmdldCwgZGF0YSkge1xuICAgICAgICByZXR1cm4geyByYW5nZTogcmFuZ2UsIHRhcmdldDogdGFyZ2V0LCBkYXRhOiBkYXRhIH07XG4gICAgfVxuICAgIERvY3VtZW50TGluay5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBEb2N1bWVudExpbmt9IGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5kZWZpbmVkKGNhbmRpZGF0ZSkgJiYgUmFuZ2UuaXMoY2FuZGlkYXRlLnJhbmdlKSAmJiAoSXMudW5kZWZpbmVkKGNhbmRpZGF0ZS50YXJnZXQpIHx8IElzLnN0cmluZyhjYW5kaWRhdGUudGFyZ2V0KSk7XG4gICAgfVxuICAgIERvY3VtZW50TGluay5pcyA9IGlzO1xufSkoRG9jdW1lbnRMaW5rIHx8IChEb2N1bWVudExpbmsgPSB7fSkpO1xuLyoqXG4gKiBUaGUgU2VsZWN0aW9uUmFuZ2UgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbiB0byB3b3JrIHdpdGhcbiAqIFNlbGVjdGlvblJhbmdlIGxpdGVyYWxzLlxuICovXG52YXIgU2VsZWN0aW9uUmFuZ2U7XG4oZnVuY3Rpb24gKFNlbGVjdGlvblJhbmdlKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBTZWxlY3Rpb25SYW5nZVxuICAgICAqIEBwYXJhbSByYW5nZSB0aGUgcmFuZ2UuXG4gICAgICogQHBhcmFtIHBhcmVudCBhbiBvcHRpb25hbCBwYXJlbnQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHJhbmdlLCBwYXJlbnQpIHtcbiAgICAgICAgcmV0dXJuIHsgcmFuZ2U6IHJhbmdlLCBwYXJlbnQ6IHBhcmVudCB9O1xuICAgIH1cbiAgICBTZWxlY3Rpb25SYW5nZS5jcmVhdGUgPSBjcmVhdGU7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpICYmIFJhbmdlLmlzKGNhbmRpZGF0ZS5yYW5nZSkgJiYgKGNhbmRpZGF0ZS5wYXJlbnQgPT09IHVuZGVmaW5lZCB8fCBTZWxlY3Rpb25SYW5nZS5pcyhjYW5kaWRhdGUucGFyZW50KSk7XG4gICAgfVxuICAgIFNlbGVjdGlvblJhbmdlLmlzID0gaXM7XG59KShTZWxlY3Rpb25SYW5nZSB8fCAoU2VsZWN0aW9uUmFuZ2UgPSB7fSkpO1xuLyoqXG4gKiBBIHNldCBvZiBwcmVkZWZpbmVkIHRva2VuIHR5cGVzLiBUaGlzIHNldCBpcyBub3QgZml4ZWRcbiAqIGFuIGNsaWVudHMgY2FuIHNwZWNpZnkgYWRkaXRpb25hbCB0b2tlbiB0eXBlcyB2aWEgdGhlXG4gKiBjb3JyZXNwb25kaW5nIGNsaWVudCBjYXBhYmlsaXRpZXMuXG4gKlxuICogQHNpbmNlIDMuMTYuMFxuICovXG52YXIgU2VtYW50aWNUb2tlblR5cGVzO1xuKGZ1bmN0aW9uIChTZW1hbnRpY1Rva2VuVHlwZXMpIHtcbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJuYW1lc3BhY2VcIl0gPSBcIm5hbWVzcGFjZVwiO1xuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgYSBnZW5lcmljIHR5cGUuIEFjdHMgYXMgYSBmYWxsYmFjayBmb3IgdHlwZXMgd2hpY2ggY2FuJ3QgYmUgbWFwcGVkIHRvXG4gICAgICogYSBzcGVjaWZpYyB0eXBlIGxpa2UgY2xhc3Mgb3IgZW51bS5cbiAgICAgKi9cbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJ0eXBlXCJdID0gXCJ0eXBlXCI7XG4gICAgU2VtYW50aWNUb2tlblR5cGVzW1wiY2xhc3NcIl0gPSBcImNsYXNzXCI7XG4gICAgU2VtYW50aWNUb2tlblR5cGVzW1wiZW51bVwiXSA9IFwiZW51bVwiO1xuICAgIFNlbWFudGljVG9rZW5UeXBlc1tcImludGVyZmFjZVwiXSA9IFwiaW50ZXJmYWNlXCI7XG4gICAgU2VtYW50aWNUb2tlblR5cGVzW1wic3RydWN0XCJdID0gXCJzdHJ1Y3RcIjtcbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJ0eXBlUGFyYW1ldGVyXCJdID0gXCJ0eXBlUGFyYW1ldGVyXCI7XG4gICAgU2VtYW50aWNUb2tlblR5cGVzW1wicGFyYW1ldGVyXCJdID0gXCJwYXJhbWV0ZXJcIjtcbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJ2YXJpYWJsZVwiXSA9IFwidmFyaWFibGVcIjtcbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJwcm9wZXJ0eVwiXSA9IFwicHJvcGVydHlcIjtcbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJlbnVtTWVtYmVyXCJdID0gXCJlbnVtTWVtYmVyXCI7XG4gICAgU2VtYW50aWNUb2tlblR5cGVzW1wiZXZlbnRcIl0gPSBcImV2ZW50XCI7XG4gICAgU2VtYW50aWNUb2tlblR5cGVzW1wiZnVuY3Rpb25cIl0gPSBcImZ1bmN0aW9uXCI7XG4gICAgU2VtYW50aWNUb2tlblR5cGVzW1wibWV0aG9kXCJdID0gXCJtZXRob2RcIjtcbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJtYWNyb1wiXSA9IFwibWFjcm9cIjtcbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJrZXl3b3JkXCJdID0gXCJrZXl3b3JkXCI7XG4gICAgU2VtYW50aWNUb2tlblR5cGVzW1wibW9kaWZpZXJcIl0gPSBcIm1vZGlmaWVyXCI7XG4gICAgU2VtYW50aWNUb2tlblR5cGVzW1wiY29tbWVudFwiXSA9IFwiY29tbWVudFwiO1xuICAgIFNlbWFudGljVG9rZW5UeXBlc1tcInN0cmluZ1wiXSA9IFwic3RyaW5nXCI7XG4gICAgU2VtYW50aWNUb2tlblR5cGVzW1wibnVtYmVyXCJdID0gXCJudW1iZXJcIjtcbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJyZWdleHBcIl0gPSBcInJlZ2V4cFwiO1xuICAgIFNlbWFudGljVG9rZW5UeXBlc1tcIm9wZXJhdG9yXCJdID0gXCJvcGVyYXRvclwiO1xuICAgIC8qKlxuICAgICAqIEBzaW5jZSAzLjE3LjBcbiAgICAgKi9cbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJkZWNvcmF0b3JcIl0gPSBcImRlY29yYXRvclwiO1xufSkoU2VtYW50aWNUb2tlblR5cGVzIHx8IChTZW1hbnRpY1Rva2VuVHlwZXMgPSB7fSkpO1xuLyoqXG4gKiBBIHNldCBvZiBwcmVkZWZpbmVkIHRva2VuIG1vZGlmaWVycy4gVGhpcyBzZXQgaXMgbm90IGZpeGVkXG4gKiBhbiBjbGllbnRzIGNhbiBzcGVjaWZ5IGFkZGl0aW9uYWwgdG9rZW4gdHlwZXMgdmlhIHRoZVxuICogY29ycmVzcG9uZGluZyBjbGllbnQgY2FwYWJpbGl0aWVzLlxuICpcbiAqIEBzaW5jZSAzLjE2LjBcbiAqL1xudmFyIFNlbWFudGljVG9rZW5Nb2RpZmllcnM7XG4oZnVuY3Rpb24gKFNlbWFudGljVG9rZW5Nb2RpZmllcnMpIHtcbiAgICBTZW1hbnRpY1Rva2VuTW9kaWZpZXJzW1wiZGVjbGFyYXRpb25cIl0gPSBcImRlY2xhcmF0aW9uXCI7XG4gICAgU2VtYW50aWNUb2tlbk1vZGlmaWVyc1tcImRlZmluaXRpb25cIl0gPSBcImRlZmluaXRpb25cIjtcbiAgICBTZW1hbnRpY1Rva2VuTW9kaWZpZXJzW1wicmVhZG9ubHlcIl0gPSBcInJlYWRvbmx5XCI7XG4gICAgU2VtYW50aWNUb2tlbk1vZGlmaWVyc1tcInN0YXRpY1wiXSA9IFwic3RhdGljXCI7XG4gICAgU2VtYW50aWNUb2tlbk1vZGlmaWVyc1tcImRlcHJlY2F0ZWRcIl0gPSBcImRlcHJlY2F0ZWRcIjtcbiAgICBTZW1hbnRpY1Rva2VuTW9kaWZpZXJzW1wiYWJzdHJhY3RcIl0gPSBcImFic3RyYWN0XCI7XG4gICAgU2VtYW50aWNUb2tlbk1vZGlmaWVyc1tcImFzeW5jXCJdID0gXCJhc3luY1wiO1xuICAgIFNlbWFudGljVG9rZW5Nb2RpZmllcnNbXCJtb2RpZmljYXRpb25cIl0gPSBcIm1vZGlmaWNhdGlvblwiO1xuICAgIFNlbWFudGljVG9rZW5Nb2RpZmllcnNbXCJkb2N1bWVudGF0aW9uXCJdID0gXCJkb2N1bWVudGF0aW9uXCI7XG4gICAgU2VtYW50aWNUb2tlbk1vZGlmaWVyc1tcImRlZmF1bHRMaWJyYXJ5XCJdID0gXCJkZWZhdWx0TGlicmFyeVwiO1xufSkoU2VtYW50aWNUb2tlbk1vZGlmaWVycyB8fCAoU2VtYW50aWNUb2tlbk1vZGlmaWVycyA9IHt9KSk7XG4vKipcbiAqIEBzaW5jZSAzLjE2LjBcbiAqL1xudmFyIFNlbWFudGljVG9rZW5zO1xuKGZ1bmN0aW9uIChTZW1hbnRpY1Rva2Vucykge1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKSAmJiAoY2FuZGlkYXRlLnJlc3VsdElkID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIGNhbmRpZGF0ZS5yZXN1bHRJZCA9PT0gJ3N0cmluZycpICYmXG4gICAgICAgICAgICBBcnJheS5pc0FycmF5KGNhbmRpZGF0ZS5kYXRhKSAmJiAoY2FuZGlkYXRlLmRhdGEubGVuZ3RoID09PSAwIHx8IHR5cGVvZiBjYW5kaWRhdGUuZGF0YVswXSA9PT0gJ251bWJlcicpO1xuICAgIH1cbiAgICBTZW1hbnRpY1Rva2Vucy5pcyA9IGlzO1xufSkoU2VtYW50aWNUb2tlbnMgfHwgKFNlbWFudGljVG9rZW5zID0ge30pKTtcbi8qKlxuICogVGhlIElubGluZVZhbHVlVGV4dCBuYW1lc3BhY2UgcHJvdmlkZXMgZnVuY3Rpb25zIHRvIGRlYWwgd2l0aCBJbmxpbmVWYWx1ZVRleHRzLlxuICpcbiAqIEBzaW5jZSAzLjE3LjBcbiAqL1xudmFyIElubGluZVZhbHVlVGV4dDtcbihmdW5jdGlvbiAoSW5saW5lVmFsdWVUZXh0KSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBJbmxpbmVWYWx1ZVRleHQgbGl0ZXJhbC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUocmFuZ2UsIHRleHQpIHtcbiAgICAgICAgcmV0dXJuIHsgcmFuZ2U6IHJhbmdlLCB0ZXh0OiB0ZXh0IH07XG4gICAgfVxuICAgIElubGluZVZhbHVlVGV4dC5jcmVhdGUgPSBjcmVhdGU7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICE9PSB1bmRlZmluZWQgJiYgY2FuZGlkYXRlICE9PSBudWxsICYmIFJhbmdlLmlzKGNhbmRpZGF0ZS5yYW5nZSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS50ZXh0KTtcbiAgICB9XG4gICAgSW5saW5lVmFsdWVUZXh0LmlzID0gaXM7XG59KShJbmxpbmVWYWx1ZVRleHQgfHwgKElubGluZVZhbHVlVGV4dCA9IHt9KSk7XG4vKipcbiAqIFRoZSBJbmxpbmVWYWx1ZVZhcmlhYmxlTG9va3VwIG5hbWVzcGFjZSBwcm92aWRlcyBmdW5jdGlvbnMgdG8gZGVhbCB3aXRoIElubGluZVZhbHVlVmFyaWFibGVMb29rdXBzLlxuICpcbiAqIEBzaW5jZSAzLjE3LjBcbiAqL1xudmFyIElubGluZVZhbHVlVmFyaWFibGVMb29rdXA7XG4oZnVuY3Rpb24gKElubGluZVZhbHVlVmFyaWFibGVMb29rdXApIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IElubGluZVZhbHVlVGV4dCBsaXRlcmFsLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShyYW5nZSwgdmFyaWFibGVOYW1lLCBjYXNlU2Vuc2l0aXZlTG9va3VwKSB7XG4gICAgICAgIHJldHVybiB7IHJhbmdlOiByYW5nZSwgdmFyaWFibGVOYW1lOiB2YXJpYWJsZU5hbWUsIGNhc2VTZW5zaXRpdmVMb29rdXA6IGNhc2VTZW5zaXRpdmVMb29rdXAgfTtcbiAgICB9XG4gICAgSW5saW5lVmFsdWVWYXJpYWJsZUxvb2t1cC5jcmVhdGUgPSBjcmVhdGU7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICE9PSB1bmRlZmluZWQgJiYgY2FuZGlkYXRlICE9PSBudWxsICYmIFJhbmdlLmlzKGNhbmRpZGF0ZS5yYW5nZSkgJiYgSXMuYm9vbGVhbihjYW5kaWRhdGUuY2FzZVNlbnNpdGl2ZUxvb2t1cClcbiAgICAgICAgICAgICYmIChJcy5zdHJpbmcoY2FuZGlkYXRlLnZhcmlhYmxlTmFtZSkgfHwgY2FuZGlkYXRlLnZhcmlhYmxlTmFtZSA9PT0gdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgSW5saW5lVmFsdWVWYXJpYWJsZUxvb2t1cC5pcyA9IGlzO1xufSkoSW5saW5lVmFsdWVWYXJpYWJsZUxvb2t1cCB8fCAoSW5saW5lVmFsdWVWYXJpYWJsZUxvb2t1cCA9IHt9KSk7XG4vKipcbiAqIFRoZSBJbmxpbmVWYWx1ZUV2YWx1YXRhYmxlRXhwcmVzc2lvbiBuYW1lc3BhY2UgcHJvdmlkZXMgZnVuY3Rpb25zIHRvIGRlYWwgd2l0aCBJbmxpbmVWYWx1ZUV2YWx1YXRhYmxlRXhwcmVzc2lvbi5cbiAqXG4gKiBAc2luY2UgMy4xNy4wXG4gKi9cbnZhciBJbmxpbmVWYWx1ZUV2YWx1YXRhYmxlRXhwcmVzc2lvbjtcbihmdW5jdGlvbiAoSW5saW5lVmFsdWVFdmFsdWF0YWJsZUV4cHJlc3Npb24pIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IElubGluZVZhbHVlRXZhbHVhdGFibGVFeHByZXNzaW9uIGxpdGVyYWwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHJhbmdlLCBleHByZXNzaW9uKSB7XG4gICAgICAgIHJldHVybiB7IHJhbmdlOiByYW5nZSwgZXhwcmVzc2lvbjogZXhwcmVzc2lvbiB9O1xuICAgIH1cbiAgICBJbmxpbmVWYWx1ZUV2YWx1YXRhYmxlRXhwcmVzc2lvbi5jcmVhdGUgPSBjcmVhdGU7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICE9PSB1bmRlZmluZWQgJiYgY2FuZGlkYXRlICE9PSBudWxsICYmIFJhbmdlLmlzKGNhbmRpZGF0ZS5yYW5nZSlcbiAgICAgICAgICAgICYmIChJcy5zdHJpbmcoY2FuZGlkYXRlLmV4cHJlc3Npb24pIHx8IGNhbmRpZGF0ZS5leHByZXNzaW9uID09PSB1bmRlZmluZWQpO1xuICAgIH1cbiAgICBJbmxpbmVWYWx1ZUV2YWx1YXRhYmxlRXhwcmVzc2lvbi5pcyA9IGlzO1xufSkoSW5saW5lVmFsdWVFdmFsdWF0YWJsZUV4cHJlc3Npb24gfHwgKElubGluZVZhbHVlRXZhbHVhdGFibGVFeHByZXNzaW9uID0ge30pKTtcbi8qKlxuICogVGhlIElubGluZVZhbHVlQ29udGV4dCBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBJbmxpbmVWYWx1ZUNvbnRleHR9IGxpdGVyYWxzLlxuICpcbiAqIEBzaW5jZSAzLjE3LjBcbiAqL1xudmFyIElubGluZVZhbHVlQ29udGV4dDtcbihmdW5jdGlvbiAoSW5saW5lVmFsdWVDb250ZXh0KSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBJbmxpbmVWYWx1ZUNvbnRleHQgbGl0ZXJhbC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUoZnJhbWVJZCwgc3RvcHBlZExvY2F0aW9uKSB7XG4gICAgICAgIHJldHVybiB7IGZyYW1lSWQ6IGZyYW1lSWQsIHN0b3BwZWRMb2NhdGlvbjogc3RvcHBlZExvY2F0aW9uIH07XG4gICAgfVxuICAgIElubGluZVZhbHVlQ29udGV4dC5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBJbmxpbmVWYWx1ZUNvbnRleHR9IGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5kZWZpbmVkKGNhbmRpZGF0ZSkgJiYgUmFuZ2UuaXModmFsdWUuc3RvcHBlZExvY2F0aW9uKTtcbiAgICB9XG4gICAgSW5saW5lVmFsdWVDb250ZXh0LmlzID0gaXM7XG59KShJbmxpbmVWYWx1ZUNvbnRleHQgfHwgKElubGluZVZhbHVlQ29udGV4dCA9IHt9KSk7XG4vKipcbiAqIElubGF5IGhpbnQga2luZHMuXG4gKlxuICogQHNpbmNlIDMuMTcuMFxuICovXG52YXIgSW5sYXlIaW50S2luZDtcbihmdW5jdGlvbiAoSW5sYXlIaW50S2luZCkge1xuICAgIC8qKlxuICAgICAqIEFuIGlubGF5IGhpbnQgdGhhdCBmb3IgYSB0eXBlIGFubm90YXRpb24uXG4gICAgICovXG4gICAgSW5sYXlIaW50S2luZC5UeXBlID0gMTtcbiAgICAvKipcbiAgICAgKiBBbiBpbmxheSBoaW50IHRoYXQgaXMgZm9yIGEgcGFyYW1ldGVyLlxuICAgICAqL1xuICAgIElubGF5SGludEtpbmQuUGFyYW1ldGVyID0gMjtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IDEgfHwgdmFsdWUgPT09IDI7XG4gICAgfVxuICAgIElubGF5SGludEtpbmQuaXMgPSBpcztcbn0pKElubGF5SGludEtpbmQgfHwgKElubGF5SGludEtpbmQgPSB7fSkpO1xudmFyIElubGF5SGludExhYmVsUGFydDtcbihmdW5jdGlvbiAoSW5sYXlIaW50TGFiZWxQYXJ0KSB7XG4gICAgZnVuY3Rpb24gY3JlYXRlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB7IHZhbHVlOiB2YWx1ZSB9O1xuICAgIH1cbiAgICBJbmxheUhpbnRMYWJlbFBhcnQuY3JlYXRlID0gY3JlYXRlO1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKVxuICAgICAgICAgICAgJiYgKGNhbmRpZGF0ZS50b29sdGlwID09PSB1bmRlZmluZWQgfHwgSXMuc3RyaW5nKGNhbmRpZGF0ZS50b29sdGlwKSB8fCBNYXJrdXBDb250ZW50LmlzKGNhbmRpZGF0ZS50b29sdGlwKSlcbiAgICAgICAgICAgICYmIChjYW5kaWRhdGUubG9jYXRpb24gPT09IHVuZGVmaW5lZCB8fCBMb2NhdGlvbi5pcyhjYW5kaWRhdGUubG9jYXRpb24pKVxuICAgICAgICAgICAgJiYgKGNhbmRpZGF0ZS5jb21tYW5kID09PSB1bmRlZmluZWQgfHwgQ29tbWFuZC5pcyhjYW5kaWRhdGUuY29tbWFuZCkpO1xuICAgIH1cbiAgICBJbmxheUhpbnRMYWJlbFBhcnQuaXMgPSBpcztcbn0pKElubGF5SGludExhYmVsUGFydCB8fCAoSW5sYXlIaW50TGFiZWxQYXJ0ID0ge30pKTtcbnZhciBJbmxheUhpbnQ7XG4oZnVuY3Rpb24gKElubGF5SGludCkge1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShwb3NpdGlvbiwgbGFiZWwsIGtpbmQpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHsgcG9zaXRpb246IHBvc2l0aW9uLCBsYWJlbDogbGFiZWwgfTtcbiAgICAgICAgaWYgKGtpbmQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzdWx0LmtpbmQgPSBraW5kO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIElubGF5SGludC5jcmVhdGUgPSBjcmVhdGU7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpICYmIFBvc2l0aW9uLmlzKGNhbmRpZGF0ZS5wb3NpdGlvbilcbiAgICAgICAgICAgICYmIChJcy5zdHJpbmcoY2FuZGlkYXRlLmxhYmVsKSB8fCBJcy50eXBlZEFycmF5KGNhbmRpZGF0ZS5sYWJlbCwgSW5sYXlIaW50TGFiZWxQYXJ0LmlzKSlcbiAgICAgICAgICAgICYmIChjYW5kaWRhdGUua2luZCA9PT0gdW5kZWZpbmVkIHx8IElubGF5SGludEtpbmQuaXMoY2FuZGlkYXRlLmtpbmQpKVxuICAgICAgICAgICAgJiYgKGNhbmRpZGF0ZS50ZXh0RWRpdHMgPT09IHVuZGVmaW5lZCkgfHwgSXMudHlwZWRBcnJheShjYW5kaWRhdGUudGV4dEVkaXRzLCBUZXh0RWRpdC5pcylcbiAgICAgICAgICAgICYmIChjYW5kaWRhdGUudG9vbHRpcCA9PT0gdW5kZWZpbmVkIHx8IElzLnN0cmluZyhjYW5kaWRhdGUudG9vbHRpcCkgfHwgTWFya3VwQ29udGVudC5pcyhjYW5kaWRhdGUudG9vbHRpcCkpXG4gICAgICAgICAgICAmJiAoY2FuZGlkYXRlLnBhZGRpbmdMZWZ0ID09PSB1bmRlZmluZWQgfHwgSXMuYm9vbGVhbihjYW5kaWRhdGUucGFkZGluZ0xlZnQpKVxuICAgICAgICAgICAgJiYgKGNhbmRpZGF0ZS5wYWRkaW5nUmlnaHQgPT09IHVuZGVmaW5lZCB8fCBJcy5ib29sZWFuKGNhbmRpZGF0ZS5wYWRkaW5nUmlnaHQpKTtcbiAgICB9XG4gICAgSW5sYXlIaW50LmlzID0gaXM7XG59KShJbmxheUhpbnQgfHwgKElubGF5SGludCA9IHt9KSk7XG52YXIgV29ya3NwYWNlRm9sZGVyO1xuKGZ1bmN0aW9uIChXb3Jrc3BhY2VGb2xkZXIpIHtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgVVJJLmlzKGNhbmRpZGF0ZS51cmkpICYmIElzLnN0cmluZyhjYW5kaWRhdGUubmFtZSk7XG4gICAgfVxuICAgIFdvcmtzcGFjZUZvbGRlci5pcyA9IGlzO1xufSkoV29ya3NwYWNlRm9sZGVyIHx8IChXb3Jrc3BhY2VGb2xkZXIgPSB7fSkpO1xudmFyIEVPTCA9IFsnXFxuJywgJ1xcclxcbicsICdcXHInXTtcbi8qKlxuICogQGRlcHJlY2F0ZWQgVXNlIHRoZSB0ZXh0IGRvY3VtZW50IGZyb20gdGhlIG5ldyB2c2NvZGUtbGFuZ3VhZ2VzZXJ2ZXItdGV4dGRvY3VtZW50IHBhY2thZ2UuXG4gKi9cbnZhciBUZXh0RG9jdW1lbnQ7XG4oZnVuY3Rpb24gKFRleHREb2N1bWVudCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgSVRleHREb2N1bWVudCBsaXRlcmFsIGZyb20gdGhlIGdpdmVuIHVyaSBhbmQgY29udGVudC5cbiAgICAgKiBAcGFyYW0gdXJpIFRoZSBkb2N1bWVudCdzIHVyaS5cbiAgICAgKiBAcGFyYW0gbGFuZ3VhZ2VJZCBUaGUgZG9jdW1lbnQncyBsYW5ndWFnZSBJZC5cbiAgICAgKiBAcGFyYW0gdmVyc2lvbiBUaGUgZG9jdW1lbnQncyB2ZXJzaW9uLlxuICAgICAqIEBwYXJhbSBjb250ZW50IFRoZSBkb2N1bWVudCdzIGNvbnRlbnQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHVyaSwgbGFuZ3VhZ2VJZCwgdmVyc2lvbiwgY29udGVudCkge1xuICAgICAgICByZXR1cm4gbmV3IEZ1bGxUZXh0RG9jdW1lbnQodXJpLCBsYW5ndWFnZUlkLCB2ZXJzaW9uLCBjb250ZW50KTtcbiAgICB9XG4gICAgVGV4dERvY3VtZW50LmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbGl0ZXJhbCBjb25mb3JtcyB0byB0aGUge0BsaW5rIElUZXh0RG9jdW1lbnR9IGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5kZWZpbmVkKGNhbmRpZGF0ZSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS51cmkpICYmIChJcy51bmRlZmluZWQoY2FuZGlkYXRlLmxhbmd1YWdlSWQpIHx8IElzLnN0cmluZyhjYW5kaWRhdGUubGFuZ3VhZ2VJZCkpICYmIElzLnVpbnRlZ2VyKGNhbmRpZGF0ZS5saW5lQ291bnQpXG4gICAgICAgICAgICAmJiBJcy5mdW5jKGNhbmRpZGF0ZS5nZXRUZXh0KSAmJiBJcy5mdW5jKGNhbmRpZGF0ZS5wb3NpdGlvbkF0KSAmJiBJcy5mdW5jKGNhbmRpZGF0ZS5vZmZzZXRBdCkgPyB0cnVlIDogZmFsc2U7XG4gICAgfVxuICAgIFRleHREb2N1bWVudC5pcyA9IGlzO1xuICAgIGZ1bmN0aW9uIGFwcGx5RWRpdHMoZG9jdW1lbnQsIGVkaXRzKSB7XG4gICAgICAgIHZhciB0ZXh0ID0gZG9jdW1lbnQuZ2V0VGV4dCgpO1xuICAgICAgICB2YXIgc29ydGVkRWRpdHMgPSBtZXJnZVNvcnQoZWRpdHMsIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICB2YXIgZGlmZiA9IGEucmFuZ2Uuc3RhcnQubGluZSAtIGIucmFuZ2Uuc3RhcnQubGluZTtcbiAgICAgICAgICAgIGlmIChkaWZmID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEucmFuZ2Uuc3RhcnQuY2hhcmFjdGVyIC0gYi5yYW5nZS5zdGFydC5jaGFyYWN0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGlmZjtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBsYXN0TW9kaWZpZWRPZmZzZXQgPSB0ZXh0Lmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IHNvcnRlZEVkaXRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICB2YXIgZSA9IHNvcnRlZEVkaXRzW2ldO1xuICAgICAgICAgICAgdmFyIHN0YXJ0T2Zmc2V0ID0gZG9jdW1lbnQub2Zmc2V0QXQoZS5yYW5nZS5zdGFydCk7XG4gICAgICAgICAgICB2YXIgZW5kT2Zmc2V0ID0gZG9jdW1lbnQub2Zmc2V0QXQoZS5yYW5nZS5lbmQpO1xuICAgICAgICAgICAgaWYgKGVuZE9mZnNldCA8PSBsYXN0TW9kaWZpZWRPZmZzZXQpIHtcbiAgICAgICAgICAgICAgICB0ZXh0ID0gdGV4dC5zdWJzdHJpbmcoMCwgc3RhcnRPZmZzZXQpICsgZS5uZXdUZXh0ICsgdGV4dC5zdWJzdHJpbmcoZW5kT2Zmc2V0LCB0ZXh0Lmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ092ZXJsYXBwaW5nIGVkaXQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxhc3RNb2RpZmllZE9mZnNldCA9IHN0YXJ0T2Zmc2V0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cbiAgICBUZXh0RG9jdW1lbnQuYXBwbHlFZGl0cyA9IGFwcGx5RWRpdHM7XG4gICAgZnVuY3Rpb24gbWVyZ2VTb3J0KGRhdGEsIGNvbXBhcmUpIHtcbiAgICAgICAgaWYgKGRhdGEubGVuZ3RoIDw9IDEpIHtcbiAgICAgICAgICAgIC8vIHNvcnRlZFxuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHAgPSAoZGF0YS5sZW5ndGggLyAyKSB8IDA7XG4gICAgICAgIHZhciBsZWZ0ID0gZGF0YS5zbGljZSgwLCBwKTtcbiAgICAgICAgdmFyIHJpZ2h0ID0gZGF0YS5zbGljZShwKTtcbiAgICAgICAgbWVyZ2VTb3J0KGxlZnQsIGNvbXBhcmUpO1xuICAgICAgICBtZXJnZVNvcnQocmlnaHQsIGNvbXBhcmUpO1xuICAgICAgICB2YXIgbGVmdElkeCA9IDA7XG4gICAgICAgIHZhciByaWdodElkeCA9IDA7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgd2hpbGUgKGxlZnRJZHggPCBsZWZ0Lmxlbmd0aCAmJiByaWdodElkeCA8IHJpZ2h0Lmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIHJldCA9IGNvbXBhcmUobGVmdFtsZWZ0SWR4XSwgcmlnaHRbcmlnaHRJZHhdKTtcbiAgICAgICAgICAgIGlmIChyZXQgPD0gMCkge1xuICAgICAgICAgICAgICAgIC8vIHNtYWxsZXJfZXF1YWwgLT4gdGFrZSBsZWZ0IHRvIHByZXNlcnZlIG9yZGVyXG4gICAgICAgICAgICAgICAgZGF0YVtpKytdID0gbGVmdFtsZWZ0SWR4KytdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gZ3JlYXRlciAtPiB0YWtlIHJpZ2h0XG4gICAgICAgICAgICAgICAgZGF0YVtpKytdID0gcmlnaHRbcmlnaHRJZHgrK107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGxlZnRJZHggPCBsZWZ0Lmxlbmd0aCkge1xuICAgICAgICAgICAgZGF0YVtpKytdID0gbGVmdFtsZWZ0SWR4KytdO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChyaWdodElkeCA8IHJpZ2h0Lmxlbmd0aCkge1xuICAgICAgICAgICAgZGF0YVtpKytdID0gcmlnaHRbcmlnaHRJZHgrK107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxufSkoVGV4dERvY3VtZW50IHx8IChUZXh0RG9jdW1lbnQgPSB7fSkpO1xuLyoqXG4gKiBAZGVwcmVjYXRlZCBVc2UgdGhlIHRleHQgZG9jdW1lbnQgZnJvbSB0aGUgbmV3IHZzY29kZS1sYW5ndWFnZXNlcnZlci10ZXh0ZG9jdW1lbnQgcGFja2FnZS5cbiAqL1xudmFyIEZ1bGxUZXh0RG9jdW1lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRnVsbFRleHREb2N1bWVudCh1cmksIGxhbmd1YWdlSWQsIHZlcnNpb24sIGNvbnRlbnQpIHtcbiAgICAgICAgdGhpcy5fdXJpID0gdXJpO1xuICAgICAgICB0aGlzLl9sYW5ndWFnZUlkID0gbGFuZ3VhZ2VJZDtcbiAgICAgICAgdGhpcy5fdmVyc2lvbiA9IHZlcnNpb247XG4gICAgICAgIHRoaXMuX2NvbnRlbnQgPSBjb250ZW50O1xuICAgICAgICB0aGlzLl9saW5lT2Zmc2V0cyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZ1bGxUZXh0RG9jdW1lbnQucHJvdG90eXBlLCBcInVyaVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3VyaTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGdWxsVGV4dERvY3VtZW50LnByb3RvdHlwZSwgXCJsYW5ndWFnZUlkXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbGFuZ3VhZ2VJZDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGdWxsVGV4dERvY3VtZW50LnByb3RvdHlwZSwgXCJ2ZXJzaW9uXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdmVyc2lvbjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIEZ1bGxUZXh0RG9jdW1lbnQucHJvdG90eXBlLmdldFRleHQgPSBmdW5jdGlvbiAocmFuZ2UpIHtcbiAgICAgICAgaWYgKHJhbmdlKSB7XG4gICAgICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLm9mZnNldEF0KHJhbmdlLnN0YXJ0KTtcbiAgICAgICAgICAgIHZhciBlbmQgPSB0aGlzLm9mZnNldEF0KHJhbmdlLmVuZCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29udGVudC5zdWJzdHJpbmcoc3RhcnQsIGVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRlbnQ7XG4gICAgfTtcbiAgICBGdWxsVGV4dERvY3VtZW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZXZlbnQsIHZlcnNpb24pIHtcbiAgICAgICAgdGhpcy5fY29udGVudCA9IGV2ZW50LnRleHQ7XG4gICAgICAgIHRoaXMuX3ZlcnNpb24gPSB2ZXJzaW9uO1xuICAgICAgICB0aGlzLl9saW5lT2Zmc2V0cyA9IHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIEZ1bGxUZXh0RG9jdW1lbnQucHJvdG90eXBlLmdldExpbmVPZmZzZXRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fbGluZU9mZnNldHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFyIGxpbmVPZmZzZXRzID0gW107XG4gICAgICAgICAgICB2YXIgdGV4dCA9IHRoaXMuX2NvbnRlbnQ7XG4gICAgICAgICAgICB2YXIgaXNMaW5lU3RhcnQgPSB0cnVlO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzTGluZVN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmVPZmZzZXRzLnB1c2goaSk7XG4gICAgICAgICAgICAgICAgICAgIGlzTGluZVN0YXJ0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBjaCA9IHRleHQuY2hhckF0KGkpO1xuICAgICAgICAgICAgICAgIGlzTGluZVN0YXJ0ID0gKGNoID09PSAnXFxyJyB8fCBjaCA9PT0gJ1xcbicpO1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ1xccicgJiYgaSArIDEgPCB0ZXh0Lmxlbmd0aCAmJiB0ZXh0LmNoYXJBdChpICsgMSkgPT09ICdcXG4nKSB7XG4gICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNMaW5lU3RhcnQgJiYgdGV4dC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgbGluZU9mZnNldHMucHVzaCh0ZXh0Lmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9saW5lT2Zmc2V0cyA9IGxpbmVPZmZzZXRzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9saW5lT2Zmc2V0cztcbiAgICB9O1xuICAgIEZ1bGxUZXh0RG9jdW1lbnQucHJvdG90eXBlLnBvc2l0aW9uQXQgPSBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgICAgIG9mZnNldCA9IE1hdGgubWF4KE1hdGgubWluKG9mZnNldCwgdGhpcy5fY29udGVudC5sZW5ndGgpLCAwKTtcbiAgICAgICAgdmFyIGxpbmVPZmZzZXRzID0gdGhpcy5nZXRMaW5lT2Zmc2V0cygpO1xuICAgICAgICB2YXIgbG93ID0gMCwgaGlnaCA9IGxpbmVPZmZzZXRzLmxlbmd0aDtcbiAgICAgICAgaWYgKGhpZ2ggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBQb3NpdGlvbi5jcmVhdGUoMCwgb2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAobG93IDwgaGlnaCkge1xuICAgICAgICAgICAgdmFyIG1pZCA9IE1hdGguZmxvb3IoKGxvdyArIGhpZ2gpIC8gMik7XG4gICAgICAgICAgICBpZiAobGluZU9mZnNldHNbbWlkXSA+IG9mZnNldCkge1xuICAgICAgICAgICAgICAgIGhpZ2ggPSBtaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb3cgPSBtaWQgKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGxvdyBpcyB0aGUgbGVhc3QgeCBmb3Igd2hpY2ggdGhlIGxpbmUgb2Zmc2V0IGlzIGxhcmdlciB0aGFuIHRoZSBjdXJyZW50IG9mZnNldFxuICAgICAgICAvLyBvciBhcnJheS5sZW5ndGggaWYgbm8gbGluZSBvZmZzZXQgaXMgbGFyZ2VyIHRoYW4gdGhlIGN1cnJlbnQgb2Zmc2V0XG4gICAgICAgIHZhciBsaW5lID0gbG93IC0gMTtcbiAgICAgICAgcmV0dXJuIFBvc2l0aW9uLmNyZWF0ZShsaW5lLCBvZmZzZXQgLSBsaW5lT2Zmc2V0c1tsaW5lXSk7XG4gICAgfTtcbiAgICBGdWxsVGV4dERvY3VtZW50LnByb3RvdHlwZS5vZmZzZXRBdCA9IGZ1bmN0aW9uIChwb3NpdGlvbikge1xuICAgICAgICB2YXIgbGluZU9mZnNldHMgPSB0aGlzLmdldExpbmVPZmZzZXRzKCk7XG4gICAgICAgIGlmIChwb3NpdGlvbi5saW5lID49IGxpbmVPZmZzZXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRlbnQubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBvc2l0aW9uLmxpbmUgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGluZU9mZnNldCA9IGxpbmVPZmZzZXRzW3Bvc2l0aW9uLmxpbmVdO1xuICAgICAgICB2YXIgbmV4dExpbmVPZmZzZXQgPSAocG9zaXRpb24ubGluZSArIDEgPCBsaW5lT2Zmc2V0cy5sZW5ndGgpID8gbGluZU9mZnNldHNbcG9zaXRpb24ubGluZSArIDFdIDogdGhpcy5fY29udGVudC5sZW5ndGg7XG4gICAgICAgIHJldHVybiBNYXRoLm1heChNYXRoLm1pbihsaW5lT2Zmc2V0ICsgcG9zaXRpb24uY2hhcmFjdGVyLCBuZXh0TGluZU9mZnNldCksIGxpbmVPZmZzZXQpO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZ1bGxUZXh0RG9jdW1lbnQucHJvdG90eXBlLCBcImxpbmVDb3VudFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TGluZU9mZnNldHMoKS5sZW5ndGg7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gRnVsbFRleHREb2N1bWVudDtcbn0oKSk7XG52YXIgSXM7XG4oZnVuY3Rpb24gKElzKSB7XG4gICAgdmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbiAgICBmdW5jdGlvbiBkZWZpbmVkKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnO1xuICAgIH1cbiAgICBJcy5kZWZpbmVkID0gZGVmaW5lZDtcbiAgICBmdW5jdGlvbiB1bmRlZmluZWQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCc7XG4gICAgfVxuICAgIElzLnVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbiAgICBmdW5jdGlvbiBib29sZWFuKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdHJ1ZSB8fCB2YWx1ZSA9PT0gZmFsc2U7XG4gICAgfVxuICAgIElzLmJvb2xlYW4gPSBib29sZWFuO1xuICAgIGZ1bmN0aW9uIHN0cmluZyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IFN0cmluZ10nO1xuICAgIH1cbiAgICBJcy5zdHJpbmcgPSBzdHJpbmc7XG4gICAgZnVuY3Rpb24gbnVtYmVyKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgTnVtYmVyXSc7XG4gICAgfVxuICAgIElzLm51bWJlciA9IG51bWJlcjtcbiAgICBmdW5jdGlvbiBudW1iZXJSYW5nZSh2YWx1ZSwgbWluLCBtYXgpIHtcbiAgICAgICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBOdW1iZXJdJyAmJiBtaW4gPD0gdmFsdWUgJiYgdmFsdWUgPD0gbWF4O1xuICAgIH1cbiAgICBJcy5udW1iZXJSYW5nZSA9IG51bWJlclJhbmdlO1xuICAgIGZ1bmN0aW9uIGludGVnZXIodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBOdW1iZXJdJyAmJiAtMjE0NzQ4MzY0OCA8PSB2YWx1ZSAmJiB2YWx1ZSA8PSAyMTQ3NDgzNjQ3O1xuICAgIH1cbiAgICBJcy5pbnRlZ2VyID0gaW50ZWdlcjtcbiAgICBmdW5jdGlvbiB1aW50ZWdlcih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IE51bWJlcl0nICYmIDAgPD0gdmFsdWUgJiYgdmFsdWUgPD0gMjE0NzQ4MzY0NztcbiAgICB9XG4gICAgSXMudWludGVnZXIgPSB1aW50ZWdlcjtcbiAgICBmdW5jdGlvbiBmdW5jKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbiAgICB9XG4gICAgSXMuZnVuYyA9IGZ1bmM7XG4gICAgZnVuY3Rpb24gb2JqZWN0TGl0ZXJhbCh2YWx1ZSkge1xuICAgICAgICAvLyBTdHJpY3RseSBzcGVha2luZyBjbGFzcyBpbnN0YW5jZXMgcGFzcyB0aGlzIGNoZWNrIGFzIHdlbGwuIFNpbmNlIHRoZSBMU1BcbiAgICAgICAgLy8gZG9lc24ndCB1c2UgY2xhc3NlcyB3ZSBpZ25vcmUgdGhpcyBmb3Igbm93LiBJZiB3ZSBkbyB3ZSBuZWVkIHRvIGFkZCBzb21ldGhpbmdcbiAgICAgICAgLy8gbGlrZSB0aGlzOiBgT2JqZWN0LmdldFByb3RvdHlwZU9mKE9iamVjdC5nZXRQcm90b3R5cGVPZih4KSkgPT09IG51bGxgXG4gICAgICAgIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnO1xuICAgIH1cbiAgICBJcy5vYmplY3RMaXRlcmFsID0gb2JqZWN0TGl0ZXJhbDtcbiAgICBmdW5jdGlvbiB0eXBlZEFycmF5KHZhbHVlLCBjaGVjaykge1xuICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUuZXZlcnkoY2hlY2spO1xuICAgIH1cbiAgICBJcy50eXBlZEFycmF5ID0gdHlwZWRBcnJheTtcbn0pKElzIHx8IChJcyA9IHt9KSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDQ4Nzk6XG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLmNyZWF0ZU1lc3NhZ2VDb25uZWN0aW9uID0gZXhwb3J0cy5Ccm93c2VyTWVzc2FnZVdyaXRlciA9IGV4cG9ydHMuQnJvd3Nlck1lc3NhZ2VSZWFkZXIgPSB2b2lkIDA7XG5jb25zdCByaWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oODkyNyk7XG4vLyBJbnN0YWxsIHRoZSBicm93c2VyIHJ1bnRpbWUgYWJzdHJhY3QuXG5yaWxfMS5kZWZhdWx0Lmluc3RhbGwoKTtcbmNvbnN0IGFwaV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4OTY5KTtcbl9fZXhwb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKDg5NjkpLCBleHBvcnRzKTtcbmNsYXNzIEJyb3dzZXJNZXNzYWdlUmVhZGVyIGV4dGVuZHMgYXBpXzEuQWJzdHJhY3RNZXNzYWdlUmVhZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX29uRGF0YSA9IG5ldyBhcGlfMS5FbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuX21lc3NhZ2VMaXN0ZW5lciA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fb25EYXRhLmZpcmUoZXZlbnQuZGF0YSk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnRleHQuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCAoZXZlbnQpID0+IHRoaXMuZmlyZUVycm9yKGV2ZW50KSk7XG4gICAgICAgIGNvbnRleHQub25tZXNzYWdlID0gdGhpcy5fbWVzc2FnZUxpc3RlbmVyO1xuICAgIH1cbiAgICBsaXN0ZW4oY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29uRGF0YS5ldmVudChjYWxsYmFjayk7XG4gICAgfVxufVxuZXhwb3J0cy5Ccm93c2VyTWVzc2FnZVJlYWRlciA9IEJyb3dzZXJNZXNzYWdlUmVhZGVyO1xuY2xhc3MgQnJvd3Nlck1lc3NhZ2VXcml0ZXIgZXh0ZW5kcyBhcGlfMS5BYnN0cmFjdE1lc3NhZ2VXcml0ZXIge1xuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgdGhpcy5lcnJvckNvdW50ID0gMDtcbiAgICAgICAgY29udGV4dC5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIChldmVudCkgPT4gdGhpcy5maXJlRXJyb3IoZXZlbnQpKTtcbiAgICB9XG4gICAgd3JpdGUobXNnKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHQucG9zdE1lc3NhZ2UobXNnKTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRXJyb3IoZXJyb3IsIG1zZyk7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZUVycm9yKGVycm9yLCBtc2cpIHtcbiAgICAgICAgdGhpcy5lcnJvckNvdW50Kys7XG4gICAgICAgIHRoaXMuZmlyZUVycm9yKGVycm9yLCBtc2csIHRoaXMuZXJyb3JDb3VudCk7XG4gICAgfVxuICAgIGVuZCgpIHtcbiAgICB9XG59XG5leHBvcnRzLkJyb3dzZXJNZXNzYWdlV3JpdGVyID0gQnJvd3Nlck1lc3NhZ2VXcml0ZXI7XG5mdW5jdGlvbiBjcmVhdGVNZXNzYWdlQ29ubmVjdGlvbihyZWFkZXIsIHdyaXRlciwgbG9nZ2VyLCBvcHRpb25zKSB7XG4gICAgaWYgKGxvZ2dlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxvZ2dlciA9IGFwaV8xLk51bGxMb2dnZXI7XG4gICAgfVxuICAgIGlmIChhcGlfMS5Db25uZWN0aW9uU3RyYXRlZ3kuaXMob3B0aW9ucykpIHtcbiAgICAgICAgb3B0aW9ucyA9IHsgY29ubmVjdGlvblN0cmF0ZWd5OiBvcHRpb25zIH07XG4gICAgfVxuICAgIHJldHVybiAoMCwgYXBpXzEuY3JlYXRlTWVzc2FnZUNvbm5lY3Rpb24pKHJlYWRlciwgd3JpdGVyLCBsb2dnZXIsIG9wdGlvbnMpO1xufVxuZXhwb3J0cy5jcmVhdGVNZXNzYWdlQ29ubmVjdGlvbiA9IGNyZWF0ZU1lc3NhZ2VDb25uZWN0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWFpbi5qcy5tYXBcblxuLyoqKi8gfSksXG5cbi8qKiovIDg5Mjc6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogcHJvdmlkZWQgZGVwZW5kZW5jeSAqLyB2YXIgY29uc29sZSA9IF9fd2VicGFja19yZXF1aXJlX18oNDM2NCk7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuY29uc3QgcmFsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQyNTQpO1xuY29uc3QgZGlzcG9zYWJsZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3OTYzKTtcbmNvbnN0IGV2ZW50c18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NzgwKTtcbmNvbnN0IG1lc3NhZ2VCdWZmZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjE4MCk7XG5jbGFzcyBNZXNzYWdlQnVmZmVyIGV4dGVuZHMgbWVzc2FnZUJ1ZmZlcl8xLkFic3RyYWN0TWVzc2FnZUJ1ZmZlciB7XG4gICAgY29uc3RydWN0b3IoZW5jb2RpbmcgPSAndXRmLTgnKSB7XG4gICAgICAgIHN1cGVyKGVuY29kaW5nKTtcbiAgICAgICAgdGhpcy5hc2NpaURlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoJ2FzY2lpJyk7XG4gICAgfVxuICAgIGVtcHR5QnVmZmVyKCkge1xuICAgICAgICByZXR1cm4gTWVzc2FnZUJ1ZmZlci5lbXB0eUJ1ZmZlcjtcbiAgICB9XG4gICAgZnJvbVN0cmluZyh2YWx1ZSwgX2VuY29kaW5nKSB7XG4gICAgICAgIHJldHVybiAobmV3IFRleHRFbmNvZGVyKCkpLmVuY29kZSh2YWx1ZSk7XG4gICAgfVxuICAgIHRvU3RyaW5nKHZhbHVlLCBlbmNvZGluZykge1xuICAgICAgICBpZiAoZW5jb2RpbmcgPT09ICdhc2NpaScpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFzY2lpRGVjb2Rlci5kZWNvZGUodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIChuZXcgVGV4dERlY29kZXIoZW5jb2RpbmcpKS5kZWNvZGUodmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzTmF0aXZlKGJ1ZmZlciwgbGVuZ3RoKSB7XG4gICAgICAgIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBidWZmZXIuc2xpY2UoMCwgbGVuZ3RoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhbGxvY05hdGl2ZShsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG4gICAgfVxufVxuTWVzc2FnZUJ1ZmZlci5lbXB0eUJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KDApO1xuY2xhc3MgUmVhZGFibGVTdHJlYW1XcmFwcGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihzb2NrZXQpIHtcbiAgICAgICAgdGhpcy5zb2NrZXQgPSBzb2NrZXQ7XG4gICAgICAgIHRoaXMuX29uRGF0YSA9IG5ldyBldmVudHNfMS5FbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuX21lc3NhZ2VMaXN0ZW5lciA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYmxvYiA9IGV2ZW50LmRhdGE7XG4gICAgICAgICAgICBibG9iLmFycmF5QnVmZmVyKCkudGhlbigoYnVmZmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fb25EYXRhLmZpcmUobmV3IFVpbnQ4QXJyYXkoYnVmZmVyKSk7XG4gICAgICAgICAgICB9LCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgKDAsIHJhbF8xLmRlZmF1bHQpKCkuY29uc29sZS5lcnJvcihgQ29udmVydGluZyBibG9iIHRvIGFycmF5IGJ1ZmZlciBmYWlsZWQuYCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIHRoaXMuX21lc3NhZ2VMaXN0ZW5lcik7XG4gICAgfVxuICAgIG9uQ2xvc2UobGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5zb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcignY2xvc2UnLCBsaXN0ZW5lcik7XG4gICAgICAgIHJldHVybiBkaXNwb3NhYmxlXzEuRGlzcG9zYWJsZS5jcmVhdGUoKCkgPT4gdGhpcy5zb2NrZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xvc2UnLCBsaXN0ZW5lcikpO1xuICAgIH1cbiAgICBvbkVycm9yKGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgbGlzdGVuZXIpO1xuICAgICAgICByZXR1cm4gZGlzcG9zYWJsZV8xLkRpc3Bvc2FibGUuY3JlYXRlKCgpID0+IHRoaXMuc29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgbGlzdGVuZXIpKTtcbiAgICB9XG4gICAgb25FbmQobGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5zb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcignZW5kJywgbGlzdGVuZXIpO1xuICAgICAgICByZXR1cm4gZGlzcG9zYWJsZV8xLkRpc3Bvc2FibGUuY3JlYXRlKCgpID0+IHRoaXMuc29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2VuZCcsIGxpc3RlbmVyKSk7XG4gICAgfVxuICAgIG9uRGF0YShsaXN0ZW5lcikge1xuICAgICAgICByZXR1cm4gdGhpcy5fb25EYXRhLmV2ZW50KGxpc3RlbmVyKTtcbiAgICB9XG59XG5jbGFzcyBXcml0YWJsZVN0cmVhbVdyYXBwZXIge1xuICAgIGNvbnN0cnVjdG9yKHNvY2tldCkge1xuICAgICAgICB0aGlzLnNvY2tldCA9IHNvY2tldDtcbiAgICB9XG4gICAgb25DbG9zZShsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLnNvY2tldC5hZGRFdmVudExpc3RlbmVyKCdjbG9zZScsIGxpc3RlbmVyKTtcbiAgICAgICAgcmV0dXJuIGRpc3Bvc2FibGVfMS5EaXNwb3NhYmxlLmNyZWF0ZSgoKSA9PiB0aGlzLnNvY2tldC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbG9zZScsIGxpc3RlbmVyKSk7XG4gICAgfVxuICAgIG9uRXJyb3IobGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5zb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBsaXN0ZW5lcik7XG4gICAgICAgIHJldHVybiBkaXNwb3NhYmxlXzEuRGlzcG9zYWJsZS5jcmVhdGUoKCkgPT4gdGhpcy5zb2NrZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCBsaXN0ZW5lcikpO1xuICAgIH1cbiAgICBvbkVuZChsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLnNvY2tldC5hZGRFdmVudExpc3RlbmVyKCdlbmQnLCBsaXN0ZW5lcik7XG4gICAgICAgIHJldHVybiBkaXNwb3NhYmxlXzEuRGlzcG9zYWJsZS5jcmVhdGUoKCkgPT4gdGhpcy5zb2NrZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZW5kJywgbGlzdGVuZXIpKTtcbiAgICB9XG4gICAgd3JpdGUoZGF0YSwgZW5jb2RpbmcpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQgJiYgZW5jb2RpbmcgIT09ICd1dGYtOCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEluIGEgQnJvd3NlciBlbnZpcm9ubWVudHMgb25seSB1dGYtOCB0ZXh0IGVuY29kaW5nIGlzIHN1cHBvcnRlZC4gQnV0IGdvdCBlbmNvZGluZzogJHtlbmNvZGluZ31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc29ja2V0LnNlbmQoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNvY2tldC5zZW5kKGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgZW5kKCkge1xuICAgICAgICB0aGlzLnNvY2tldC5jbG9zZSgpO1xuICAgIH1cbn1cbmNvbnN0IF90ZXh0RW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuY29uc3QgX3JpbCA9IE9iamVjdC5mcmVlemUoe1xuICAgIG1lc3NhZ2VCdWZmZXI6IE9iamVjdC5mcmVlemUoe1xuICAgICAgICBjcmVhdGU6IChlbmNvZGluZykgPT4gbmV3IE1lc3NhZ2VCdWZmZXIoZW5jb2RpbmcpXG4gICAgfSksXG4gICAgYXBwbGljYXRpb25Kc29uOiBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgZW5jb2RlcjogT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgICAgICBuYW1lOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICBlbmNvZGU6IChtc2csIG9wdGlvbnMpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5jaGFyc2V0ICE9PSAndXRmLTgnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW4gYSBCcm93c2VyIGVudmlyb25tZW50cyBvbmx5IHV0Zi04IHRleHQgZW5jb2RpbmcgaXMgc3VwcG9ydGVkLiBCdXQgZ290IGVuY29kaW5nOiAke29wdGlvbnMuY2hhcnNldH1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShfdGV4dEVuY29kZXIuZW5jb2RlKEpTT04uc3RyaW5naWZ5KG1zZywgdW5kZWZpbmVkLCAwKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSxcbiAgICAgICAgZGVjb2RlcjogT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgICAgICBuYW1lOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICBkZWNvZGU6IChidWZmZXIsIG9wdGlvbnMpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIShidWZmZXIgaW5zdGFuY2VvZiBVaW50OEFycmF5KSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEluIGEgQnJvd3NlciBlbnZpcm9ubWVudHMgb25seSBVaW50OEFycmF5cyBhcmUgc3VwcG9ydGVkLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKEpTT04ucGFyc2UobmV3IFRleHREZWNvZGVyKG9wdGlvbnMuY2hhcnNldCkuZGVjb2RlKGJ1ZmZlcikpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICB9KSxcbiAgICBzdHJlYW06IE9iamVjdC5mcmVlemUoe1xuICAgICAgICBhc1JlYWRhYmxlU3RyZWFtOiAoc29ja2V0KSA9PiBuZXcgUmVhZGFibGVTdHJlYW1XcmFwcGVyKHNvY2tldCksXG4gICAgICAgIGFzV3JpdGFibGVTdHJlYW06IChzb2NrZXQpID0+IG5ldyBXcml0YWJsZVN0cmVhbVdyYXBwZXIoc29ja2V0KVxuICAgIH0pLFxuICAgIGNvbnNvbGU6IGNvbnNvbGUsXG4gICAgdGltZXI6IE9iamVjdC5mcmVlemUoe1xuICAgICAgICBzZXRUaW1lb3V0KGNhbGxiYWNrLCBtcywgLi4uYXJncykge1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlID0gc2V0VGltZW91dChjYWxsYmFjaywgbXMsIC4uLmFyZ3MpO1xuICAgICAgICAgICAgcmV0dXJuIHsgZGlzcG9zZTogKCkgPT4gY2xlYXJUaW1lb3V0KGhhbmRsZSkgfTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0SW1tZWRpYXRlKGNhbGxiYWNrLCAuLi5hcmdzKSB7XG4gICAgICAgICAgICBjb25zdCBoYW5kbGUgPSBzZXRUaW1lb3V0KGNhbGxiYWNrLCAwLCAuLi5hcmdzKTtcbiAgICAgICAgICAgIHJldHVybiB7IGRpc3Bvc2U6ICgpID0+IGNsZWFyVGltZW91dChoYW5kbGUpIH07XG4gICAgICAgIH0sXG4gICAgICAgIHNldEludGVydmFsKGNhbGxiYWNrLCBtcywgLi4uYXJncykge1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlID0gc2V0SW50ZXJ2YWwoY2FsbGJhY2ssIG1zLCAuLi5hcmdzKTtcbiAgICAgICAgICAgIHJldHVybiB7IGRpc3Bvc2U6ICgpID0+IGNsZWFySW50ZXJ2YWwoaGFuZGxlKSB9O1xuICAgICAgICB9LFxuICAgIH0pXG59KTtcbmZ1bmN0aW9uIFJJTCgpIHtcbiAgICByZXR1cm4gX3JpbDtcbn1cbihmdW5jdGlvbiAoUklMKSB7XG4gICAgZnVuY3Rpb24gaW5zdGFsbCgpIHtcbiAgICAgICAgcmFsXzEuZGVmYXVsdC5pbnN0YWxsKF9yaWwpO1xuICAgIH1cbiAgICBSSUwuaW5zdGFsbCA9IGluc3RhbGw7XG59KShSSUwgfHwgKFJJTCA9IHt9KSk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IFJJTDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJpbC5qcy5tYXBcblxuLyoqKi8gfSksXG5cbi8qKiovIDg5Njk6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vLi4vdHlwaW5ncy90aGVuYWJsZS5kLnRzXCIgLz5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5UcmFjZUZvcm1hdCA9IGV4cG9ydHMuVHJhY2VWYWx1ZXMgPSBleHBvcnRzLlRyYWNlID0gZXhwb3J0cy5Qcm9ncmVzc1R5cGUgPSBleHBvcnRzLlByb2dyZXNzVG9rZW4gPSBleHBvcnRzLmNyZWF0ZU1lc3NhZ2VDb25uZWN0aW9uID0gZXhwb3J0cy5OdWxsTG9nZ2VyID0gZXhwb3J0cy5Db25uZWN0aW9uT3B0aW9ucyA9IGV4cG9ydHMuQ29ubmVjdGlvblN0cmF0ZWd5ID0gZXhwb3J0cy5Xcml0ZWFibGVTdHJlYW1NZXNzYWdlV3JpdGVyID0gZXhwb3J0cy5BYnN0cmFjdE1lc3NhZ2VXcml0ZXIgPSBleHBvcnRzLk1lc3NhZ2VXcml0ZXIgPSBleHBvcnRzLlJlYWRhYmxlU3RyZWFtTWVzc2FnZVJlYWRlciA9IGV4cG9ydHMuQWJzdHJhY3RNZXNzYWdlUmVhZGVyID0gZXhwb3J0cy5NZXNzYWdlUmVhZGVyID0gZXhwb3J0cy5DYW5jZWxsYXRpb25Ub2tlbiA9IGV4cG9ydHMuQ2FuY2VsbGF0aW9uVG9rZW5Tb3VyY2UgPSBleHBvcnRzLkVtaXR0ZXIgPSBleHBvcnRzLkV2ZW50ID0gZXhwb3J0cy5EaXNwb3NhYmxlID0gZXhwb3J0cy5MUlVDYWNoZSA9IGV4cG9ydHMuVG91Y2ggPSBleHBvcnRzLkxpbmtlZE1hcCA9IGV4cG9ydHMuUGFyYW1ldGVyU3RydWN0dXJlcyA9IGV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTkgPSBleHBvcnRzLk5vdGlmaWNhdGlvblR5cGU4ID0gZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlNyA9IGV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTYgPSBleHBvcnRzLk5vdGlmaWNhdGlvblR5cGU1ID0gZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlNCA9IGV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTMgPSBleHBvcnRzLk5vdGlmaWNhdGlvblR5cGUyID0gZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlMSA9IGV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTAgPSBleHBvcnRzLk5vdGlmaWNhdGlvblR5cGUgPSBleHBvcnRzLkVycm9yQ29kZXMgPSBleHBvcnRzLlJlc3BvbnNlRXJyb3IgPSBleHBvcnRzLlJlcXVlc3RUeXBlOSA9IGV4cG9ydHMuUmVxdWVzdFR5cGU4ID0gZXhwb3J0cy5SZXF1ZXN0VHlwZTcgPSBleHBvcnRzLlJlcXVlc3RUeXBlNiA9IGV4cG9ydHMuUmVxdWVzdFR5cGU1ID0gZXhwb3J0cy5SZXF1ZXN0VHlwZTQgPSBleHBvcnRzLlJlcXVlc3RUeXBlMyA9IGV4cG9ydHMuUmVxdWVzdFR5cGUyID0gZXhwb3J0cy5SZXF1ZXN0VHlwZTEgPSBleHBvcnRzLlJlcXVlc3RUeXBlMCA9IGV4cG9ydHMuUmVxdWVzdFR5cGUgPSBleHBvcnRzLk1lc3NhZ2UgPSBleHBvcnRzLlJBTCA9IHZvaWQgMDtcbmV4cG9ydHMuQ2FuY2VsbGF0aW9uU3RyYXRlZ3kgPSBleHBvcnRzLkNhbmNlbGxhdGlvblNlbmRlclN0cmF0ZWd5ID0gZXhwb3J0cy5DYW5jZWxsYXRpb25SZWNlaXZlclN0cmF0ZWd5ID0gZXhwb3J0cy5Db25uZWN0aW9uRXJyb3IgPSBleHBvcnRzLkNvbm5lY3Rpb25FcnJvcnMgPSBleHBvcnRzLkxvZ1RyYWNlTm90aWZpY2F0aW9uID0gZXhwb3J0cy5TZXRUcmFjZU5vdGlmaWNhdGlvbiA9IHZvaWQgMDtcbmNvbnN0IG1lc3NhZ2VzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQzMTMpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTWVzc2FnZVwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuTWVzc2FnZTsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJSZXF1ZXN0VHlwZVwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuUmVxdWVzdFR5cGU7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUmVxdWVzdFR5cGUwXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZXNfMS5SZXF1ZXN0VHlwZTA7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUmVxdWVzdFR5cGUxXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZXNfMS5SZXF1ZXN0VHlwZTE7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUmVxdWVzdFR5cGUyXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZXNfMS5SZXF1ZXN0VHlwZTI7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUmVxdWVzdFR5cGUzXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZXNfMS5SZXF1ZXN0VHlwZTM7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUmVxdWVzdFR5cGU0XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZXNfMS5SZXF1ZXN0VHlwZTQ7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUmVxdWVzdFR5cGU1XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZXNfMS5SZXF1ZXN0VHlwZTU7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUmVxdWVzdFR5cGU2XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZXNfMS5SZXF1ZXN0VHlwZTY7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUmVxdWVzdFR5cGU3XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZXNfMS5SZXF1ZXN0VHlwZTc7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUmVxdWVzdFR5cGU4XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZXNfMS5SZXF1ZXN0VHlwZTg7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUmVxdWVzdFR5cGU5XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZXNfMS5SZXF1ZXN0VHlwZTk7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUmVzcG9uc2VFcnJvclwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuUmVzcG9uc2VFcnJvcjsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJFcnJvckNvZGVzXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZXNfMS5FcnJvckNvZGVzOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5vdGlmaWNhdGlvblR5cGVcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlc18xLk5vdGlmaWNhdGlvblR5cGU7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTm90aWZpY2F0aW9uVHlwZTBcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlc18xLk5vdGlmaWNhdGlvblR5cGUwOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5vdGlmaWNhdGlvblR5cGUxXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZXNfMS5Ob3RpZmljYXRpb25UeXBlMTsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOb3RpZmljYXRpb25UeXBlMlwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuTm90aWZpY2F0aW9uVHlwZTI7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTm90aWZpY2F0aW9uVHlwZTNcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlc18xLk5vdGlmaWNhdGlvblR5cGUzOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5vdGlmaWNhdGlvblR5cGU0XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZXNfMS5Ob3RpZmljYXRpb25UeXBlNDsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOb3RpZmljYXRpb25UeXBlNVwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuTm90aWZpY2F0aW9uVHlwZTU7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTm90aWZpY2F0aW9uVHlwZTZcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlc18xLk5vdGlmaWNhdGlvblR5cGU2OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5vdGlmaWNhdGlvblR5cGU3XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZXNfMS5Ob3RpZmljYXRpb25UeXBlNzsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOb3RpZmljYXRpb25UeXBlOFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuTm90aWZpY2F0aW9uVHlwZTg7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTm90aWZpY2F0aW9uVHlwZTlcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlc18xLk5vdGlmaWNhdGlvblR5cGU5OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlBhcmFtZXRlclN0cnVjdHVyZXNcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlc18xLlBhcmFtZXRlclN0cnVjdHVyZXM7IH0gfSkpO1xuY29uc3QgbGlua2VkTWFwXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYxNzYpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTGlua2VkTWFwXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbGlua2VkTWFwXzEuTGlua2VkTWFwOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkxSVUNhY2hlXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbGlua2VkTWFwXzEuTFJVQ2FjaGU7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVG91Y2hcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsaW5rZWRNYXBfMS5Ub3VjaDsgfSB9KSk7XG5jb25zdCBkaXNwb3NhYmxlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc5NjMpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRGlzcG9zYWJsZVwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRpc3Bvc2FibGVfMS5EaXNwb3NhYmxlOyB9IH0pKTtcbmNvbnN0IGV2ZW50c18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NzgwKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkV2ZW50XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZXZlbnRzXzEuRXZlbnQ7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRW1pdHRlclwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGV2ZW50c18xLkVtaXR0ZXI7IH0gfSkpO1xuY29uc3QgY2FuY2VsbGF0aW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMxMDYpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ2FuY2VsbGF0aW9uVG9rZW5Tb3VyY2VcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjYW5jZWxsYXRpb25fMS5DYW5jZWxsYXRpb25Ub2tlblNvdXJjZTsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDYW5jZWxsYXRpb25Ub2tlblwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNhbmNlbGxhdGlvbl8xLkNhbmNlbGxhdGlvblRva2VuOyB9IH0pKTtcbmNvbnN0IG1lc3NhZ2VSZWFkZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oOTgxMyk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJNZXNzYWdlUmVhZGVyXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZVJlYWRlcl8xLk1lc3NhZ2VSZWFkZXI7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQWJzdHJhY3RNZXNzYWdlUmVhZGVyXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZVJlYWRlcl8xLkFic3RyYWN0TWVzc2FnZVJlYWRlcjsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJSZWFkYWJsZVN0cmVhbU1lc3NhZ2VSZWFkZXJcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlUmVhZGVyXzEuUmVhZGFibGVTdHJlYW1NZXNzYWdlUmVhZGVyOyB9IH0pKTtcbmNvbnN0IG1lc3NhZ2VXcml0ZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNzc0NSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJNZXNzYWdlV3JpdGVyXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZVdyaXRlcl8xLk1lc3NhZ2VXcml0ZXI7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQWJzdHJhY3RNZXNzYWdlV3JpdGVyXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZVdyaXRlcl8xLkFic3RyYWN0TWVzc2FnZVdyaXRlcjsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJXcml0ZWFibGVTdHJlYW1NZXNzYWdlV3JpdGVyXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZVdyaXRlcl8xLldyaXRlYWJsZVN0cmVhbU1lc3NhZ2VXcml0ZXI7IH0gfSkpO1xuY29uc3QgY29ubmVjdGlvbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NjMwKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNvbm5lY3Rpb25TdHJhdGVneVwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbm5lY3Rpb25fMS5Db25uZWN0aW9uU3RyYXRlZ3k7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ29ubmVjdGlvbk9wdGlvbnNcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25uZWN0aW9uXzEuQ29ubmVjdGlvbk9wdGlvbnM7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTnVsbExvZ2dlclwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbm5lY3Rpb25fMS5OdWxsTG9nZ2VyOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNyZWF0ZU1lc3NhZ2VDb25uZWN0aW9uXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29ubmVjdGlvbl8xLmNyZWF0ZU1lc3NhZ2VDb25uZWN0aW9uOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlByb2dyZXNzVG9rZW5cIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25uZWN0aW9uXzEuUHJvZ3Jlc3NUb2tlbjsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJQcm9ncmVzc1R5cGVcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25uZWN0aW9uXzEuUHJvZ3Jlc3NUeXBlOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlRyYWNlXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29ubmVjdGlvbl8xLlRyYWNlOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlRyYWNlVmFsdWVzXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29ubmVjdGlvbl8xLlRyYWNlVmFsdWVzOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlRyYWNlRm9ybWF0XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29ubmVjdGlvbl8xLlRyYWNlRm9ybWF0OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNldFRyYWNlTm90aWZpY2F0aW9uXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29ubmVjdGlvbl8xLlNldFRyYWNlTm90aWZpY2F0aW9uOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkxvZ1RyYWNlTm90aWZpY2F0aW9uXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29ubmVjdGlvbl8xLkxvZ1RyYWNlTm90aWZpY2F0aW9uOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNvbm5lY3Rpb25FcnJvcnNcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25uZWN0aW9uXzEuQ29ubmVjdGlvbkVycm9yczsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDb25uZWN0aW9uRXJyb3JcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25uZWN0aW9uXzEuQ29ubmVjdGlvbkVycm9yOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3lcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25uZWN0aW9uXzEuQ2FuY2VsbGF0aW9uUmVjZWl2ZXJTdHJhdGVneTsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDYW5jZWxsYXRpb25TZW5kZXJTdHJhdGVneVwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbm5lY3Rpb25fMS5DYW5jZWxsYXRpb25TZW5kZXJTdHJhdGVneTsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDYW5jZWxsYXRpb25TdHJhdGVneVwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbm5lY3Rpb25fMS5DYW5jZWxsYXRpb25TdHJhdGVneTsgfSB9KSk7XG5jb25zdCByYWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNDI1NCk7XG5leHBvcnRzLlJBTCA9IHJhbF8xLmRlZmF1bHQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcGkuanMubWFwXG5cbi8qKiovIH0pLFxuXG4vKioqLyAzMTA2OlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuQ2FuY2VsbGF0aW9uVG9rZW5Tb3VyY2UgPSBleHBvcnRzLkNhbmNlbGxhdGlvblRva2VuID0gdm9pZCAwO1xuY29uc3QgcmFsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQyNTQpO1xuY29uc3QgSXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYxNDUpO1xuY29uc3QgZXZlbnRzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY3ODApO1xudmFyIENhbmNlbGxhdGlvblRva2VuO1xuKGZ1bmN0aW9uIChDYW5jZWxsYXRpb25Ub2tlbikge1xuICAgIENhbmNlbGxhdGlvblRva2VuLk5vbmUgPSBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgaXNDYW5jZWxsYXRpb25SZXF1ZXN0ZWQ6IGZhbHNlLFxuICAgICAgICBvbkNhbmNlbGxhdGlvblJlcXVlc3RlZDogZXZlbnRzXzEuRXZlbnQuTm9uZVxuICAgIH0pO1xuICAgIENhbmNlbGxhdGlvblRva2VuLkNhbmNlbGxlZCA9IE9iamVjdC5mcmVlemUoe1xuICAgICAgICBpc0NhbmNlbGxhdGlvblJlcXVlc3RlZDogdHJ1ZSxcbiAgICAgICAgb25DYW5jZWxsYXRpb25SZXF1ZXN0ZWQ6IGV2ZW50c18xLkV2ZW50Lk5vbmVcbiAgICB9KTtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJiAoY2FuZGlkYXRlID09PSBDYW5jZWxsYXRpb25Ub2tlbi5Ob25lXG4gICAgICAgICAgICB8fCBjYW5kaWRhdGUgPT09IENhbmNlbGxhdGlvblRva2VuLkNhbmNlbGxlZFxuICAgICAgICAgICAgfHwgKElzLmJvb2xlYW4oY2FuZGlkYXRlLmlzQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKSAmJiAhIWNhbmRpZGF0ZS5vbkNhbmNlbGxhdGlvblJlcXVlc3RlZCkpO1xuICAgIH1cbiAgICBDYW5jZWxsYXRpb25Ub2tlbi5pcyA9IGlzO1xufSkoQ2FuY2VsbGF0aW9uVG9rZW4gPSBleHBvcnRzLkNhbmNlbGxhdGlvblRva2VuIHx8IChleHBvcnRzLkNhbmNlbGxhdGlvblRva2VuID0ge30pKTtcbmNvbnN0IHNob3J0Y3V0RXZlbnQgPSBPYmplY3QuZnJlZXplKGZ1bmN0aW9uIChjYWxsYmFjaywgY29udGV4dCkge1xuICAgIGNvbnN0IGhhbmRsZSA9ICgwLCByYWxfMS5kZWZhdWx0KSgpLnRpbWVyLnNldFRpbWVvdXQoY2FsbGJhY2suYmluZChjb250ZXh0KSwgMCk7XG4gICAgcmV0dXJuIHsgZGlzcG9zZSgpIHsgaGFuZGxlLmRpc3Bvc2UoKTsgfSB9O1xufSk7XG5jbGFzcyBNdXRhYmxlVG9rZW4ge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLl9pc0NhbmNlbGxlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBjYW5jZWwoKSB7XG4gICAgICAgIGlmICghdGhpcy5faXNDYW5jZWxsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2lzQ2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9lbWl0dGVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZW1pdHRlci5maXJlKHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGlzQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNDYW5jZWxsZWQ7XG4gICAgfVxuICAgIGdldCBvbkNhbmNlbGxhdGlvblJlcXVlc3RlZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzQ2FuY2VsbGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gc2hvcnRjdXRFdmVudDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX2VtaXR0ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX2VtaXR0ZXIgPSBuZXcgZXZlbnRzXzEuRW1pdHRlcigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9lbWl0dGVyLmV2ZW50O1xuICAgIH1cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICBpZiAodGhpcy5fZW1pdHRlcikge1xuICAgICAgICAgICAgdGhpcy5fZW1pdHRlci5kaXNwb3NlKCk7XG4gICAgICAgICAgICB0aGlzLl9lbWl0dGVyID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxufVxuY2xhc3MgQ2FuY2VsbGF0aW9uVG9rZW5Tb3VyY2Uge1xuICAgIGdldCB0b2tlbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLl90b2tlbikge1xuICAgICAgICAgICAgLy8gYmUgbGF6eSBhbmQgY3JlYXRlIHRoZSB0b2tlbiBvbmx5IHdoZW5cbiAgICAgICAgICAgIC8vIGFjdHVhbGx5IG5lZWRlZFxuICAgICAgICAgICAgdGhpcy5fdG9rZW4gPSBuZXcgTXV0YWJsZVRva2VuKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3Rva2VuO1xuICAgIH1cbiAgICBjYW5jZWwoKSB7XG4gICAgICAgIGlmICghdGhpcy5fdG9rZW4pIHtcbiAgICAgICAgICAgIC8vIHNhdmUgYW4gb2JqZWN0IGJ5IHJldHVybmluZyB0aGUgZGVmYXVsdFxuICAgICAgICAgICAgLy8gY2FuY2VsbGVkIHRva2VuIHdoZW4gY2FuY2VsbGF0aW9uIGhhcHBlbnNcbiAgICAgICAgICAgIC8vIGJlZm9yZSBzb21lb25lIGFza3MgZm9yIHRoZSB0b2tlblxuICAgICAgICAgICAgdGhpcy5fdG9rZW4gPSBDYW5jZWxsYXRpb25Ub2tlbi5DYW5jZWxsZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl90b2tlbi5jYW5jZWwoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3Rva2VuKSB7XG4gICAgICAgICAgICAvLyBlbnN1cmUgdG8gaW5pdGlhbGl6ZSB3aXRoIGFuIGVtcHR5IHRva2VuIGlmIHdlIGhhZCBub25lXG4gICAgICAgICAgICB0aGlzLl90b2tlbiA9IENhbmNlbGxhdGlvblRva2VuLk5vbmU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5fdG9rZW4gaW5zdGFuY2VvZiBNdXRhYmxlVG9rZW4pIHtcbiAgICAgICAgICAgIC8vIGFjdHVhbGx5IGRpc3Bvc2VcbiAgICAgICAgICAgIHRoaXMuX3Rva2VuLmRpc3Bvc2UoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuQ2FuY2VsbGF0aW9uVG9rZW5Tb3VyY2UgPSBDYW5jZWxsYXRpb25Ub2tlblNvdXJjZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNhbmNlbGxhdGlvbi5qcy5tYXBcblxuLyoqKi8gfSksXG5cbi8qKiovIDQ2MzA6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuY3JlYXRlTWVzc2FnZUNvbm5lY3Rpb24gPSBleHBvcnRzLkNvbm5lY3Rpb25PcHRpb25zID0gZXhwb3J0cy5DYW5jZWxsYXRpb25TdHJhdGVneSA9IGV4cG9ydHMuQ2FuY2VsbGF0aW9uU2VuZGVyU3RyYXRlZ3kgPSBleHBvcnRzLkNhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kgPSBleHBvcnRzLkNvbm5lY3Rpb25TdHJhdGVneSA9IGV4cG9ydHMuQ29ubmVjdGlvbkVycm9yID0gZXhwb3J0cy5Db25uZWN0aW9uRXJyb3JzID0gZXhwb3J0cy5Mb2dUcmFjZU5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuU2V0VHJhY2VOb3RpZmljYXRpb24gPSBleHBvcnRzLlRyYWNlRm9ybWF0ID0gZXhwb3J0cy5UcmFjZVZhbHVlcyA9IGV4cG9ydHMuVHJhY2UgPSBleHBvcnRzLk51bGxMb2dnZXIgPSBleHBvcnRzLlByb2dyZXNzVHlwZSA9IGV4cG9ydHMuUHJvZ3Jlc3NUb2tlbiA9IHZvaWQgMDtcbmNvbnN0IHJhbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MjU0KTtcbmNvbnN0IElzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2MTQ1KTtcbmNvbnN0IG1lc3NhZ2VzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQzMTMpO1xuY29uc3QgbGlua2VkTWFwXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYxNzYpO1xuY29uc3QgZXZlbnRzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY3ODApO1xuY29uc3QgY2FuY2VsbGF0aW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMxMDYpO1xudmFyIENhbmNlbE5vdGlmaWNhdGlvbjtcbihmdW5jdGlvbiAoQ2FuY2VsTm90aWZpY2F0aW9uKSB7XG4gICAgQ2FuY2VsTm90aWZpY2F0aW9uLnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Ob3RpZmljYXRpb25UeXBlKCckL2NhbmNlbFJlcXVlc3QnKTtcbn0pKENhbmNlbE5vdGlmaWNhdGlvbiB8fCAoQ2FuY2VsTm90aWZpY2F0aW9uID0ge30pKTtcbnZhciBQcm9ncmVzc1Rva2VuO1xuKGZ1bmN0aW9uIChQcm9ncmVzc1Rva2VuKSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJztcbiAgICB9XG4gICAgUHJvZ3Jlc3NUb2tlbi5pcyA9IGlzO1xufSkoUHJvZ3Jlc3NUb2tlbiA9IGV4cG9ydHMuUHJvZ3Jlc3NUb2tlbiB8fCAoZXhwb3J0cy5Qcm9ncmVzc1Rva2VuID0ge30pKTtcbnZhciBQcm9ncmVzc05vdGlmaWNhdGlvbjtcbihmdW5jdGlvbiAoUHJvZ3Jlc3NOb3RpZmljYXRpb24pIHtcbiAgICBQcm9ncmVzc05vdGlmaWNhdGlvbi50eXBlID0gbmV3IG1lc3NhZ2VzXzEuTm90aWZpY2F0aW9uVHlwZSgnJC9wcm9ncmVzcycpO1xufSkoUHJvZ3Jlc3NOb3RpZmljYXRpb24gfHwgKFByb2dyZXNzTm90aWZpY2F0aW9uID0ge30pKTtcbmNsYXNzIFByb2dyZXNzVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgfVxufVxuZXhwb3J0cy5Qcm9ncmVzc1R5cGUgPSBQcm9ncmVzc1R5cGU7XG52YXIgU3RhclJlcXVlc3RIYW5kbGVyO1xuKGZ1bmN0aW9uIChTdGFyUmVxdWVzdEhhbmRsZXIpIHtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gSXMuZnVuYyh2YWx1ZSk7XG4gICAgfVxuICAgIFN0YXJSZXF1ZXN0SGFuZGxlci5pcyA9IGlzO1xufSkoU3RhclJlcXVlc3RIYW5kbGVyIHx8IChTdGFyUmVxdWVzdEhhbmRsZXIgPSB7fSkpO1xuZXhwb3J0cy5OdWxsTG9nZ2VyID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgZXJyb3I6ICgpID0+IHsgfSxcbiAgICB3YXJuOiAoKSA9PiB7IH0sXG4gICAgaW5mbzogKCkgPT4geyB9LFxuICAgIGxvZzogKCkgPT4geyB9XG59KTtcbnZhciBUcmFjZTtcbihmdW5jdGlvbiAoVHJhY2UpIHtcbiAgICBUcmFjZVtUcmFjZVtcIk9mZlwiXSA9IDBdID0gXCJPZmZcIjtcbiAgICBUcmFjZVtUcmFjZVtcIk1lc3NhZ2VzXCJdID0gMV0gPSBcIk1lc3NhZ2VzXCI7XG4gICAgVHJhY2VbVHJhY2VbXCJDb21wYWN0XCJdID0gMl0gPSBcIkNvbXBhY3RcIjtcbiAgICBUcmFjZVtUcmFjZVtcIlZlcmJvc2VcIl0gPSAzXSA9IFwiVmVyYm9zZVwiO1xufSkoVHJhY2UgPSBleHBvcnRzLlRyYWNlIHx8IChleHBvcnRzLlRyYWNlID0ge30pKTtcbnZhciBUcmFjZVZhbHVlcztcbihmdW5jdGlvbiAoVHJhY2VWYWx1ZXMpIHtcbiAgICAvKipcbiAgICAgKiBUdXJuIHRyYWNpbmcgb2ZmLlxuICAgICAqL1xuICAgIFRyYWNlVmFsdWVzLk9mZiA9ICdvZmYnO1xuICAgIC8qKlxuICAgICAqIFRyYWNlIG1lc3NhZ2VzIG9ubHkuXG4gICAgICovXG4gICAgVHJhY2VWYWx1ZXMuTWVzc2FnZXMgPSAnbWVzc2FnZXMnO1xuICAgIC8qKlxuICAgICAqIENvbXBhY3QgbWVzc2FnZSB0cmFjaW5nLlxuICAgICAqL1xuICAgIFRyYWNlVmFsdWVzLkNvbXBhY3QgPSAnY29tcGFjdCc7XG4gICAgLyoqXG4gICAgICogVmVyYm9zZSBtZXNzYWdlIHRyYWNpbmcuXG4gICAgICovXG4gICAgVHJhY2VWYWx1ZXMuVmVyYm9zZSA9ICd2ZXJib3NlJztcbn0pKFRyYWNlVmFsdWVzID0gZXhwb3J0cy5UcmFjZVZhbHVlcyB8fCAoZXhwb3J0cy5UcmFjZVZhbHVlcyA9IHt9KSk7XG4oZnVuY3Rpb24gKFRyYWNlKSB7XG4gICAgZnVuY3Rpb24gZnJvbVN0cmluZyh2YWx1ZSkge1xuICAgICAgICBpZiAoIUlzLnN0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBUcmFjZS5PZmY7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWUgPSB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBzd2l0Y2ggKHZhbHVlKSB7XG4gICAgICAgICAgICBjYXNlICdvZmYnOlxuICAgICAgICAgICAgICAgIHJldHVybiBUcmFjZS5PZmY7XG4gICAgICAgICAgICBjYXNlICdtZXNzYWdlcyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFRyYWNlLk1lc3NhZ2VzO1xuICAgICAgICAgICAgY2FzZSAnY29tcGFjdCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFRyYWNlLkNvbXBhY3Q7XG4gICAgICAgICAgICBjYXNlICd2ZXJib3NlJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gVHJhY2UuVmVyYm9zZTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFRyYWNlLk9mZjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBUcmFjZS5mcm9tU3RyaW5nID0gZnJvbVN0cmluZztcbiAgICBmdW5jdGlvbiB0b1N0cmluZyh2YWx1ZSkge1xuICAgICAgICBzd2l0Y2ggKHZhbHVlKSB7XG4gICAgICAgICAgICBjYXNlIFRyYWNlLk9mZjpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ29mZic7XG4gICAgICAgICAgICBjYXNlIFRyYWNlLk1lc3NhZ2VzOlxuICAgICAgICAgICAgICAgIHJldHVybiAnbWVzc2FnZXMnO1xuICAgICAgICAgICAgY2FzZSBUcmFjZS5Db21wYWN0OlxuICAgICAgICAgICAgICAgIHJldHVybiAnY29tcGFjdCc7XG4gICAgICAgICAgICBjYXNlIFRyYWNlLlZlcmJvc2U6XG4gICAgICAgICAgICAgICAgcmV0dXJuICd2ZXJib3NlJztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdvZmYnO1xuICAgICAgICB9XG4gICAgfVxuICAgIFRyYWNlLnRvU3RyaW5nID0gdG9TdHJpbmc7XG59KShUcmFjZSA9IGV4cG9ydHMuVHJhY2UgfHwgKGV4cG9ydHMuVHJhY2UgPSB7fSkpO1xudmFyIFRyYWNlRm9ybWF0O1xuKGZ1bmN0aW9uIChUcmFjZUZvcm1hdCkge1xuICAgIFRyYWNlRm9ybWF0W1wiVGV4dFwiXSA9IFwidGV4dFwiO1xuICAgIFRyYWNlRm9ybWF0W1wiSlNPTlwiXSA9IFwianNvblwiO1xufSkoVHJhY2VGb3JtYXQgPSBleHBvcnRzLlRyYWNlRm9ybWF0IHx8IChleHBvcnRzLlRyYWNlRm9ybWF0ID0ge30pKTtcbihmdW5jdGlvbiAoVHJhY2VGb3JtYXQpIHtcbiAgICBmdW5jdGlvbiBmcm9tU3RyaW5nKHZhbHVlKSB7XG4gICAgICAgIGlmICghSXMuc3RyaW5nKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIFRyYWNlRm9ybWF0LlRleHQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWUgPSB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAodmFsdWUgPT09ICdqc29uJykge1xuICAgICAgICAgICAgcmV0dXJuIFRyYWNlRm9ybWF0LkpTT047XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gVHJhY2VGb3JtYXQuVGV4dDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBUcmFjZUZvcm1hdC5mcm9tU3RyaW5nID0gZnJvbVN0cmluZztcbn0pKFRyYWNlRm9ybWF0ID0gZXhwb3J0cy5UcmFjZUZvcm1hdCB8fCAoZXhwb3J0cy5UcmFjZUZvcm1hdCA9IHt9KSk7XG52YXIgU2V0VHJhY2VOb3RpZmljYXRpb247XG4oZnVuY3Rpb24gKFNldFRyYWNlTm90aWZpY2F0aW9uKSB7XG4gICAgU2V0VHJhY2VOb3RpZmljYXRpb24udHlwZSA9IG5ldyBtZXNzYWdlc18xLk5vdGlmaWNhdGlvblR5cGUoJyQvc2V0VHJhY2UnKTtcbn0pKFNldFRyYWNlTm90aWZpY2F0aW9uID0gZXhwb3J0cy5TZXRUcmFjZU5vdGlmaWNhdGlvbiB8fCAoZXhwb3J0cy5TZXRUcmFjZU5vdGlmaWNhdGlvbiA9IHt9KSk7XG52YXIgTG9nVHJhY2VOb3RpZmljYXRpb247XG4oZnVuY3Rpb24gKExvZ1RyYWNlTm90aWZpY2F0aW9uKSB7XG4gICAgTG9nVHJhY2VOb3RpZmljYXRpb24udHlwZSA9IG5ldyBtZXNzYWdlc18xLk5vdGlmaWNhdGlvblR5cGUoJyQvbG9nVHJhY2UnKTtcbn0pKExvZ1RyYWNlTm90aWZpY2F0aW9uID0gZXhwb3J0cy5Mb2dUcmFjZU5vdGlmaWNhdGlvbiB8fCAoZXhwb3J0cy5Mb2dUcmFjZU5vdGlmaWNhdGlvbiA9IHt9KSk7XG52YXIgQ29ubmVjdGlvbkVycm9ycztcbihmdW5jdGlvbiAoQ29ubmVjdGlvbkVycm9ycykge1xuICAgIC8qKlxuICAgICAqIFRoZSBjb25uZWN0aW9uIGlzIGNsb3NlZC5cbiAgICAgKi9cbiAgICBDb25uZWN0aW9uRXJyb3JzW0Nvbm5lY3Rpb25FcnJvcnNbXCJDbG9zZWRcIl0gPSAxXSA9IFwiQ2xvc2VkXCI7XG4gICAgLyoqXG4gICAgICogVGhlIGNvbm5lY3Rpb24gZ290IGRpc3Bvc2VkLlxuICAgICAqL1xuICAgIENvbm5lY3Rpb25FcnJvcnNbQ29ubmVjdGlvbkVycm9yc1tcIkRpc3Bvc2VkXCJdID0gMl0gPSBcIkRpc3Bvc2VkXCI7XG4gICAgLyoqXG4gICAgICogVGhlIGNvbm5lY3Rpb24gaXMgYWxyZWFkeSBpbiBsaXN0ZW5pbmcgbW9kZS5cbiAgICAgKi9cbiAgICBDb25uZWN0aW9uRXJyb3JzW0Nvbm5lY3Rpb25FcnJvcnNbXCJBbHJlYWR5TGlzdGVuaW5nXCJdID0gM10gPSBcIkFscmVhZHlMaXN0ZW5pbmdcIjtcbn0pKENvbm5lY3Rpb25FcnJvcnMgPSBleHBvcnRzLkNvbm5lY3Rpb25FcnJvcnMgfHwgKGV4cG9ydHMuQ29ubmVjdGlvbkVycm9ycyA9IHt9KSk7XG5jbGFzcyBDb25uZWN0aW9uRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoY29kZSwgbWVzc2FnZSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIENvbm5lY3Rpb25FcnJvci5wcm90b3R5cGUpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ29ubmVjdGlvbkVycm9yID0gQ29ubmVjdGlvbkVycm9yO1xudmFyIENvbm5lY3Rpb25TdHJhdGVneTtcbihmdW5jdGlvbiAoQ29ubmVjdGlvblN0cmF0ZWd5KSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgJiYgSXMuZnVuYyhjYW5kaWRhdGUuY2FuY2VsVW5kaXNwYXRjaGVkKTtcbiAgICB9XG4gICAgQ29ubmVjdGlvblN0cmF0ZWd5LmlzID0gaXM7XG59KShDb25uZWN0aW9uU3RyYXRlZ3kgPSBleHBvcnRzLkNvbm5lY3Rpb25TdHJhdGVneSB8fCAoZXhwb3J0cy5Db25uZWN0aW9uU3RyYXRlZ3kgPSB7fSkpO1xudmFyIENhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3k7XG4oZnVuY3Rpb24gKENhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kpIHtcbiAgICBDYW5jZWxsYXRpb25SZWNlaXZlclN0cmF0ZWd5Lk1lc3NhZ2UgPSBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgY3JlYXRlQ2FuY2VsbGF0aW9uVG9rZW5Tb3VyY2UoXykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBjYW5jZWxsYXRpb25fMS5DYW5jZWxsYXRpb25Ub2tlblNvdXJjZSgpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgJiYgSXMuZnVuYyhjYW5kaWRhdGUuY3JlYXRlQ2FuY2VsbGF0aW9uVG9rZW5Tb3VyY2UpO1xuICAgIH1cbiAgICBDYW5jZWxsYXRpb25SZWNlaXZlclN0cmF0ZWd5LmlzID0gaXM7XG59KShDYW5jZWxsYXRpb25SZWNlaXZlclN0cmF0ZWd5ID0gZXhwb3J0cy5DYW5jZWxsYXRpb25SZWNlaXZlclN0cmF0ZWd5IHx8IChleHBvcnRzLkNhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kgPSB7fSkpO1xudmFyIENhbmNlbGxhdGlvblNlbmRlclN0cmF0ZWd5O1xuKGZ1bmN0aW9uIChDYW5jZWxsYXRpb25TZW5kZXJTdHJhdGVneSkge1xuICAgIENhbmNlbGxhdGlvblNlbmRlclN0cmF0ZWd5Lk1lc3NhZ2UgPSBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgc2VuZENhbmNlbGxhdGlvbihjb25uLCBpZCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbm4uc2VuZE5vdGlmaWNhdGlvbihDYW5jZWxOb3RpZmljYXRpb24udHlwZSwgeyBpZCB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgY2xlYW51cChfKSB7IH1cbiAgICB9KTtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJiBJcy5mdW5jKGNhbmRpZGF0ZS5zZW5kQ2FuY2VsbGF0aW9uKSAmJiBJcy5mdW5jKGNhbmRpZGF0ZS5jbGVhbnVwKTtcbiAgICB9XG4gICAgQ2FuY2VsbGF0aW9uU2VuZGVyU3RyYXRlZ3kuaXMgPSBpcztcbn0pKENhbmNlbGxhdGlvblNlbmRlclN0cmF0ZWd5ID0gZXhwb3J0cy5DYW5jZWxsYXRpb25TZW5kZXJTdHJhdGVneSB8fCAoZXhwb3J0cy5DYW5jZWxsYXRpb25TZW5kZXJTdHJhdGVneSA9IHt9KSk7XG52YXIgQ2FuY2VsbGF0aW9uU3RyYXRlZ3k7XG4oZnVuY3Rpb24gKENhbmNlbGxhdGlvblN0cmF0ZWd5KSB7XG4gICAgQ2FuY2VsbGF0aW9uU3RyYXRlZ3kuTWVzc2FnZSA9IE9iamVjdC5mcmVlemUoe1xuICAgICAgICByZWNlaXZlcjogQ2FuY2VsbGF0aW9uUmVjZWl2ZXJTdHJhdGVneS5NZXNzYWdlLFxuICAgICAgICBzZW5kZXI6IENhbmNlbGxhdGlvblNlbmRlclN0cmF0ZWd5Lk1lc3NhZ2VcbiAgICB9KTtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJiBDYW5jZWxsYXRpb25SZWNlaXZlclN0cmF0ZWd5LmlzKGNhbmRpZGF0ZS5yZWNlaXZlcikgJiYgQ2FuY2VsbGF0aW9uU2VuZGVyU3RyYXRlZ3kuaXMoY2FuZGlkYXRlLnNlbmRlcik7XG4gICAgfVxuICAgIENhbmNlbGxhdGlvblN0cmF0ZWd5LmlzID0gaXM7XG59KShDYW5jZWxsYXRpb25TdHJhdGVneSA9IGV4cG9ydHMuQ2FuY2VsbGF0aW9uU3RyYXRlZ3kgfHwgKGV4cG9ydHMuQ2FuY2VsbGF0aW9uU3RyYXRlZ3kgPSB7fSkpO1xudmFyIENvbm5lY3Rpb25PcHRpb25zO1xuKGZ1bmN0aW9uIChDb25uZWN0aW9uT3B0aW9ucykge1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICYmIChDYW5jZWxsYXRpb25TdHJhdGVneS5pcyhjYW5kaWRhdGUuY2FuY2VsbGF0aW9uU3RyYXRlZ3kpIHx8IENvbm5lY3Rpb25TdHJhdGVneS5pcyhjYW5kaWRhdGUuY29ubmVjdGlvblN0cmF0ZWd5KSk7XG4gICAgfVxuICAgIENvbm5lY3Rpb25PcHRpb25zLmlzID0gaXM7XG59KShDb25uZWN0aW9uT3B0aW9ucyA9IGV4cG9ydHMuQ29ubmVjdGlvbk9wdGlvbnMgfHwgKGV4cG9ydHMuQ29ubmVjdGlvbk9wdGlvbnMgPSB7fSkpO1xudmFyIENvbm5lY3Rpb25TdGF0ZTtcbihmdW5jdGlvbiAoQ29ubmVjdGlvblN0YXRlKSB7XG4gICAgQ29ubmVjdGlvblN0YXRlW0Nvbm5lY3Rpb25TdGF0ZVtcIk5ld1wiXSA9IDFdID0gXCJOZXdcIjtcbiAgICBDb25uZWN0aW9uU3RhdGVbQ29ubmVjdGlvblN0YXRlW1wiTGlzdGVuaW5nXCJdID0gMl0gPSBcIkxpc3RlbmluZ1wiO1xuICAgIENvbm5lY3Rpb25TdGF0ZVtDb25uZWN0aW9uU3RhdGVbXCJDbG9zZWRcIl0gPSAzXSA9IFwiQ2xvc2VkXCI7XG4gICAgQ29ubmVjdGlvblN0YXRlW0Nvbm5lY3Rpb25TdGF0ZVtcIkRpc3Bvc2VkXCJdID0gNF0gPSBcIkRpc3Bvc2VkXCI7XG59KShDb25uZWN0aW9uU3RhdGUgfHwgKENvbm5lY3Rpb25TdGF0ZSA9IHt9KSk7XG5mdW5jdGlvbiBjcmVhdGVNZXNzYWdlQ29ubmVjdGlvbihtZXNzYWdlUmVhZGVyLCBtZXNzYWdlV3JpdGVyLCBfbG9nZ2VyLCBvcHRpb25zKSB7XG4gICAgY29uc3QgbG9nZ2VyID0gX2xvZ2dlciAhPT0gdW5kZWZpbmVkID8gX2xvZ2dlciA6IGV4cG9ydHMuTnVsbExvZ2dlcjtcbiAgICBsZXQgc2VxdWVuY2VOdW1iZXIgPSAwO1xuICAgIGxldCBub3RpZmljYXRpb25TZXF1ZW5jZU51bWJlciA9IDA7XG4gICAgbGV0IHVua25vd25SZXNwb25zZVNlcXVlbmNlTnVtYmVyID0gMDtcbiAgICBjb25zdCB2ZXJzaW9uID0gJzIuMCc7XG4gICAgbGV0IHN0YXJSZXF1ZXN0SGFuZGxlciA9IHVuZGVmaW5lZDtcbiAgICBjb25zdCByZXF1ZXN0SGFuZGxlcnMgPSBuZXcgTWFwKCk7XG4gICAgbGV0IHN0YXJOb3RpZmljYXRpb25IYW5kbGVyID0gdW5kZWZpbmVkO1xuICAgIGNvbnN0IG5vdGlmaWNhdGlvbkhhbmRsZXJzID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IHByb2dyZXNzSGFuZGxlcnMgPSBuZXcgTWFwKCk7XG4gICAgbGV0IHRpbWVyO1xuICAgIGxldCBtZXNzYWdlUXVldWUgPSBuZXcgbGlua2VkTWFwXzEuTGlua2VkTWFwKCk7XG4gICAgbGV0IHJlc3BvbnNlUHJvbWlzZXMgPSBuZXcgTWFwKCk7XG4gICAgbGV0IGtub3duQ2FuY2VsZWRSZXF1ZXN0cyA9IG5ldyBTZXQoKTtcbiAgICBsZXQgcmVxdWVzdFRva2VucyA9IG5ldyBNYXAoKTtcbiAgICBsZXQgdHJhY2UgPSBUcmFjZS5PZmY7XG4gICAgbGV0IHRyYWNlRm9ybWF0ID0gVHJhY2VGb3JtYXQuVGV4dDtcbiAgICBsZXQgdHJhY2VyO1xuICAgIGxldCBzdGF0ZSA9IENvbm5lY3Rpb25TdGF0ZS5OZXc7XG4gICAgY29uc3QgZXJyb3JFbWl0dGVyID0gbmV3IGV2ZW50c18xLkVtaXR0ZXIoKTtcbiAgICBjb25zdCBjbG9zZUVtaXR0ZXIgPSBuZXcgZXZlbnRzXzEuRW1pdHRlcigpO1xuICAgIGNvbnN0IHVuaGFuZGxlZE5vdGlmaWNhdGlvbkVtaXR0ZXIgPSBuZXcgZXZlbnRzXzEuRW1pdHRlcigpO1xuICAgIGNvbnN0IHVuaGFuZGxlZFByb2dyZXNzRW1pdHRlciA9IG5ldyBldmVudHNfMS5FbWl0dGVyKCk7XG4gICAgY29uc3QgZGlzcG9zZUVtaXR0ZXIgPSBuZXcgZXZlbnRzXzEuRW1pdHRlcigpO1xuICAgIGNvbnN0IGNhbmNlbGxhdGlvblN0cmF0ZWd5ID0gKG9wdGlvbnMgJiYgb3B0aW9ucy5jYW5jZWxsYXRpb25TdHJhdGVneSkgPyBvcHRpb25zLmNhbmNlbGxhdGlvblN0cmF0ZWd5IDogQ2FuY2VsbGF0aW9uU3RyYXRlZ3kuTWVzc2FnZTtcbiAgICBmdW5jdGlvbiBjcmVhdGVSZXF1ZXN0UXVldWVLZXkoaWQpIHtcbiAgICAgICAgaWYgKGlkID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbid0IHNlbmQgcmVxdWVzdHMgd2l0aCBpZCBudWxsIHNpbmNlIHRoZSByZXNwb25zZSBjYW4ndCBiZSBjb3JyZWxhdGVkLmApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAncmVxLScgKyBpZC50b1N0cmluZygpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVSZXNwb25zZVF1ZXVlS2V5KGlkKSB7XG4gICAgICAgIGlmIChpZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuICdyZXMtdW5rbm93bi0nICsgKCsrdW5rbm93blJlc3BvbnNlU2VxdWVuY2VOdW1iZXIpLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gJ3Jlcy0nICsgaWQudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVOb3RpZmljYXRpb25RdWV1ZUtleSgpIHtcbiAgICAgICAgcmV0dXJuICdub3QtJyArICgrK25vdGlmaWNhdGlvblNlcXVlbmNlTnVtYmVyKS50b1N0cmluZygpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhZGRNZXNzYWdlVG9RdWV1ZShxdWV1ZSwgbWVzc2FnZSkge1xuICAgICAgICBpZiAobWVzc2FnZXNfMS5NZXNzYWdlLmlzUmVxdWVzdChtZXNzYWdlKSkge1xuICAgICAgICAgICAgcXVldWUuc2V0KGNyZWF0ZVJlcXVlc3RRdWV1ZUtleShtZXNzYWdlLmlkKSwgbWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobWVzc2FnZXNfMS5NZXNzYWdlLmlzUmVzcG9uc2UobWVzc2FnZSkpIHtcbiAgICAgICAgICAgIHF1ZXVlLnNldChjcmVhdGVSZXNwb25zZVF1ZXVlS2V5KG1lc3NhZ2UuaWQpLCBtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHF1ZXVlLnNldChjcmVhdGVOb3RpZmljYXRpb25RdWV1ZUtleSgpLCBtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjYW5jZWxVbmRpc3BhdGNoZWQoX21lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNMaXN0ZW5pbmcoKSB7XG4gICAgICAgIHJldHVybiBzdGF0ZSA9PT0gQ29ubmVjdGlvblN0YXRlLkxpc3RlbmluZztcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNDbG9zZWQoKSB7XG4gICAgICAgIHJldHVybiBzdGF0ZSA9PT0gQ29ubmVjdGlvblN0YXRlLkNsb3NlZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNEaXNwb3NlZCgpIHtcbiAgICAgICAgcmV0dXJuIHN0YXRlID09PSBDb25uZWN0aW9uU3RhdGUuRGlzcG9zZWQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNsb3NlSGFuZGxlcigpIHtcbiAgICAgICAgaWYgKHN0YXRlID09PSBDb25uZWN0aW9uU3RhdGUuTmV3IHx8IHN0YXRlID09PSBDb25uZWN0aW9uU3RhdGUuTGlzdGVuaW5nKSB7XG4gICAgICAgICAgICBzdGF0ZSA9IENvbm5lY3Rpb25TdGF0ZS5DbG9zZWQ7XG4gICAgICAgICAgICBjbG9zZUVtaXR0ZXIuZmlyZSh1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZSBjb25uZWN0aW9uIGlzIGRpc3Bvc2VkIGRvbid0IHNlbnQgY2xvc2UgZXZlbnRzLlxuICAgIH1cbiAgICBmdW5jdGlvbiByZWFkRXJyb3JIYW5kbGVyKGVycm9yKSB7XG4gICAgICAgIGVycm9yRW1pdHRlci5maXJlKFtlcnJvciwgdW5kZWZpbmVkLCB1bmRlZmluZWRdKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gd3JpdGVFcnJvckhhbmRsZXIoZGF0YSkge1xuICAgICAgICBlcnJvckVtaXR0ZXIuZmlyZShkYXRhKTtcbiAgICB9XG4gICAgbWVzc2FnZVJlYWRlci5vbkNsb3NlKGNsb3NlSGFuZGxlcik7XG4gICAgbWVzc2FnZVJlYWRlci5vbkVycm9yKHJlYWRFcnJvckhhbmRsZXIpO1xuICAgIG1lc3NhZ2VXcml0ZXIub25DbG9zZShjbG9zZUhhbmRsZXIpO1xuICAgIG1lc3NhZ2VXcml0ZXIub25FcnJvcih3cml0ZUVycm9ySGFuZGxlcik7XG4gICAgZnVuY3Rpb24gdHJpZ2dlck1lc3NhZ2VRdWV1ZSgpIHtcbiAgICAgICAgaWYgKHRpbWVyIHx8IG1lc3NhZ2VRdWV1ZS5zaXplID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGltZXIgPSAoMCwgcmFsXzEuZGVmYXVsdCkoKS50aW1lci5zZXRJbW1lZGlhdGUoKCkgPT4ge1xuICAgICAgICAgICAgdGltZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBwcm9jZXNzTWVzc2FnZVF1ZXVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwcm9jZXNzTWVzc2FnZVF1ZXVlKCkge1xuICAgICAgICBpZiAobWVzc2FnZVF1ZXVlLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXNzYWdlID0gbWVzc2FnZVF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAobWVzc2FnZXNfMS5NZXNzYWdlLmlzUmVxdWVzdChtZXNzYWdlKSkge1xuICAgICAgICAgICAgICAgIGhhbmRsZVJlcXVlc3QobWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChtZXNzYWdlc18xLk1lc3NhZ2UuaXNOb3RpZmljYXRpb24obWVzc2FnZSkpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVOb3RpZmljYXRpb24obWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChtZXNzYWdlc18xLk1lc3NhZ2UuaXNSZXNwb25zZShtZXNzYWdlKSkge1xuICAgICAgICAgICAgICAgIGhhbmRsZVJlc3BvbnNlKG1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlSW52YWxpZE1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0cmlnZ2VyTWVzc2FnZVF1ZXVlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgY2FsbGJhY2sgPSAobWVzc2FnZSkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2UgaGF2ZSByZWNlaXZlZCBhIGNhbmNlbGxhdGlvbiBtZXNzYWdlLiBDaGVjayBpZiB0aGUgbWVzc2FnZSBpcyBzdGlsbCBpbiB0aGUgcXVldWVcbiAgICAgICAgICAgIC8vIGFuZCBjYW5jZWwgaXQgaWYgYWxsb3dlZCB0byBkbyBzby5cbiAgICAgICAgICAgIGlmIChtZXNzYWdlc18xLk1lc3NhZ2UuaXNOb3RpZmljYXRpb24obWVzc2FnZSkgJiYgbWVzc2FnZS5tZXRob2QgPT09IENhbmNlbE5vdGlmaWNhdGlvbi50eXBlLm1ldGhvZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhbmNlbElkID0gbWVzc2FnZS5wYXJhbXMuaWQ7XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gY3JlYXRlUmVxdWVzdFF1ZXVlS2V5KGNhbmNlbElkKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0b0NhbmNlbCA9IG1lc3NhZ2VRdWV1ZS5nZXQoa2V5KTtcbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZXNfMS5NZXNzYWdlLmlzUmVxdWVzdCh0b0NhbmNlbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RyYXRlZ3kgPSBvcHRpb25zPy5jb25uZWN0aW9uU3RyYXRlZ3k7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gKHN0cmF0ZWd5ICYmIHN0cmF0ZWd5LmNhbmNlbFVuZGlzcGF0Y2hlZCkgPyBzdHJhdGVneS5jYW5jZWxVbmRpc3BhdGNoZWQodG9DYW5jZWwsIGNhbmNlbFVuZGlzcGF0Y2hlZCkgOiBjYW5jZWxVbmRpc3BhdGNoZWQodG9DYW5jZWwpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UgJiYgKHJlc3BvbnNlLmVycm9yICE9PSB1bmRlZmluZWQgfHwgcmVzcG9uc2UucmVzdWx0ICE9PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlUXVldWUuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0VG9rZW5zLmRlbGV0ZShjYW5jZWxJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5pZCA9IHRvQ2FuY2VsLmlkO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2VTZW5kaW5nUmVzcG9uc2UocmVzcG9uc2UsIG1lc3NhZ2UubWV0aG9kLCBEYXRlLm5vdygpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VXcml0ZXIud3JpdGUocmVzcG9uc2UpLmNhdGNoKCgpID0+IGxvZ2dlci5lcnJvcihgU2VuZGluZyByZXNwb25zZSBmb3IgY2FuY2VsZWQgbWVzc2FnZSBmYWlsZWQuYCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGNhbmNlbGxhdGlvblRva2VuID0gcmVxdWVzdFRva2Vucy5nZXQoY2FuY2VsSWQpO1xuICAgICAgICAgICAgICAgIC8vIFRoZSByZXF1ZXN0IGlzIGFscmVhZHkgcnVubmluZy4gQ2FuY2VsIHRoZSB0b2tlblxuICAgICAgICAgICAgICAgIGlmIChjYW5jZWxsYXRpb25Ub2tlbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbmNlbGxhdGlvblRva2VuLmNhbmNlbCgpO1xuICAgICAgICAgICAgICAgICAgICB0cmFjZVJlY2VpdmVkTm90aWZpY2F0aW9uKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBSZW1lbWJlciB0aGUgY2FuY2VsIGJ1dCBzdGlsbCBxdWV1ZSB0aGUgbWVzc2FnZSB0b1xuICAgICAgICAgICAgICAgICAgICAvLyBjbGVhbiB1cCBzdGF0ZSBpbiBwcm9jZXNzIG1lc3NhZ2UuXG4gICAgICAgICAgICAgICAgICAgIGtub3duQ2FuY2VsZWRSZXF1ZXN0cy5hZGQoY2FuY2VsSWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFkZE1lc3NhZ2VUb1F1ZXVlKG1lc3NhZ2VRdWV1ZSwgbWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0cmlnZ2VyTWVzc2FnZVF1ZXVlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGZ1bmN0aW9uIGhhbmRsZVJlcXVlc3QocmVxdWVzdE1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKGlzRGlzcG9zZWQoKSkge1xuICAgICAgICAgICAgLy8gd2UgcmV0dXJuIGhlcmUgc2lsZW50bHkgc2luY2Ugd2UgZmlyZWQgYW4gZXZlbnQgd2hlbiB0aGVcbiAgICAgICAgICAgIC8vIGNvbm5lY3Rpb24gZ290IGRpc3Bvc2VkLlxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHJlcGx5KHJlc3VsdE9yRXJyb3IsIG1ldGhvZCwgc3RhcnRUaW1lKSB7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0ge1xuICAgICAgICAgICAgICAgIGpzb25ycGM6IHZlcnNpb24sXG4gICAgICAgICAgICAgICAgaWQ6IHJlcXVlc3RNZXNzYWdlLmlkXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHJlc3VsdE9yRXJyb3IgaW5zdGFuY2VvZiBtZXNzYWdlc18xLlJlc3BvbnNlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmVycm9yID0gcmVzdWx0T3JFcnJvci50b0pzb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UucmVzdWx0ID0gcmVzdWx0T3JFcnJvciA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IHJlc3VsdE9yRXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmFjZVNlbmRpbmdSZXNwb25zZShtZXNzYWdlLCBtZXRob2QsIHN0YXJ0VGltZSk7XG4gICAgICAgICAgICBtZXNzYWdlV3JpdGVyLndyaXRlKG1lc3NhZ2UpLmNhdGNoKCgpID0+IGxvZ2dlci5lcnJvcihgU2VuZGluZyByZXNwb25zZSBmYWlsZWQuYCkpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHJlcGx5RXJyb3IoZXJyb3IsIG1ldGhvZCwgc3RhcnRUaW1lKSB7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0ge1xuICAgICAgICAgICAgICAgIGpzb25ycGM6IHZlcnNpb24sXG4gICAgICAgICAgICAgICAgaWQ6IHJlcXVlc3RNZXNzYWdlLmlkLFxuICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvci50b0pzb24oKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRyYWNlU2VuZGluZ1Jlc3BvbnNlKG1lc3NhZ2UsIG1ldGhvZCwgc3RhcnRUaW1lKTtcbiAgICAgICAgICAgIG1lc3NhZ2VXcml0ZXIud3JpdGUobWVzc2FnZSkuY2F0Y2goKCkgPT4gbG9nZ2VyLmVycm9yKGBTZW5kaW5nIHJlc3BvbnNlIGZhaWxlZC5gKSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcmVwbHlTdWNjZXNzKHJlc3VsdCwgbWV0aG9kLCBzdGFydFRpbWUpIHtcbiAgICAgICAgICAgIC8vIFRoZSBKU09OIFJQQyBkZWZpbmVzIHRoYXQgYSByZXNwb25zZSBtdXN0IGVpdGhlciBoYXZlIGEgcmVzdWx0IG9yIGFuIGVycm9yXG4gICAgICAgICAgICAvLyBTbyB3ZSBjYW4ndCB0cmVhdCB1bmRlZmluZWQgYXMgYSB2YWxpZCByZXNwb25zZSByZXN1bHQuXG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IHtcbiAgICAgICAgICAgICAgICBqc29ucnBjOiB2ZXJzaW9uLFxuICAgICAgICAgICAgICAgIGlkOiByZXF1ZXN0TWVzc2FnZS5pZCxcbiAgICAgICAgICAgICAgICByZXN1bHQ6IHJlc3VsdFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRyYWNlU2VuZGluZ1Jlc3BvbnNlKG1lc3NhZ2UsIG1ldGhvZCwgc3RhcnRUaW1lKTtcbiAgICAgICAgICAgIG1lc3NhZ2VXcml0ZXIud3JpdGUobWVzc2FnZSkuY2F0Y2goKCkgPT4gbG9nZ2VyLmVycm9yKGBTZW5kaW5nIHJlc3BvbnNlIGZhaWxlZC5gKSk7XG4gICAgICAgIH1cbiAgICAgICAgdHJhY2VSZWNlaXZlZFJlcXVlc3QocmVxdWVzdE1lc3NhZ2UpO1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gcmVxdWVzdEhhbmRsZXJzLmdldChyZXF1ZXN0TWVzc2FnZS5tZXRob2QpO1xuICAgICAgICBsZXQgdHlwZTtcbiAgICAgICAgbGV0IHJlcXVlc3RIYW5kbGVyO1xuICAgICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICAgICAgdHlwZSA9IGVsZW1lbnQudHlwZTtcbiAgICAgICAgICAgIHJlcXVlc3RIYW5kbGVyID0gZWxlbWVudC5oYW5kbGVyO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIGlmIChyZXF1ZXN0SGFuZGxlciB8fCBzdGFyUmVxdWVzdEhhbmRsZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IHRva2VuS2V5ID0gcmVxdWVzdE1lc3NhZ2UuaWQgPz8gU3RyaW5nKERhdGUubm93KCkpOyAvL1xuICAgICAgICAgICAgY29uc3QgY2FuY2VsbGF0aW9uU291cmNlID0gY2FuY2VsbGF0aW9uU3RyYXRlZ3kucmVjZWl2ZXIuY3JlYXRlQ2FuY2VsbGF0aW9uVG9rZW5Tb3VyY2UodG9rZW5LZXkpO1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RNZXNzYWdlLmlkICE9PSBudWxsICYmIGtub3duQ2FuY2VsZWRSZXF1ZXN0cy5oYXMocmVxdWVzdE1lc3NhZ2UuaWQpKSB7XG4gICAgICAgICAgICAgICAgY2FuY2VsbGF0aW9uU291cmNlLmNhbmNlbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RNZXNzYWdlLmlkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdFRva2Vucy5zZXQodG9rZW5LZXksIGNhbmNlbGxhdGlvblNvdXJjZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGxldCBoYW5kbGVyUmVzdWx0O1xuICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0SGFuZGxlcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVxdWVzdE1lc3NhZ2UucGFyYW1zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlICE9PSB1bmRlZmluZWQgJiYgdHlwZS5udW1iZXJPZlBhcmFtcyAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcGx5RXJyb3IobmV3IG1lc3NhZ2VzXzEuUmVzcG9uc2VFcnJvcihtZXNzYWdlc18xLkVycm9yQ29kZXMuSW52YWxpZFBhcmFtcywgYFJlcXVlc3QgJHtyZXF1ZXN0TWVzc2FnZS5tZXRob2R9IGRlZmluZXMgJHt0eXBlLm51bWJlck9mUGFyYW1zfSBwYXJhbXMgYnV0IHJlY2VpdmVkIG5vbmUuYCksIHJlcXVlc3RNZXNzYWdlLm1ldGhvZCwgc3RhcnRUaW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVyUmVzdWx0ID0gcmVxdWVzdEhhbmRsZXIoY2FuY2VsbGF0aW9uU291cmNlLnRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHJlcXVlc3RNZXNzYWdlLnBhcmFtcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlICE9PSB1bmRlZmluZWQgJiYgdHlwZS5wYXJhbWV0ZXJTdHJ1Y3R1cmVzID09PSBtZXNzYWdlc18xLlBhcmFtZXRlclN0cnVjdHVyZXMuYnlOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVwbHlFcnJvcihuZXcgbWVzc2FnZXNfMS5SZXNwb25zZUVycm9yKG1lc3NhZ2VzXzEuRXJyb3JDb2Rlcy5JbnZhbGlkUGFyYW1zLCBgUmVxdWVzdCAke3JlcXVlc3RNZXNzYWdlLm1ldGhvZH0gZGVmaW5lcyBwYXJhbWV0ZXJzIGJ5IG5hbWUgYnV0IHJlY2VpdmVkIHBhcmFtZXRlcnMgYnkgcG9zaXRpb25gKSwgcmVxdWVzdE1lc3NhZ2UubWV0aG9kLCBzdGFydFRpbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXJSZXN1bHQgPSByZXF1ZXN0SGFuZGxlciguLi5yZXF1ZXN0TWVzc2FnZS5wYXJhbXMsIGNhbmNlbGxhdGlvblNvdXJjZS50b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSAhPT0gdW5kZWZpbmVkICYmIHR5cGUucGFyYW1ldGVyU3RydWN0dXJlcyA9PT0gbWVzc2FnZXNfMS5QYXJhbWV0ZXJTdHJ1Y3R1cmVzLmJ5UG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXBseUVycm9yKG5ldyBtZXNzYWdlc18xLlJlc3BvbnNlRXJyb3IobWVzc2FnZXNfMS5FcnJvckNvZGVzLkludmFsaWRQYXJhbXMsIGBSZXF1ZXN0ICR7cmVxdWVzdE1lc3NhZ2UubWV0aG9kfSBkZWZpbmVzIHBhcmFtZXRlcnMgYnkgcG9zaXRpb24gYnV0IHJlY2VpdmVkIHBhcmFtZXRlcnMgYnkgbmFtZWApLCByZXF1ZXN0TWVzc2FnZS5tZXRob2QsIHN0YXJ0VGltZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlclJlc3VsdCA9IHJlcXVlc3RIYW5kbGVyKHJlcXVlc3RNZXNzYWdlLnBhcmFtcywgY2FuY2VsbGF0aW9uU291cmNlLnRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzdGFyUmVxdWVzdEhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlclJlc3VsdCA9IHN0YXJSZXF1ZXN0SGFuZGxlcihyZXF1ZXN0TWVzc2FnZS5tZXRob2QsIHJlcXVlc3RNZXNzYWdlLnBhcmFtcywgY2FuY2VsbGF0aW9uU291cmNlLnRva2VuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvbWlzZSA9IGhhbmRsZXJSZXN1bHQ7XG4gICAgICAgICAgICAgICAgaWYgKCFoYW5kbGVyUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3RUb2tlbnMuZGVsZXRlKHRva2VuS2V5KTtcbiAgICAgICAgICAgICAgICAgICAgcmVwbHlTdWNjZXNzKGhhbmRsZXJSZXN1bHQsIHJlcXVlc3RNZXNzYWdlLm1ldGhvZCwgc3RhcnRUaW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocHJvbWlzZS50aGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb21pc2UudGhlbigocmVzdWx0T3JFcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdFRva2Vucy5kZWxldGUodG9rZW5LZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVwbHkocmVzdWx0T3JFcnJvciwgcmVxdWVzdE1lc3NhZ2UubWV0aG9kLCBzdGFydFRpbWUpO1xuICAgICAgICAgICAgICAgICAgICB9LCBlcnJvciA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0VG9rZW5zLmRlbGV0ZSh0b2tlbktleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBtZXNzYWdlc18xLlJlc3BvbnNlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXBseUVycm9yKGVycm9yLCByZXF1ZXN0TWVzc2FnZS5tZXRob2QsIHN0YXJ0VGltZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChlcnJvciAmJiBJcy5zdHJpbmcoZXJyb3IubWVzc2FnZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXBseUVycm9yKG5ldyBtZXNzYWdlc18xLlJlc3BvbnNlRXJyb3IobWVzc2FnZXNfMS5FcnJvckNvZGVzLkludGVybmFsRXJyb3IsIGBSZXF1ZXN0ICR7cmVxdWVzdE1lc3NhZ2UubWV0aG9kfSBmYWlsZWQgd2l0aCBtZXNzYWdlOiAke2Vycm9yLm1lc3NhZ2V9YCksIHJlcXVlc3RNZXNzYWdlLm1ldGhvZCwgc3RhcnRUaW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcGx5RXJyb3IobmV3IG1lc3NhZ2VzXzEuUmVzcG9uc2VFcnJvcihtZXNzYWdlc18xLkVycm9yQ29kZXMuSW50ZXJuYWxFcnJvciwgYFJlcXVlc3QgJHtyZXF1ZXN0TWVzc2FnZS5tZXRob2R9IGZhaWxlZCB1bmV4cGVjdGVkbHkgd2l0aG91dCBwcm92aWRpbmcgYW55IGRldGFpbHMuYCksIHJlcXVlc3RNZXNzYWdlLm1ldGhvZCwgc3RhcnRUaW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0VG9rZW5zLmRlbGV0ZSh0b2tlbktleSk7XG4gICAgICAgICAgICAgICAgICAgIHJlcGx5KGhhbmRsZXJSZXN1bHQsIHJlcXVlc3RNZXNzYWdlLm1ldGhvZCwgc3RhcnRUaW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0VG9rZW5zLmRlbGV0ZSh0b2tlbktleSk7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgbWVzc2FnZXNfMS5SZXNwb25zZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcGx5KGVycm9yLCByZXF1ZXN0TWVzc2FnZS5tZXRob2QsIHN0YXJ0VGltZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGVycm9yICYmIElzLnN0cmluZyhlcnJvci5tZXNzYWdlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXBseUVycm9yKG5ldyBtZXNzYWdlc18xLlJlc3BvbnNlRXJyb3IobWVzc2FnZXNfMS5FcnJvckNvZGVzLkludGVybmFsRXJyb3IsIGBSZXF1ZXN0ICR7cmVxdWVzdE1lc3NhZ2UubWV0aG9kfSBmYWlsZWQgd2l0aCBtZXNzYWdlOiAke2Vycm9yLm1lc3NhZ2V9YCksIHJlcXVlc3RNZXNzYWdlLm1ldGhvZCwgc3RhcnRUaW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcGx5RXJyb3IobmV3IG1lc3NhZ2VzXzEuUmVzcG9uc2VFcnJvcihtZXNzYWdlc18xLkVycm9yQ29kZXMuSW50ZXJuYWxFcnJvciwgYFJlcXVlc3QgJHtyZXF1ZXN0TWVzc2FnZS5tZXRob2R9IGZhaWxlZCB1bmV4cGVjdGVkbHkgd2l0aG91dCBwcm92aWRpbmcgYW55IGRldGFpbHMuYCksIHJlcXVlc3RNZXNzYWdlLm1ldGhvZCwgc3RhcnRUaW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXBseUVycm9yKG5ldyBtZXNzYWdlc18xLlJlc3BvbnNlRXJyb3IobWVzc2FnZXNfMS5FcnJvckNvZGVzLk1ldGhvZE5vdEZvdW5kLCBgVW5oYW5kbGVkIG1ldGhvZCAke3JlcXVlc3RNZXNzYWdlLm1ldGhvZH1gKSwgcmVxdWVzdE1lc3NhZ2UubWV0aG9kLCBzdGFydFRpbWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhbmRsZVJlc3BvbnNlKHJlc3BvbnNlTWVzc2FnZSkge1xuICAgICAgICBpZiAoaXNEaXNwb3NlZCgpKSB7XG4gICAgICAgICAgICAvLyBTZWUgaGFuZGxlIHJlcXVlc3QuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3BvbnNlTWVzc2FnZS5pZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlTWVzc2FnZS5lcnJvcikge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihgUmVjZWl2ZWQgcmVzcG9uc2UgbWVzc2FnZSB3aXRob3V0IGlkOiBFcnJvciBpczogXFxuJHtKU09OLnN0cmluZ2lmeShyZXNwb25zZU1lc3NhZ2UuZXJyb3IsIHVuZGVmaW5lZCwgNCl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoYFJlY2VpdmVkIHJlc3BvbnNlIG1lc3NhZ2Ugd2l0aG91dCBpZC4gTm8gZnVydGhlciBlcnJvciBpbmZvcm1hdGlvbiBwcm92aWRlZC5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IHJlc3BvbnNlTWVzc2FnZS5pZDtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlUHJvbWlzZSA9IHJlc3BvbnNlUHJvbWlzZXMuZ2V0KGtleSk7XG4gICAgICAgICAgICB0cmFjZVJlY2VpdmVkUmVzcG9uc2UocmVzcG9uc2VNZXNzYWdlLCByZXNwb25zZVByb21pc2UpO1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlUHJvbWlzZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2VQcm9taXNlcy5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2VNZXNzYWdlLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IHJlc3BvbnNlTWVzc2FnZS5lcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlUHJvbWlzZS5yZWplY3QobmV3IG1lc3NhZ2VzXzEuUmVzcG9uc2VFcnJvcihlcnJvci5jb2RlLCBlcnJvci5tZXNzYWdlLCBlcnJvci5kYXRhKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocmVzcG9uc2VNZXNzYWdlLnJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZVByb21pc2UucmVzb2x2ZShyZXNwb25zZU1lc3NhZ2UucmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU2hvdWxkIG5ldmVyIGhhcHBlbi4nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yLm1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihgUmVzcG9uc2UgaGFuZGxlciAnJHtyZXNwb25zZVByb21pc2UubWV0aG9kfScgZmFpbGVkIHdpdGggbWVzc2FnZTogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGBSZXNwb25zZSBoYW5kbGVyICcke3Jlc3BvbnNlUHJvbWlzZS5tZXRob2R9JyBmYWlsZWQgdW5leHBlY3RlZGx5LmApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhbmRsZU5vdGlmaWNhdGlvbihtZXNzYWdlKSB7XG4gICAgICAgIGlmIChpc0Rpc3Bvc2VkKCkpIHtcbiAgICAgICAgICAgIC8vIFNlZSBoYW5kbGUgcmVxdWVzdC5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdHlwZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IG5vdGlmaWNhdGlvbkhhbmRsZXI7XG4gICAgICAgIGlmIChtZXNzYWdlLm1ldGhvZCA9PT0gQ2FuY2VsTm90aWZpY2F0aW9uLnR5cGUubWV0aG9kKSB7XG4gICAgICAgICAgICBjb25zdCBjYW5jZWxJZCA9IG1lc3NhZ2UucGFyYW1zLmlkO1xuICAgICAgICAgICAga25vd25DYW5jZWxlZFJlcXVlc3RzLmRlbGV0ZShjYW5jZWxJZCk7XG4gICAgICAgICAgICB0cmFjZVJlY2VpdmVkTm90aWZpY2F0aW9uKG1lc3NhZ2UpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IG5vdGlmaWNhdGlvbkhhbmRsZXJzLmdldChtZXNzYWdlLm1ldGhvZCk7XG4gICAgICAgICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIG5vdGlmaWNhdGlvbkhhbmRsZXIgPSBlbGVtZW50LmhhbmRsZXI7XG4gICAgICAgICAgICAgICAgdHlwZSA9IGVsZW1lbnQudHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobm90aWZpY2F0aW9uSGFuZGxlciB8fCBzdGFyTm90aWZpY2F0aW9uSGFuZGxlcikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0cmFjZVJlY2VpdmVkTm90aWZpY2F0aW9uKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIGlmIChub3RpZmljYXRpb25IYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLnBhcmFtcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUubnVtYmVyT2ZQYXJhbXMgIT09IDAgJiYgdHlwZS5wYXJhbWV0ZXJTdHJ1Y3R1cmVzICE9PSBtZXNzYWdlc18xLlBhcmFtZXRlclN0cnVjdHVyZXMuYnlOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihgTm90aWZpY2F0aW9uICR7bWVzc2FnZS5tZXRob2R9IGRlZmluZXMgJHt0eXBlLm51bWJlck9mUGFyYW1zfSBwYXJhbXMgYnV0IHJlY2VpdmVkIG5vbmUuYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbm90aWZpY2F0aW9uSGFuZGxlcigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkobWVzc2FnZS5wYXJhbXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGVyZSBhcmUgSlNPTi1SUEMgbGlicmFyaWVzIHRoYXQgc2VuZCBwcm9ncmVzcyBtZXNzYWdlIGFzIHBvc2l0aW9uYWwgcGFyYW1zIGFsdGhvdWdoXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzcGVjaWZpZWQgYXMgbmFtZWQuIFNvIGNvbnZlcnQgdGhlbSBpZiB0aGlzIGlzIHRoZSBjYXNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyYW1zID0gbWVzc2FnZS5wYXJhbXM7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWVzc2FnZS5tZXRob2QgPT09IFByb2dyZXNzTm90aWZpY2F0aW9uLnR5cGUubWV0aG9kICYmIHBhcmFtcy5sZW5ndGggPT09IDIgJiYgUHJvZ3Jlc3NUb2tlbi5pcyhwYXJhbXNbMF0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm90aWZpY2F0aW9uSGFuZGxlcih7IHRva2VuOiBwYXJhbXNbMF0sIHZhbHVlOiBwYXJhbXNbMV0gfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlLnBhcmFtZXRlclN0cnVjdHVyZXMgPT09IG1lc3NhZ2VzXzEuUGFyYW1ldGVyU3RydWN0dXJlcy5ieU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihgTm90aWZpY2F0aW9uICR7bWVzc2FnZS5tZXRob2R9IGRlZmluZXMgcGFyYW1ldGVycyBieSBuYW1lIGJ1dCByZWNlaXZlZCBwYXJhbWV0ZXJzIGJ5IHBvc2l0aW9uYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUubnVtYmVyT2ZQYXJhbXMgIT09IG1lc3NhZ2UucGFyYW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGBOb3RpZmljYXRpb24gJHttZXNzYWdlLm1ldGhvZH0gZGVmaW5lcyAke3R5cGUubnVtYmVyT2ZQYXJhbXN9IHBhcmFtcyBidXQgcmVjZWl2ZWQgJHtwYXJhbXMubGVuZ3RofSBhcmd1bWVudHNgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3RpZmljYXRpb25IYW5kbGVyKC4uLnBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSAhPT0gdW5kZWZpbmVkICYmIHR5cGUucGFyYW1ldGVyU3RydWN0dXJlcyA9PT0gbWVzc2FnZXNfMS5QYXJhbWV0ZXJTdHJ1Y3R1cmVzLmJ5UG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoYE5vdGlmaWNhdGlvbiAke21lc3NhZ2UubWV0aG9kfSBkZWZpbmVzIHBhcmFtZXRlcnMgYnkgcG9zaXRpb24gYnV0IHJlY2VpdmVkIHBhcmFtZXRlcnMgYnkgbmFtZWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbm90aWZpY2F0aW9uSGFuZGxlcihtZXNzYWdlLnBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc3Rhck5vdGlmaWNhdGlvbkhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgc3Rhck5vdGlmaWNhdGlvbkhhbmRsZXIobWVzc2FnZS5tZXRob2QsIG1lc3NhZ2UucGFyYW1zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IubWVzc2FnZSkge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoYE5vdGlmaWNhdGlvbiBoYW5kbGVyICcke21lc3NhZ2UubWV0aG9kfScgZmFpbGVkIHdpdGggbWVzc2FnZTogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGBOb3RpZmljYXRpb24gaGFuZGxlciAnJHttZXNzYWdlLm1ldGhvZH0nIGZhaWxlZCB1bmV4cGVjdGVkbHkuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdW5oYW5kbGVkTm90aWZpY2F0aW9uRW1pdHRlci5maXJlKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhbmRsZUludmFsaWRNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKCFtZXNzYWdlKSB7XG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoJ1JlY2VpdmVkIGVtcHR5IG1lc3NhZ2UuJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbG9nZ2VyLmVycm9yKGBSZWNlaXZlZCBtZXNzYWdlIHdoaWNoIGlzIG5laXRoZXIgYSByZXNwb25zZSBub3IgYSBub3RpZmljYXRpb24gbWVzc2FnZTpcXG4ke0pTT04uc3RyaW5naWZ5KG1lc3NhZ2UsIG51bGwsIDQpfWApO1xuICAgICAgICAvLyBUZXN0IHdoZXRoZXIgd2UgZmluZCBhbiBpZCB0byByZWplY3QgdGhlIHByb21pc2VcbiAgICAgICAgY29uc3QgcmVzcG9uc2VNZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgaWYgKElzLnN0cmluZyhyZXNwb25zZU1lc3NhZ2UuaWQpIHx8IElzLm51bWJlcihyZXNwb25zZU1lc3NhZ2UuaWQpKSB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSByZXNwb25zZU1lc3NhZ2UuaWQ7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZUhhbmRsZXIgPSByZXNwb25zZVByb21pc2VzLmdldChrZXkpO1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlSGFuZGxlcikge1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlSGFuZGxlci5yZWplY3QobmV3IEVycm9yKCdUaGUgcmVjZWl2ZWQgcmVzcG9uc2UgaGFzIG5laXRoZXIgYSByZXN1bHQgbm9yIGFuIGVycm9yIHByb3BlcnR5LicpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBzdHJpbmdpZnlUcmFjZShwYXJhbXMpIHtcbiAgICAgICAgaWYgKHBhcmFtcyA9PT0gdW5kZWZpbmVkIHx8IHBhcmFtcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHRyYWNlKSB7XG4gICAgICAgICAgICBjYXNlIFRyYWNlLlZlcmJvc2U6XG4gICAgICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHBhcmFtcywgbnVsbCwgNCk7XG4gICAgICAgICAgICBjYXNlIFRyYWNlLkNvbXBhY3Q6XG4gICAgICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHBhcmFtcyk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdHJhY2VTZW5kaW5nUmVxdWVzdChtZXNzYWdlKSB7XG4gICAgICAgIGlmICh0cmFjZSA9PT0gVHJhY2UuT2ZmIHx8ICF0cmFjZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHJhY2VGb3JtYXQgPT09IFRyYWNlRm9ybWF0LlRleHQpIHtcbiAgICAgICAgICAgIGxldCBkYXRhID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKCh0cmFjZSA9PT0gVHJhY2UuVmVyYm9zZSB8fCB0cmFjZSA9PT0gVHJhY2UuQ29tcGFjdCkgJiYgbWVzc2FnZS5wYXJhbXMpIHtcbiAgICAgICAgICAgICAgICBkYXRhID0gYFBhcmFtczogJHtzdHJpbmdpZnlUcmFjZShtZXNzYWdlLnBhcmFtcyl9XFxuXFxuYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyYWNlci5sb2coYFNlbmRpbmcgcmVxdWVzdCAnJHttZXNzYWdlLm1ldGhvZH0gLSAoJHttZXNzYWdlLmlkfSknLmAsIGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbG9nTFNQTWVzc2FnZSgnc2VuZC1yZXF1ZXN0JywgbWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdHJhY2VTZW5kaW5nTm90aWZpY2F0aW9uKG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKHRyYWNlID09PSBUcmFjZS5PZmYgfHwgIXRyYWNlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0cmFjZUZvcm1hdCA9PT0gVHJhY2VGb3JtYXQuVGV4dCkge1xuICAgICAgICAgICAgbGV0IGRhdGEgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAodHJhY2UgPT09IFRyYWNlLlZlcmJvc2UgfHwgdHJhY2UgPT09IFRyYWNlLkNvbXBhY3QpIHtcbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZS5wYXJhbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGBQYXJhbXM6ICR7c3RyaW5naWZ5VHJhY2UobWVzc2FnZS5wYXJhbXMpfVxcblxcbmA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0gJ05vIHBhcmFtZXRlcnMgcHJvdmlkZWQuXFxuXFxuJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmFjZXIubG9nKGBTZW5kaW5nIG5vdGlmaWNhdGlvbiAnJHttZXNzYWdlLm1ldGhvZH0nLmAsIGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbG9nTFNQTWVzc2FnZSgnc2VuZC1ub3RpZmljYXRpb24nLCBtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB0cmFjZVNlbmRpbmdSZXNwb25zZShtZXNzYWdlLCBtZXRob2QsIHN0YXJ0VGltZSkge1xuICAgICAgICBpZiAodHJhY2UgPT09IFRyYWNlLk9mZiB8fCAhdHJhY2VyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyYWNlRm9ybWF0ID09PSBUcmFjZUZvcm1hdC5UZXh0KSB7XG4gICAgICAgICAgICBsZXQgZGF0YSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmICh0cmFjZSA9PT0gVHJhY2UuVmVyYm9zZSB8fCB0cmFjZSA9PT0gVHJhY2UuQ29tcGFjdCkge1xuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLmVycm9yICYmIG1lc3NhZ2UuZXJyb3IuZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0gYEVycm9yIGRhdGE6ICR7c3RyaW5naWZ5VHJhY2UobWVzc2FnZS5lcnJvci5kYXRhKX1cXG5cXG5gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UucmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gYFJlc3VsdDogJHtzdHJpbmdpZnlUcmFjZShtZXNzYWdlLnJlc3VsdCl9XFxuXFxuYDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChtZXNzYWdlLmVycm9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSAnTm8gcmVzdWx0IHJldHVybmVkLlxcblxcbic7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmFjZXIubG9nKGBTZW5kaW5nIHJlc3BvbnNlICcke21ldGhvZH0gLSAoJHttZXNzYWdlLmlkfSknLiBQcm9jZXNzaW5nIHJlcXVlc3QgdG9vayAke0RhdGUubm93KCkgLSBzdGFydFRpbWV9bXNgLCBkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxvZ0xTUE1lc3NhZ2UoJ3NlbmQtcmVzcG9uc2UnLCBtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB0cmFjZVJlY2VpdmVkUmVxdWVzdChtZXNzYWdlKSB7XG4gICAgICAgIGlmICh0cmFjZSA9PT0gVHJhY2UuT2ZmIHx8ICF0cmFjZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHJhY2VGb3JtYXQgPT09IFRyYWNlRm9ybWF0LlRleHQpIHtcbiAgICAgICAgICAgIGxldCBkYXRhID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKCh0cmFjZSA9PT0gVHJhY2UuVmVyYm9zZSB8fCB0cmFjZSA9PT0gVHJhY2UuQ29tcGFjdCkgJiYgbWVzc2FnZS5wYXJhbXMpIHtcbiAgICAgICAgICAgICAgICBkYXRhID0gYFBhcmFtczogJHtzdHJpbmdpZnlUcmFjZShtZXNzYWdlLnBhcmFtcyl9XFxuXFxuYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyYWNlci5sb2coYFJlY2VpdmVkIHJlcXVlc3QgJyR7bWVzc2FnZS5tZXRob2R9IC0gKCR7bWVzc2FnZS5pZH0pJy5gLCBkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxvZ0xTUE1lc3NhZ2UoJ3JlY2VpdmUtcmVxdWVzdCcsIG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRyYWNlUmVjZWl2ZWROb3RpZmljYXRpb24obWVzc2FnZSkge1xuICAgICAgICBpZiAodHJhY2UgPT09IFRyYWNlLk9mZiB8fCAhdHJhY2VyIHx8IG1lc3NhZ2UubWV0aG9kID09PSBMb2dUcmFjZU5vdGlmaWNhdGlvbi50eXBlLm1ldGhvZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0cmFjZUZvcm1hdCA9PT0gVHJhY2VGb3JtYXQuVGV4dCkge1xuICAgICAgICAgICAgbGV0IGRhdGEgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAodHJhY2UgPT09IFRyYWNlLlZlcmJvc2UgfHwgdHJhY2UgPT09IFRyYWNlLkNvbXBhY3QpIHtcbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZS5wYXJhbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGBQYXJhbXM6ICR7c3RyaW5naWZ5VHJhY2UobWVzc2FnZS5wYXJhbXMpfVxcblxcbmA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0gJ05vIHBhcmFtZXRlcnMgcHJvdmlkZWQuXFxuXFxuJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmFjZXIubG9nKGBSZWNlaXZlZCBub3RpZmljYXRpb24gJyR7bWVzc2FnZS5tZXRob2R9Jy5gLCBkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxvZ0xTUE1lc3NhZ2UoJ3JlY2VpdmUtbm90aWZpY2F0aW9uJywgbWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdHJhY2VSZWNlaXZlZFJlc3BvbnNlKG1lc3NhZ2UsIHJlc3BvbnNlUHJvbWlzZSkge1xuICAgICAgICBpZiAodHJhY2UgPT09IFRyYWNlLk9mZiB8fCAhdHJhY2VyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyYWNlRm9ybWF0ID09PSBUcmFjZUZvcm1hdC5UZXh0KSB7XG4gICAgICAgICAgICBsZXQgZGF0YSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmICh0cmFjZSA9PT0gVHJhY2UuVmVyYm9zZSB8fCB0cmFjZSA9PT0gVHJhY2UuQ29tcGFjdCkge1xuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLmVycm9yICYmIG1lc3NhZ2UuZXJyb3IuZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0gYEVycm9yIGRhdGE6ICR7c3RyaW5naWZ5VHJhY2UobWVzc2FnZS5lcnJvci5kYXRhKX1cXG5cXG5gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UucmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gYFJlc3VsdDogJHtzdHJpbmdpZnlUcmFjZShtZXNzYWdlLnJlc3VsdCl9XFxuXFxuYDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChtZXNzYWdlLmVycm9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSAnTm8gcmVzdWx0IHJldHVybmVkLlxcblxcbic7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzcG9uc2VQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBtZXNzYWdlLmVycm9yID8gYCBSZXF1ZXN0IGZhaWxlZDogJHttZXNzYWdlLmVycm9yLm1lc3NhZ2V9ICgke21lc3NhZ2UuZXJyb3IuY29kZX0pLmAgOiAnJztcbiAgICAgICAgICAgICAgICB0cmFjZXIubG9nKGBSZWNlaXZlZCByZXNwb25zZSAnJHtyZXNwb25zZVByb21pc2UubWV0aG9kfSAtICgke21lc3NhZ2UuaWR9KScgaW4gJHtEYXRlLm5vdygpIC0gcmVzcG9uc2VQcm9taXNlLnRpbWVyU3RhcnR9bXMuJHtlcnJvcn1gLCBkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRyYWNlci5sb2coYFJlY2VpdmVkIHJlc3BvbnNlICR7bWVzc2FnZS5pZH0gd2l0aG91dCBhY3RpdmUgcmVzcG9uc2UgcHJvbWlzZS5gLCBkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxvZ0xTUE1lc3NhZ2UoJ3JlY2VpdmUtcmVzcG9uc2UnLCBtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBsb2dMU1BNZXNzYWdlKHR5cGUsIG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKCF0cmFjZXIgfHwgdHJhY2UgPT09IFRyYWNlLk9mZikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxzcE1lc3NhZ2UgPSB7XG4gICAgICAgICAgICBpc0xTUE1lc3NhZ2U6IHRydWUsXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKVxuICAgICAgICB9O1xuICAgICAgICB0cmFjZXIubG9nKGxzcE1lc3NhZ2UpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0aHJvd0lmQ2xvc2VkT3JEaXNwb3NlZCgpIHtcbiAgICAgICAgaWYgKGlzQ2xvc2VkKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBDb25uZWN0aW9uRXJyb3IoQ29ubmVjdGlvbkVycm9ycy5DbG9zZWQsICdDb25uZWN0aW9uIGlzIGNsb3NlZC4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNEaXNwb3NlZCgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQ29ubmVjdGlvbkVycm9yKENvbm5lY3Rpb25FcnJvcnMuRGlzcG9zZWQsICdDb25uZWN0aW9uIGlzIGRpc3Bvc2VkLicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRocm93SWZMaXN0ZW5pbmcoKSB7XG4gICAgICAgIGlmIChpc0xpc3RlbmluZygpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQ29ubmVjdGlvbkVycm9yKENvbm5lY3Rpb25FcnJvcnMuQWxyZWFkeUxpc3RlbmluZywgJ0Nvbm5lY3Rpb24gaXMgYWxyZWFkeSBsaXN0ZW5pbmcnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB0aHJvd0lmTm90TGlzdGVuaW5nKCkge1xuICAgICAgICBpZiAoIWlzTGlzdGVuaW5nKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FsbCBsaXN0ZW4oKSBmaXJzdC4nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB1bmRlZmluZWRUb051bGwocGFyYW0pIHtcbiAgICAgICAgaWYgKHBhcmFtID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHBhcmFtO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIG51bGxUb1VuZGVmaW5lZChwYXJhbSkge1xuICAgICAgICBpZiAocGFyYW0gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyYW07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gaXNOYW1lZFBhcmFtKHBhcmFtKSB7XG4gICAgICAgIHJldHVybiBwYXJhbSAhPT0gdW5kZWZpbmVkICYmIHBhcmFtICE9PSBudWxsICYmICFBcnJheS5pc0FycmF5KHBhcmFtKSAmJiB0eXBlb2YgcGFyYW0gPT09ICdvYmplY3QnO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21wdXRlU2luZ2xlUGFyYW0ocGFyYW1ldGVyU3RydWN0dXJlcywgcGFyYW0pIHtcbiAgICAgICAgc3dpdGNoIChwYXJhbWV0ZXJTdHJ1Y3R1cmVzKSB7XG4gICAgICAgICAgICBjYXNlIG1lc3NhZ2VzXzEuUGFyYW1ldGVyU3RydWN0dXJlcy5hdXRvOlxuICAgICAgICAgICAgICAgIGlmIChpc05hbWVkUGFyYW0ocGFyYW0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsVG9VbmRlZmluZWQocGFyYW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFt1bmRlZmluZWRUb051bGwocGFyYW0pXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIG1lc3NhZ2VzXzEuUGFyYW1ldGVyU3RydWN0dXJlcy5ieU5hbWU6XG4gICAgICAgICAgICAgICAgaWYgKCFpc05hbWVkUGFyYW0ocGFyYW0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUmVjZWl2ZWQgcGFyYW1ldGVycyBieSBuYW1lIGJ1dCBwYXJhbSBpcyBub3QgYW4gb2JqZWN0IGxpdGVyYWwuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsVG9VbmRlZmluZWQocGFyYW0pO1xuICAgICAgICAgICAgY2FzZSBtZXNzYWdlc18xLlBhcmFtZXRlclN0cnVjdHVyZXMuYnlQb3NpdGlvbjpcbiAgICAgICAgICAgICAgICByZXR1cm4gW3VuZGVmaW5lZFRvTnVsbChwYXJhbSldO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gcGFyYW1ldGVyIHN0cnVjdHVyZSAke3BhcmFtZXRlclN0cnVjdHVyZXMudG9TdHJpbmcoKX1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjb21wdXRlTWVzc2FnZVBhcmFtcyh0eXBlLCBwYXJhbXMpIHtcbiAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgY29uc3QgbnVtYmVyT2ZQYXJhbXMgPSB0eXBlLm51bWJlck9mUGFyYW1zO1xuICAgICAgICBzd2l0Y2ggKG51bWJlck9mUGFyYW1zKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGNvbXB1dGVTaW5nbGVQYXJhbSh0eXBlLnBhcmFtZXRlclN0cnVjdHVyZXMsIHBhcmFtc1swXSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyYW1zLmxlbmd0aCAmJiBpIDwgbnVtYmVyT2ZQYXJhbXM7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh1bmRlZmluZWRUb051bGwocGFyYW1zW2ldKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwYXJhbXMubGVuZ3RoIDwgbnVtYmVyT2ZQYXJhbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IHBhcmFtcy5sZW5ndGg7IGkgPCBudW1iZXJPZlBhcmFtczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBjb25zdCBjb25uZWN0aW9uID0ge1xuICAgICAgICBzZW5kTm90aWZpY2F0aW9uOiAodHlwZSwgLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgdGhyb3dJZkNsb3NlZE9yRGlzcG9zZWQoKTtcbiAgICAgICAgICAgIGxldCBtZXRob2Q7XG4gICAgICAgICAgICBsZXQgbWVzc2FnZVBhcmFtcztcbiAgICAgICAgICAgIGlmIChJcy5zdHJpbmcodHlwZSkpIHtcbiAgICAgICAgICAgICAgICBtZXRob2QgPSB0eXBlO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpcnN0ID0gYXJnc1swXTtcbiAgICAgICAgICAgICAgICBsZXQgcGFyYW1TdGFydCA9IDA7XG4gICAgICAgICAgICAgICAgbGV0IHBhcmFtZXRlclN0cnVjdHVyZXMgPSBtZXNzYWdlc18xLlBhcmFtZXRlclN0cnVjdHVyZXMuYXV0bztcbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZXNfMS5QYXJhbWV0ZXJTdHJ1Y3R1cmVzLmlzKGZpcnN0KSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJhbVN0YXJ0ID0gMTtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1ldGVyU3RydWN0dXJlcyA9IGZpcnN0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgcGFyYW1FbmQgPSBhcmdzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBjb25zdCBudW1iZXJPZlBhcmFtcyA9IHBhcmFtRW5kIC0gcGFyYW1TdGFydDtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG51bWJlck9mUGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VQYXJhbXMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZVBhcmFtcyA9IGNvbXB1dGVTaW5nbGVQYXJhbShwYXJhbWV0ZXJTdHJ1Y3R1cmVzLCBhcmdzW3BhcmFtU3RhcnRdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtZXRlclN0cnVjdHVyZXMgPT09IG1lc3NhZ2VzXzEuUGFyYW1ldGVyU3RydWN0dXJlcy5ieU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFJlY2VpdmVkICR7bnVtYmVyT2ZQYXJhbXN9IHBhcmFtZXRlcnMgZm9yICdieSBOYW1lJyBub3RpZmljYXRpb24gcGFyYW1ldGVyIHN0cnVjdHVyZS5gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VQYXJhbXMgPSBhcmdzLnNsaWNlKHBhcmFtU3RhcnQsIHBhcmFtRW5kKS5tYXAodmFsdWUgPT4gdW5kZWZpbmVkVG9OdWxsKHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJhbXMgPSBhcmdzO1xuICAgICAgICAgICAgICAgIG1ldGhvZCA9IHR5cGUubWV0aG9kO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2VQYXJhbXMgPSBjb21wdXRlTWVzc2FnZVBhcmFtcyh0eXBlLCBwYXJhbXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgbm90aWZpY2F0aW9uTWVzc2FnZSA9IHtcbiAgICAgICAgICAgICAgICBqc29ucnBjOiB2ZXJzaW9uLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgICAgICAgICAgIHBhcmFtczogbWVzc2FnZVBhcmFtc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRyYWNlU2VuZGluZ05vdGlmaWNhdGlvbihub3RpZmljYXRpb25NZXNzYWdlKTtcbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlV3JpdGVyLndyaXRlKG5vdGlmaWNhdGlvbk1lc3NhZ2UpLmNhdGNoKCgpID0+IGxvZ2dlci5lcnJvcihgU2VuZGluZyBub3RpZmljYXRpb24gZmFpbGVkLmApKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25Ob3RpZmljYXRpb246ICh0eXBlLCBoYW5kbGVyKSA9PiB7XG4gICAgICAgICAgICB0aHJvd0lmQ2xvc2VkT3JEaXNwb3NlZCgpO1xuICAgICAgICAgICAgbGV0IG1ldGhvZDtcbiAgICAgICAgICAgIGlmIChJcy5mdW5jKHR5cGUpKSB7XG4gICAgICAgICAgICAgICAgc3Rhck5vdGlmaWNhdGlvbkhhbmRsZXIgPSB0eXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaGFuZGxlcikge1xuICAgICAgICAgICAgICAgIGlmIChJcy5zdHJpbmcodHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kID0gdHlwZTtcbiAgICAgICAgICAgICAgICAgICAgbm90aWZpY2F0aW9uSGFuZGxlcnMuc2V0KHR5cGUsIHsgdHlwZTogdW5kZWZpbmVkLCBoYW5kbGVyIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kID0gdHlwZS5tZXRob2Q7XG4gICAgICAgICAgICAgICAgICAgIG5vdGlmaWNhdGlvbkhhbmRsZXJzLnNldCh0eXBlLm1ldGhvZCwgeyB0eXBlLCBoYW5kbGVyIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZGlzcG9zZTogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAobWV0aG9kICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vdGlmaWNhdGlvbkhhbmRsZXJzLmRlbGV0ZShtZXRob2QpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3Rhck5vdGlmaWNhdGlvbkhhbmRsZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBvblByb2dyZXNzOiAoX3R5cGUsIHRva2VuLCBoYW5kbGVyKSA9PiB7XG4gICAgICAgICAgICBpZiAocHJvZ3Jlc3NIYW5kbGVycy5oYXModG9rZW4pKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQcm9ncmVzcyBoYW5kbGVyIGZvciB0b2tlbiAke3Rva2VufSBhbHJlYWR5IHJlZ2lzdGVyZWRgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByb2dyZXNzSGFuZGxlcnMuc2V0KHRva2VuLCBoYW5kbGVyKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZGlzcG9zZTogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBwcm9ncmVzc0hhbmRsZXJzLmRlbGV0ZSh0b2tlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgc2VuZFByb2dyZXNzOiAoX3R5cGUsIHRva2VuLCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb24uc2VuZE5vdGlmaWNhdGlvbihQcm9ncmVzc05vdGlmaWNhdGlvbi50eXBlLCB7IHRva2VuLCB2YWx1ZSB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgb25VbmhhbmRsZWRQcm9ncmVzczogdW5oYW5kbGVkUHJvZ3Jlc3NFbWl0dGVyLmV2ZW50LFxuICAgICAgICBzZW5kUmVxdWVzdDogKHR5cGUsIC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgIHRocm93SWZDbG9zZWRPckRpc3Bvc2VkKCk7XG4gICAgICAgICAgICB0aHJvd0lmTm90TGlzdGVuaW5nKCk7XG4gICAgICAgICAgICBsZXQgbWV0aG9kO1xuICAgICAgICAgICAgbGV0IG1lc3NhZ2VQYXJhbXM7XG4gICAgICAgICAgICBsZXQgdG9rZW4gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoSXMuc3RyaW5nKHR5cGUpKSB7XG4gICAgICAgICAgICAgICAgbWV0aG9kID0gdHlwZTtcbiAgICAgICAgICAgICAgICBjb25zdCBmaXJzdCA9IGFyZ3NbMF07XG4gICAgICAgICAgICAgICAgY29uc3QgbGFzdCA9IGFyZ3NbYXJncy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICBsZXQgcGFyYW1TdGFydCA9IDA7XG4gICAgICAgICAgICAgICAgbGV0IHBhcmFtZXRlclN0cnVjdHVyZXMgPSBtZXNzYWdlc18xLlBhcmFtZXRlclN0cnVjdHVyZXMuYXV0bztcbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZXNfMS5QYXJhbWV0ZXJTdHJ1Y3R1cmVzLmlzKGZpcnN0KSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJhbVN0YXJ0ID0gMTtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1ldGVyU3RydWN0dXJlcyA9IGZpcnN0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgcGFyYW1FbmQgPSBhcmdzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAoY2FuY2VsbGF0aW9uXzEuQ2FuY2VsbGF0aW9uVG9rZW4uaXMobGFzdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1FbmQgPSBwYXJhbUVuZCAtIDE7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuID0gbGFzdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgbnVtYmVyT2ZQYXJhbXMgPSBwYXJhbUVuZCAtIHBhcmFtU3RhcnQ7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChudW1iZXJPZlBhcmFtcykge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlUGFyYW1zID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VQYXJhbXMgPSBjb21wdXRlU2luZ2xlUGFyYW0ocGFyYW1ldGVyU3RydWN0dXJlcywgYXJnc1twYXJhbVN0YXJ0XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbWV0ZXJTdHJ1Y3R1cmVzID09PSBtZXNzYWdlc18xLlBhcmFtZXRlclN0cnVjdHVyZXMuYnlOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBSZWNlaXZlZCAke251bWJlck9mUGFyYW1zfSBwYXJhbWV0ZXJzIGZvciAnYnkgTmFtZScgcmVxdWVzdCBwYXJhbWV0ZXIgc3RydWN0dXJlLmApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZVBhcmFtcyA9IGFyZ3Muc2xpY2UocGFyYW1TdGFydCwgcGFyYW1FbmQpLm1hcCh2YWx1ZSA9PiB1bmRlZmluZWRUb051bGwodmFsdWUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IGFyZ3M7XG4gICAgICAgICAgICAgICAgbWV0aG9kID0gdHlwZS5tZXRob2Q7XG4gICAgICAgICAgICAgICAgbWVzc2FnZVBhcmFtcyA9IGNvbXB1dGVNZXNzYWdlUGFyYW1zKHR5cGUsIHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgY29uc3QgbnVtYmVyT2ZQYXJhbXMgPSB0eXBlLm51bWJlck9mUGFyYW1zO1xuICAgICAgICAgICAgICAgIHRva2VuID0gY2FuY2VsbGF0aW9uXzEuQ2FuY2VsbGF0aW9uVG9rZW4uaXMocGFyYW1zW251bWJlck9mUGFyYW1zXSkgPyBwYXJhbXNbbnVtYmVyT2ZQYXJhbXNdIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaWQgPSBzZXF1ZW5jZU51bWJlcisrO1xuICAgICAgICAgICAgbGV0IGRpc3Bvc2FibGU7XG4gICAgICAgICAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgICAgICAgICBkaXNwb3NhYmxlID0gdG9rZW4ub25DYW5jZWxsYXRpb25SZXF1ZXN0ZWQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwID0gY2FuY2VsbGF0aW9uU3RyYXRlZ3kuc2VuZGVyLnNlbmRDYW5jZWxsYXRpb24oY29ubmVjdGlvbiwgaWQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIubG9nKGBSZWNlaXZlZCBubyBwcm9taXNlIGZyb20gY2FuY2VsbGF0aW9uIHN0cmF0ZWd5IHdoZW4gY2FuY2VsbGluZyBpZCAke2lkfWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHAuY2F0Y2goKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coYFNlbmRpbmcgY2FuY2VsbGF0aW9uIG1lc3NhZ2VzIGZvciBpZCAke2lkfSBmYWlsZWRgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVxdWVzdE1lc3NhZ2UgPSB7XG4gICAgICAgICAgICAgICAgICAgIGpzb25ycGM6IHZlcnNpb24sXG4gICAgICAgICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtczogbWVzc2FnZVBhcmFtc1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzb2x2ZVdpdGhDbGVhbnVwID0gKHIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyKTtcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsbGF0aW9uU3RyYXRlZ3kuc2VuZGVyLmNsZWFudXAoaWQpO1xuICAgICAgICAgICAgICAgICAgICBkaXNwb3NhYmxlPy5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjb25zdCByZWplY3RXaXRoQ2xlYW51cCA9IChyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChyKTtcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsbGF0aW9uU3RyYXRlZ3kuc2VuZGVyLmNsZWFudXAoaWQpO1xuICAgICAgICAgICAgICAgICAgICBkaXNwb3NhYmxlPy5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBsZXQgcmVzcG9uc2VQcm9taXNlID0geyBtZXRob2Q6IG1ldGhvZCwgdGltZXJTdGFydDogRGF0ZS5ub3coKSwgcmVzb2x2ZTogcmVzb2x2ZVdpdGhDbGVhbnVwLCByZWplY3Q6IHJlamVjdFdpdGhDbGVhbnVwIH07XG4gICAgICAgICAgICAgICAgdHJhY2VTZW5kaW5nUmVxdWVzdChyZXF1ZXN0TWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZVdyaXRlci53cml0ZShyZXF1ZXN0TWVzc2FnZSkuY2F0Y2goKCkgPT4gbG9nZ2VyLmVycm9yKGBTZW5kaW5nIHJlcXVlc3QgZmFpbGVkLmApKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV3JpdGluZyB0aGUgbWVzc2FnZSBmYWlsZWQuIFNvIHdlIG5lZWQgdG8gcmVqZWN0IHRoZSBwcm9taXNlLlxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZVByb21pc2UucmVqZWN0KG5ldyBtZXNzYWdlc18xLlJlc3BvbnNlRXJyb3IobWVzc2FnZXNfMS5FcnJvckNvZGVzLk1lc3NhZ2VXcml0ZUVycm9yLCBlLm1lc3NhZ2UgPyBlLm1lc3NhZ2UgOiAnVW5rbm93biByZWFzb24nKSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlUHJvbWlzZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZVByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VQcm9taXNlcy5zZXQoaWQsIHJlc3BvbnNlUHJvbWlzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LFxuICAgICAgICBvblJlcXVlc3Q6ICh0eXBlLCBoYW5kbGVyKSA9PiB7XG4gICAgICAgICAgICB0aHJvd0lmQ2xvc2VkT3JEaXNwb3NlZCgpO1xuICAgICAgICAgICAgbGV0IG1ldGhvZCA9IG51bGw7XG4gICAgICAgICAgICBpZiAoU3RhclJlcXVlc3RIYW5kbGVyLmlzKHR5cGUpKSB7XG4gICAgICAgICAgICAgICAgbWV0aG9kID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHN0YXJSZXF1ZXN0SGFuZGxlciA9IHR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChJcy5zdHJpbmcodHlwZSkpIHtcbiAgICAgICAgICAgICAgICBtZXRob2QgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kID0gdHlwZTtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdEhhbmRsZXJzLnNldCh0eXBlLCB7IGhhbmRsZXI6IGhhbmRsZXIsIHR5cGU6IHVuZGVmaW5lZCB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoaGFuZGxlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZCA9IHR5cGUubWV0aG9kO1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0SGFuZGxlcnMuc2V0KHR5cGUubWV0aG9kLCB7IHR5cGUsIGhhbmRsZXIgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkaXNwb3NlOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZXRob2QgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobWV0aG9kICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RIYW5kbGVycy5kZWxldGUobWV0aG9kKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJSZXF1ZXN0SGFuZGxlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGhhc1BlbmRpbmdSZXNwb25zZTogKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlUHJvbWlzZXMuc2l6ZSA+IDA7XG4gICAgICAgIH0sXG4gICAgICAgIHRyYWNlOiBhc3luYyAoX3ZhbHVlLCBfdHJhY2VyLCBzZW5kTm90aWZpY2F0aW9uT3JUcmFjZU9wdGlvbnMpID0+IHtcbiAgICAgICAgICAgIGxldCBfc2VuZE5vdGlmaWNhdGlvbiA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IF90cmFjZUZvcm1hdCA9IFRyYWNlRm9ybWF0LlRleHQ7XG4gICAgICAgICAgICBpZiAoc2VuZE5vdGlmaWNhdGlvbk9yVHJhY2VPcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoSXMuYm9vbGVhbihzZW5kTm90aWZpY2F0aW9uT3JUcmFjZU9wdGlvbnMpKSB7XG4gICAgICAgICAgICAgICAgICAgIF9zZW5kTm90aWZpY2F0aW9uID0gc2VuZE5vdGlmaWNhdGlvbk9yVHJhY2VPcHRpb25zO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgX3NlbmROb3RpZmljYXRpb24gPSBzZW5kTm90aWZpY2F0aW9uT3JUcmFjZU9wdGlvbnMuc2VuZE5vdGlmaWNhdGlvbiB8fCBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgX3RyYWNlRm9ybWF0ID0gc2VuZE5vdGlmaWNhdGlvbk9yVHJhY2VPcHRpb25zLnRyYWNlRm9ybWF0IHx8IFRyYWNlRm9ybWF0LlRleHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJhY2UgPSBfdmFsdWU7XG4gICAgICAgICAgICB0cmFjZUZvcm1hdCA9IF90cmFjZUZvcm1hdDtcbiAgICAgICAgICAgIGlmICh0cmFjZSA9PT0gVHJhY2UuT2ZmKSB7XG4gICAgICAgICAgICAgICAgdHJhY2VyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdHJhY2VyID0gX3RyYWNlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfc2VuZE5vdGlmaWNhdGlvbiAmJiAhaXNDbG9zZWQoKSAmJiAhaXNEaXNwb3NlZCgpKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgY29ubmVjdGlvbi5zZW5kTm90aWZpY2F0aW9uKFNldFRyYWNlTm90aWZpY2F0aW9uLnR5cGUsIHsgdmFsdWU6IFRyYWNlLnRvU3RyaW5nKF92YWx1ZSkgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG9uRXJyb3I6IGVycm9yRW1pdHRlci5ldmVudCxcbiAgICAgICAgb25DbG9zZTogY2xvc2VFbWl0dGVyLmV2ZW50LFxuICAgICAgICBvblVuaGFuZGxlZE5vdGlmaWNhdGlvbjogdW5oYW5kbGVkTm90aWZpY2F0aW9uRW1pdHRlci5ldmVudCxcbiAgICAgICAgb25EaXNwb3NlOiBkaXNwb3NlRW1pdHRlci5ldmVudCxcbiAgICAgICAgZW5kOiAoKSA9PiB7XG4gICAgICAgICAgICBtZXNzYWdlV3JpdGVyLmVuZCgpO1xuICAgICAgICB9LFxuICAgICAgICBkaXNwb3NlOiAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoaXNEaXNwb3NlZCgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhdGUgPSBDb25uZWN0aW9uU3RhdGUuRGlzcG9zZWQ7XG4gICAgICAgICAgICBkaXNwb3NlRW1pdHRlci5maXJlKHVuZGVmaW5lZCk7XG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBtZXNzYWdlc18xLlJlc3BvbnNlRXJyb3IobWVzc2FnZXNfMS5FcnJvckNvZGVzLlBlbmRpbmdSZXNwb25zZVJlamVjdGVkLCAnUGVuZGluZyByZXNwb25zZSByZWplY3RlZCBzaW5jZSBjb25uZWN0aW9uIGdvdCBkaXNwb3NlZCcpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBwcm9taXNlIG9mIHJlc3BvbnNlUHJvbWlzZXMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNwb25zZVByb21pc2VzID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgcmVxdWVzdFRva2VucyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIGtub3duQ2FuY2VsZWRSZXF1ZXN0cyA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgIG1lc3NhZ2VRdWV1ZSA9IG5ldyBsaW5rZWRNYXBfMS5MaW5rZWRNYXAoKTtcbiAgICAgICAgICAgIC8vIFRlc3QgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gICAgICAgICAgICBpZiAoSXMuZnVuYyhtZXNzYWdlV3JpdGVyLmRpc3Bvc2UpKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZVdyaXRlci5kaXNwb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoSXMuZnVuYyhtZXNzYWdlUmVhZGVyLmRpc3Bvc2UpKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZVJlYWRlci5kaXNwb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGxpc3RlbjogKCkgPT4ge1xuICAgICAgICAgICAgdGhyb3dJZkNsb3NlZE9yRGlzcG9zZWQoKTtcbiAgICAgICAgICAgIHRocm93SWZMaXN0ZW5pbmcoKTtcbiAgICAgICAgICAgIHN0YXRlID0gQ29ubmVjdGlvblN0YXRlLkxpc3RlbmluZztcbiAgICAgICAgICAgIG1lc3NhZ2VSZWFkZXIubGlzdGVuKGNhbGxiYWNrKTtcbiAgICAgICAgfSxcbiAgICAgICAgaW5zcGVjdDogKCkgPT4ge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgICAgICgwLCByYWxfMS5kZWZhdWx0KSgpLmNvbnNvbGUubG9nKCdpbnNwZWN0Jyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbm5lY3Rpb24ub25Ob3RpZmljYXRpb24oTG9nVHJhY2VOb3RpZmljYXRpb24udHlwZSwgKHBhcmFtcykgPT4ge1xuICAgICAgICBpZiAodHJhY2UgPT09IFRyYWNlLk9mZiB8fCAhdHJhY2VyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmVyYm9zZSA9IHRyYWNlID09PSBUcmFjZS5WZXJib3NlIHx8IHRyYWNlID09PSBUcmFjZS5Db21wYWN0O1xuICAgICAgICB0cmFjZXIubG9nKHBhcmFtcy5tZXNzYWdlLCB2ZXJib3NlID8gcGFyYW1zLnZlcmJvc2UgOiB1bmRlZmluZWQpO1xuICAgIH0pO1xuICAgIGNvbm5lY3Rpb24ub25Ob3RpZmljYXRpb24oUHJvZ3Jlc3NOb3RpZmljYXRpb24udHlwZSwgKHBhcmFtcykgPT4ge1xuICAgICAgICBjb25zdCBoYW5kbGVyID0gcHJvZ3Jlc3NIYW5kbGVycy5nZXQocGFyYW1zLnRva2VuKTtcbiAgICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgICAgIGhhbmRsZXIocGFyYW1zLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHVuaGFuZGxlZFByb2dyZXNzRW1pdHRlci5maXJlKHBhcmFtcyk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gY29ubmVjdGlvbjtcbn1cbmV4cG9ydHMuY3JlYXRlTWVzc2FnZUNvbm5lY3Rpb24gPSBjcmVhdGVNZXNzYWdlQ29ubmVjdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbm5lY3Rpb24uanMubWFwXG5cbi8qKiovIH0pLFxuXG4vKioqLyA3OTYzOlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuRGlzcG9zYWJsZSA9IHZvaWQgMDtcbnZhciBEaXNwb3NhYmxlO1xuKGZ1bmN0aW9uIChEaXNwb3NhYmxlKSB7XG4gICAgZnVuY3Rpb24gY3JlYXRlKGZ1bmMpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRpc3Bvc2U6IGZ1bmNcbiAgICAgICAgfTtcbiAgICB9XG4gICAgRGlzcG9zYWJsZS5jcmVhdGUgPSBjcmVhdGU7XG59KShEaXNwb3NhYmxlID0gZXhwb3J0cy5EaXNwb3NhYmxlIHx8IChleHBvcnRzLkRpc3Bvc2FibGUgPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGlzcG9zYWJsZS5qcy5tYXBcblxuLyoqKi8gfSksXG5cbi8qKiovIDY3ODA6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuRW1pdHRlciA9IGV4cG9ydHMuRXZlbnQgPSB2b2lkIDA7XG5jb25zdCByYWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNDI1NCk7XG52YXIgRXZlbnQ7XG4oZnVuY3Rpb24gKEV2ZW50KSB7XG4gICAgY29uc3QgX2Rpc3Bvc2FibGUgPSB7IGRpc3Bvc2UoKSB7IH0gfTtcbiAgICBFdmVudC5Ob25lID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gX2Rpc3Bvc2FibGU7IH07XG59KShFdmVudCA9IGV4cG9ydHMuRXZlbnQgfHwgKGV4cG9ydHMuRXZlbnQgPSB7fSkpO1xuY2xhc3MgQ2FsbGJhY2tMaXN0IHtcbiAgICBhZGQoY2FsbGJhY2ssIGNvbnRleHQgPSBudWxsLCBidWNrZXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9jYWxsYmFja3MpIHtcbiAgICAgICAgICAgIHRoaXMuX2NhbGxiYWNrcyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dHMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgICAgIHRoaXMuX2NvbnRleHRzLnB1c2goY29udGV4dCk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGJ1Y2tldCkpIHtcbiAgICAgICAgICAgIGJ1Y2tldC5wdXNoKHsgZGlzcG9zZTogKCkgPT4gdGhpcy5yZW1vdmUoY2FsbGJhY2ssIGNvbnRleHQpIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlbW92ZShjYWxsYmFjaywgY29udGV4dCA9IG51bGwpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9jYWxsYmFja3MpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZm91bmRDYWxsYmFja1dpdGhEaWZmZXJlbnRDb250ZXh0ID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSB0aGlzLl9jYWxsYmFja3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jYWxsYmFja3NbaV0gPT09IGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2NvbnRleHRzW2ldID09PSBjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNhbGxiYWNrICYgY29udGV4dCBtYXRjaCA9PiByZW1vdmUgaXRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FsbGJhY2tzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29udGV4dHMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmb3VuZENhbGxiYWNrV2l0aERpZmZlcmVudENvbnRleHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZm91bmRDYWxsYmFja1dpdGhEaWZmZXJlbnRDb250ZXh0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1doZW4gYWRkaW5nIGEgbGlzdGVuZXIgd2l0aCBhIGNvbnRleHQsIHlvdSBzaG91bGQgcmVtb3ZlIGl0IHdpdGggdGhlIHNhbWUgY29udGV4dCcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGludm9rZSguLi5hcmdzKSB7XG4gICAgICAgIGlmICghdGhpcy5fY2FsbGJhY2tzKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmV0ID0gW10sIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcy5zbGljZSgwKSwgY29udGV4dHMgPSB0aGlzLl9jb250ZXh0cy5zbGljZSgwKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXQucHVzaChjYWxsYmFja3NbaV0uYXBwbHkoY29udGV4dHNbaV0sIGFyZ3MpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgICAgICAgICAoMCwgcmFsXzEuZGVmYXVsdCkoKS5jb25zb2xlLmVycm9yKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIGlzRW1wdHkoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5fY2FsbGJhY2tzIHx8IHRoaXMuX2NhbGxiYWNrcy5sZW5ndGggPT09IDA7XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIHRoaXMuX2NhbGxiYWNrcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fY29udGV4dHMgPSB1bmRlZmluZWQ7XG4gICAgfVxufVxuY2xhc3MgRW1pdHRlciB7XG4gICAgY29uc3RydWN0b3IoX29wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5fb3B0aW9ucyA9IF9vcHRpb25zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGb3IgdGhlIHB1YmxpYyB0byBhbGxvdyB0byBzdWJzY3JpYmVcbiAgICAgKiB0byBldmVudHMgZnJvbSB0aGlzIEVtaXR0ZXJcbiAgICAgKi9cbiAgICBnZXQgZXZlbnQoKSB7XG4gICAgICAgIGlmICghdGhpcy5fZXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50ID0gKGxpc3RlbmVyLCB0aGlzQXJncywgZGlzcG9zYWJsZXMpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2NhbGxiYWNrcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYWxsYmFja3MgPSBuZXcgQ2FsbGJhY2tMaXN0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9vcHRpb25zICYmIHRoaXMuX29wdGlvbnMub25GaXJzdExpc3RlbmVyQWRkICYmIHRoaXMuX2NhbGxiYWNrcy5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fb3B0aW9ucy5vbkZpcnN0TGlzdGVuZXJBZGQodGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2NhbGxiYWNrcy5hZGQobGlzdGVuZXIsIHRoaXNBcmdzKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3Bvc2U6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5fY2FsbGJhY2tzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGlzcG9zYWJsZSBpcyBkaXNwb3NlZCBhZnRlciBlbWl0dGVyIGlzIGRpc3Bvc2VkLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NhbGxiYWNrcy5yZW1vdmUobGlzdGVuZXIsIHRoaXNBcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5kaXNwb3NlID0gRW1pdHRlci5fbm9vcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9vcHRpb25zICYmIHRoaXMuX29wdGlvbnMub25MYXN0TGlzdGVuZXJSZW1vdmUgJiYgdGhpcy5fY2FsbGJhY2tzLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX29wdGlvbnMub25MYXN0TGlzdGVuZXJSZW1vdmUodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRpc3Bvc2FibGVzKSkge1xuICAgICAgICAgICAgICAgICAgICBkaXNwb3NhYmxlcy5wdXNoKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9ldmVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVG8gYmUga2VwdCBwcml2YXRlIHRvIGZpcmUgYW4gZXZlbnQgdG9cbiAgICAgKiBzdWJzY3JpYmVyc1xuICAgICAqL1xuICAgIGZpcmUoZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2NhbGxiYWNrcykge1xuICAgICAgICAgICAgdGhpcy5fY2FsbGJhY2tzLmludm9rZS5jYWxsKHRoaXMuX2NhbGxiYWNrcywgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIGlmICh0aGlzLl9jYWxsYmFja3MpIHtcbiAgICAgICAgICAgIHRoaXMuX2NhbGxiYWNrcy5kaXNwb3NlKCk7XG4gICAgICAgICAgICB0aGlzLl9jYWxsYmFja3MgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkVtaXR0ZXIgPSBFbWl0dGVyO1xuRW1pdHRlci5fbm9vcCA9IGZ1bmN0aW9uICgpIHsgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV2ZW50cy5qcy5tYXBcblxuLyoqKi8gfSksXG5cbi8qKiovIDYxNDU6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuc3RyaW5nQXJyYXkgPSBleHBvcnRzLmFycmF5ID0gZXhwb3J0cy5mdW5jID0gZXhwb3J0cy5lcnJvciA9IGV4cG9ydHMubnVtYmVyID0gZXhwb3J0cy5zdHJpbmcgPSBleHBvcnRzLmJvb2xlYW4gPSB2b2lkIDA7XG5mdW5jdGlvbiBib29sZWFuKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB0cnVlIHx8IHZhbHVlID09PSBmYWxzZTtcbn1cbmV4cG9ydHMuYm9vbGVhbiA9IGJvb2xlYW47XG5mdW5jdGlvbiBzdHJpbmcodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fCB2YWx1ZSBpbnN0YW5jZW9mIFN0cmluZztcbn1cbmV4cG9ydHMuc3RyaW5nID0gc3RyaW5nO1xuZnVuY3Rpb24gbnVtYmVyKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgfHwgdmFsdWUgaW5zdGFuY2VvZiBOdW1iZXI7XG59XG5leHBvcnRzLm51bWJlciA9IG51bWJlcjtcbmZ1bmN0aW9uIGVycm9yKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgRXJyb3I7XG59XG5leHBvcnRzLmVycm9yID0gZXJyb3I7XG5mdW5jdGlvbiBmdW5jKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuZnVuYyA9IGZ1bmM7XG5mdW5jdGlvbiBhcnJheSh2YWx1ZSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKTtcbn1cbmV4cG9ydHMuYXJyYXkgPSBhcnJheTtcbmZ1bmN0aW9uIHN0cmluZ0FycmF5KHZhbHVlKSB7XG4gICAgcmV0dXJuIGFycmF5KHZhbHVlKSAmJiB2YWx1ZS5ldmVyeShlbGVtID0+IHN0cmluZyhlbGVtKSk7XG59XG5leHBvcnRzLnN0cmluZ0FycmF5ID0gc3RyaW5nQXJyYXk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pcy5qcy5tYXBcblxuLyoqKi8gfSksXG5cbi8qKiovIDYxNzY6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbnZhciBfYTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5MUlVDYWNoZSA9IGV4cG9ydHMuTGlua2VkTWFwID0gZXhwb3J0cy5Ub3VjaCA9IHZvaWQgMDtcbnZhciBUb3VjaDtcbihmdW5jdGlvbiAoVG91Y2gpIHtcbiAgICBUb3VjaC5Ob25lID0gMDtcbiAgICBUb3VjaC5GaXJzdCA9IDE7XG4gICAgVG91Y2guQXNPbGQgPSBUb3VjaC5GaXJzdDtcbiAgICBUb3VjaC5MYXN0ID0gMjtcbiAgICBUb3VjaC5Bc05ldyA9IFRvdWNoLkxhc3Q7XG59KShUb3VjaCA9IGV4cG9ydHMuVG91Y2ggfHwgKGV4cG9ydHMuVG91Y2ggPSB7fSkpO1xuY2xhc3MgTGlua2VkTWFwIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpc1tfYV0gPSAnTGlua2VkTWFwJztcbiAgICAgICAgdGhpcy5fbWFwID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9oZWFkID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl90YWlsID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9zaXplID0gMDtcbiAgICAgICAgdGhpcy5fc3RhdGUgPSAwO1xuICAgIH1cbiAgICBjbGVhcigpIHtcbiAgICAgICAgdGhpcy5fbWFwLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuX2hlYWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX3RhaWwgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX3NpemUgPSAwO1xuICAgICAgICB0aGlzLl9zdGF0ZSsrO1xuICAgIH1cbiAgICBpc0VtcHR5KCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuX2hlYWQgJiYgIXRoaXMuX3RhaWw7XG4gICAgfVxuICAgIGdldCBzaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2l6ZTtcbiAgICB9XG4gICAgZ2V0IGZpcnN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faGVhZD8udmFsdWU7XG4gICAgfVxuICAgIGdldCBsYXN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGFpbD8udmFsdWU7XG4gICAgfVxuICAgIGhhcyhrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcC5oYXMoa2V5KTtcbiAgICB9XG4gICAgZ2V0KGtleSwgdG91Y2ggPSBUb3VjaC5Ob25lKSB7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzLl9tYXAuZ2V0KGtleSk7XG4gICAgICAgIGlmICghaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG91Y2ggIT09IFRvdWNoLk5vbmUpIHtcbiAgICAgICAgICAgIHRoaXMudG91Y2goaXRlbSwgdG91Y2gpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpdGVtLnZhbHVlO1xuICAgIH1cbiAgICBzZXQoa2V5LCB2YWx1ZSwgdG91Y2ggPSBUb3VjaC5Ob25lKSB7XG4gICAgICAgIGxldCBpdGVtID0gdGhpcy5fbWFwLmdldChrZXkpO1xuICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgICAgaXRlbS52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgaWYgKHRvdWNoICE9PSBUb3VjaC5Ob25lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50b3VjaChpdGVtLCB0b3VjaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpdGVtID0geyBrZXksIHZhbHVlLCBuZXh0OiB1bmRlZmluZWQsIHByZXZpb3VzOiB1bmRlZmluZWQgfTtcbiAgICAgICAgICAgIHN3aXRjaCAodG91Y2gpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFRvdWNoLk5vbmU6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkSXRlbUxhc3QoaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgVG91Y2guRmlyc3Q6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkSXRlbUZpcnN0KGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFRvdWNoLkxhc3Q6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkSXRlbUxhc3QoaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkSXRlbUxhc3QoaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fbWFwLnNldChrZXksIGl0ZW0pO1xuICAgICAgICAgICAgdGhpcy5fc2l6ZSsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkZWxldGUoa2V5KSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMucmVtb3ZlKGtleSk7XG4gICAgfVxuICAgIHJlbW92ZShrZXkpIHtcbiAgICAgICAgY29uc3QgaXRlbSA9IHRoaXMuX21hcC5nZXQoa2V5KTtcbiAgICAgICAgaWYgKCFpdGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX21hcC5kZWxldGUoa2V5KTtcbiAgICAgICAgdGhpcy5yZW1vdmVJdGVtKGl0ZW0pO1xuICAgICAgICB0aGlzLl9zaXplLS07XG4gICAgICAgIHJldHVybiBpdGVtLnZhbHVlO1xuICAgIH1cbiAgICBzaGlmdCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9oZWFkICYmICF0aGlzLl90YWlsKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5faGVhZCB8fCAhdGhpcy5fdGFpbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGxpc3QnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5faGVhZDtcbiAgICAgICAgdGhpcy5fbWFwLmRlbGV0ZShpdGVtLmtleSk7XG4gICAgICAgIHRoaXMucmVtb3ZlSXRlbShpdGVtKTtcbiAgICAgICAgdGhpcy5fc2l6ZS0tO1xuICAgICAgICByZXR1cm4gaXRlbS52YWx1ZTtcbiAgICB9XG4gICAgZm9yRWFjaChjYWxsYmFja2ZuLCB0aGlzQXJnKSB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5fc3RhdGU7XG4gICAgICAgIGxldCBjdXJyZW50ID0gdGhpcy5faGVhZDtcbiAgICAgICAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzQXJnKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2tmbi5iaW5kKHRoaXNBcmcpKGN1cnJlbnQudmFsdWUsIGN1cnJlbnQua2V5LCB0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrZm4oY3VycmVudC52YWx1ZSwgY3VycmVudC5rZXksIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX3N0YXRlICE9PSBzdGF0ZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTGlua2VkTWFwIGdvdCBtb2RpZmllZCBkdXJpbmcgaXRlcmF0aW9uLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBrZXlzKCkge1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuX3N0YXRlO1xuICAgICAgICBsZXQgY3VycmVudCA9IHRoaXMuX2hlYWQ7XG4gICAgICAgIGNvbnN0IGl0ZXJhdG9yID0ge1xuICAgICAgICAgICAgW1N5bWJvbC5pdGVyYXRvcl06ICgpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlcmF0b3I7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbmV4dDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9zdGF0ZSAhPT0gc3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBMaW5rZWRNYXAgZ290IG1vZGlmaWVkIGR1cmluZyBpdGVyYXRpb24uYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHsgdmFsdWU6IGN1cnJlbnQua2V5LCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yO1xuICAgIH1cbiAgICB2YWx1ZXMoKSB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5fc3RhdGU7XG4gICAgICAgIGxldCBjdXJyZW50ID0gdGhpcy5faGVhZDtcbiAgICAgICAgY29uc3QgaXRlcmF0b3IgPSB7XG4gICAgICAgICAgICBbU3ltYm9sLml0ZXJhdG9yXTogKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVyYXRvcjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBuZXh0OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3N0YXRlICE9PSBzdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYExpbmtlZE1hcCBnb3QgbW9kaWZpZWQgZHVyaW5nIGl0ZXJhdGlvbi5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0geyB2YWx1ZTogY3VycmVudC52YWx1ZSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBpdGVyYXRvcjtcbiAgICB9XG4gICAgZW50cmllcygpIHtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLl9zdGF0ZTtcbiAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzLl9oZWFkO1xuICAgICAgICBjb25zdCBpdGVyYXRvciA9IHtcbiAgICAgICAgICAgIFtTeW1ib2wuaXRlcmF0b3JdOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZXJhdG9yO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5leHQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fc3RhdGUgIT09IHN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTGlua2VkTWFwIGdvdCBtb2RpZmllZCBkdXJpbmcgaXRlcmF0aW9uLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB7IHZhbHVlOiBbY3VycmVudC5rZXksIGN1cnJlbnQudmFsdWVdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yO1xuICAgIH1cbiAgICBbKF9hID0gU3ltYm9sLnRvU3RyaW5nVGFnLCBTeW1ib2wuaXRlcmF0b3IpXSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW50cmllcygpO1xuICAgIH1cbiAgICB0cmltT2xkKG5ld1NpemUpIHtcbiAgICAgICAgaWYgKG5ld1NpemUgPj0gdGhpcy5zaXplKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5ld1NpemUgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY3VycmVudCA9IHRoaXMuX2hlYWQ7XG4gICAgICAgIGxldCBjdXJyZW50U2l6ZSA9IHRoaXMuc2l6ZTtcbiAgICAgICAgd2hpbGUgKGN1cnJlbnQgJiYgY3VycmVudFNpemUgPiBuZXdTaXplKSB7XG4gICAgICAgICAgICB0aGlzLl9tYXAuZGVsZXRlKGN1cnJlbnQua2V5KTtcbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gICAgICAgICAgICBjdXJyZW50U2l6ZS0tO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2hlYWQgPSBjdXJyZW50O1xuICAgICAgICB0aGlzLl9zaXplID0gY3VycmVudFNpemU7XG4gICAgICAgIGlmIChjdXJyZW50KSB7XG4gICAgICAgICAgICBjdXJyZW50LnByZXZpb3VzID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3N0YXRlKys7XG4gICAgfVxuICAgIGFkZEl0ZW1GaXJzdChpdGVtKSB7XG4gICAgICAgIC8vIEZpcnN0IHRpbWUgSW5zZXJ0XG4gICAgICAgIGlmICghdGhpcy5faGVhZCAmJiAhdGhpcy5fdGFpbCkge1xuICAgICAgICAgICAgdGhpcy5fdGFpbCA9IGl0ZW07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXRoaXMuX2hlYWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBsaXN0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpdGVtLm5leHQgPSB0aGlzLl9oZWFkO1xuICAgICAgICAgICAgdGhpcy5faGVhZC5wcmV2aW91cyA9IGl0ZW07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faGVhZCA9IGl0ZW07XG4gICAgICAgIHRoaXMuX3N0YXRlKys7XG4gICAgfVxuICAgIGFkZEl0ZW1MYXN0KGl0ZW0pIHtcbiAgICAgICAgLy8gRmlyc3QgdGltZSBJbnNlcnRcbiAgICAgICAgaWYgKCF0aGlzLl9oZWFkICYmICF0aGlzLl90YWlsKSB7XG4gICAgICAgICAgICB0aGlzLl9oZWFkID0gaXRlbTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGhpcy5fdGFpbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGxpc3QnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGl0ZW0ucHJldmlvdXMgPSB0aGlzLl90YWlsO1xuICAgICAgICAgICAgdGhpcy5fdGFpbC5uZXh0ID0gaXRlbTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl90YWlsID0gaXRlbTtcbiAgICAgICAgdGhpcy5fc3RhdGUrKztcbiAgICB9XG4gICAgcmVtb3ZlSXRlbShpdGVtKSB7XG4gICAgICAgIGlmIChpdGVtID09PSB0aGlzLl9oZWFkICYmIGl0ZW0gPT09IHRoaXMuX3RhaWwpIHtcbiAgICAgICAgICAgIHRoaXMuX2hlYWQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLl90YWlsID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGl0ZW0gPT09IHRoaXMuX2hlYWQpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgY2FuIG9ubHkgaGFwcGVuZWQgaWYgc2l6ZSA9PT0gMSB3aGljaCBpcyBoYW5kbGVcbiAgICAgICAgICAgIC8vIGJ5IHRoZSBjYXNlIGFib3ZlLlxuICAgICAgICAgICAgaWYgKCFpdGVtLm5leHQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbGlzdCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaXRlbS5uZXh0LnByZXZpb3VzID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5faGVhZCA9IGl0ZW0ubmV4dDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpdGVtID09PSB0aGlzLl90YWlsKSB7XG4gICAgICAgICAgICAvLyBUaGlzIGNhbiBvbmx5IGhhcHBlbmVkIGlmIHNpemUgPT09IDEgd2hpY2ggaXMgaGFuZGxlXG4gICAgICAgICAgICAvLyBieSB0aGUgY2FzZSBhYm92ZS5cbiAgICAgICAgICAgIGlmICghaXRlbS5wcmV2aW91cykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBsaXN0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpdGVtLnByZXZpb3VzLm5leHQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLl90YWlsID0gaXRlbS5wcmV2aW91cztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IG5leHQgPSBpdGVtLm5leHQ7XG4gICAgICAgICAgICBjb25zdCBwcmV2aW91cyA9IGl0ZW0ucHJldmlvdXM7XG4gICAgICAgICAgICBpZiAoIW5leHQgfHwgIXByZXZpb3VzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGxpc3QnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5leHQucHJldmlvdXMgPSBwcmV2aW91cztcbiAgICAgICAgICAgIHByZXZpb3VzLm5leHQgPSBuZXh0O1xuICAgICAgICB9XG4gICAgICAgIGl0ZW0ubmV4dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaXRlbS5wcmV2aW91cyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fc3RhdGUrKztcbiAgICB9XG4gICAgdG91Y2goaXRlbSwgdG91Y2gpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9oZWFkIHx8ICF0aGlzLl90YWlsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbGlzdCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgodG91Y2ggIT09IFRvdWNoLkZpcnN0ICYmIHRvdWNoICE9PSBUb3VjaC5MYXN0KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b3VjaCA9PT0gVG91Y2guRmlyc3QpIHtcbiAgICAgICAgICAgIGlmIChpdGVtID09PSB0aGlzLl9oZWFkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbmV4dCA9IGl0ZW0ubmV4dDtcbiAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzID0gaXRlbS5wcmV2aW91cztcbiAgICAgICAgICAgIC8vIFVubGluayB0aGUgaXRlbVxuICAgICAgICAgICAgaWYgKGl0ZW0gPT09IHRoaXMuX3RhaWwpIHtcbiAgICAgICAgICAgICAgICAvLyBwcmV2aW91cyBtdXN0IGJlIGRlZmluZWQgc2luY2UgaXRlbSB3YXMgbm90IGhlYWQgYnV0IGlzIHRhaWxcbiAgICAgICAgICAgICAgICAvLyBTbyB0aGVyZSBhcmUgbW9yZSB0aGFuIG9uIGl0ZW0gaW4gdGhlIG1hcFxuICAgICAgICAgICAgICAgIHByZXZpb3VzLm5leHQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGFpbCA9IHByZXZpb3VzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gQm90aCBuZXh0IGFuZCBwcmV2aW91cyBhcmUgbm90IHVuZGVmaW5lZCBzaW5jZSBpdGVtIHdhcyBuZWl0aGVyIGhlYWQgbm9yIHRhaWwuXG4gICAgICAgICAgICAgICAgbmV4dC5wcmV2aW91cyA9IHByZXZpb3VzO1xuICAgICAgICAgICAgICAgIHByZXZpb3VzLm5leHQgPSBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSW5zZXJ0IHRoZSBub2RlIGF0IGhlYWRcbiAgICAgICAgICAgIGl0ZW0ucHJldmlvdXMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpdGVtLm5leHQgPSB0aGlzLl9oZWFkO1xuICAgICAgICAgICAgdGhpcy5faGVhZC5wcmV2aW91cyA9IGl0ZW07XG4gICAgICAgICAgICB0aGlzLl9oZWFkID0gaXRlbTtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlKys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodG91Y2ggPT09IFRvdWNoLkxhc3QpIHtcbiAgICAgICAgICAgIGlmIChpdGVtID09PSB0aGlzLl90YWlsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbmV4dCA9IGl0ZW0ubmV4dDtcbiAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzID0gaXRlbS5wcmV2aW91cztcbiAgICAgICAgICAgIC8vIFVubGluayB0aGUgaXRlbS5cbiAgICAgICAgICAgIGlmIChpdGVtID09PSB0aGlzLl9oZWFkKSB7XG4gICAgICAgICAgICAgICAgLy8gbmV4dCBtdXN0IGJlIGRlZmluZWQgc2luY2UgaXRlbSB3YXMgbm90IHRhaWwgYnV0IGlzIGhlYWRcbiAgICAgICAgICAgICAgICAvLyBTbyB0aGVyZSBhcmUgbW9yZSB0aGFuIG9uIGl0ZW0gaW4gdGhlIG1hcFxuICAgICAgICAgICAgICAgIG5leHQucHJldmlvdXMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgdGhpcy5faGVhZCA9IG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBCb3RoIG5leHQgYW5kIHByZXZpb3VzIGFyZSBub3QgdW5kZWZpbmVkIHNpbmNlIGl0ZW0gd2FzIG5laXRoZXIgaGVhZCBub3IgdGFpbC5cbiAgICAgICAgICAgICAgICBuZXh0LnByZXZpb3VzID0gcHJldmlvdXM7XG4gICAgICAgICAgICAgICAgcHJldmlvdXMubmV4dCA9IG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpdGVtLm5leHQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpdGVtLnByZXZpb3VzID0gdGhpcy5fdGFpbDtcbiAgICAgICAgICAgIHRoaXMuX3RhaWwubmV4dCA9IGl0ZW07XG4gICAgICAgICAgICB0aGlzLl90YWlsID0gaXRlbTtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICBjb25zdCBkYXRhID0gW107XG4gICAgICAgIHRoaXMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICAgICAgZGF0YS5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgZnJvbUpTT04oZGF0YSkge1xuICAgICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIGRhdGEpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5MaW5rZWRNYXAgPSBMaW5rZWRNYXA7XG5jbGFzcyBMUlVDYWNoZSBleHRlbmRzIExpbmtlZE1hcCB7XG4gICAgY29uc3RydWN0b3IobGltaXQsIHJhdGlvID0gMSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl9saW1pdCA9IGxpbWl0O1xuICAgICAgICB0aGlzLl9yYXRpbyA9IE1hdGgubWluKE1hdGgubWF4KDAsIHJhdGlvKSwgMSk7XG4gICAgfVxuICAgIGdldCBsaW1pdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xpbWl0O1xuICAgIH1cbiAgICBzZXQgbGltaXQobGltaXQpIHtcbiAgICAgICAgdGhpcy5fbGltaXQgPSBsaW1pdDtcbiAgICAgICAgdGhpcy5jaGVja1RyaW0oKTtcbiAgICB9XG4gICAgZ2V0IHJhdGlvKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmF0aW87XG4gICAgfVxuICAgIHNldCByYXRpbyhyYXRpbykge1xuICAgICAgICB0aGlzLl9yYXRpbyA9IE1hdGgubWluKE1hdGgubWF4KDAsIHJhdGlvKSwgMSk7XG4gICAgICAgIHRoaXMuY2hlY2tUcmltKCk7XG4gICAgfVxuICAgIGdldChrZXksIHRvdWNoID0gVG91Y2guQXNOZXcpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmdldChrZXksIHRvdWNoKTtcbiAgICB9XG4gICAgcGVlayhrZXkpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmdldChrZXksIFRvdWNoLk5vbmUpO1xuICAgIH1cbiAgICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgICBzdXBlci5zZXQoa2V5LCB2YWx1ZSwgVG91Y2guTGFzdCk7XG4gICAgICAgIHRoaXMuY2hlY2tUcmltKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBjaGVja1RyaW0oKSB7XG4gICAgICAgIGlmICh0aGlzLnNpemUgPiB0aGlzLl9saW1pdCkge1xuICAgICAgICAgICAgdGhpcy50cmltT2xkKE1hdGgucm91bmQodGhpcy5fbGltaXQgKiB0aGlzLl9yYXRpbykpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5MUlVDYWNoZSA9IExSVUNhY2hlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGlua2VkTWFwLmpzLm1hcFxuXG4vKioqLyB9KSxcblxuLyoqKi8gMjE4MDpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMpID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLkFic3RyYWN0TWVzc2FnZUJ1ZmZlciA9IHZvaWQgMDtcbmNvbnN0IENSID0gMTM7XG5jb25zdCBMRiA9IDEwO1xuY29uc3QgQ1JMRiA9ICdcXHJcXG4nO1xuY2xhc3MgQWJzdHJhY3RNZXNzYWdlQnVmZmVyIHtcbiAgICBjb25zdHJ1Y3RvcihlbmNvZGluZyA9ICd1dGYtOCcpIHtcbiAgICAgICAgdGhpcy5fZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgICAgICAgdGhpcy5fY2h1bmtzID0gW107XG4gICAgICAgIHRoaXMuX3RvdGFsTGVuZ3RoID0gMDtcbiAgICB9XG4gICAgZ2V0IGVuY29kaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZW5jb2Rpbmc7XG4gICAgfVxuICAgIGFwcGVuZChjaHVuaykge1xuICAgICAgICBjb25zdCB0b0FwcGVuZCA9IHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycgPyB0aGlzLmZyb21TdHJpbmcoY2h1bmssIHRoaXMuX2VuY29kaW5nKSA6IGNodW5rO1xuICAgICAgICB0aGlzLl9jaHVua3MucHVzaCh0b0FwcGVuZCk7XG4gICAgICAgIHRoaXMuX3RvdGFsTGVuZ3RoICs9IHRvQXBwZW5kLmJ5dGVMZW5ndGg7XG4gICAgfVxuICAgIHRyeVJlYWRIZWFkZXJzKCkge1xuICAgICAgICBpZiAodGhpcy5fY2h1bmtzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3RhdGUgPSAwO1xuICAgICAgICBsZXQgY2h1bmtJbmRleCA9IDA7XG4gICAgICAgIGxldCBvZmZzZXQgPSAwO1xuICAgICAgICBsZXQgY2h1bmtCeXRlc1JlYWQgPSAwO1xuICAgICAgICByb3c6IHdoaWxlIChjaHVua0luZGV4IDwgdGhpcy5fY2h1bmtzLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgY2h1bmsgPSB0aGlzLl9jaHVua3NbY2h1bmtJbmRleF07XG4gICAgICAgICAgICBvZmZzZXQgPSAwO1xuICAgICAgICAgICAgY29sdW1uOiB3aGlsZSAob2Zmc2V0IDwgY2h1bmsubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBjaHVua1tvZmZzZXRdO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBDUjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoc3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IDM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIExGOlxuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChzdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0gNDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIHJvdztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaHVua0J5dGVzUmVhZCArPSBjaHVuay5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgY2h1bmtJbmRleCsrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZSAhPT0gNCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGUgYnVmZmVyIGNvbnRhaW5zIHRoZSB0d28gQ1JMRiBhdCB0aGUgZW5kLiBTbyB3ZSB3aWxsXG4gICAgICAgIC8vIGhhdmUgdHdvIGVtcHR5IGxpbmVzIGFmdGVyIHRoZSBzcGxpdCBhdCB0aGUgZW5kIGFzIHdlbGwuXG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IHRoaXMuX3JlYWQoY2h1bmtCeXRlc1JlYWQgKyBvZmZzZXQpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgTWFwKCk7XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSB0aGlzLnRvU3RyaW5nKGJ1ZmZlciwgJ2FzY2lpJykuc3BsaXQoQ1JMRik7XG4gICAgICAgIGlmIChoZWFkZXJzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBoZWFkZXJzLmxlbmd0aCAtIDI7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyID0gaGVhZGVyc1tpXTtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gaGVhZGVyLmluZGV4T2YoJzonKTtcbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01lc3NhZ2UgaGVhZGVyIG11c3Qgc2VwYXJhdGUga2V5IGFuZCB2YWx1ZSB1c2luZyA6Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBoZWFkZXIuc3Vic3RyKDAsIGluZGV4KTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gaGVhZGVyLnN1YnN0cihpbmRleCArIDEpLnRyaW0oKTtcbiAgICAgICAgICAgIHJlc3VsdC5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgdHJ5UmVhZEJvZHkobGVuZ3RoKSB7XG4gICAgICAgIGlmICh0aGlzLl90b3RhbExlbmd0aCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcmVhZChsZW5ndGgpO1xuICAgIH1cbiAgICBnZXQgbnVtYmVyT2ZCeXRlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RvdGFsTGVuZ3RoO1xuICAgIH1cbiAgICBfcmVhZChieXRlQ291bnQpIHtcbiAgICAgICAgaWYgKGJ5dGVDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW1wdHlCdWZmZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnl0ZUNvdW50ID4gdGhpcy5fdG90YWxMZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IHJlYWQgc28gbWFueSBieXRlcyFgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fY2h1bmtzWzBdLmJ5dGVMZW5ndGggPT09IGJ5dGVDb3VudCkge1xuICAgICAgICAgICAgLy8gc3VwZXIgZmFzdCBwYXRoLCBwcmVjaXNlbHkgZmlyc3QgY2h1bmsgbXVzdCBiZSByZXR1cm5lZFxuICAgICAgICAgICAgY29uc3QgY2h1bmsgPSB0aGlzLl9jaHVua3NbMF07XG4gICAgICAgICAgICB0aGlzLl9jaHVua3Muc2hpZnQoKTtcbiAgICAgICAgICAgIHRoaXMuX3RvdGFsTGVuZ3RoIC09IGJ5dGVDb3VudDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFzTmF0aXZlKGNodW5rKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fY2h1bmtzWzBdLmJ5dGVMZW5ndGggPiBieXRlQ291bnQpIHtcbiAgICAgICAgICAgIC8vIGZhc3QgcGF0aCwgdGhlIHJlYWRpbmcgaXMgZW50aXJlbHkgd2l0aGluIHRoZSBmaXJzdCBjaHVua1xuICAgICAgICAgICAgY29uc3QgY2h1bmsgPSB0aGlzLl9jaHVua3NbMF07XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLmFzTmF0aXZlKGNodW5rLCBieXRlQ291bnQpO1xuICAgICAgICAgICAgdGhpcy5fY2h1bmtzWzBdID0gY2h1bmsuc2xpY2UoYnl0ZUNvdW50KTtcbiAgICAgICAgICAgIHRoaXMuX3RvdGFsTGVuZ3RoIC09IGJ5dGVDb3VudDtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5hbGxvY05hdGl2ZShieXRlQ291bnQpO1xuICAgICAgICBsZXQgcmVzdWx0T2Zmc2V0ID0gMDtcbiAgICAgICAgbGV0IGNodW5rSW5kZXggPSAwO1xuICAgICAgICB3aGlsZSAoYnl0ZUNvdW50ID4gMCkge1xuICAgICAgICAgICAgY29uc3QgY2h1bmsgPSB0aGlzLl9jaHVua3NbY2h1bmtJbmRleF07XG4gICAgICAgICAgICBpZiAoY2h1bmsuYnl0ZUxlbmd0aCA+IGJ5dGVDb3VudCkge1xuICAgICAgICAgICAgICAgIC8vIHRoaXMgY2h1bmsgd2lsbCBzdXJ2aXZlXG4gICAgICAgICAgICAgICAgY29uc3QgY2h1bmtQYXJ0ID0gY2h1bmsuc2xpY2UoMCwgYnl0ZUNvdW50KTtcbiAgICAgICAgICAgICAgICByZXN1bHQuc2V0KGNodW5rUGFydCwgcmVzdWx0T2Zmc2V0KTtcbiAgICAgICAgICAgICAgICByZXN1bHRPZmZzZXQgKz0gYnl0ZUNvdW50O1xuICAgICAgICAgICAgICAgIHRoaXMuX2NodW5rc1tjaHVua0luZGV4XSA9IGNodW5rLnNsaWNlKGJ5dGVDb3VudCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fdG90YWxMZW5ndGggLT0gYnl0ZUNvdW50O1xuICAgICAgICAgICAgICAgIGJ5dGVDb3VudCAtPSBieXRlQ291bnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGNodW5rIHdpbGwgYmUgZW50aXJlbHkgcmVhZFxuICAgICAgICAgICAgICAgIHJlc3VsdC5zZXQoY2h1bmssIHJlc3VsdE9mZnNldCk7XG4gICAgICAgICAgICAgICAgcmVzdWx0T2Zmc2V0ICs9IGNodW5rLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2h1bmtzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fdG90YWxMZW5ndGggLT0gY2h1bmsuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgICAgICBieXRlQ291bnQgLT0gY2h1bmsuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbmV4cG9ydHMuQWJzdHJhY3RNZXNzYWdlQnVmZmVyID0gQWJzdHJhY3RNZXNzYWdlQnVmZmVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWVzc2FnZUJ1ZmZlci5qcy5tYXBcblxuLyoqKi8gfSksXG5cbi8qKiovIDk4MTM6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuUmVhZGFibGVTdHJlYW1NZXNzYWdlUmVhZGVyID0gZXhwb3J0cy5BYnN0cmFjdE1lc3NhZ2VSZWFkZXIgPSBleHBvcnRzLk1lc3NhZ2VSZWFkZXIgPSB2b2lkIDA7XG5jb25zdCByYWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNDI1NCk7XG5jb25zdCBJcyA9IF9fd2VicGFja19yZXF1aXJlX18oNjE0NSk7XG5jb25zdCBldmVudHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNjc4MCk7XG52YXIgTWVzc2FnZVJlYWRlcjtcbihmdW5jdGlvbiAoTWVzc2FnZVJlYWRlcikge1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGxldCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJiBJcy5mdW5jKGNhbmRpZGF0ZS5saXN0ZW4pICYmIElzLmZ1bmMoY2FuZGlkYXRlLmRpc3Bvc2UpICYmXG4gICAgICAgICAgICBJcy5mdW5jKGNhbmRpZGF0ZS5vbkVycm9yKSAmJiBJcy5mdW5jKGNhbmRpZGF0ZS5vbkNsb3NlKSAmJiBJcy5mdW5jKGNhbmRpZGF0ZS5vblBhcnRpYWxNZXNzYWdlKTtcbiAgICB9XG4gICAgTWVzc2FnZVJlYWRlci5pcyA9IGlzO1xufSkoTWVzc2FnZVJlYWRlciA9IGV4cG9ydHMuTWVzc2FnZVJlYWRlciB8fCAoZXhwb3J0cy5NZXNzYWdlUmVhZGVyID0ge30pKTtcbmNsYXNzIEFic3RyYWN0TWVzc2FnZVJlYWRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuZXJyb3JFbWl0dGVyID0gbmV3IGV2ZW50c18xLkVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5jbG9zZUVtaXR0ZXIgPSBuZXcgZXZlbnRzXzEuRW1pdHRlcigpO1xuICAgICAgICB0aGlzLnBhcnRpYWxNZXNzYWdlRW1pdHRlciA9IG5ldyBldmVudHNfMS5FbWl0dGVyKCk7XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIHRoaXMuZXJyb3JFbWl0dGVyLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5jbG9zZUVtaXR0ZXIuZGlzcG9zZSgpO1xuICAgIH1cbiAgICBnZXQgb25FcnJvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3JFbWl0dGVyLmV2ZW50O1xuICAgIH1cbiAgICBmaXJlRXJyb3IoZXJyb3IpIHtcbiAgICAgICAgdGhpcy5lcnJvckVtaXR0ZXIuZmlyZSh0aGlzLmFzRXJyb3IoZXJyb3IpKTtcbiAgICB9XG4gICAgZ2V0IG9uQ2xvc2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsb3NlRW1pdHRlci5ldmVudDtcbiAgICB9XG4gICAgZmlyZUNsb3NlKCkge1xuICAgICAgICB0aGlzLmNsb3NlRW1pdHRlci5maXJlKHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIGdldCBvblBhcnRpYWxNZXNzYWdlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJ0aWFsTWVzc2FnZUVtaXR0ZXIuZXZlbnQ7XG4gICAgfVxuICAgIGZpcmVQYXJ0aWFsTWVzc2FnZShpbmZvKSB7XG4gICAgICAgIHRoaXMucGFydGlhbE1lc3NhZ2VFbWl0dGVyLmZpcmUoaW5mbyk7XG4gICAgfVxuICAgIGFzRXJyb3IoZXJyb3IpIHtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoYFJlYWRlciByZWNlaXZlZCBlcnJvci4gUmVhc29uOiAke0lzLnN0cmluZyhlcnJvci5tZXNzYWdlKSA/IGVycm9yLm1lc3NhZ2UgOiAndW5rbm93bid9YCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkFic3RyYWN0TWVzc2FnZVJlYWRlciA9IEFic3RyYWN0TWVzc2FnZVJlYWRlcjtcbnZhciBSZXNvbHZlZE1lc3NhZ2VSZWFkZXJPcHRpb25zO1xuKGZ1bmN0aW9uIChSZXNvbHZlZE1lc3NhZ2VSZWFkZXJPcHRpb25zKSB7XG4gICAgZnVuY3Rpb24gZnJvbU9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICBsZXQgY2hhcnNldDtcbiAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgbGV0IGNvbnRlbnREZWNvZGVyO1xuICAgICAgICBjb25zdCBjb250ZW50RGVjb2RlcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIGxldCBjb250ZW50VHlwZURlY29kZXI7XG4gICAgICAgIGNvbnN0IGNvbnRlbnRUeXBlRGVjb2RlcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjaGFyc2V0ID0gb3B0aW9ucyA/PyAndXRmLTgnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2hhcnNldCA9IG9wdGlvbnMuY2hhcnNldCA/PyAndXRmLTgnO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuY29udGVudERlY29kZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNvbnRlbnREZWNvZGVyID0gb3B0aW9ucy5jb250ZW50RGVjb2RlcjtcbiAgICAgICAgICAgICAgICBjb250ZW50RGVjb2RlcnMuc2V0KGNvbnRlbnREZWNvZGVyLm5hbWUsIGNvbnRlbnREZWNvZGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmNvbnRlbnREZWNvZGVycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBkZWNvZGVyIG9mIG9wdGlvbnMuY29udGVudERlY29kZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnREZWNvZGVycy5zZXQoZGVjb2Rlci5uYW1lLCBkZWNvZGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5jb250ZW50VHlwZURlY29kZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlRGVjb2RlciA9IG9wdGlvbnMuY29udGVudFR5cGVEZWNvZGVyO1xuICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlRGVjb2RlcnMuc2V0KGNvbnRlbnRUeXBlRGVjb2Rlci5uYW1lLCBjb250ZW50VHlwZURlY29kZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuY29udGVudFR5cGVEZWNvZGVycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBkZWNvZGVyIG9mIG9wdGlvbnMuY29udGVudFR5cGVEZWNvZGVycykge1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50VHlwZURlY29kZXJzLnNldChkZWNvZGVyLm5hbWUsIGRlY29kZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udGVudFR5cGVEZWNvZGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnRlbnRUeXBlRGVjb2RlciA9ICgwLCByYWxfMS5kZWZhdWx0KSgpLmFwcGxpY2F0aW9uSnNvbi5kZWNvZGVyO1xuICAgICAgICAgICAgY29udGVudFR5cGVEZWNvZGVycy5zZXQoY29udGVudFR5cGVEZWNvZGVyLm5hbWUsIGNvbnRlbnRUeXBlRGVjb2Rlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgY2hhcnNldCwgY29udGVudERlY29kZXIsIGNvbnRlbnREZWNvZGVycywgY29udGVudFR5cGVEZWNvZGVyLCBjb250ZW50VHlwZURlY29kZXJzIH07XG4gICAgfVxuICAgIFJlc29sdmVkTWVzc2FnZVJlYWRlck9wdGlvbnMuZnJvbU9wdGlvbnMgPSBmcm9tT3B0aW9ucztcbn0pKFJlc29sdmVkTWVzc2FnZVJlYWRlck9wdGlvbnMgfHwgKFJlc29sdmVkTWVzc2FnZVJlYWRlck9wdGlvbnMgPSB7fSkpO1xuY2xhc3MgUmVhZGFibGVTdHJlYW1NZXNzYWdlUmVhZGVyIGV4dGVuZHMgQWJzdHJhY3RNZXNzYWdlUmVhZGVyIHtcbiAgICBjb25zdHJ1Y3RvcihyZWFkYWJsZSwgb3B0aW9ucykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnJlYWRhYmxlID0gcmVhZGFibGU7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IFJlc29sdmVkTWVzc2FnZVJlYWRlck9wdGlvbnMuZnJvbU9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gKDAsIHJhbF8xLmRlZmF1bHQpKCkubWVzc2FnZUJ1ZmZlci5jcmVhdGUodGhpcy5vcHRpb25zLmNoYXJzZXQpO1xuICAgICAgICB0aGlzLl9wYXJ0aWFsTWVzc2FnZVRpbWVvdXQgPSAxMDAwMDtcbiAgICAgICAgdGhpcy5uZXh0TWVzc2FnZUxlbmd0aCA9IC0xO1xuICAgICAgICB0aGlzLm1lc3NhZ2VUb2tlbiA9IDA7XG4gICAgfVxuICAgIHNldCBwYXJ0aWFsTWVzc2FnZVRpbWVvdXQodGltZW91dCkge1xuICAgICAgICB0aGlzLl9wYXJ0aWFsTWVzc2FnZVRpbWVvdXQgPSB0aW1lb3V0O1xuICAgIH1cbiAgICBnZXQgcGFydGlhbE1lc3NhZ2VUaW1lb3V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFydGlhbE1lc3NhZ2VUaW1lb3V0O1xuICAgIH1cbiAgICBsaXN0ZW4oY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5uZXh0TWVzc2FnZUxlbmd0aCA9IC0xO1xuICAgICAgICB0aGlzLm1lc3NhZ2VUb2tlbiA9IDA7XG4gICAgICAgIHRoaXMucGFydGlhbE1lc3NhZ2VUaW1lciA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLnJlYWRhYmxlLm9uRGF0YSgoZGF0YSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5vbkRhdGEoZGF0YSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlYWRhYmxlLm9uRXJyb3IoKGVycm9yKSA9PiB0aGlzLmZpcmVFcnJvcihlcnJvcikpO1xuICAgICAgICB0aGlzLnJlYWRhYmxlLm9uQ2xvc2UoKCkgPT4gdGhpcy5maXJlQ2xvc2UoKSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIG9uRGF0YShkYXRhKSB7XG4gICAgICAgIHRoaXMuYnVmZmVyLmFwcGVuZChkYXRhKTtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm5leHRNZXNzYWdlTGVuZ3RoID09PSAtMSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGhlYWRlcnMgPSB0aGlzLmJ1ZmZlci50cnlSZWFkSGVhZGVycygpO1xuICAgICAgICAgICAgICAgIGlmICghaGVhZGVycykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRMZW5ndGggPSBoZWFkZXJzLmdldCgnQ29udGVudC1MZW5ndGgnKTtcbiAgICAgICAgICAgICAgICBpZiAoIWNvbnRlbnRMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIZWFkZXIgbXVzdCBwcm92aWRlIGEgQ29udGVudC1MZW5ndGggcHJvcGVydHkuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IHBhcnNlSW50KGNvbnRlbnRMZW5ndGgpO1xuICAgICAgICAgICAgICAgIGlmIChpc05hTihsZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ29udGVudC1MZW5ndGggdmFsdWUgbXVzdCBiZSBhIG51bWJlci4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0TWVzc2FnZUxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSB0aGlzLmJ1ZmZlci50cnlSZWFkQm9keSh0aGlzLm5leHRNZXNzYWdlTGVuZ3RoKTtcbiAgICAgICAgICAgIGlmIChib2R5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAvKiogV2UgaGF2ZW4ndCByZWNlaXZlZCB0aGUgZnVsbCBtZXNzYWdlIHlldC4gKi9cbiAgICAgICAgICAgICAgICB0aGlzLnNldFBhcnRpYWxNZXNzYWdlVGltZXIoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNsZWFyUGFydGlhbE1lc3NhZ2VUaW1lcigpO1xuICAgICAgICAgICAgdGhpcy5uZXh0TWVzc2FnZUxlbmd0aCA9IC0xO1xuICAgICAgICAgICAgbGV0IHA7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmNvbnRlbnREZWNvZGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBwID0gdGhpcy5vcHRpb25zLmNvbnRlbnREZWNvZGVyLmRlY29kZShib2R5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHAgPSBQcm9taXNlLnJlc29sdmUoYm9keSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwLnRoZW4oKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLmNvbnRlbnRUeXBlRGVjb2Rlci5kZWNvZGUodmFsdWUsIHRoaXMub3B0aW9ucykudGhlbigobXNnKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FsbGJhY2sobXNnKTtcbiAgICAgICAgICAgICAgICB9LCAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maXJlRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5maXJlRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2xlYXJQYXJ0aWFsTWVzc2FnZVRpbWVyKCkge1xuICAgICAgICBpZiAodGhpcy5wYXJ0aWFsTWVzc2FnZVRpbWVyKSB7XG4gICAgICAgICAgICB0aGlzLnBhcnRpYWxNZXNzYWdlVGltZXIuZGlzcG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5wYXJ0aWFsTWVzc2FnZVRpbWVyID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldFBhcnRpYWxNZXNzYWdlVGltZXIoKSB7XG4gICAgICAgIHRoaXMuY2xlYXJQYXJ0aWFsTWVzc2FnZVRpbWVyKCk7XG4gICAgICAgIGlmICh0aGlzLl9wYXJ0aWFsTWVzc2FnZVRpbWVvdXQgPD0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGFydGlhbE1lc3NhZ2VUaW1lciA9ICgwLCByYWxfMS5kZWZhdWx0KSgpLnRpbWVyLnNldFRpbWVvdXQoKHRva2VuLCB0aW1lb3V0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnBhcnRpYWxNZXNzYWdlVGltZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAodG9rZW4gPT09IHRoaXMubWVzc2FnZVRva2VuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maXJlUGFydGlhbE1lc3NhZ2UoeyBtZXNzYWdlVG9rZW46IHRva2VuLCB3YWl0aW5nVGltZTogdGltZW91dCB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFBhcnRpYWxNZXNzYWdlVGltZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcy5fcGFydGlhbE1lc3NhZ2VUaW1lb3V0LCB0aGlzLm1lc3NhZ2VUb2tlbiwgdGhpcy5fcGFydGlhbE1lc3NhZ2VUaW1lb3V0KTtcbiAgICB9XG59XG5leHBvcnRzLlJlYWRhYmxlU3RyZWFtTWVzc2FnZVJlYWRlciA9IFJlYWRhYmxlU3RyZWFtTWVzc2FnZVJlYWRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1lc3NhZ2VSZWFkZXIuanMubWFwXG5cbi8qKiovIH0pLFxuXG4vKioqLyA3NzQ1OlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLldyaXRlYWJsZVN0cmVhbU1lc3NhZ2VXcml0ZXIgPSBleHBvcnRzLkFic3RyYWN0TWVzc2FnZVdyaXRlciA9IGV4cG9ydHMuTWVzc2FnZVdyaXRlciA9IHZvaWQgMDtcbmNvbnN0IHJhbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MjU0KTtcbmNvbnN0IElzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2MTQ1KTtcbmNvbnN0IHNlbWFwaG9yZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5OTMxKTtcbmNvbnN0IGV2ZW50c18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NzgwKTtcbmNvbnN0IENvbnRlbnRMZW5ndGggPSAnQ29udGVudC1MZW5ndGg6ICc7XG5jb25zdCBDUkxGID0gJ1xcclxcbic7XG52YXIgTWVzc2FnZVdyaXRlcjtcbihmdW5jdGlvbiAoTWVzc2FnZVdyaXRlcikge1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGxldCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJiBJcy5mdW5jKGNhbmRpZGF0ZS5kaXNwb3NlKSAmJiBJcy5mdW5jKGNhbmRpZGF0ZS5vbkNsb3NlKSAmJlxuICAgICAgICAgICAgSXMuZnVuYyhjYW5kaWRhdGUub25FcnJvcikgJiYgSXMuZnVuYyhjYW5kaWRhdGUud3JpdGUpO1xuICAgIH1cbiAgICBNZXNzYWdlV3JpdGVyLmlzID0gaXM7XG59KShNZXNzYWdlV3JpdGVyID0gZXhwb3J0cy5NZXNzYWdlV3JpdGVyIHx8IChleHBvcnRzLk1lc3NhZ2VXcml0ZXIgPSB7fSkpO1xuY2xhc3MgQWJzdHJhY3RNZXNzYWdlV3JpdGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5lcnJvckVtaXR0ZXIgPSBuZXcgZXZlbnRzXzEuRW1pdHRlcigpO1xuICAgICAgICB0aGlzLmNsb3NlRW1pdHRlciA9IG5ldyBldmVudHNfMS5FbWl0dGVyKCk7XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIHRoaXMuZXJyb3JFbWl0dGVyLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5jbG9zZUVtaXR0ZXIuZGlzcG9zZSgpO1xuICAgIH1cbiAgICBnZXQgb25FcnJvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3JFbWl0dGVyLmV2ZW50O1xuICAgIH1cbiAgICBmaXJlRXJyb3IoZXJyb3IsIG1lc3NhZ2UsIGNvdW50KSB7XG4gICAgICAgIHRoaXMuZXJyb3JFbWl0dGVyLmZpcmUoW3RoaXMuYXNFcnJvcihlcnJvciksIG1lc3NhZ2UsIGNvdW50XSk7XG4gICAgfVxuICAgIGdldCBvbkNsb3NlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbG9zZUVtaXR0ZXIuZXZlbnQ7XG4gICAgfVxuICAgIGZpcmVDbG9zZSgpIHtcbiAgICAgICAgdGhpcy5jbG9zZUVtaXR0ZXIuZmlyZSh1bmRlZmluZWQpO1xuICAgIH1cbiAgICBhc0Vycm9yKGVycm9yKSB7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKGBXcml0ZXIgcmVjZWl2ZWQgZXJyb3IuIFJlYXNvbjogJHtJcy5zdHJpbmcoZXJyb3IubWVzc2FnZSkgPyBlcnJvci5tZXNzYWdlIDogJ3Vua25vd24nfWApO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5BYnN0cmFjdE1lc3NhZ2VXcml0ZXIgPSBBYnN0cmFjdE1lc3NhZ2VXcml0ZXI7XG52YXIgUmVzb2x2ZWRNZXNzYWdlV3JpdGVyT3B0aW9ucztcbihmdW5jdGlvbiAoUmVzb2x2ZWRNZXNzYWdlV3JpdGVyT3B0aW9ucykge1xuICAgIGZ1bmN0aW9uIGZyb21PcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGNoYXJzZXQ6IG9wdGlvbnMgPz8gJ3V0Zi04JywgY29udGVudFR5cGVFbmNvZGVyOiAoMCwgcmFsXzEuZGVmYXVsdCkoKS5hcHBsaWNhdGlvbkpzb24uZW5jb2RlciB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHsgY2hhcnNldDogb3B0aW9ucy5jaGFyc2V0ID8/ICd1dGYtOCcsIGNvbnRlbnRFbmNvZGVyOiBvcHRpb25zLmNvbnRlbnRFbmNvZGVyLCBjb250ZW50VHlwZUVuY29kZXI6IG9wdGlvbnMuY29udGVudFR5cGVFbmNvZGVyID8/ICgwLCByYWxfMS5kZWZhdWx0KSgpLmFwcGxpY2F0aW9uSnNvbi5lbmNvZGVyIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgUmVzb2x2ZWRNZXNzYWdlV3JpdGVyT3B0aW9ucy5mcm9tT3B0aW9ucyA9IGZyb21PcHRpb25zO1xufSkoUmVzb2x2ZWRNZXNzYWdlV3JpdGVyT3B0aW9ucyB8fCAoUmVzb2x2ZWRNZXNzYWdlV3JpdGVyT3B0aW9ucyA9IHt9KSk7XG5jbGFzcyBXcml0ZWFibGVTdHJlYW1NZXNzYWdlV3JpdGVyIGV4dGVuZHMgQWJzdHJhY3RNZXNzYWdlV3JpdGVyIHtcbiAgICBjb25zdHJ1Y3Rvcih3cml0YWJsZSwgb3B0aW9ucykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLndyaXRhYmxlID0gd3JpdGFibGU7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IFJlc29sdmVkTWVzc2FnZVdyaXRlck9wdGlvbnMuZnJvbU9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIHRoaXMuZXJyb3JDb3VudCA9IDA7XG4gICAgICAgIHRoaXMud3JpdGVTZW1hcGhvcmUgPSBuZXcgc2VtYXBob3JlXzEuU2VtYXBob3JlKDEpO1xuICAgICAgICB0aGlzLndyaXRhYmxlLm9uRXJyb3IoKGVycm9yKSA9PiB0aGlzLmZpcmVFcnJvcihlcnJvcikpO1xuICAgICAgICB0aGlzLndyaXRhYmxlLm9uQ2xvc2UoKCkgPT4gdGhpcy5maXJlQ2xvc2UoKSk7XG4gICAgfVxuICAgIGFzeW5jIHdyaXRlKG1zZykge1xuICAgICAgICByZXR1cm4gdGhpcy53cml0ZVNlbWFwaG9yZS5sb2NrKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSB0aGlzLm9wdGlvbnMuY29udGVudFR5cGVFbmNvZGVyLmVuY29kZShtc2csIHRoaXMub3B0aW9ucykudGhlbigoYnVmZmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5jb250ZW50RW5jb2RlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuY29udGVudEVuY29kZXIuZW5jb2RlKGJ1ZmZlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYnVmZmVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHBheWxvYWQudGhlbigoYnVmZmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaGVhZGVycyA9IFtdO1xuICAgICAgICAgICAgICAgIGhlYWRlcnMucHVzaChDb250ZW50TGVuZ3RoLCBidWZmZXIuYnl0ZUxlbmd0aC50b1N0cmluZygpLCBDUkxGKTtcbiAgICAgICAgICAgICAgICBoZWFkZXJzLnB1c2goQ1JMRik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZG9Xcml0ZShtc2csIGhlYWRlcnMsIGJ1ZmZlcik7XG4gICAgICAgICAgICB9LCAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpcmVFcnJvcihlcnJvcik7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIGRvV3JpdGUobXNnLCBoZWFkZXJzLCBkYXRhKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLndyaXRhYmxlLndyaXRlKGhlYWRlcnMuam9pbignJyksICdhc2NpaScpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud3JpdGFibGUud3JpdGUoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZUVycm9yKGVycm9yLCBtc2cpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYW5kbGVFcnJvcihlcnJvciwgbXNnKSB7XG4gICAgICAgIHRoaXMuZXJyb3JDb3VudCsrO1xuICAgICAgICB0aGlzLmZpcmVFcnJvcihlcnJvciwgbXNnLCB0aGlzLmVycm9yQ291bnQpO1xuICAgIH1cbiAgICBlbmQoKSB7XG4gICAgICAgIHRoaXMud3JpdGFibGUuZW5kKCk7XG4gICAgfVxufVxuZXhwb3J0cy5Xcml0ZWFibGVTdHJlYW1NZXNzYWdlV3JpdGVyID0gV3JpdGVhYmxlU3RyZWFtTWVzc2FnZVdyaXRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1lc3NhZ2VXcml0ZXIuanMubWFwXG5cbi8qKiovIH0pLFxuXG4vKioqLyA0MzEzOlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLk1lc3NhZ2UgPSBleHBvcnRzLk5vdGlmaWNhdGlvblR5cGU5ID0gZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlOCA9IGV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTcgPSBleHBvcnRzLk5vdGlmaWNhdGlvblR5cGU2ID0gZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlNSA9IGV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTQgPSBleHBvcnRzLk5vdGlmaWNhdGlvblR5cGUzID0gZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlMiA9IGV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTEgPSBleHBvcnRzLk5vdGlmaWNhdGlvblR5cGUwID0gZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlID0gZXhwb3J0cy5SZXF1ZXN0VHlwZTkgPSBleHBvcnRzLlJlcXVlc3RUeXBlOCA9IGV4cG9ydHMuUmVxdWVzdFR5cGU3ID0gZXhwb3J0cy5SZXF1ZXN0VHlwZTYgPSBleHBvcnRzLlJlcXVlc3RUeXBlNSA9IGV4cG9ydHMuUmVxdWVzdFR5cGU0ID0gZXhwb3J0cy5SZXF1ZXN0VHlwZTMgPSBleHBvcnRzLlJlcXVlc3RUeXBlMiA9IGV4cG9ydHMuUmVxdWVzdFR5cGUxID0gZXhwb3J0cy5SZXF1ZXN0VHlwZSA9IGV4cG9ydHMuUmVxdWVzdFR5cGUwID0gZXhwb3J0cy5BYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmUgPSBleHBvcnRzLlBhcmFtZXRlclN0cnVjdHVyZXMgPSBleHBvcnRzLlJlc3BvbnNlRXJyb3IgPSBleHBvcnRzLkVycm9yQ29kZXMgPSB2b2lkIDA7XG5jb25zdCBpcyA9IF9fd2VicGFja19yZXF1aXJlX18oNjE0NSk7XG4vKipcbiAqIFByZWRlZmluZWQgZXJyb3IgY29kZXMuXG4gKi9cbnZhciBFcnJvckNvZGVzO1xuKGZ1bmN0aW9uIChFcnJvckNvZGVzKSB7XG4gICAgLy8gRGVmaW5lZCBieSBKU09OIFJQQ1xuICAgIEVycm9yQ29kZXMuUGFyc2VFcnJvciA9IC0zMjcwMDtcbiAgICBFcnJvckNvZGVzLkludmFsaWRSZXF1ZXN0ID0gLTMyNjAwO1xuICAgIEVycm9yQ29kZXMuTWV0aG9kTm90Rm91bmQgPSAtMzI2MDE7XG4gICAgRXJyb3JDb2Rlcy5JbnZhbGlkUGFyYW1zID0gLTMyNjAyO1xuICAgIEVycm9yQ29kZXMuSW50ZXJuYWxFcnJvciA9IC0zMjYwMztcbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIHRoZSBzdGFydCByYW5nZSBvZiBKU09OIFJQQyByZXNlcnZlZCBlcnJvciBjb2Rlcy5cbiAgICAgKiBJdCBkb2Vzbid0IGRlbm90ZSBhIHJlYWwgZXJyb3IgY29kZS4gTm8gYXBwbGljYXRpb24gZXJyb3IgY29kZXMgc2hvdWxkXG4gICAgICogYmUgZGVmaW5lZCBiZXR3ZWVuIHRoZSBzdGFydCBhbmQgZW5kIHJhbmdlLiBGb3IgYmFja3dhcmRzXG4gICAgICogY29tcGF0aWJpbGl0eSB0aGUgYFNlcnZlck5vdEluaXRpYWxpemVkYCBhbmQgdGhlIGBVbmtub3duRXJyb3JDb2RlYFxuICAgICAqIGFyZSBsZWZ0IGluIHRoZSByYW5nZS5cbiAgICAgKlxuICAgICAqIEBzaW5jZSAzLjE2LjBcbiAgICAqL1xuICAgIEVycm9yQ29kZXMuanNvbnJwY1Jlc2VydmVkRXJyb3JSYW5nZVN0YXJ0ID0gLTMyMDk5O1xuICAgIC8qKiBAZGVwcmVjYXRlZCB1c2UgIGpzb25ycGNSZXNlcnZlZEVycm9yUmFuZ2VTdGFydCAqL1xuICAgIEVycm9yQ29kZXMuc2VydmVyRXJyb3JTdGFydCA9IC0zMjA5OTtcbiAgICAvKipcbiAgICAgKiBBbiBlcnJvciBvY2N1cnJlZCB3aGVuIHdyaXRlIGEgbWVzc2FnZSB0byB0aGUgdHJhbnNwb3J0IGxheWVyLlxuICAgICAqL1xuICAgIEVycm9yQ29kZXMuTWVzc2FnZVdyaXRlRXJyb3IgPSAtMzIwOTk7XG4gICAgLyoqXG4gICAgICogQW4gZXJyb3Igb2NjdXJyZWQgd2hlbiByZWFkaW5nIGEgbWVzc2FnZSBmcm9tIHRoZSB0cmFuc3BvcnQgbGF5ZXIuXG4gICAgICovXG4gICAgRXJyb3JDb2Rlcy5NZXNzYWdlUmVhZEVycm9yID0gLTMyMDk4O1xuICAgIC8qKlxuICAgICAqIFRoZSBjb25uZWN0aW9uIGdvdCBkaXNwb3NlZCBvciBsb3N0IGFuZCBhbGwgcGVuZGluZyByZXNwb25zZXMgZ290XG4gICAgICogcmVqZWN0ZWQuXG4gICAgICovXG4gICAgRXJyb3JDb2Rlcy5QZW5kaW5nUmVzcG9uc2VSZWplY3RlZCA9IC0zMjA5NztcbiAgICAvKipcbiAgICAgKiBUaGUgY29ubmVjdGlvbiBpcyBpbmFjdGl2ZSBhbmQgYSB1c2Ugb2YgaXQgZmFpbGVkLlxuICAgICAqL1xuICAgIEVycm9yQ29kZXMuQ29ubmVjdGlvbkluYWN0aXZlID0gLTMyMDk2O1xuICAgIC8qKlxuICAgICAqIEVycm9yIGNvZGUgaW5kaWNhdGluZyB0aGF0IGEgc2VydmVyIHJlY2VpdmVkIGEgbm90aWZpY2F0aW9uIG9yXG4gICAgICogcmVxdWVzdCBiZWZvcmUgdGhlIHNlcnZlciBoYXMgcmVjZWl2ZWQgdGhlIGBpbml0aWFsaXplYCByZXF1ZXN0LlxuICAgICAqL1xuICAgIEVycm9yQ29kZXMuU2VydmVyTm90SW5pdGlhbGl6ZWQgPSAtMzIwMDI7XG4gICAgRXJyb3JDb2Rlcy5Vbmtub3duRXJyb3JDb2RlID0gLTMyMDAxO1xuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgdGhlIGVuZCByYW5nZSBvZiBKU09OIFJQQyByZXNlcnZlZCBlcnJvciBjb2Rlcy5cbiAgICAgKiBJdCBkb2Vzbid0IGRlbm90ZSBhIHJlYWwgZXJyb3IgY29kZS5cbiAgICAgKlxuICAgICAqIEBzaW5jZSAzLjE2LjBcbiAgICAqL1xuICAgIEVycm9yQ29kZXMuanNvbnJwY1Jlc2VydmVkRXJyb3JSYW5nZUVuZCA9IC0zMjAwMDtcbiAgICAvKiogQGRlcHJlY2F0ZWQgdXNlICBqc29ucnBjUmVzZXJ2ZWRFcnJvclJhbmdlRW5kICovXG4gICAgRXJyb3JDb2Rlcy5zZXJ2ZXJFcnJvckVuZCA9IC0zMjAwMDtcbn0pKEVycm9yQ29kZXMgPSBleHBvcnRzLkVycm9yQ29kZXMgfHwgKGV4cG9ydHMuRXJyb3JDb2RlcyA9IHt9KSk7XG4vKipcbiAqIEFuIGVycm9yIG9iamVjdCByZXR1cm4gaW4gYSByZXNwb25zZSBpbiBjYXNlIGEgcmVxdWVzdFxuICogaGFzIGZhaWxlZC5cbiAqL1xuY2xhc3MgUmVzcG9uc2VFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcihjb2RlLCBtZXNzYWdlLCBkYXRhKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLmNvZGUgPSBpcy5udW1iZXIoY29kZSkgPyBjb2RlIDogRXJyb3JDb2Rlcy5Vbmtub3duRXJyb3JDb2RlO1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgUmVzcG9uc2VFcnJvci5wcm90b3R5cGUpO1xuICAgIH1cbiAgICB0b0pzb24oKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgICAgIGNvZGU6IHRoaXMuY29kZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZVxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5kYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlc3VsdC5kYXRhID0gdGhpcy5kYXRhO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuZXhwb3J0cy5SZXNwb25zZUVycm9yID0gUmVzcG9uc2VFcnJvcjtcbmNsYXNzIFBhcmFtZXRlclN0cnVjdHVyZXMge1xuICAgIGNvbnN0cnVjdG9yKGtpbmQpIHtcbiAgICAgICAgdGhpcy5raW5kID0ga2luZDtcbiAgICB9XG4gICAgc3RhdGljIGlzKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gUGFyYW1ldGVyU3RydWN0dXJlcy5hdXRvIHx8IHZhbHVlID09PSBQYXJhbWV0ZXJTdHJ1Y3R1cmVzLmJ5TmFtZSB8fCB2YWx1ZSA9PT0gUGFyYW1ldGVyU3RydWN0dXJlcy5ieVBvc2l0aW9uO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMua2luZDtcbiAgICB9XG59XG5leHBvcnRzLlBhcmFtZXRlclN0cnVjdHVyZXMgPSBQYXJhbWV0ZXJTdHJ1Y3R1cmVzO1xuLyoqXG4gKiBUaGUgcGFyYW1ldGVyIHN0cnVjdHVyZSBpcyBhdXRvbWF0aWNhbGx5IGluZmVycmVkIG9uIHRoZSBudW1iZXIgb2YgcGFyYW1ldGVyc1xuICogYW5kIHRoZSBwYXJhbWV0ZXIgdHlwZSBpbiBjYXNlIG9mIGEgc2luZ2xlIHBhcmFtLlxuICovXG5QYXJhbWV0ZXJTdHJ1Y3R1cmVzLmF1dG8gPSBuZXcgUGFyYW1ldGVyU3RydWN0dXJlcygnYXV0bycpO1xuLyoqXG4gKiBGb3JjZXMgYGJ5UG9zaXRpb25gIHBhcmFtZXRlciBzdHJ1Y3R1cmUuIFRoaXMgaXMgdXNlZnVsIGlmIHlvdSBoYXZlIGEgc2luZ2xlXG4gKiBwYXJhbWV0ZXIgd2hpY2ggaGFzIGEgbGl0ZXJhbCB0eXBlLlxuICovXG5QYXJhbWV0ZXJTdHJ1Y3R1cmVzLmJ5UG9zaXRpb24gPSBuZXcgUGFyYW1ldGVyU3RydWN0dXJlcygnYnlQb3NpdGlvbicpO1xuLyoqXG4gKiBGb3JjZXMgYGJ5TmFtZWAgcGFyYW1ldGVyIHN0cnVjdHVyZS4gVGhpcyBpcyBvbmx5IHVzZWZ1bCB3aGVuIGhhdmluZyBhIHNpbmdsZVxuICogcGFyYW1ldGVyLiBUaGUgbGlicmFyeSB3aWxsIHJlcG9ydCBlcnJvcnMgaWYgdXNlZCB3aXRoIGEgZGlmZmVyZW50IG51bWJlciBvZlxuICogcGFyYW1ldGVycy5cbiAqL1xuUGFyYW1ldGVyU3RydWN0dXJlcy5ieU5hbWUgPSBuZXcgUGFyYW1ldGVyU3RydWN0dXJlcygnYnlOYW1lJyk7XG4vKipcbiAqIEFuIGFic3RyYWN0IGltcGxlbWVudGF0aW9uIG9mIGEgTWVzc2FnZVR5cGUuXG4gKi9cbmNsYXNzIEFic3RyYWN0TWVzc2FnZVNpZ25hdHVyZSB7XG4gICAgY29uc3RydWN0b3IobWV0aG9kLCBudW1iZXJPZlBhcmFtcykge1xuICAgICAgICB0aGlzLm1ldGhvZCA9IG1ldGhvZDtcbiAgICAgICAgdGhpcy5udW1iZXJPZlBhcmFtcyA9IG51bWJlck9mUGFyYW1zO1xuICAgIH1cbiAgICBnZXQgcGFyYW1ldGVyU3RydWN0dXJlcygpIHtcbiAgICAgICAgcmV0dXJuIFBhcmFtZXRlclN0cnVjdHVyZXMuYXV0bztcbiAgICB9XG59XG5leHBvcnRzLkFic3RyYWN0TWVzc2FnZVNpZ25hdHVyZSA9IEFic3RyYWN0TWVzc2FnZVNpZ25hdHVyZTtcbi8qKlxuICogQ2xhc3NlcyB0byB0eXBlIHJlcXVlc3QgcmVzcG9uc2UgcGFpcnNcbiAqL1xuY2xhc3MgUmVxdWVzdFR5cGUwIGV4dGVuZHMgQWJzdHJhY3RNZXNzYWdlU2lnbmF0dXJlIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRob2QpIHtcbiAgICAgICAgc3VwZXIobWV0aG9kLCAwKTtcbiAgICB9XG59XG5leHBvcnRzLlJlcXVlc3RUeXBlMCA9IFJlcXVlc3RUeXBlMDtcbmNsYXNzIFJlcXVlc3RUeXBlIGV4dGVuZHMgQWJzdHJhY3RNZXNzYWdlU2lnbmF0dXJlIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRob2QsIF9wYXJhbWV0ZXJTdHJ1Y3R1cmVzID0gUGFyYW1ldGVyU3RydWN0dXJlcy5hdXRvKSB7XG4gICAgICAgIHN1cGVyKG1ldGhvZCwgMSk7XG4gICAgICAgIHRoaXMuX3BhcmFtZXRlclN0cnVjdHVyZXMgPSBfcGFyYW1ldGVyU3RydWN0dXJlcztcbiAgICB9XG4gICAgZ2V0IHBhcmFtZXRlclN0cnVjdHVyZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJhbWV0ZXJTdHJ1Y3R1cmVzO1xuICAgIH1cbn1cbmV4cG9ydHMuUmVxdWVzdFR5cGUgPSBSZXF1ZXN0VHlwZTtcbmNsYXNzIFJlcXVlc3RUeXBlMSBleHRlbmRzIEFic3RyYWN0TWVzc2FnZVNpZ25hdHVyZSB7XG4gICAgY29uc3RydWN0b3IobWV0aG9kLCBfcGFyYW1ldGVyU3RydWN0dXJlcyA9IFBhcmFtZXRlclN0cnVjdHVyZXMuYXV0bykge1xuICAgICAgICBzdXBlcihtZXRob2QsIDEpO1xuICAgICAgICB0aGlzLl9wYXJhbWV0ZXJTdHJ1Y3R1cmVzID0gX3BhcmFtZXRlclN0cnVjdHVyZXM7XG4gICAgfVxuICAgIGdldCBwYXJhbWV0ZXJTdHJ1Y3R1cmVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFyYW1ldGVyU3RydWN0dXJlcztcbiAgICB9XG59XG5leHBvcnRzLlJlcXVlc3RUeXBlMSA9IFJlcXVlc3RUeXBlMTtcbmNsYXNzIFJlcXVlc3RUeXBlMiBleHRlbmRzIEFic3RyYWN0TWVzc2FnZVNpZ25hdHVyZSB7XG4gICAgY29uc3RydWN0b3IobWV0aG9kKSB7XG4gICAgICAgIHN1cGVyKG1ldGhvZCwgMik7XG4gICAgfVxufVxuZXhwb3J0cy5SZXF1ZXN0VHlwZTIgPSBSZXF1ZXN0VHlwZTI7XG5jbGFzcyBSZXF1ZXN0VHlwZTMgZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCkge1xuICAgICAgICBzdXBlcihtZXRob2QsIDMpO1xuICAgIH1cbn1cbmV4cG9ydHMuUmVxdWVzdFR5cGUzID0gUmVxdWVzdFR5cGUzO1xuY2xhc3MgUmVxdWVzdFR5cGU0IGV4dGVuZHMgQWJzdHJhY3RNZXNzYWdlU2lnbmF0dXJlIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRob2QpIHtcbiAgICAgICAgc3VwZXIobWV0aG9kLCA0KTtcbiAgICB9XG59XG5leHBvcnRzLlJlcXVlc3RUeXBlNCA9IFJlcXVlc3RUeXBlNDtcbmNsYXNzIFJlcXVlc3RUeXBlNSBleHRlbmRzIEFic3RyYWN0TWVzc2FnZVNpZ25hdHVyZSB7XG4gICAgY29uc3RydWN0b3IobWV0aG9kKSB7XG4gICAgICAgIHN1cGVyKG1ldGhvZCwgNSk7XG4gICAgfVxufVxuZXhwb3J0cy5SZXF1ZXN0VHlwZTUgPSBSZXF1ZXN0VHlwZTU7XG5jbGFzcyBSZXF1ZXN0VHlwZTYgZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCkge1xuICAgICAgICBzdXBlcihtZXRob2QsIDYpO1xuICAgIH1cbn1cbmV4cG9ydHMuUmVxdWVzdFR5cGU2ID0gUmVxdWVzdFR5cGU2O1xuY2xhc3MgUmVxdWVzdFR5cGU3IGV4dGVuZHMgQWJzdHJhY3RNZXNzYWdlU2lnbmF0dXJlIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRob2QpIHtcbiAgICAgICAgc3VwZXIobWV0aG9kLCA3KTtcbiAgICB9XG59XG5leHBvcnRzLlJlcXVlc3RUeXBlNyA9IFJlcXVlc3RUeXBlNztcbmNsYXNzIFJlcXVlc3RUeXBlOCBleHRlbmRzIEFic3RyYWN0TWVzc2FnZVNpZ25hdHVyZSB7XG4gICAgY29uc3RydWN0b3IobWV0aG9kKSB7XG4gICAgICAgIHN1cGVyKG1ldGhvZCwgOCk7XG4gICAgfVxufVxuZXhwb3J0cy5SZXF1ZXN0VHlwZTggPSBSZXF1ZXN0VHlwZTg7XG5jbGFzcyBSZXF1ZXN0VHlwZTkgZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCkge1xuICAgICAgICBzdXBlcihtZXRob2QsIDkpO1xuICAgIH1cbn1cbmV4cG9ydHMuUmVxdWVzdFR5cGU5ID0gUmVxdWVzdFR5cGU5O1xuY2xhc3MgTm90aWZpY2F0aW9uVHlwZSBleHRlbmRzIEFic3RyYWN0TWVzc2FnZVNpZ25hdHVyZSB7XG4gICAgY29uc3RydWN0b3IobWV0aG9kLCBfcGFyYW1ldGVyU3RydWN0dXJlcyA9IFBhcmFtZXRlclN0cnVjdHVyZXMuYXV0bykge1xuICAgICAgICBzdXBlcihtZXRob2QsIDEpO1xuICAgICAgICB0aGlzLl9wYXJhbWV0ZXJTdHJ1Y3R1cmVzID0gX3BhcmFtZXRlclN0cnVjdHVyZXM7XG4gICAgfVxuICAgIGdldCBwYXJhbWV0ZXJTdHJ1Y3R1cmVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFyYW1ldGVyU3RydWN0dXJlcztcbiAgICB9XG59XG5leHBvcnRzLk5vdGlmaWNhdGlvblR5cGUgPSBOb3RpZmljYXRpb25UeXBlO1xuY2xhc3MgTm90aWZpY2F0aW9uVHlwZTAgZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCkge1xuICAgICAgICBzdXBlcihtZXRob2QsIDApO1xuICAgIH1cbn1cbmV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTAgPSBOb3RpZmljYXRpb25UeXBlMDtcbmNsYXNzIE5vdGlmaWNhdGlvblR5cGUxIGV4dGVuZHMgQWJzdHJhY3RNZXNzYWdlU2lnbmF0dXJlIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRob2QsIF9wYXJhbWV0ZXJTdHJ1Y3R1cmVzID0gUGFyYW1ldGVyU3RydWN0dXJlcy5hdXRvKSB7XG4gICAgICAgIHN1cGVyKG1ldGhvZCwgMSk7XG4gICAgICAgIHRoaXMuX3BhcmFtZXRlclN0cnVjdHVyZXMgPSBfcGFyYW1ldGVyU3RydWN0dXJlcztcbiAgICB9XG4gICAgZ2V0IHBhcmFtZXRlclN0cnVjdHVyZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJhbWV0ZXJTdHJ1Y3R1cmVzO1xuICAgIH1cbn1cbmV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTEgPSBOb3RpZmljYXRpb25UeXBlMTtcbmNsYXNzIE5vdGlmaWNhdGlvblR5cGUyIGV4dGVuZHMgQWJzdHJhY3RNZXNzYWdlU2lnbmF0dXJlIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRob2QpIHtcbiAgICAgICAgc3VwZXIobWV0aG9kLCAyKTtcbiAgICB9XG59XG5leHBvcnRzLk5vdGlmaWNhdGlvblR5cGUyID0gTm90aWZpY2F0aW9uVHlwZTI7XG5jbGFzcyBOb3RpZmljYXRpb25UeXBlMyBleHRlbmRzIEFic3RyYWN0TWVzc2FnZVNpZ25hdHVyZSB7XG4gICAgY29uc3RydWN0b3IobWV0aG9kKSB7XG4gICAgICAgIHN1cGVyKG1ldGhvZCwgMyk7XG4gICAgfVxufVxuZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlMyA9IE5vdGlmaWNhdGlvblR5cGUzO1xuY2xhc3MgTm90aWZpY2F0aW9uVHlwZTQgZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCkge1xuICAgICAgICBzdXBlcihtZXRob2QsIDQpO1xuICAgIH1cbn1cbmV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTQgPSBOb3RpZmljYXRpb25UeXBlNDtcbmNsYXNzIE5vdGlmaWNhdGlvblR5cGU1IGV4dGVuZHMgQWJzdHJhY3RNZXNzYWdlU2lnbmF0dXJlIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRob2QpIHtcbiAgICAgICAgc3VwZXIobWV0aG9kLCA1KTtcbiAgICB9XG59XG5leHBvcnRzLk5vdGlmaWNhdGlvblR5cGU1ID0gTm90aWZpY2F0aW9uVHlwZTU7XG5jbGFzcyBOb3RpZmljYXRpb25UeXBlNiBleHRlbmRzIEFic3RyYWN0TWVzc2FnZVNpZ25hdHVyZSB7XG4gICAgY29uc3RydWN0b3IobWV0aG9kKSB7XG4gICAgICAgIHN1cGVyKG1ldGhvZCwgNik7XG4gICAgfVxufVxuZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlNiA9IE5vdGlmaWNhdGlvblR5cGU2O1xuY2xhc3MgTm90aWZpY2F0aW9uVHlwZTcgZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCkge1xuICAgICAgICBzdXBlcihtZXRob2QsIDcpO1xuICAgIH1cbn1cbmV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTcgPSBOb3RpZmljYXRpb25UeXBlNztcbmNsYXNzIE5vdGlmaWNhdGlvblR5cGU4IGV4dGVuZHMgQWJzdHJhY3RNZXNzYWdlU2lnbmF0dXJlIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRob2QpIHtcbiAgICAgICAgc3VwZXIobWV0aG9kLCA4KTtcbiAgICB9XG59XG5leHBvcnRzLk5vdGlmaWNhdGlvblR5cGU4ID0gTm90aWZpY2F0aW9uVHlwZTg7XG5jbGFzcyBOb3RpZmljYXRpb25UeXBlOSBleHRlbmRzIEFic3RyYWN0TWVzc2FnZVNpZ25hdHVyZSB7XG4gICAgY29uc3RydWN0b3IobWV0aG9kKSB7XG4gICAgICAgIHN1cGVyKG1ldGhvZCwgOSk7XG4gICAgfVxufVxuZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlOSA9IE5vdGlmaWNhdGlvblR5cGU5O1xudmFyIE1lc3NhZ2U7XG4oZnVuY3Rpb24gKE1lc3NhZ2UpIHtcbiAgICAvKipcbiAgICAgKiBUZXN0cyBpZiB0aGUgZ2l2ZW4gbWVzc2FnZSBpcyBhIHJlcXVlc3QgbWVzc2FnZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzUmVxdWVzdChtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IG1lc3NhZ2U7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgJiYgaXMuc3RyaW5nKGNhbmRpZGF0ZS5tZXRob2QpICYmIChpcy5zdHJpbmcoY2FuZGlkYXRlLmlkKSB8fCBpcy5udW1iZXIoY2FuZGlkYXRlLmlkKSk7XG4gICAgfVxuICAgIE1lc3NhZ2UuaXNSZXF1ZXN0ID0gaXNSZXF1ZXN0O1xuICAgIC8qKlxuICAgICAqIFRlc3RzIGlmIHRoZSBnaXZlbiBtZXNzYWdlIGlzIGEgbm90aWZpY2F0aW9uIG1lc3NhZ2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc05vdGlmaWNhdGlvbihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IG1lc3NhZ2U7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgJiYgaXMuc3RyaW5nKGNhbmRpZGF0ZS5tZXRob2QpICYmIG1lc3NhZ2UuaWQgPT09IHZvaWQgMDtcbiAgICB9XG4gICAgTWVzc2FnZS5pc05vdGlmaWNhdGlvbiA9IGlzTm90aWZpY2F0aW9uO1xuICAgIC8qKlxuICAgICAqIFRlc3RzIGlmIHRoZSBnaXZlbiBtZXNzYWdlIGlzIGEgcmVzcG9uc2UgbWVzc2FnZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzUmVzcG9uc2UobWVzc2FnZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSBtZXNzYWdlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICYmIChjYW5kaWRhdGUucmVzdWx0ICE9PSB2b2lkIDAgfHwgISFjYW5kaWRhdGUuZXJyb3IpICYmIChpcy5zdHJpbmcoY2FuZGlkYXRlLmlkKSB8fCBpcy5udW1iZXIoY2FuZGlkYXRlLmlkKSB8fCBjYW5kaWRhdGUuaWQgPT09IG51bGwpO1xuICAgIH1cbiAgICBNZXNzYWdlLmlzUmVzcG9uc2UgPSBpc1Jlc3BvbnNlO1xufSkoTWVzc2FnZSA9IGV4cG9ydHMuTWVzc2FnZSB8fCAoZXhwb3J0cy5NZXNzYWdlID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1lc3NhZ2VzLmpzLm1hcFxuXG4vKioqLyB9KSxcblxuLyoqKi8gNDI1NDpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMpID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xubGV0IF9yYWw7XG5mdW5jdGlvbiBSQUwoKSB7XG4gICAgaWYgKF9yYWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIHJ1bnRpbWUgYWJzdHJhY3Rpb24gbGF5ZXIgaW5zdGFsbGVkYCk7XG4gICAgfVxuICAgIHJldHVybiBfcmFsO1xufVxuKGZ1bmN0aW9uIChSQUwpIHtcbiAgICBmdW5jdGlvbiBpbnN0YWxsKHJhbCkge1xuICAgICAgICBpZiAocmFsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gcnVudGltZSBhYnN0cmFjdGlvbiBsYXllciBwcm92aWRlZGApO1xuICAgICAgICB9XG4gICAgICAgIF9yYWwgPSByYWw7XG4gICAgfVxuICAgIFJBTC5pbnN0YWxsID0gaW5zdGFsbDtcbn0pKFJBTCB8fCAoUkFMID0ge30pKTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gUkFMO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmFsLmpzLm1hcFxuXG4vKioqLyB9KSxcblxuLyoqKi8gOTkzMTpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5TZW1hcGhvcmUgPSB2b2lkIDA7XG5jb25zdCByYWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNDI1NCk7XG5jbGFzcyBTZW1hcGhvcmUge1xuICAgIGNvbnN0cnVjdG9yKGNhcGFjaXR5ID0gMSkge1xuICAgICAgICBpZiAoY2FwYWNpdHkgPD0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYXBhY2l0eSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY2FwYWNpdHkgPSBjYXBhY2l0eTtcbiAgICAgICAgdGhpcy5fYWN0aXZlID0gMDtcbiAgICAgICAgdGhpcy5fd2FpdGluZyA9IFtdO1xuICAgIH1cbiAgICBsb2NrKHRodW5rKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLl93YWl0aW5nLnB1c2goeyB0aHVuaywgcmVzb2x2ZSwgcmVqZWN0IH0pO1xuICAgICAgICAgICAgdGhpcy5ydW5OZXh0KCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXQgYWN0aXZlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWN0aXZlO1xuICAgIH1cbiAgICBydW5OZXh0KCkge1xuICAgICAgICBpZiAodGhpcy5fd2FpdGluZy5sZW5ndGggPT09IDAgfHwgdGhpcy5fYWN0aXZlID09PSB0aGlzLl9jYXBhY2l0eSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgICgwLCByYWxfMS5kZWZhdWx0KSgpLnRpbWVyLnNldEltbWVkaWF0ZSgoKSA9PiB0aGlzLmRvUnVuTmV4dCgpKTtcbiAgICB9XG4gICAgZG9SdW5OZXh0KCkge1xuICAgICAgICBpZiAodGhpcy5fd2FpdGluZy5sZW5ndGggPT09IDAgfHwgdGhpcy5fYWN0aXZlID09PSB0aGlzLl9jYXBhY2l0eSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5leHQgPSB0aGlzLl93YWl0aW5nLnNoaWZ0KCk7XG4gICAgICAgIHRoaXMuX2FjdGl2ZSsrO1xuICAgICAgICBpZiAodGhpcy5fYWN0aXZlID4gdGhpcy5fY2FwYWNpdHkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVG8gbWFueSB0aHVua3MgYWN0aXZlYCk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IG5leHQudGh1bmsoKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnRoZW4oKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FjdGl2ZS0tO1xuICAgICAgICAgICAgICAgICAgICBuZXh0LnJlc29sdmUodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJ1bk5leHQoKTtcbiAgICAgICAgICAgICAgICB9LCAoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FjdGl2ZS0tO1xuICAgICAgICAgICAgICAgICAgICBuZXh0LnJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJ1bk5leHQoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FjdGl2ZS0tO1xuICAgICAgICAgICAgICAgIG5leHQucmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgIHRoaXMucnVuTmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuX2FjdGl2ZS0tO1xuICAgICAgICAgICAgbmV4dC5yZWplY3QoZXJyKTtcbiAgICAgICAgICAgIHRoaXMucnVuTmV4dCgpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5TZW1hcGhvcmUgPSBTZW1hcGhvcmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZW1hcGhvcmUuanMubWFwXG5cbi8qKiovIH0pLFxuXG4vKioqLyAyNzMwOlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgZm9yRWFjaCA9IF9fd2VicGFja19yZXF1aXJlX18oNzA1KTtcbnZhciBhdmFpbGFibGVUeXBlZEFycmF5cyA9IF9fd2VicGFja19yZXF1aXJlX18oNDgzNCk7XG52YXIgY2FsbEJpbmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg0OTgpO1xudmFyIGNhbGxCb3VuZCA9IF9fd2VicGFja19yZXF1aXJlX18oOTgxOCk7XG52YXIgZ09QRCA9IF9fd2VicGFja19yZXF1aXJlX18oOTMzNik7XG5cbnZhciAkdG9TdHJpbmcgPSBjYWxsQm91bmQoJ09iamVjdC5wcm90b3R5cGUudG9TdHJpbmcnKTtcbnZhciBoYXNUb1N0cmluZ1RhZyA9IF9fd2VicGFja19yZXF1aXJlX18oMTkxMykoKTtcblxudmFyIGcgPSB0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ3VuZGVmaW5lZCcgPyBfX3dlYnBhY2tfcmVxdWlyZV9fLmcgOiBnbG9iYWxUaGlzO1xudmFyIHR5cGVkQXJyYXlzID0gYXZhaWxhYmxlVHlwZWRBcnJheXMoKTtcblxudmFyICRzbGljZSA9IGNhbGxCb3VuZCgnU3RyaW5nLnByb3RvdHlwZS5zbGljZScpO1xudmFyIGdldFByb3RvdHlwZU9mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mOyAvLyByZXF1aXJlKCdnZXRwcm90b3R5cGVvZicpO1xuXG52YXIgJGluZGV4T2YgPSBjYWxsQm91bmQoJ0FycmF5LnByb3RvdHlwZS5pbmRleE9mJywgdHJ1ZSkgfHwgZnVuY3Rpb24gaW5kZXhPZihhcnJheSwgdmFsdWUpIHtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkgKz0gMSkge1xuXHRcdGlmIChhcnJheVtpXSA9PT0gdmFsdWUpIHtcblx0XHRcdHJldHVybiBpO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gLTE7XG59O1xudmFyIGNhY2hlID0geyBfX3Byb3RvX186IG51bGwgfTtcbmlmIChoYXNUb1N0cmluZ1RhZyAmJiBnT1BEICYmIGdldFByb3RvdHlwZU9mKSB7XG5cdGZvckVhY2godHlwZWRBcnJheXMsIGZ1bmN0aW9uICh0eXBlZEFycmF5KSB7XG5cdFx0dmFyIGFyciA9IG5ldyBnW3R5cGVkQXJyYXldKCk7XG5cdFx0aWYgKFN5bWJvbC50b1N0cmluZ1RhZyBpbiBhcnIpIHtcblx0XHRcdHZhciBwcm90byA9IGdldFByb3RvdHlwZU9mKGFycik7XG5cdFx0XHR2YXIgZGVzY3JpcHRvciA9IGdPUEQocHJvdG8sIFN5bWJvbC50b1N0cmluZ1RhZyk7XG5cdFx0XHRpZiAoIWRlc2NyaXB0b3IpIHtcblx0XHRcdFx0dmFyIHN1cGVyUHJvdG8gPSBnZXRQcm90b3R5cGVPZihwcm90byk7XG5cdFx0XHRcdGRlc2NyaXB0b3IgPSBnT1BEKHN1cGVyUHJvdG8sIFN5bWJvbC50b1N0cmluZ1RhZyk7XG5cdFx0XHR9XG5cdFx0XHRjYWNoZVsnJCcgKyB0eXBlZEFycmF5XSA9IGNhbGxCaW5kKGRlc2NyaXB0b3IuZ2V0KTtcblx0XHR9XG5cdH0pO1xufSBlbHNlIHtcblx0Zm9yRWFjaCh0eXBlZEFycmF5cywgZnVuY3Rpb24gKHR5cGVkQXJyYXkpIHtcblx0XHR2YXIgYXJyID0gbmV3IGdbdHlwZWRBcnJheV0oKTtcblx0XHRjYWNoZVsnJCcgKyB0eXBlZEFycmF5XSA9IGNhbGxCaW5kKGFyci5zbGljZSk7XG5cdH0pO1xufVxuXG52YXIgdHJ5VHlwZWRBcnJheXMgPSBmdW5jdGlvbiB0cnlBbGxUeXBlZEFycmF5cyh2YWx1ZSkge1xuXHR2YXIgZm91bmQgPSBmYWxzZTtcblx0Zm9yRWFjaChjYWNoZSwgZnVuY3Rpb24gKGdldHRlciwgdHlwZWRBcnJheSkge1xuXHRcdGlmICghZm91bmQpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGlmICgnJCcgKyBnZXR0ZXIodmFsdWUpID09PSB0eXBlZEFycmF5KSB7XG5cdFx0XHRcdFx0Zm91bmQgPSAkc2xpY2UodHlwZWRBcnJheSwgMSk7XG5cdFx0XHRcdH1cblx0XHRcdH0gY2F0Y2ggKGUpIHsgLyoqLyB9XG5cdFx0fVxuXHR9KTtcblx0cmV0dXJuIGZvdW5kO1xufTtcblxudmFyIHRyeVNsaWNlcyA9IGZ1bmN0aW9uIHRyeUFsbFNsaWNlcyh2YWx1ZSkge1xuXHR2YXIgZm91bmQgPSBmYWxzZTtcblx0Zm9yRWFjaChjYWNoZSwgZnVuY3Rpb24gKGdldHRlciwgbmFtZSkge1xuXHRcdGlmICghZm91bmQpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGdldHRlcih2YWx1ZSk7XG5cdFx0XHRcdGZvdW5kID0gJHNsaWNlKG5hbWUsIDEpO1xuXHRcdFx0fSBjYXRjaCAoZSkgeyAvKiovIH1cblx0XHR9XG5cdH0pO1xuXHRyZXR1cm4gZm91bmQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkge1xuXHRpZiAoIXZhbHVlIHx8IHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdGlmICghaGFzVG9TdHJpbmdUYWcpIHtcblx0XHR2YXIgdGFnID0gJHNsaWNlKCR0b1N0cmluZyh2YWx1ZSksIDgsIC0xKTtcblx0XHRpZiAoJGluZGV4T2YodHlwZWRBcnJheXMsIHRhZykgPiAtMSkge1xuXHRcdFx0cmV0dXJuIHRhZztcblx0XHR9XG5cdFx0aWYgKHRhZyAhPT0gJ09iamVjdCcpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0Ly8gbm9kZSA8IDAuNiBoaXRzIGhlcmUgb24gcmVhbCBUeXBlZCBBcnJheXNcblx0XHRyZXR1cm4gdHJ5U2xpY2VzKHZhbHVlKTtcblx0fVxuXHRpZiAoIWdPUEQpIHsgcmV0dXJuIG51bGw7IH0gLy8gdW5rbm93biBlbmdpbmVcblx0cmV0dXJuIHRyeVR5cGVkQXJyYXlzKHZhbHVlKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDQ4MzQ6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBwb3NzaWJsZU5hbWVzID0gW1xuXHQnQmlnSW50NjRBcnJheScsXG5cdCdCaWdVaW50NjRBcnJheScsXG5cdCdGbG9hdDMyQXJyYXknLFxuXHQnRmxvYXQ2NEFycmF5Jyxcblx0J0ludDE2QXJyYXknLFxuXHQnSW50MzJBcnJheScsXG5cdCdJbnQ4QXJyYXknLFxuXHQnVWludDE2QXJyYXknLFxuXHQnVWludDMyQXJyYXknLFxuXHQnVWludDhBcnJheScsXG5cdCdVaW50OENsYW1wZWRBcnJheSdcbl07XG5cbnZhciBnID0gdHlwZW9mIGdsb2JhbFRoaXMgPT09ICd1bmRlZmluZWQnID8gX193ZWJwYWNrX3JlcXVpcmVfXy5nIDogZ2xvYmFsVGhpcztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBhdmFpbGFibGVUeXBlZEFycmF5cygpIHtcblx0dmFyIG91dCA9IFtdO1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IHBvc3NpYmxlTmFtZXMubGVuZ3RoOyBpKyspIHtcblx0XHRpZiAodHlwZW9mIGdbcG9zc2libGVOYW1lc1tpXV0gPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdG91dFtvdXQubGVuZ3RoXSA9IHBvc3NpYmxlTmFtZXNbaV07XG5cdFx0fVxuXHR9XG5cdHJldHVybiBvdXQ7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA4MDQxOlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX19fd2VicGFja19tb2R1bGVfXywgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFY6ICgpID0+ICgvKiBiaW5kaW5nICovIFRleHREb2N1bWVudClcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5jbGFzcyBGdWxsVGV4dERvY3VtZW50IHtcbiAgICBjb25zdHJ1Y3Rvcih1cmksIGxhbmd1YWdlSWQsIHZlcnNpb24sIGNvbnRlbnQpIHtcbiAgICAgICAgdGhpcy5fdXJpID0gdXJpO1xuICAgICAgICB0aGlzLl9sYW5ndWFnZUlkID0gbGFuZ3VhZ2VJZDtcbiAgICAgICAgdGhpcy5fdmVyc2lvbiA9IHZlcnNpb247XG4gICAgICAgIHRoaXMuX2NvbnRlbnQgPSBjb250ZW50O1xuICAgICAgICB0aGlzLl9saW5lT2Zmc2V0cyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZ2V0IHVyaSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3VyaTtcbiAgICB9XG4gICAgZ2V0IGxhbmd1YWdlSWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sYW5ndWFnZUlkO1xuICAgIH1cbiAgICBnZXQgdmVyc2lvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZlcnNpb247XG4gICAgfVxuICAgIGdldFRleHQocmFuZ2UpIHtcbiAgICAgICAgaWYgKHJhbmdlKSB7XG4gICAgICAgICAgICBjb25zdCBzdGFydCA9IHRoaXMub2Zmc2V0QXQocmFuZ2Uuc3RhcnQpO1xuICAgICAgICAgICAgY29uc3QgZW5kID0gdGhpcy5vZmZzZXRBdChyYW5nZS5lbmQpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRlbnQuc3Vic3RyaW5nKHN0YXJ0LCBlbmQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9jb250ZW50O1xuICAgIH1cbiAgICB1cGRhdGUoY2hhbmdlcywgdmVyc2lvbikge1xuICAgICAgICBmb3IgKGNvbnN0IGNoYW5nZSBvZiBjaGFuZ2VzKSB7XG4gICAgICAgICAgICBpZiAoRnVsbFRleHREb2N1bWVudC5pc0luY3JlbWVudGFsKGNoYW5nZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBtYWtlcyBzdXJlIHN0YXJ0IGlzIGJlZm9yZSBlbmRcbiAgICAgICAgICAgICAgICBjb25zdCByYW5nZSA9IGdldFdlbGxmb3JtZWRSYW5nZShjaGFuZ2UucmFuZ2UpO1xuICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSBjb250ZW50XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhcnRPZmZzZXQgPSB0aGlzLm9mZnNldEF0KHJhbmdlLnN0YXJ0KTtcbiAgICAgICAgICAgICAgICBjb25zdCBlbmRPZmZzZXQgPSB0aGlzLm9mZnNldEF0KHJhbmdlLmVuZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29udGVudCA9IHRoaXMuX2NvbnRlbnQuc3Vic3RyaW5nKDAsIHN0YXJ0T2Zmc2V0KSArIGNoYW5nZS50ZXh0ICsgdGhpcy5fY29udGVudC5zdWJzdHJpbmcoZW5kT2Zmc2V0LCB0aGlzLl9jb250ZW50Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlIHRoZSBvZmZzZXRzXG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhcnRMaW5lID0gTWF0aC5tYXgocmFuZ2Uuc3RhcnQubGluZSwgMCk7XG4gICAgICAgICAgICAgICAgY29uc3QgZW5kTGluZSA9IE1hdGgubWF4KHJhbmdlLmVuZC5saW5lLCAwKTtcbiAgICAgICAgICAgICAgICBsZXQgbGluZU9mZnNldHMgPSB0aGlzLl9saW5lT2Zmc2V0cztcbiAgICAgICAgICAgICAgICBjb25zdCBhZGRlZExpbmVPZmZzZXRzID0gY29tcHV0ZUxpbmVPZmZzZXRzKGNoYW5nZS50ZXh0LCBmYWxzZSwgc3RhcnRPZmZzZXQpO1xuICAgICAgICAgICAgICAgIGlmIChlbmRMaW5lIC0gc3RhcnRMaW5lID09PSBhZGRlZExpbmVPZmZzZXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gYWRkZWRMaW5lT2Zmc2V0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGluZU9mZnNldHNbaSArIHN0YXJ0TGluZSArIDFdID0gYWRkZWRMaW5lT2Zmc2V0c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFkZGVkTGluZU9mZnNldHMubGVuZ3RoIDwgMTAwMDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVPZmZzZXRzLnNwbGljZShzdGFydExpbmUgKyAxLCBlbmRMaW5lIC0gc3RhcnRMaW5lLCAuLi5hZGRlZExpbmVPZmZzZXRzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHsgLy8gYXZvaWQgdG9vIG1hbnkgYXJndW1lbnRzIGZvciBzcGxpY2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2xpbmVPZmZzZXRzID0gbGluZU9mZnNldHMgPSBsaW5lT2Zmc2V0cy5zbGljZSgwLCBzdGFydExpbmUgKyAxKS5jb25jYXQoYWRkZWRMaW5lT2Zmc2V0cywgbGluZU9mZnNldHMuc2xpY2UoZW5kTGluZSArIDEpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBkaWZmID0gY2hhbmdlLnRleHQubGVuZ3RoIC0gKGVuZE9mZnNldCAtIHN0YXJ0T2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBpZiAoZGlmZiAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gc3RhcnRMaW5lICsgMSArIGFkZGVkTGluZU9mZnNldHMubGVuZ3RoLCBsZW4gPSBsaW5lT2Zmc2V0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGluZU9mZnNldHNbaV0gPSBsaW5lT2Zmc2V0c1tpXSArIGRpZmY7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChGdWxsVGV4dERvY3VtZW50LmlzRnVsbChjaGFuZ2UpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29udGVudCA9IGNoYW5nZS50ZXh0O1xuICAgICAgICAgICAgICAgIHRoaXMuX2xpbmVPZmZzZXRzID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGNoYW5nZSBldmVudCByZWNlaXZlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ZlcnNpb24gPSB2ZXJzaW9uO1xuICAgIH1cbiAgICBnZXRMaW5lT2Zmc2V0cygpIHtcbiAgICAgICAgaWYgKHRoaXMuX2xpbmVPZmZzZXRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2xpbmVPZmZzZXRzID0gY29tcHV0ZUxpbmVPZmZzZXRzKHRoaXMuX2NvbnRlbnQsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9saW5lT2Zmc2V0cztcbiAgICB9XG4gICAgcG9zaXRpb25BdChvZmZzZXQpIHtcbiAgICAgICAgb2Zmc2V0ID0gTWF0aC5tYXgoTWF0aC5taW4ob2Zmc2V0LCB0aGlzLl9jb250ZW50Lmxlbmd0aCksIDApO1xuICAgICAgICBjb25zdCBsaW5lT2Zmc2V0cyA9IHRoaXMuZ2V0TGluZU9mZnNldHMoKTtcbiAgICAgICAgbGV0IGxvdyA9IDAsIGhpZ2ggPSBsaW5lT2Zmc2V0cy5sZW5ndGg7XG4gICAgICAgIGlmIChoaWdoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4geyBsaW5lOiAwLCBjaGFyYWN0ZXI6IG9mZnNldCB9O1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChsb3cgPCBoaWdoKSB7XG4gICAgICAgICAgICBjb25zdCBtaWQgPSBNYXRoLmZsb29yKChsb3cgKyBoaWdoKSAvIDIpO1xuICAgICAgICAgICAgaWYgKGxpbmVPZmZzZXRzW21pZF0gPiBvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICBoaWdoID0gbWlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbG93ID0gbWlkICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBsb3cgaXMgdGhlIGxlYXN0IHggZm9yIHdoaWNoIHRoZSBsaW5lIG9mZnNldCBpcyBsYXJnZXIgdGhhbiB0aGUgY3VycmVudCBvZmZzZXRcbiAgICAgICAgLy8gb3IgYXJyYXkubGVuZ3RoIGlmIG5vIGxpbmUgb2Zmc2V0IGlzIGxhcmdlciB0aGFuIHRoZSBjdXJyZW50IG9mZnNldFxuICAgICAgICBjb25zdCBsaW5lID0gbG93IC0gMTtcbiAgICAgICAgb2Zmc2V0ID0gdGhpcy5lbnN1cmVCZWZvcmVFT0wob2Zmc2V0LCBsaW5lT2Zmc2V0c1tsaW5lXSk7XG4gICAgICAgIHJldHVybiB7IGxpbmUsIGNoYXJhY3Rlcjogb2Zmc2V0IC0gbGluZU9mZnNldHNbbGluZV0gfTtcbiAgICB9XG4gICAgb2Zmc2V0QXQocG9zaXRpb24pIHtcbiAgICAgICAgY29uc3QgbGluZU9mZnNldHMgPSB0aGlzLmdldExpbmVPZmZzZXRzKCk7XG4gICAgICAgIGlmIChwb3NpdGlvbi5saW5lID49IGxpbmVPZmZzZXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRlbnQubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBvc2l0aW9uLmxpbmUgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsaW5lT2Zmc2V0ID0gbGluZU9mZnNldHNbcG9zaXRpb24ubGluZV07XG4gICAgICAgIGlmIChwb3NpdGlvbi5jaGFyYWN0ZXIgPD0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGxpbmVPZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV4dExpbmVPZmZzZXQgPSAocG9zaXRpb24ubGluZSArIDEgPCBsaW5lT2Zmc2V0cy5sZW5ndGgpID8gbGluZU9mZnNldHNbcG9zaXRpb24ubGluZSArIDFdIDogdGhpcy5fY29udGVudC5sZW5ndGg7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IE1hdGgubWluKGxpbmVPZmZzZXQgKyBwb3NpdGlvbi5jaGFyYWN0ZXIsIG5leHRMaW5lT2Zmc2V0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5zdXJlQmVmb3JlRU9MKG9mZnNldCwgbGluZU9mZnNldCk7XG4gICAgfVxuICAgIGVuc3VyZUJlZm9yZUVPTChvZmZzZXQsIGxpbmVPZmZzZXQpIHtcbiAgICAgICAgd2hpbGUgKG9mZnNldCA+IGxpbmVPZmZzZXQgJiYgaXNFT0wodGhpcy5fY29udGVudC5jaGFyQ29kZUF0KG9mZnNldCAtIDEpKSkge1xuICAgICAgICAgICAgb2Zmc2V0LS07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9XG4gICAgZ2V0IGxpbmVDb3VudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TGluZU9mZnNldHMoKS5sZW5ndGg7XG4gICAgfVxuICAgIHN0YXRpYyBpc0luY3JlbWVudGFsKGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IGV2ZW50O1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICE9PSB1bmRlZmluZWQgJiYgY2FuZGlkYXRlICE9PSBudWxsICYmXG4gICAgICAgICAgICB0eXBlb2YgY2FuZGlkYXRlLnRleHQgPT09ICdzdHJpbmcnICYmIGNhbmRpZGF0ZS5yYW5nZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAoY2FuZGlkYXRlLnJhbmdlTGVuZ3RoID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIGNhbmRpZGF0ZS5yYW5nZUxlbmd0aCA9PT0gJ251bWJlcicpO1xuICAgIH1cbiAgICBzdGF0aWMgaXNGdWxsKGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IGV2ZW50O1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICE9PSB1bmRlZmluZWQgJiYgY2FuZGlkYXRlICE9PSBudWxsICYmXG4gICAgICAgICAgICB0eXBlb2YgY2FuZGlkYXRlLnRleHQgPT09ICdzdHJpbmcnICYmIGNhbmRpZGF0ZS5yYW5nZSA9PT0gdW5kZWZpbmVkICYmIGNhbmRpZGF0ZS5yYW5nZUxlbmd0aCA9PT0gdW5kZWZpbmVkO1xuICAgIH1cbn1cbnZhciBUZXh0RG9jdW1lbnQ7XG4oZnVuY3Rpb24gKFRleHREb2N1bWVudCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgdGV4dCBkb2N1bWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB1cmkgVGhlIGRvY3VtZW50J3MgdXJpLlxuICAgICAqIEBwYXJhbSBsYW5ndWFnZUlkICBUaGUgZG9jdW1lbnQncyBsYW5ndWFnZSBJZC5cbiAgICAgKiBAcGFyYW0gdmVyc2lvbiBUaGUgZG9jdW1lbnQncyBpbml0aWFsIHZlcnNpb24gbnVtYmVyLlxuICAgICAqIEBwYXJhbSBjb250ZW50IFRoZSBkb2N1bWVudCdzIGNvbnRlbnQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHVyaSwgbGFuZ3VhZ2VJZCwgdmVyc2lvbiwgY29udGVudCkge1xuICAgICAgICByZXR1cm4gbmV3IEZ1bGxUZXh0RG9jdW1lbnQodXJpLCBsYW5ndWFnZUlkLCB2ZXJzaW9uLCBjb250ZW50KTtcbiAgICB9XG4gICAgVGV4dERvY3VtZW50LmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIGEgVGV4dERvY3VtZW50IGJ5IG1vZGlmeWluZyBpdHMgY29udGVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkb2N1bWVudCB0aGUgZG9jdW1lbnQgdG8gdXBkYXRlLiBPbmx5IGRvY3VtZW50cyBjcmVhdGVkIGJ5IFRleHREb2N1bWVudC5jcmVhdGUgYXJlIHZhbGlkIGlucHV0cy5cbiAgICAgKiBAcGFyYW0gY2hhbmdlcyB0aGUgY2hhbmdlcyB0byBhcHBseSB0byB0aGUgZG9jdW1lbnQuXG4gICAgICogQHBhcmFtIHZlcnNpb24gdGhlIGNoYW5nZXMgdmVyc2lvbiBmb3IgdGhlIGRvY3VtZW50LlxuICAgICAqIEByZXR1cm5zIFRoZSB1cGRhdGVkIFRleHREb2N1bWVudC4gTm90ZTogVGhhdCdzIHRoZSBzYW1lIGRvY3VtZW50IGluc3RhbmNlIHBhc3NlZCBpbiBhcyBmaXJzdCBwYXJhbWV0ZXIuXG4gICAgICpcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1cGRhdGUoZG9jdW1lbnQsIGNoYW5nZXMsIHZlcnNpb24pIHtcbiAgICAgICAgaWYgKGRvY3VtZW50IGluc3RhbmNlb2YgRnVsbFRleHREb2N1bWVudCkge1xuICAgICAgICAgICAgZG9jdW1lbnQudXBkYXRlKGNoYW5nZXMsIHZlcnNpb24pO1xuICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUZXh0RG9jdW1lbnQudXBkYXRlOiBkb2N1bWVudCBtdXN0IGJlIGNyZWF0ZWQgYnkgVGV4dERvY3VtZW50LmNyZWF0ZScpO1xuICAgICAgICB9XG4gICAgfVxuICAgIFRleHREb2N1bWVudC51cGRhdGUgPSB1cGRhdGU7XG4gICAgZnVuY3Rpb24gYXBwbHlFZGl0cyhkb2N1bWVudCwgZWRpdHMpIHtcbiAgICAgICAgY29uc3QgdGV4dCA9IGRvY3VtZW50LmdldFRleHQoKTtcbiAgICAgICAgY29uc3Qgc29ydGVkRWRpdHMgPSBtZXJnZVNvcnQoZWRpdHMubWFwKGdldFdlbGxmb3JtZWRFZGl0KSwgKGEsIGIpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGRpZmYgPSBhLnJhbmdlLnN0YXJ0LmxpbmUgLSBiLnJhbmdlLnN0YXJ0LmxpbmU7XG4gICAgICAgICAgICBpZiAoZGlmZiA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhLnJhbmdlLnN0YXJ0LmNoYXJhY3RlciAtIGIucmFuZ2Uuc3RhcnQuY2hhcmFjdGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRpZmY7XG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgbGFzdE1vZGlmaWVkT2Zmc2V0ID0gMDtcbiAgICAgICAgY29uc3Qgc3BhbnMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBlIG9mIHNvcnRlZEVkaXRzKSB7XG4gICAgICAgICAgICBjb25zdCBzdGFydE9mZnNldCA9IGRvY3VtZW50Lm9mZnNldEF0KGUucmFuZ2Uuc3RhcnQpO1xuICAgICAgICAgICAgaWYgKHN0YXJ0T2Zmc2V0IDwgbGFzdE1vZGlmaWVkT2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPdmVybGFwcGluZyBlZGl0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzdGFydE9mZnNldCA+IGxhc3RNb2RpZmllZE9mZnNldCkge1xuICAgICAgICAgICAgICAgIHNwYW5zLnB1c2godGV4dC5zdWJzdHJpbmcobGFzdE1vZGlmaWVkT2Zmc2V0LCBzdGFydE9mZnNldCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGUubmV3VGV4dC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBzcGFucy5wdXNoKGUubmV3VGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYXN0TW9kaWZpZWRPZmZzZXQgPSBkb2N1bWVudC5vZmZzZXRBdChlLnJhbmdlLmVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgc3BhbnMucHVzaCh0ZXh0LnN1YnN0cihsYXN0TW9kaWZpZWRPZmZzZXQpKTtcbiAgICAgICAgcmV0dXJuIHNwYW5zLmpvaW4oJycpO1xuICAgIH1cbiAgICBUZXh0RG9jdW1lbnQuYXBwbHlFZGl0cyA9IGFwcGx5RWRpdHM7XG59KShUZXh0RG9jdW1lbnQgfHwgKFRleHREb2N1bWVudCA9IHt9KSk7XG5mdW5jdGlvbiBtZXJnZVNvcnQoZGF0YSwgY29tcGFyZSkge1xuICAgIGlmIChkYXRhLmxlbmd0aCA8PSAxKSB7XG4gICAgICAgIC8vIHNvcnRlZFxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgY29uc3QgcCA9IChkYXRhLmxlbmd0aCAvIDIpIHwgMDtcbiAgICBjb25zdCBsZWZ0ID0gZGF0YS5zbGljZSgwLCBwKTtcbiAgICBjb25zdCByaWdodCA9IGRhdGEuc2xpY2UocCk7XG4gICAgbWVyZ2VTb3J0KGxlZnQsIGNvbXBhcmUpO1xuICAgIG1lcmdlU29ydChyaWdodCwgY29tcGFyZSk7XG4gICAgbGV0IGxlZnRJZHggPSAwO1xuICAgIGxldCByaWdodElkeCA9IDA7XG4gICAgbGV0IGkgPSAwO1xuICAgIHdoaWxlIChsZWZ0SWR4IDwgbGVmdC5sZW5ndGggJiYgcmlnaHRJZHggPCByaWdodC5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gY29tcGFyZShsZWZ0W2xlZnRJZHhdLCByaWdodFtyaWdodElkeF0pO1xuICAgICAgICBpZiAocmV0IDw9IDApIHtcbiAgICAgICAgICAgIC8vIHNtYWxsZXJfZXF1YWwgLT4gdGFrZSBsZWZ0IHRvIHByZXNlcnZlIG9yZGVyXG4gICAgICAgICAgICBkYXRhW2krK10gPSBsZWZ0W2xlZnRJZHgrK107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBncmVhdGVyIC0+IHRha2UgcmlnaHRcbiAgICAgICAgICAgIGRhdGFbaSsrXSA9IHJpZ2h0W3JpZ2h0SWR4KytdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHdoaWxlIChsZWZ0SWR4IDwgbGVmdC5sZW5ndGgpIHtcbiAgICAgICAgZGF0YVtpKytdID0gbGVmdFtsZWZ0SWR4KytdO1xuICAgIH1cbiAgICB3aGlsZSAocmlnaHRJZHggPCByaWdodC5sZW5ndGgpIHtcbiAgICAgICAgZGF0YVtpKytdID0gcmlnaHRbcmlnaHRJZHgrK107XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xufVxuZnVuY3Rpb24gY29tcHV0ZUxpbmVPZmZzZXRzKHRleHQsIGlzQXRMaW5lU3RhcnQsIHRleHRPZmZzZXQgPSAwKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gaXNBdExpbmVTdGFydCA/IFt0ZXh0T2Zmc2V0XSA6IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGV4dC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjaCA9IHRleHQuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGlzRU9MKGNoKSkge1xuICAgICAgICAgICAgaWYgKGNoID09PSAxMyAvKiBDaGFyQ29kZS5DYXJyaWFnZVJldHVybiAqLyAmJiBpICsgMSA8IHRleHQubGVuZ3RoICYmIHRleHQuY2hhckNvZGVBdChpICsgMSkgPT09IDEwIC8qIENoYXJDb2RlLkxpbmVGZWVkICovKSB7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnB1c2godGV4dE9mZnNldCArIGkgKyAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gaXNFT0woY2hhcikge1xuICAgIHJldHVybiBjaGFyID09PSAxMyAvKiBDaGFyQ29kZS5DYXJyaWFnZVJldHVybiAqLyB8fCBjaGFyID09PSAxMCAvKiBDaGFyQ29kZS5MaW5lRmVlZCAqLztcbn1cbmZ1bmN0aW9uIGdldFdlbGxmb3JtZWRSYW5nZShyYW5nZSkge1xuICAgIGNvbnN0IHN0YXJ0ID0gcmFuZ2Uuc3RhcnQ7XG4gICAgY29uc3QgZW5kID0gcmFuZ2UuZW5kO1xuICAgIGlmIChzdGFydC5saW5lID4gZW5kLmxpbmUgfHwgKHN0YXJ0LmxpbmUgPT09IGVuZC5saW5lICYmIHN0YXJ0LmNoYXJhY3RlciA+IGVuZC5jaGFyYWN0ZXIpKSB7XG4gICAgICAgIHJldHVybiB7IHN0YXJ0OiBlbmQsIGVuZDogc3RhcnQgfTtcbiAgICB9XG4gICAgcmV0dXJuIHJhbmdlO1xufVxuZnVuY3Rpb24gZ2V0V2VsbGZvcm1lZEVkaXQodGV4dEVkaXQpIHtcbiAgICBjb25zdCByYW5nZSA9IGdldFdlbGxmb3JtZWRSYW5nZSh0ZXh0RWRpdC5yYW5nZSk7XG4gICAgaWYgKHJhbmdlICE9PSB0ZXh0RWRpdC5yYW5nZSkge1xuICAgICAgICByZXR1cm4geyBuZXdUZXh0OiB0ZXh0RWRpdC5uZXdUZXh0LCByYW5nZSB9O1xuICAgIH1cbiAgICByZXR1cm4gdGV4dEVkaXQ7XG59XG5cblxuLyoqKi8gfSlcblxuLyoqKioqKi8gXHR9KTtcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuLyoqKioqKi8gXHRcdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuLyoqKioqKi8gXHRcdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqLyBcdFxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIFx0Lyogd2VicGFjay9ydW50aW1lL2NvbXBhdCBnZXQgZGVmYXVsdCBleHBvcnQgKi9cbi8qKioqKiovIFx0KCgpID0+IHtcbi8qKioqKiovIFx0XHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IChtb2R1bGUpID0+IHtcbi8qKioqKiovIFx0XHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuLyoqKioqKi8gXHRcdFx0XHQoKSA9PiAobW9kdWxlWydkZWZhdWx0J10pIDpcbi8qKioqKiovIFx0XHRcdFx0KCkgPT4gKG1vZHVsZSk7XG4vKioqKioqLyBcdFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCB7IGE6IGdldHRlciB9KTtcbi8qKioqKiovIFx0XHRcdHJldHVybiBnZXR0ZXI7XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovIFx0fSkoKTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdC8qIHdlYnBhY2svcnVudGltZS9kZWZpbmUgcHJvcGVydHkgZ2V0dGVycyAqL1xuLyoqKioqKi8gXHQoKCkgPT4ge1xuLyoqKioqKi8gXHRcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb25zIGZvciBoYXJtb255IGV4cG9ydHNcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSAoZXhwb3J0cywgZGVmaW5pdGlvbikgPT4ge1xuLyoqKioqKi8gXHRcdFx0Zm9yKHZhciBrZXkgaW4gZGVmaW5pdGlvbikge1xuLyoqKioqKi8gXHRcdFx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZGVmaW5pdGlvbiwga2V5KSAmJiAhX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIGtleSkpIHtcbi8qKioqKiovIFx0XHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuLyoqKioqKi8gXHRcdFx0XHR9XG4vKioqKioqLyBcdFx0XHR9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovIFx0fSkoKTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdC8qIHdlYnBhY2svcnVudGltZS9nbG9iYWwgKi9cbi8qKioqKiovIFx0KCgpID0+IHtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmcgPSAoZnVuY3Rpb24oKSB7XG4vKioqKioqLyBcdFx0XHRpZiAodHlwZW9mIGdsb2JhbFRoaXMgPT09ICdvYmplY3QnKSByZXR1cm4gZ2xvYmFsVGhpcztcbi8qKioqKiovIFx0XHRcdHRyeSB7XG4vKioqKioqLyBcdFx0XHRcdHJldHVybiB0aGlzIHx8IG5ldyBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuLyoqKioqKi8gXHRcdFx0fSBjYXRjaCAoZSkge1xuLyoqKioqKi8gXHRcdFx0XHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcpIHJldHVybiB3aW5kb3c7XG4vKioqKioqLyBcdFx0XHR9XG4vKioqKioqLyBcdFx0fSkoKTtcbi8qKioqKiovIFx0fSkoKTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdC8qIHdlYnBhY2svcnVudGltZS9oYXNPd25Qcm9wZXJ0eSBzaG9ydGhhbmQgKi9cbi8qKioqKiovIFx0KCgpID0+IHtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSAob2JqLCBwcm9wKSA9PiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkpXG4vKioqKioqLyBcdH0pKCk7XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvKiB3ZWJwYWNrL3J1bnRpbWUvbWFrZSBuYW1lc3BhY2Ugb2JqZWN0ICovXG4vKioqKioqLyBcdCgoKSA9PiB7XG4vKioqKioqLyBcdFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18uciA9IChleHBvcnRzKSA9PiB7XG4vKioqKioqLyBcdFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbi8qKioqKiovIFx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4vKioqKioqLyBcdFx0XHR9XG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqKioqKi8gXHRcdH07XG4vKioqKioqLyBcdH0pKCk7XG4vKioqKioqLyBcdFxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fID0ge307XG4vLyBUaGlzIGVudHJ5IG5lZWQgdG8gYmUgd3JhcHBlZCBpbiBhbiBJSUZFIGJlY2F1c2UgaXQgbmVlZCB0byBiZSBpbiBzdHJpY3QgbW9kZS5cbigoKSA9PiB7XG5cInVzZSBzdHJpY3RcIjtcbi8vIEVTTSBDT01QQVQgRkxBR1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuXG4vLyBFWFBPUlRTXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xuICBMYW5ndWFnZUNsaWVudDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gTGFuZ3VhZ2VDbGllbnQpXG59KTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuLi8uLi9ub2RlX21vZHVsZXMvdnNjb2RlLXdzLWpzb25ycGMvbm9kZV9tb2R1bGVzL3ZzY29kZS1qc29ucnBjL2xpYi9icm93c2VyL21haW4uanNcbnZhciBtYWluID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0ODc5KTtcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi4vLi4vbm9kZV9tb2R1bGVzL3ZzY29kZS13cy1qc29ucnBjL25vZGVfbW9kdWxlcy92c2NvZGUtanNvbnJwYy9saWIvY29tbW9uL21lc3NhZ2VzLmpzXG52YXIgbWVzc2FnZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQzMTMpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4uLy4uL25vZGVfbW9kdWxlcy92c2NvZGUtd3MtanNvbnJwYy9saWIvZGlzcG9zYWJsZS5qc1xuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICogQ29weXJpZ2h0IChjKSAyMDE4LTIwMjIgVHlwZUZveCBHbWJIIChodHRwOi8vd3d3LnR5cGVmb3guaW8pLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cclxuXHJcbmNsYXNzIERpc3Bvc2FibGVDb2xsZWN0aW9uIHtcclxuICAgIGRpc3Bvc2FibGVzID0gW107XHJcbiAgICBkaXNwb3NlKCkge1xyXG4gICAgICAgIHdoaWxlICh0aGlzLmRpc3Bvc2FibGVzLmxlbmd0aCAhPT0gMCkge1xyXG4gICAgICAgICAgICB0aGlzLmRpc3Bvc2FibGVzLnBvcCgpLmRpc3Bvc2UoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBwdXNoKGRpc3Bvc2FibGUpIHtcclxuICAgICAgICBjb25zdCBkaXNwb3NhYmxlcyA9IHRoaXMuZGlzcG9zYWJsZXM7XHJcbiAgICAgICAgZGlzcG9zYWJsZXMucHVzaChkaXNwb3NhYmxlKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBkaXNwb3NlKCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBkaXNwb3NhYmxlcy5pbmRleE9mKGRpc3Bvc2FibGUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRpc3Bvc2FibGVzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59XHJcblxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kaXNwb3NhYmxlLmpzLm1hcFxuLy8gRVhURVJOQUwgTU9EVUxFOiAuLi8uLi9ub2RlX21vZHVsZXMvdnNjb2RlLXdzLWpzb25ycGMvbm9kZV9tb2R1bGVzL3ZzY29kZS1qc29ucnBjL2xpYi9jb21tb24vbWVzc2FnZVJlYWRlci5qc1xudmFyIG1lc3NhZ2VSZWFkZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk4MTMpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4uLy4uL25vZGVfbW9kdWxlcy92c2NvZGUtd3MtanNvbnJwYy9saWIvc29ja2V0L3JlYWRlci5qc1xuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICogQ29weXJpZ2h0IChjKSAyMDE4LTIwMjIgVHlwZUZveCBHbWJIIChodHRwOi8vd3d3LnR5cGVmb3guaW8pLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cclxuXHJcbmNsYXNzIFdlYlNvY2tldE1lc3NhZ2VSZWFkZXIgZXh0ZW5kcyBtZXNzYWdlUmVhZGVyLkFic3RyYWN0TWVzc2FnZVJlYWRlciB7XHJcbiAgICBzb2NrZXQ7XHJcbiAgICBzdGF0ZSA9ICdpbml0aWFsJztcclxuICAgIGNhbGxiYWNrO1xyXG4gICAgZXZlbnRzID0gW107XHJcbiAgICBjb25zdHJ1Y3Rvcihzb2NrZXQpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuc29ja2V0ID0gc29ja2V0O1xyXG4gICAgICAgIHRoaXMuc29ja2V0Lm9uTWVzc2FnZShtZXNzYWdlID0+IHRoaXMucmVhZE1lc3NhZ2UobWVzc2FnZSkpO1xyXG4gICAgICAgIHRoaXMuc29ja2V0Lm9uRXJyb3IoZXJyb3IgPT4gdGhpcy5maXJlRXJyb3IoZXJyb3IpKTtcclxuICAgICAgICB0aGlzLnNvY2tldC5vbkNsb3NlKChjb2RlLCByZWFzb24pID0+IHtcclxuICAgICAgICAgICAgaWYgKGNvZGUgIT09IDEwMDApIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICcnICsgY29kZSxcclxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBgRXJyb3IgZHVyaW5nIHNvY2tldCByZWNvbm5lY3Q6IGNvZGUgPSAke2NvZGV9LCByZWFzb24gPSAke3JlYXNvbn1gXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5maXJlRXJyb3IoZXJyb3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuZmlyZUNsb3NlKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBsaXN0ZW4oY2FsbGJhY2spIHtcclxuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gJ2luaXRpYWwnKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAnbGlzdGVuaW5nJztcclxuICAgICAgICAgICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xyXG4gICAgICAgICAgICB3aGlsZSAodGhpcy5ldmVudHMubGVuZ3RoICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBldmVudCA9IHRoaXMuZXZlbnRzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50Lm1lc3NhZ2UpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWRNZXNzYWdlKGV2ZW50Lm1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnQuZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpcmVFcnJvcihldmVudC5lcnJvcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpcmVDbG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGRpc3Bvc2U6ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNhbGxiYWNrID09PSBjYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FsbGJhY2sgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgcmVhZE1lc3NhZ2UobWVzc2FnZSkge1xyXG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSAnaW5pdGlhbCcpIHtcclxuICAgICAgICAgICAgdGhpcy5ldmVudHMuc3BsaWNlKDAsIDAsIHsgbWVzc2FnZSB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5zdGF0ZSA9PT0gJ2xpc3RlbmluZycpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBKU09OLnBhcnNlKG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jYWxsYmFjayhkYXRhKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IHtcclxuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnJyArIDQwMCxcclxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBgRXJyb3IgZHVyaW5nIG1lc3NhZ2UgcGFyc2luZywgcmVhc29uID0gJHt0eXBlb2YgZXJyID09PSAnb2JqZWN0JyA/IGVyci5tZXNzYWdlIDogJ3Vua25vd24nfWBcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB0aGlzLmZpcmVFcnJvcihlcnJvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmaXJlRXJyb3IoZXJyb3IpIHtcclxuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gJ2luaXRpYWwnKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzLnNwbGljZSgwLCAwLCB7IGVycm9yIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLnN0YXRlID09PSAnbGlzdGVuaW5nJykge1xyXG4gICAgICAgICAgICBzdXBlci5maXJlRXJyb3IoZXJyb3IpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZpcmVDbG9zZSgpIHtcclxuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gJ2luaXRpYWwnKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzLnNwbGljZSgwLCAwLCB7fSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc3RhdGUgPT09ICdsaXN0ZW5pbmcnKSB7XHJcbiAgICAgICAgICAgIHN1cGVyLmZpcmVDbG9zZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnN0YXRlID0gJ2Nsb3NlZCc7XHJcbiAgICB9XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVhZGVyLmpzLm1hcFxuLy8gRVhURVJOQUwgTU9EVUxFOiAuLi8uLi9ub2RlX21vZHVsZXMvdnNjb2RlLXdzLWpzb25ycGMvbm9kZV9tb2R1bGVzL3ZzY29kZS1qc29ucnBjL2xpYi9jb21tb24vbWVzc2FnZVdyaXRlci5qc1xudmFyIG1lc3NhZ2VXcml0ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc3NDUpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4uLy4uL25vZGVfbW9kdWxlcy92c2NvZGUtd3MtanNvbnJwYy9saWIvc29ja2V0L3dyaXRlci5qc1xuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICogQ29weXJpZ2h0IChjKSAyMDE4LTIwMjIgVHlwZUZveCBHbWJIIChodHRwOi8vd3d3LnR5cGVmb3guaW8pLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cclxuXHJcbmNsYXNzIFdlYlNvY2tldE1lc3NhZ2VXcml0ZXIgZXh0ZW5kcyBtZXNzYWdlV3JpdGVyLkFic3RyYWN0TWVzc2FnZVdyaXRlciB7XHJcbiAgICBzb2NrZXQ7XHJcbiAgICBlcnJvckNvdW50ID0gMDtcclxuICAgIGNvbnN0cnVjdG9yKHNvY2tldCkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5zb2NrZXQgPSBzb2NrZXQ7XHJcbiAgICB9XHJcbiAgICBlbmQoKSB7XHJcbiAgICB9XHJcbiAgICBhc3luYyB3cml0ZShtc2cpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBjb25zdCBjb250ZW50ID0gSlNPTi5zdHJpbmdpZnkobXNnKTtcclxuICAgICAgICAgICAgdGhpcy5zb2NrZXQuc2VuZChjb250ZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgdGhpcy5lcnJvckNvdW50Kys7XHJcbiAgICAgICAgICAgIHRoaXMuZmlyZUVycm9yKGUsIG1zZywgdGhpcy5lcnJvckNvdW50KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d3JpdGVyLmpzLm1hcFxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4uLy4uL25vZGVfbW9kdWxlcy92c2NvZGUtd3MtanNvbnJwYy9saWIvc29ja2V0L2Nvbm5lY3Rpb24uanNcbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAqIENvcHlyaWdodCAoYykgMjAxOC0yMDIyIFR5cGVGb3ggR21iSCAoaHR0cDovL3d3dy50eXBlZm94LmlvKS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXHJcblxyXG5cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZVdlYlNvY2tldENvbm5lY3Rpb24oc29ja2V0LCBsb2dnZXIpIHtcclxuICAgIGNvbnN0IG1lc3NhZ2VSZWFkZXIgPSBuZXcgV2ViU29ja2V0TWVzc2FnZVJlYWRlcihzb2NrZXQpO1xyXG4gICAgY29uc3QgbWVzc2FnZVdyaXRlciA9IG5ldyBXZWJTb2NrZXRNZXNzYWdlV3JpdGVyKHNvY2tldCk7XHJcbiAgICBjb25zdCBjb25uZWN0aW9uID0gKDAsbWFpbi5jcmVhdGVNZXNzYWdlQ29ubmVjdGlvbikobWVzc2FnZVJlYWRlciwgbWVzc2FnZVdyaXRlciwgbG9nZ2VyKTtcclxuICAgIGNvbm5lY3Rpb24ub25DbG9zZSgoKSA9PiBjb25uZWN0aW9uLmRpc3Bvc2UoKSk7XHJcbiAgICByZXR1cm4gY29ubmVjdGlvbjtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25uZWN0aW9uLmpzLm1hcFxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4uLy4uL25vZGVfbW9kdWxlcy92c2NvZGUtd3MtanNvbnJwYy9saWIvc29ja2V0L2luZGV4LmpzXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTgtMjAyMiBUeXBlRm94IEdtYkggKGh0dHA6Ly93d3cudHlwZWZveC5pbykuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xyXG5cclxuXHJcblxyXG5cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi4vLi4vbm9kZV9tb2R1bGVzL3ZzY29kZS13cy1qc29ucnBjL2xpYi9sb2dnZXIuanNcbi8qIHByb3ZpZGVkIGRlcGVuZGVuY3kgKi8gdmFyIGNvbnNvbGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQzNjQpO1xuY2xhc3MgQ29uc29sZUxvZ2dlciB7XHJcbiAgICBlcnJvcihtZXNzYWdlKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcclxuICAgIH1cclxuICAgIHdhcm4obWVzc2FnZSkge1xyXG4gICAgICAgIGNvbnNvbGUud2FybihtZXNzYWdlKTtcclxuICAgIH1cclxuICAgIGluZm8obWVzc2FnZSkge1xyXG4gICAgICAgIGNvbnNvbGUuaW5mbyhtZXNzYWdlKTtcclxuICAgIH1cclxuICAgIGxvZyhtZXNzYWdlKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2cobWVzc2FnZSk7XHJcbiAgICB9XHJcbiAgICBkZWJ1ZyhtZXNzYWdlKSB7XHJcbiAgICAgICAgY29uc29sZS5kZWJ1ZyhtZXNzYWdlKTtcclxuICAgIH1cclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2dnZXIuanMubWFwXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi4vLi4vbm9kZV9tb2R1bGVzL3ZzY29kZS13cy1qc29ucnBjL2xpYi9jb25uZWN0aW9uLmpzXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTgtMjAyMiBUeXBlRm94IEdtYkggKGh0dHA6Ly93d3cudHlwZWZveC5pbykuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xyXG5cclxuXHJcbmZ1bmN0aW9uIGxpc3RlbihvcHRpb25zKSB7XHJcbiAgICBjb25zdCB7IHdlYlNvY2tldCwgb25Db25uZWN0aW9uIH0gPSBvcHRpb25zO1xyXG4gICAgY29uc3QgbG9nZ2VyID0gb3B0aW9ucy5sb2dnZXIgfHwgbmV3IENvbnNvbGVMb2dnZXIoKTtcclxuICAgIHdlYlNvY2tldC5vbm9wZW4gPSAoKSA9PiB7XHJcbiAgICAgICAgY29uc3Qgc29ja2V0ID0gdG9Tb2NrZXQod2ViU29ja2V0KTtcclxuICAgICAgICBjb25zdCBjb25uZWN0aW9uID0gY3JlYXRlV2ViU29ja2V0Q29ubmVjdGlvbihzb2NrZXQsIGxvZ2dlcik7XHJcbiAgICAgICAgb25Db25uZWN0aW9uKGNvbm5lY3Rpb24pO1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiB0b1NvY2tldCh3ZWJTb2NrZXQpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgc2VuZDogY29udGVudCA9PiB3ZWJTb2NrZXQuc2VuZChjb250ZW50KSxcclxuICAgICAgICBvbk1lc3NhZ2U6IGNiID0+IHtcclxuICAgICAgICAgICAgd2ViU29ja2V0Lm9ubWVzc2FnZSA9IGV2ZW50ID0+IGNiKGV2ZW50LmRhdGEpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb25FcnJvcjogY2IgPT4ge1xyXG4gICAgICAgICAgICB3ZWJTb2NrZXQub25lcnJvciA9IGV2ZW50ID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICgnbWVzc2FnZScgaW4gZXZlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYihldmVudC5tZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG9uQ2xvc2U6IGNiID0+IHtcclxuICAgICAgICAgICAgd2ViU29ja2V0Lm9uY2xvc2UgPSBldmVudCA9PiBjYihldmVudC5jb2RlLCBldmVudC5yZWFzb24pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZGlzcG9zZTogKCkgPT4gd2ViU29ja2V0LmNsb3NlKClcclxuICAgIH07XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29ubmVjdGlvbi5qcy5tYXBcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuLi8uLi9ub2RlX21vZHVsZXMvdnNjb2RlLXdzLWpzb25ycGMvbGliL2luZGV4LmpzXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTgtMjAyMiBUeXBlRm94IEdtYkggKGh0dHA6Ly93d3cudHlwZWZveC5pbykuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi4vLi4vbm9kZV9tb2R1bGVzL3ZzY29kZS1sYW5ndWFnZXNlcnZlci1wcm90b2NvbC9saWIvYnJvd3Nlci9tYWluLmpzXG52YXIgYnJvd3Nlcl9tYWluID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NTAxKTtcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi4vLi4vbm9kZV9tb2R1bGVzL3ZzY29kZS1sYW5ndWFnZXNlcnZlci1wcm90b2NvbC9icm93c2VyLmpzXG52YXIgYnJvd3NlciA9IF9fd2VicGFja19yZXF1aXJlX18oODcxMyk7XG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vc3JjL3NlcnZpY2VzL2Jhc2Utc2VydmljZS50c1xudmFyIGJhc2Vfc2VydmljZSA9IF9fd2VicGFja19yZXF1aXJlX18oMjEyNSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvbWVzc2FnZS10eXBlcy50c1xuZnVuY3Rpb24gX2RlZmluZV9wcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgICBpZiAoa2V5IGluIG9iaikge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBvYmpba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gb2JqO1xufVxuY2xhc3MgQmFzZU1lc3NhZ2Uge1xuICAgIGNvbnN0cnVjdG9yKGRvY3VtZW50SWRlbnRpZmllciwgY2FsbGJhY2tJZCl7XG4gICAgICAgIF9kZWZpbmVfcHJvcGVydHkodGhpcywgXCJzZXNzaW9uSWRcIiwgdm9pZCAwKTtcbiAgICAgICAgX2RlZmluZV9wcm9wZXJ0eSh0aGlzLCBcImRvY3VtZW50VXJpXCIsIHZvaWQgMCk7XG4gICAgICAgIF9kZWZpbmVfcHJvcGVydHkodGhpcywgXCJ2ZXJzaW9uXCIsIHZvaWQgMCk7XG4gICAgICAgIF9kZWZpbmVfcHJvcGVydHkodGhpcywgXCJjYWxsYmFja0lkXCIsIHZvaWQgMCk7XG4gICAgICAgIHRoaXMuc2Vzc2lvbklkID0gZG9jdW1lbnRJZGVudGlmaWVyLnNlc3Npb25JZDtcbiAgICAgICAgdGhpcy5kb2N1bWVudFVyaSA9IGRvY3VtZW50SWRlbnRpZmllci5kb2N1bWVudFVyaTtcbiAgICAgICAgdGhpcy5jYWxsYmFja0lkID0gY2FsbGJhY2tJZDtcbiAgICB9XG59XG5jbGFzcyBJbml0TWVzc2FnZSBleHRlbmRzIEJhc2VNZXNzYWdlIHtcbiAgICBjb25zdHJ1Y3Rvcihkb2N1bWVudElkZW50aWZpZXIsIGNhbGxiYWNrSWQsIHZhbHVlLCB2ZXJzaW9uLCBtb2RlLCBvcHRpb25zKXtcbiAgICAgICAgc3VwZXIoZG9jdW1lbnRJZGVudGlmaWVyLCBjYWxsYmFja0lkKTtcbiAgICAgICAgX2RlZmluZV9wcm9wZXJ0eSh0aGlzLCBcInR5cGVcIiwgTWVzc2FnZVR5cGUuaW5pdCk7XG4gICAgICAgIF9kZWZpbmVfcHJvcGVydHkodGhpcywgXCJtb2RlXCIsIHZvaWQgMCk7XG4gICAgICAgIF9kZWZpbmVfcHJvcGVydHkodGhpcywgXCJvcHRpb25zXCIsIHZvaWQgMCk7XG4gICAgICAgIF9kZWZpbmVfcHJvcGVydHkodGhpcywgXCJ2YWx1ZVwiLCB2b2lkIDApO1xuICAgICAgICBfZGVmaW5lX3Byb3BlcnR5KHRoaXMsIFwidmVyc2lvblwiLCB2b2lkIDApO1xuICAgICAgICB0aGlzLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLm1vZGUgPSBtb2RlO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxufVxuY2xhc3MgRm9ybWF0TWVzc2FnZSBleHRlbmRzIEJhc2VNZXNzYWdlIHtcbiAgICBjb25zdHJ1Y3Rvcihkb2N1bWVudElkZW50aWZpZXIsIGNhbGxiYWNrSWQsIHZhbHVlLCBmb3JtYXQpe1xuICAgICAgICBzdXBlcihkb2N1bWVudElkZW50aWZpZXIsIGNhbGxiYWNrSWQpO1xuICAgICAgICBfZGVmaW5lX3Byb3BlcnR5KHRoaXMsIFwidHlwZVwiLCBNZXNzYWdlVHlwZS5mb3JtYXQpO1xuICAgICAgICBfZGVmaW5lX3Byb3BlcnR5KHRoaXMsIFwidmFsdWVcIiwgdm9pZCAwKTtcbiAgICAgICAgX2RlZmluZV9wcm9wZXJ0eSh0aGlzLCBcImZvcm1hdFwiLCB2b2lkIDApO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuZm9ybWF0ID0gZm9ybWF0O1xuICAgIH1cbn1cbmNsYXNzIENvbXBsZXRlTWVzc2FnZSBleHRlbmRzIEJhc2VNZXNzYWdlIHtcbiAgICBjb25zdHJ1Y3Rvcihkb2N1bWVudElkZW50aWZpZXIsIGNhbGxiYWNrSWQsIHZhbHVlKXtcbiAgICAgICAgc3VwZXIoZG9jdW1lbnRJZGVudGlmaWVyLCBjYWxsYmFja0lkKTtcbiAgICAgICAgX2RlZmluZV9wcm9wZXJ0eSh0aGlzLCBcInR5cGVcIiwgTWVzc2FnZVR5cGUuY29tcGxldGUpO1xuICAgICAgICBfZGVmaW5lX3Byb3BlcnR5KHRoaXMsIFwidmFsdWVcIiwgdm9pZCAwKTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbn1cbmNsYXNzIFJlc29sdmVDb21wbGV0aW9uTWVzc2FnZSBleHRlbmRzIEJhc2VNZXNzYWdlIHtcbiAgICBjb25zdHJ1Y3Rvcihkb2N1bWVudElkZW50aWZpZXIsIGNhbGxiYWNrSWQsIHZhbHVlKXtcbiAgICAgICAgc3VwZXIoZG9jdW1lbnRJZGVudGlmaWVyLCBjYWxsYmFja0lkKTtcbiAgICAgICAgX2RlZmluZV9wcm9wZXJ0eSh0aGlzLCBcInR5cGVcIiwgTWVzc2FnZVR5cGUucmVzb2x2ZUNvbXBsZXRpb24pO1xuICAgICAgICBfZGVmaW5lX3Byb3BlcnR5KHRoaXMsIFwidmFsdWVcIiwgdm9pZCAwKTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbn1cbmNsYXNzIEhvdmVyTWVzc2FnZSBleHRlbmRzIEJhc2VNZXNzYWdlIHtcbiAgICBjb25zdHJ1Y3Rvcihkb2N1bWVudElkZW50aWZpZXIsIGNhbGxiYWNrSWQsIHZhbHVlKXtcbiAgICAgICAgc3VwZXIoZG9jdW1lbnRJZGVudGlmaWVyLCBjYWxsYmFja0lkKTtcbiAgICAgICAgX2RlZmluZV9wcm9wZXJ0eSh0aGlzLCBcInR5cGVcIiwgTWVzc2FnZVR5cGUuaG92ZXIpO1xuICAgICAgICBfZGVmaW5lX3Byb3BlcnR5KHRoaXMsIFwidmFsdWVcIiwgdm9pZCAwKTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbn1cbmNsYXNzIFZhbGlkYXRlTWVzc2FnZSBleHRlbmRzIEJhc2VNZXNzYWdlIHtcbiAgICBjb25zdHJ1Y3Rvcihkb2N1bWVudElkZW50aWZpZXIsIGNhbGxiYWNrSWQpe1xuICAgICAgICBzdXBlcihkb2N1bWVudElkZW50aWZpZXIsIGNhbGxiYWNrSWQpO1xuICAgICAgICBfZGVmaW5lX3Byb3BlcnR5KHRoaXMsIFwidHlwZVwiLCBNZXNzYWdlVHlwZS52YWxpZGF0ZSk7XG4gICAgfVxufVxuY2xhc3MgQ2hhbmdlTWVzc2FnZSBleHRlbmRzIEJhc2VNZXNzYWdlIHtcbiAgICBjb25zdHJ1Y3Rvcihkb2N1bWVudElkZW50aWZpZXIsIGNhbGxiYWNrSWQsIHZhbHVlLCB2ZXJzaW9uKXtcbiAgICAgICAgc3VwZXIoZG9jdW1lbnRJZGVudGlmaWVyLCBjYWxsYmFja0lkKTtcbiAgICAgICAgX2RlZmluZV9wcm9wZXJ0eSh0aGlzLCBcInR5cGVcIiwgTWVzc2FnZVR5cGUuY2hhbmdlKTtcbiAgICAgICAgX2RlZmluZV9wcm9wZXJ0eSh0aGlzLCBcInZhbHVlXCIsIHZvaWQgMCk7XG4gICAgICAgIF9kZWZpbmVfcHJvcGVydHkodGhpcywgXCJ2ZXJzaW9uXCIsIHZvaWQgMCk7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICB9XG59XG5jbGFzcyBEZWx0YXNNZXNzYWdlIGV4dGVuZHMgQmFzZU1lc3NhZ2Uge1xuICAgIGNvbnN0cnVjdG9yKGRvY3VtZW50SWRlbnRpZmllciwgY2FsbGJhY2tJZCwgdmFsdWUsIHZlcnNpb24pe1xuICAgICAgICBzdXBlcihkb2N1bWVudElkZW50aWZpZXIsIGNhbGxiYWNrSWQpO1xuICAgICAgICBfZGVmaW5lX3Byb3BlcnR5KHRoaXMsIFwidHlwZVwiLCBNZXNzYWdlVHlwZS5hcHBseURlbHRhKTtcbiAgICAgICAgX2RlZmluZV9wcm9wZXJ0eSh0aGlzLCBcInZhbHVlXCIsIHZvaWQgMCk7XG4gICAgICAgIF9kZWZpbmVfcHJvcGVydHkodGhpcywgXCJ2ZXJzaW9uXCIsIHZvaWQgMCk7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICB9XG59XG5jbGFzcyBDaGFuZ2VNb2RlTWVzc2FnZSBleHRlbmRzIEJhc2VNZXNzYWdlIHtcbiAgICBjb25zdHJ1Y3Rvcihkb2N1bWVudElkZW50aWZpZXIsIGNhbGxiYWNrSWQsIHZhbHVlLCB2ZXJzaW9uLCBtb2RlKXtcbiAgICAgICAgc3VwZXIoZG9jdW1lbnRJZGVudGlmaWVyLCBjYWxsYmFja0lkKTtcbiAgICAgICAgX2RlZmluZV9wcm9wZXJ0eSh0aGlzLCBcInR5cGVcIiwgTWVzc2FnZVR5cGUuY2hhbmdlTW9kZSk7XG4gICAgICAgIF9kZWZpbmVfcHJvcGVydHkodGhpcywgXCJtb2RlXCIsIHZvaWQgMCk7XG4gICAgICAgIF9kZWZpbmVfcHJvcGVydHkodGhpcywgXCJ2YWx1ZVwiLCB2b2lkIDApO1xuICAgICAgICBfZGVmaW5lX3Byb3BlcnR5KHRoaXMsIFwidmVyc2lvblwiLCB2b2lkIDApO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMubW9kZSA9IG1vZGU7XG4gICAgICAgIHRoaXMudmVyc2lvbiA9IHZlcnNpb247XG4gICAgfVxufVxuY2xhc3MgQ2hhbmdlT3B0aW9uc01lc3NhZ2UgZXh0ZW5kcyBCYXNlTWVzc2FnZSB7XG4gICAgY29uc3RydWN0b3IoZG9jdW1lbnRJZGVudGlmaWVyLCBjYWxsYmFja0lkLCBvcHRpb25zLCBtZXJnZSA9IGZhbHNlKXtcbiAgICAgICAgc3VwZXIoZG9jdW1lbnRJZGVudGlmaWVyLCBjYWxsYmFja0lkKTtcbiAgICAgICAgX2RlZmluZV9wcm9wZXJ0eSh0aGlzLCBcInR5cGVcIiwgTWVzc2FnZVR5cGUuY2hhbmdlT3B0aW9ucyk7XG4gICAgICAgIF9kZWZpbmVfcHJvcGVydHkodGhpcywgXCJvcHRpb25zXCIsIHZvaWQgMCk7XG4gICAgICAgIF9kZWZpbmVfcHJvcGVydHkodGhpcywgXCJtZXJnZVwiLCB2b2lkIDApO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLm1lcmdlID0gbWVyZ2U7XG4gICAgfVxufVxuY2xhc3MgQ2xvc2VEb2N1bWVudE1lc3NhZ2UgZXh0ZW5kcyBCYXNlTWVzc2FnZSB7XG4gICAgY29uc3RydWN0b3IoZG9jdW1lbnRJZGVudGlmaWVyLCBjYWxsYmFja0lkKXtcbiAgICAgICAgc3VwZXIoZG9jdW1lbnRJZGVudGlmaWVyLCBjYWxsYmFja0lkKTtcbiAgICAgICAgX2RlZmluZV9wcm9wZXJ0eSh0aGlzLCBcInR5cGVcIiwgTWVzc2FnZVR5cGUuY2xvc2VEb2N1bWVudCk7XG4gICAgfVxufVxuY2xhc3MgQ2xvc2VDb25uZWN0aW9uTWVzc2FnZSB7XG4gICAgY29uc3RydWN0b3IoY2FsbGJhY2tJZCl7XG4gICAgICAgIF9kZWZpbmVfcHJvcGVydHkodGhpcywgXCJ0eXBlXCIsIE1lc3NhZ2VUeXBlLmNsb3NlQ29ubmVjdGlvbik7XG4gICAgICAgIF9kZWZpbmVfcHJvcGVydHkodGhpcywgXCJjYWxsYmFja0lkXCIsIHZvaWQgMCk7XG4gICAgICAgIHRoaXMuY2FsbGJhY2tJZCA9IGNhbGxiYWNrSWQ7XG4gICAgfVxufVxuY2xhc3MgR2xvYmFsT3B0aW9uc01lc3NhZ2Uge1xuICAgIGNvbnN0cnVjdG9yKHNlcnZpY2VOYW1lLCBvcHRpb25zLCBtZXJnZSl7XG4gICAgICAgIF9kZWZpbmVfcHJvcGVydHkodGhpcywgXCJ0eXBlXCIsIE1lc3NhZ2VUeXBlLmdsb2JhbE9wdGlvbnMpO1xuICAgICAgICBfZGVmaW5lX3Byb3BlcnR5KHRoaXMsIFwic2VydmljZU5hbWVcIiwgdm9pZCAwKTtcbiAgICAgICAgX2RlZmluZV9wcm9wZXJ0eSh0aGlzLCBcIm9wdGlvbnNcIiwgdm9pZCAwKTtcbiAgICAgICAgX2RlZmluZV9wcm9wZXJ0eSh0aGlzLCBcIm1lcmdlXCIsIHZvaWQgMCk7XG4gICAgICAgIHRoaXMuc2VydmljZU5hbWUgPSBzZXJ2aWNlTmFtZTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5tZXJnZSA9IG1lcmdlO1xuICAgIH1cbn1cbmNsYXNzIENvbmZpZ3VyZUZlYXR1cmVzTWVzc2FnZSB7XG4gICAgY29uc3RydWN0b3Ioc2VydmljZU5hbWUsIG9wdGlvbnMpe1xuICAgICAgICBfZGVmaW5lX3Byb3BlcnR5KHRoaXMsIFwidHlwZVwiLCBNZXNzYWdlVHlwZS5jb25maWd1cmVGZWF0dXJlcyk7XG4gICAgICAgIF9kZWZpbmVfcHJvcGVydHkodGhpcywgXCJzZXJ2aWNlTmFtZVwiLCB2b2lkIDApO1xuICAgICAgICBfZGVmaW5lX3Byb3BlcnR5KHRoaXMsIFwib3B0aW9uc1wiLCB2b2lkIDApO1xuICAgICAgICB0aGlzLnNlcnZpY2VOYW1lID0gc2VydmljZU5hbWU7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgfVxufVxuY2xhc3MgU2lnbmF0dXJlSGVscE1lc3NhZ2UgZXh0ZW5kcyBCYXNlTWVzc2FnZSB7XG4gICAgY29uc3RydWN0b3IoZG9jdW1lbnRJZGVudGlmaWVyLCBjYWxsYmFja0lkLCB2YWx1ZSl7XG4gICAgICAgIHN1cGVyKGRvY3VtZW50SWRlbnRpZmllciwgY2FsbGJhY2tJZCk7XG4gICAgICAgIF9kZWZpbmVfcHJvcGVydHkodGhpcywgXCJ0eXBlXCIsIE1lc3NhZ2VUeXBlLnNpZ25hdHVyZUhlbHApO1xuICAgICAgICBfZGVmaW5lX3Byb3BlcnR5KHRoaXMsIFwidmFsdWVcIiwgdm9pZCAwKTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbn1cbmNsYXNzIERvY3VtZW50SGlnaGxpZ2h0TWVzc2FnZSBleHRlbmRzIEJhc2VNZXNzYWdlIHtcbiAgICBjb25zdHJ1Y3Rvcihkb2N1bWVudElkZW50aWZpZXIsIGNhbGxiYWNrSWQsIHZhbHVlKXtcbiAgICAgICAgc3VwZXIoZG9jdW1lbnRJZGVudGlmaWVyLCBjYWxsYmFja0lkKTtcbiAgICAgICAgX2RlZmluZV9wcm9wZXJ0eSh0aGlzLCBcInR5cGVcIiwgTWVzc2FnZVR5cGUuZG9jdW1lbnRIaWdobGlnaHQpO1xuICAgICAgICBfZGVmaW5lX3Byb3BlcnR5KHRoaXMsIFwidmFsdWVcIiwgdm9pZCAwKTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbn1cbmNsYXNzIEdldFNlbWFudGljVG9rZW5zTWVzc2FnZSBleHRlbmRzIEJhc2VNZXNzYWdlIHtcbiAgICBjb25zdHJ1Y3Rvcihkb2N1bWVudElkZW50aWZpZXIsIGNhbGxiYWNrSWQsIHZhbHVlKXtcbiAgICAgICAgc3VwZXIoZG9jdW1lbnRJZGVudGlmaWVyLCBjYWxsYmFja0lkKTtcbiAgICAgICAgX2RlZmluZV9wcm9wZXJ0eSh0aGlzLCBcInR5cGVcIiwgTWVzc2FnZVR5cGUuZ2V0U2VtYW50aWNUb2tlbnMpO1xuICAgICAgICBfZGVmaW5lX3Byb3BlcnR5KHRoaXMsIFwidmFsdWVcIiwgdm9pZCAwKTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbn1cbmNsYXNzIEdldENvZGVBY3Rpb25zTWVzc2FnZSBleHRlbmRzIEJhc2VNZXNzYWdlIHtcbiAgICBjb25zdHJ1Y3Rvcihkb2N1bWVudElkZW50aWZpZXIsIGNhbGxiYWNrSWQsIHZhbHVlLCBjb250ZXh0KXtcbiAgICAgICAgc3VwZXIoZG9jdW1lbnRJZGVudGlmaWVyLCBjYWxsYmFja0lkKTtcbiAgICAgICAgX2RlZmluZV9wcm9wZXJ0eSh0aGlzLCBcInR5cGVcIiwgTWVzc2FnZVR5cGUuZ2V0Q29kZUFjdGlvbnMpO1xuICAgICAgICBfZGVmaW5lX3Byb3BlcnR5KHRoaXMsIFwidmFsdWVcIiwgdm9pZCAwKTtcbiAgICAgICAgX2RlZmluZV9wcm9wZXJ0eSh0aGlzLCBcImNvbnRleHRcIiwgdm9pZCAwKTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIH1cbn1cbmNsYXNzIFNldFdvcmtzcGFjZU1lc3NhZ2Uge1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlKXtcbiAgICAgICAgX2RlZmluZV9wcm9wZXJ0eSh0aGlzLCBcInR5cGVcIiwgTWVzc2FnZVR5cGUuc2V0V29ya3NwYWNlKTtcbiAgICAgICAgX2RlZmluZV9wcm9wZXJ0eSh0aGlzLCBcInZhbHVlXCIsIHZvaWQgMCk7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG59XG5jbGFzcyBFeGVjdXRlQ29tbWFuZE1lc3NhZ2Uge1xuICAgIGNvbnN0cnVjdG9yKHNlcnZpY2VOYW1lLCBjYWxsYmFja0lkLCBjb21tYW5kLCBhcmdzKXtcbiAgICAgICAgX2RlZmluZV9wcm9wZXJ0eSh0aGlzLCBcImNhbGxiYWNrSWRcIiwgdm9pZCAwKTtcbiAgICAgICAgX2RlZmluZV9wcm9wZXJ0eSh0aGlzLCBcInNlcnZpY2VOYW1lXCIsIHZvaWQgMCk7XG4gICAgICAgIF9kZWZpbmVfcHJvcGVydHkodGhpcywgXCJ0eXBlXCIsIE1lc3NhZ2VUeXBlLmV4ZWN1dGVDb21tYW5kKTtcbiAgICAgICAgX2RlZmluZV9wcm9wZXJ0eSh0aGlzLCBcInZhbHVlXCIsIHZvaWQgMCk7XG4gICAgICAgIF9kZWZpbmVfcHJvcGVydHkodGhpcywgXCJhcmdzXCIsIHZvaWQgMCk7XG4gICAgICAgIHRoaXMuc2VydmljZU5hbWUgPSBzZXJ2aWNlTmFtZTtcbiAgICAgICAgdGhpcy5jYWxsYmFja0lkID0gY2FsbGJhY2tJZDtcbiAgICAgICAgdGhpcy52YWx1ZSA9IGNvbW1hbmQ7XG4gICAgICAgIHRoaXMuYXJncyA9IGFyZ3M7XG4gICAgfVxufVxuY2xhc3MgQXBwbGllZEVkaXRNZXNzYWdlIHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSwgc2VydmljZU5hbWUsIGNhbGxiYWNrSWQpe1xuICAgICAgICBfZGVmaW5lX3Byb3BlcnR5KHRoaXMsIFwiY2FsbGJhY2tJZFwiLCB2b2lkIDApO1xuICAgICAgICBfZGVmaW5lX3Byb3BlcnR5KHRoaXMsIFwic2VydmljZU5hbWVcIiwgdm9pZCAwKTtcbiAgICAgICAgX2RlZmluZV9wcm9wZXJ0eSh0aGlzLCBcInR5cGVcIiwgTWVzc2FnZVR5cGUuYXBwbGllZEVkaXQpO1xuICAgICAgICBfZGVmaW5lX3Byb3BlcnR5KHRoaXMsIFwidmFsdWVcIiwgdm9pZCAwKTtcbiAgICAgICAgdGhpcy5zZXJ2aWNlTmFtZSA9IHNlcnZpY2VOYW1lO1xuICAgICAgICB0aGlzLmNhbGxiYWNrSWQgPSBjYWxsYmFja0lkO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxufVxudmFyIE1lc3NhZ2VUeXBlO1xuKGZ1bmN0aW9uKE1lc3NhZ2VUeXBlKSB7XG4gICAgTWVzc2FnZVR5cGVbTWVzc2FnZVR5cGVbXCJpbml0XCJdID0gMF0gPSBcImluaXRcIjtcbiAgICBNZXNzYWdlVHlwZVtNZXNzYWdlVHlwZVtcImZvcm1hdFwiXSA9IDFdID0gXCJmb3JtYXRcIjtcbiAgICBNZXNzYWdlVHlwZVtNZXNzYWdlVHlwZVtcImNvbXBsZXRlXCJdID0gMl0gPSBcImNvbXBsZXRlXCI7XG4gICAgTWVzc2FnZVR5cGVbTWVzc2FnZVR5cGVbXCJyZXNvbHZlQ29tcGxldGlvblwiXSA9IDNdID0gXCJyZXNvbHZlQ29tcGxldGlvblwiO1xuICAgIE1lc3NhZ2VUeXBlW01lc3NhZ2VUeXBlW1wiY2hhbmdlXCJdID0gNF0gPSBcImNoYW5nZVwiO1xuICAgIE1lc3NhZ2VUeXBlW01lc3NhZ2VUeXBlW1wiaG92ZXJcIl0gPSA1XSA9IFwiaG92ZXJcIjtcbiAgICBNZXNzYWdlVHlwZVtNZXNzYWdlVHlwZVtcInZhbGlkYXRlXCJdID0gNl0gPSBcInZhbGlkYXRlXCI7XG4gICAgTWVzc2FnZVR5cGVbTWVzc2FnZVR5cGVbXCJhcHBseURlbHRhXCJdID0gN10gPSBcImFwcGx5RGVsdGFcIjtcbiAgICBNZXNzYWdlVHlwZVtNZXNzYWdlVHlwZVtcImNoYW5nZU1vZGVcIl0gPSA4XSA9IFwiY2hhbmdlTW9kZVwiO1xuICAgIE1lc3NhZ2VUeXBlW01lc3NhZ2VUeXBlW1wiY2hhbmdlT3B0aW9uc1wiXSA9IDldID0gXCJjaGFuZ2VPcHRpb25zXCI7XG4gICAgTWVzc2FnZVR5cGVbTWVzc2FnZVR5cGVbXCJjbG9zZURvY3VtZW50XCJdID0gMTBdID0gXCJjbG9zZURvY3VtZW50XCI7XG4gICAgTWVzc2FnZVR5cGVbTWVzc2FnZVR5cGVbXCJnbG9iYWxPcHRpb25zXCJdID0gMTFdID0gXCJnbG9iYWxPcHRpb25zXCI7XG4gICAgTWVzc2FnZVR5cGVbTWVzc2FnZVR5cGVbXCJjb25maWd1cmVGZWF0dXJlc1wiXSA9IDEyXSA9IFwiY29uZmlndXJlRmVhdHVyZXNcIjtcbiAgICBNZXNzYWdlVHlwZVtNZXNzYWdlVHlwZVtcInNpZ25hdHVyZUhlbHBcIl0gPSAxM10gPSBcInNpZ25hdHVyZUhlbHBcIjtcbiAgICBNZXNzYWdlVHlwZVtNZXNzYWdlVHlwZVtcImRvY3VtZW50SGlnaGxpZ2h0XCJdID0gMTRdID0gXCJkb2N1bWVudEhpZ2hsaWdodFwiO1xuICAgIE1lc3NhZ2VUeXBlW01lc3NhZ2VUeXBlW1wiY2xvc2VDb25uZWN0aW9uXCJdID0gMTVdID0gXCJjbG9zZUNvbm5lY3Rpb25cIjtcbiAgICBNZXNzYWdlVHlwZVtNZXNzYWdlVHlwZVtcImNhcGFiaWxpdGllc0NoYW5nZVwiXSA9IDE2XSA9IFwiY2FwYWJpbGl0aWVzQ2hhbmdlXCI7XG4gICAgTWVzc2FnZVR5cGVbTWVzc2FnZVR5cGVbXCJnZXRTZW1hbnRpY1Rva2Vuc1wiXSA9IDE3XSA9IFwiZ2V0U2VtYW50aWNUb2tlbnNcIjtcbiAgICBNZXNzYWdlVHlwZVtNZXNzYWdlVHlwZVtcImdldENvZGVBY3Rpb25zXCJdID0gMThdID0gXCJnZXRDb2RlQWN0aW9uc1wiO1xuICAgIE1lc3NhZ2VUeXBlW01lc3NhZ2VUeXBlW1wiZXhlY3V0ZUNvbW1hbmRcIl0gPSAxOV0gPSBcImV4ZWN1dGVDb21tYW5kXCI7XG4gICAgTWVzc2FnZVR5cGVbTWVzc2FnZVR5cGVbXCJhcHBseUVkaXRcIl0gPSAyMF0gPSBcImFwcGx5RWRpdFwiO1xuICAgIE1lc3NhZ2VUeXBlW01lc3NhZ2VUeXBlW1wiYXBwbGllZEVkaXRcIl0gPSAyMV0gPSBcImFwcGxpZWRFZGl0XCI7XG4gICAgTWVzc2FnZVR5cGVbTWVzc2FnZVR5cGVbXCJzZXRXb3Jrc3BhY2VcIl0gPSAyMl0gPSBcInNldFdvcmtzcGFjZVwiO1xufSkoTWVzc2FnZVR5cGUgfHwgKE1lc3NhZ2VUeXBlID0ge30pKTtcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4uLy4uL25vZGVfbW9kdWxlcy92c2NvZGUtdXJpL2xpYi9lc20vaW5kZXgubWpzXG4vKiBwcm92aWRlZCBkZXBlbmRlbmN5ICovIHZhciBwcm9jZXNzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5OTA3KTtcbnZhciBMSUI7KCgpPT57XCJ1c2Ugc3RyaWN0XCI7dmFyIHQ9ezQ3MDp0PT57ZnVuY3Rpb24gZSh0KXtpZihcInN0cmluZ1wiIT10eXBlb2YgdCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiUGF0aCBtdXN0IGJlIGEgc3RyaW5nLiBSZWNlaXZlZCBcIitKU09OLnN0cmluZ2lmeSh0KSl9ZnVuY3Rpb24gcih0LGUpe2Zvcih2YXIgcixuPVwiXCIsaT0wLG89LTEscz0wLGg9MDtoPD10Lmxlbmd0aDsrK2gpe2lmKGg8dC5sZW5ndGgpcj10LmNoYXJDb2RlQXQoaCk7ZWxzZXtpZig0Nz09PXIpYnJlYWs7cj00N31pZig0Nz09PXIpe2lmKG89PT1oLTF8fDE9PT1zKTtlbHNlIGlmKG8hPT1oLTEmJjI9PT1zKXtpZihuLmxlbmd0aDwyfHwyIT09aXx8NDYhPT1uLmNoYXJDb2RlQXQobi5sZW5ndGgtMSl8fDQ2IT09bi5jaGFyQ29kZUF0KG4ubGVuZ3RoLTIpKWlmKG4ubGVuZ3RoPjIpe3ZhciBhPW4ubGFzdEluZGV4T2YoXCIvXCIpO2lmKGEhPT1uLmxlbmd0aC0xKXstMT09PWE/KG49XCJcIixpPTApOmk9KG49bi5zbGljZSgwLGEpKS5sZW5ndGgtMS1uLmxhc3RJbmRleE9mKFwiL1wiKSxvPWgscz0wO2NvbnRpbnVlfX1lbHNlIGlmKDI9PT1uLmxlbmd0aHx8MT09PW4ubGVuZ3RoKXtuPVwiXCIsaT0wLG89aCxzPTA7Y29udGludWV9ZSYmKG4ubGVuZ3RoPjA/bis9XCIvLi5cIjpuPVwiLi5cIixpPTIpfWVsc2Ugbi5sZW5ndGg+MD9uKz1cIi9cIit0LnNsaWNlKG8rMSxoKTpuPXQuc2xpY2UobysxLGgpLGk9aC1vLTE7bz1oLHM9MH1lbHNlIDQ2PT09ciYmLTEhPT1zPysrczpzPS0xfXJldHVybiBufXZhciBuPXtyZXNvbHZlOmZ1bmN0aW9uKCl7Zm9yKHZhciB0LG49XCJcIixpPSExLG89YXJndW1lbnRzLmxlbmd0aC0xO28+PS0xJiYhaTtvLS0pe3ZhciBzO28+PTA/cz1hcmd1bWVudHNbb106KHZvaWQgMD09PXQmJih0PXByb2Nlc3MuY3dkKCkpLHM9dCksZShzKSwwIT09cy5sZW5ndGgmJihuPXMrXCIvXCIrbixpPTQ3PT09cy5jaGFyQ29kZUF0KDApKX1yZXR1cm4gbj1yKG4sIWkpLGk/bi5sZW5ndGg+MD9cIi9cIituOlwiL1wiOm4ubGVuZ3RoPjA/bjpcIi5cIn0sbm9ybWFsaXplOmZ1bmN0aW9uKHQpe2lmKGUodCksMD09PXQubGVuZ3RoKXJldHVyblwiLlwiO3ZhciBuPTQ3PT09dC5jaGFyQ29kZUF0KDApLGk9NDc9PT10LmNoYXJDb2RlQXQodC5sZW5ndGgtMSk7cmV0dXJuIDAhPT0odD1yKHQsIW4pKS5sZW5ndGh8fG58fCh0PVwiLlwiKSx0Lmxlbmd0aD4wJiZpJiYodCs9XCIvXCIpLG4/XCIvXCIrdDp0fSxpc0Fic29sdXRlOmZ1bmN0aW9uKHQpe3JldHVybiBlKHQpLHQubGVuZ3RoPjAmJjQ3PT09dC5jaGFyQ29kZUF0KDApfSxqb2luOmZ1bmN0aW9uKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuXCIuXCI7Zm9yKHZhciB0LHI9MDtyPGFyZ3VtZW50cy5sZW5ndGg7KytyKXt2YXIgaT1hcmd1bWVudHNbcl07ZShpKSxpLmxlbmd0aD4wJiYodm9pZCAwPT09dD90PWk6dCs9XCIvXCIraSl9cmV0dXJuIHZvaWQgMD09PXQ/XCIuXCI6bi5ub3JtYWxpemUodCl9LHJlbGF0aXZlOmZ1bmN0aW9uKHQscil7aWYoZSh0KSxlKHIpLHQ9PT1yKXJldHVyblwiXCI7aWYoKHQ9bi5yZXNvbHZlKHQpKT09PShyPW4ucmVzb2x2ZShyKSkpcmV0dXJuXCJcIjtmb3IodmFyIGk9MTtpPHQubGVuZ3RoJiY0Nz09PXQuY2hhckNvZGVBdChpKTsrK2kpO2Zvcih2YXIgbz10Lmxlbmd0aCxzPW8taSxoPTE7aDxyLmxlbmd0aCYmNDc9PT1yLmNoYXJDb2RlQXQoaCk7KytoKTtmb3IodmFyIGE9ci5sZW5ndGgtaCxjPXM8YT9zOmEsZj0tMSx1PTA7dTw9YzsrK3Upe2lmKHU9PT1jKXtpZihhPmMpe2lmKDQ3PT09ci5jaGFyQ29kZUF0KGgrdSkpcmV0dXJuIHIuc2xpY2UoaCt1KzEpO2lmKDA9PT11KXJldHVybiByLnNsaWNlKGgrdSl9ZWxzZSBzPmMmJig0Nz09PXQuY2hhckNvZGVBdChpK3UpP2Y9dTowPT09dSYmKGY9MCkpO2JyZWFrfXZhciBsPXQuY2hhckNvZGVBdChpK3UpO2lmKGwhPT1yLmNoYXJDb2RlQXQoaCt1KSlicmVhazs0Nz09PWwmJihmPXUpfXZhciBnPVwiXCI7Zm9yKHU9aStmKzE7dTw9bzsrK3UpdSE9PW8mJjQ3IT09dC5jaGFyQ29kZUF0KHUpfHwoMD09PWcubGVuZ3RoP2crPVwiLi5cIjpnKz1cIi8uLlwiKTtyZXR1cm4gZy5sZW5ndGg+MD9nK3Iuc2xpY2UoaCtmKTooaCs9Ziw0Nz09PXIuY2hhckNvZGVBdChoKSYmKytoLHIuc2xpY2UoaCkpfSxfbWFrZUxvbmc6ZnVuY3Rpb24odCl7cmV0dXJuIHR9LGRpcm5hbWU6ZnVuY3Rpb24odCl7aWYoZSh0KSwwPT09dC5sZW5ndGgpcmV0dXJuXCIuXCI7Zm9yKHZhciByPXQuY2hhckNvZGVBdCgwKSxuPTQ3PT09cixpPS0xLG89ITAscz10Lmxlbmd0aC0xO3M+PTE7LS1zKWlmKDQ3PT09KHI9dC5jaGFyQ29kZUF0KHMpKSl7aWYoIW8pe2k9czticmVha319ZWxzZSBvPSExO3JldHVybi0xPT09aT9uP1wiL1wiOlwiLlwiOm4mJjE9PT1pP1wiLy9cIjp0LnNsaWNlKDAsaSl9LGJhc2VuYW1lOmZ1bmN0aW9uKHQscil7aWYodm9pZCAwIT09ciYmXCJzdHJpbmdcIiE9dHlwZW9mIHIpdGhyb3cgbmV3IFR5cGVFcnJvcignXCJleHRcIiBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nJyk7ZSh0KTt2YXIgbixpPTAsbz0tMSxzPSEwO2lmKHZvaWQgMCE9PXImJnIubGVuZ3RoPjAmJnIubGVuZ3RoPD10Lmxlbmd0aCl7aWYoci5sZW5ndGg9PT10Lmxlbmd0aCYmcj09PXQpcmV0dXJuXCJcIjt2YXIgaD1yLmxlbmd0aC0xLGE9LTE7Zm9yKG49dC5sZW5ndGgtMTtuPj0wOy0tbil7dmFyIGM9dC5jaGFyQ29kZUF0KG4pO2lmKDQ3PT09Yyl7aWYoIXMpe2k9bisxO2JyZWFrfX1lbHNlLTE9PT1hJiYocz0hMSxhPW4rMSksaD49MCYmKGM9PT1yLmNoYXJDb2RlQXQoaCk/LTE9PS0taCYmKG89bik6KGg9LTEsbz1hKSl9cmV0dXJuIGk9PT1vP289YTotMT09PW8mJihvPXQubGVuZ3RoKSx0LnNsaWNlKGksbyl9Zm9yKG49dC5sZW5ndGgtMTtuPj0wOy0tbilpZig0Nz09PXQuY2hhckNvZGVBdChuKSl7aWYoIXMpe2k9bisxO2JyZWFrfX1lbHNlLTE9PT1vJiYocz0hMSxvPW4rMSk7cmV0dXJuLTE9PT1vP1wiXCI6dC5zbGljZShpLG8pfSxleHRuYW1lOmZ1bmN0aW9uKHQpe2UodCk7Zm9yKHZhciByPS0xLG49MCxpPS0xLG89ITAscz0wLGg9dC5sZW5ndGgtMTtoPj0wOy0taCl7dmFyIGE9dC5jaGFyQ29kZUF0KGgpO2lmKDQ3IT09YSktMT09PWkmJihvPSExLGk9aCsxKSw0Nj09PWE/LTE9PT1yP3I9aDoxIT09cyYmKHM9MSk6LTEhPT1yJiYocz0tMSk7ZWxzZSBpZighbyl7bj1oKzE7YnJlYWt9fXJldHVybi0xPT09cnx8LTE9PT1pfHwwPT09c3x8MT09PXMmJnI9PT1pLTEmJnI9PT1uKzE/XCJcIjp0LnNsaWNlKHIsaSl9LGZvcm1hdDpmdW5jdGlvbih0KXtpZihudWxsPT09dHx8XCJvYmplY3RcIiE9dHlwZW9mIHQpdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwicGF0aE9iamVjdFwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgJyt0eXBlb2YgdCk7cmV0dXJuIGZ1bmN0aW9uKHQsZSl7dmFyIHI9ZS5kaXJ8fGUucm9vdCxuPWUuYmFzZXx8KGUubmFtZXx8XCJcIikrKGUuZXh0fHxcIlwiKTtyZXR1cm4gcj9yPT09ZS5yb290P3IrbjpyK1wiL1wiK246bn0oMCx0KX0scGFyc2U6ZnVuY3Rpb24odCl7ZSh0KTt2YXIgcj17cm9vdDpcIlwiLGRpcjpcIlwiLGJhc2U6XCJcIixleHQ6XCJcIixuYW1lOlwiXCJ9O2lmKDA9PT10Lmxlbmd0aClyZXR1cm4gcjt2YXIgbixpPXQuY2hhckNvZGVBdCgwKSxvPTQ3PT09aTtvPyhyLnJvb3Q9XCIvXCIsbj0xKTpuPTA7Zm9yKHZhciBzPS0xLGg9MCxhPS0xLGM9ITAsZj10Lmxlbmd0aC0xLHU9MDtmPj1uOy0tZilpZig0NyE9PShpPXQuY2hhckNvZGVBdChmKSkpLTE9PT1hJiYoYz0hMSxhPWYrMSksNDY9PT1pPy0xPT09cz9zPWY6MSE9PXUmJih1PTEpOi0xIT09cyYmKHU9LTEpO2Vsc2UgaWYoIWMpe2g9ZisxO2JyZWFrfXJldHVybi0xPT09c3x8LTE9PT1hfHwwPT09dXx8MT09PXUmJnM9PT1hLTEmJnM9PT1oKzE/LTEhPT1hJiYoci5iYXNlPXIubmFtZT0wPT09aCYmbz90LnNsaWNlKDEsYSk6dC5zbGljZShoLGEpKTooMD09PWgmJm8/KHIubmFtZT10LnNsaWNlKDEscyksci5iYXNlPXQuc2xpY2UoMSxhKSk6KHIubmFtZT10LnNsaWNlKGgscyksci5iYXNlPXQuc2xpY2UoaCxhKSksci5leHQ9dC5zbGljZShzLGEpKSxoPjA/ci5kaXI9dC5zbGljZSgwLGgtMSk6byYmKHIuZGlyPVwiL1wiKSxyfSxzZXA6XCIvXCIsZGVsaW1pdGVyOlwiOlwiLHdpbjMyOm51bGwscG9zaXg6bnVsbH07bi5wb3NpeD1uLHQuZXhwb3J0cz1ufX0sZT17fTtmdW5jdGlvbiByKG4pe3ZhciBpPWVbbl07aWYodm9pZCAwIT09aSlyZXR1cm4gaS5leHBvcnRzO3ZhciBvPWVbbl09e2V4cG9ydHM6e319O3JldHVybiB0W25dKG8sby5leHBvcnRzLHIpLG8uZXhwb3J0c31yLmQ9KHQsZSk9Pntmb3IodmFyIG4gaW4gZSlyLm8oZSxuKSYmIXIubyh0LG4pJiZPYmplY3QuZGVmaW5lUHJvcGVydHkodCxuLHtlbnVtZXJhYmxlOiEwLGdldDplW25dfSl9LHIubz0odCxlKT0+T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsZSksci5yPXQ9PntcInVuZGVmaW5lZFwiIT10eXBlb2YgU3ltYm9sJiZTeW1ib2wudG9TdHJpbmdUYWcmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFN5bWJvbC50b1N0cmluZ1RhZyx7dmFsdWU6XCJNb2R1bGVcIn0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pfTt2YXIgbj17fTsoKCk9PntsZXQgdDtpZihyLnIobiksci5kKG4se1VSSTooKT0+ZixVdGlsczooKT0+UH0pLFwib2JqZWN0XCI9PXR5cGVvZiBwcm9jZXNzKXQ9XCJ3aW4zMlwiPT09cHJvY2Vzcy5wbGF0Zm9ybTtlbHNlIGlmKFwib2JqZWN0XCI9PXR5cGVvZiBuYXZpZ2F0b3Ipe2xldCBlPW5hdmlnYXRvci51c2VyQWdlbnQ7dD1lLmluZGV4T2YoXCJXaW5kb3dzXCIpPj0wfWNvbnN0IGU9L15cXHdbXFx3XFxkKy4tXSokLyxpPS9eXFwvLyxvPS9eXFwvXFwvLztmdW5jdGlvbiBzKHQscil7aWYoIXQuc2NoZW1lJiZyKXRocm93IG5ldyBFcnJvcihgW1VyaUVycm9yXTogU2NoZW1lIGlzIG1pc3Npbmc6IHtzY2hlbWU6IFwiXCIsIGF1dGhvcml0eTogXCIke3QuYXV0aG9yaXR5fVwiLCBwYXRoOiBcIiR7dC5wYXRofVwiLCBxdWVyeTogXCIke3QucXVlcnl9XCIsIGZyYWdtZW50OiBcIiR7dC5mcmFnbWVudH1cIn1gKTtpZih0LnNjaGVtZSYmIWUudGVzdCh0LnNjaGVtZSkpdGhyb3cgbmV3IEVycm9yKFwiW1VyaUVycm9yXTogU2NoZW1lIGNvbnRhaW5zIGlsbGVnYWwgY2hhcmFjdGVycy5cIik7aWYodC5wYXRoKWlmKHQuYXV0aG9yaXR5KXtpZighaS50ZXN0KHQucGF0aCkpdGhyb3cgbmV3IEVycm9yKCdbVXJpRXJyb3JdOiBJZiBhIFVSSSBjb250YWlucyBhbiBhdXRob3JpdHkgY29tcG9uZW50LCB0aGVuIHRoZSBwYXRoIGNvbXBvbmVudCBtdXN0IGVpdGhlciBiZSBlbXB0eSBvciBiZWdpbiB3aXRoIGEgc2xhc2ggKFwiL1wiKSBjaGFyYWN0ZXInKX1lbHNlIGlmKG8udGVzdCh0LnBhdGgpKXRocm93IG5ldyBFcnJvcignW1VyaUVycm9yXTogSWYgYSBVUkkgZG9lcyBub3QgY29udGFpbiBhbiBhdXRob3JpdHkgY29tcG9uZW50LCB0aGVuIHRoZSBwYXRoIGNhbm5vdCBiZWdpbiB3aXRoIHR3byBzbGFzaCBjaGFyYWN0ZXJzIChcIi8vXCIpJyl9Y29uc3QgaD1cIlwiLGE9XCIvXCIsYz0vXigoW146Lz8jXSs/KTopPyhcXC9cXC8oW14vPyNdKikpPyhbXj8jXSopKFxcPyhbXiNdKikpPygjKC4qKSk/LztjbGFzcyBme3N0YXRpYyBpc1VyaSh0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIGZ8fCEhdCYmXCJzdHJpbmdcIj09dHlwZW9mIHQuYXV0aG9yaXR5JiZcInN0cmluZ1wiPT10eXBlb2YgdC5mcmFnbWVudCYmXCJzdHJpbmdcIj09dHlwZW9mIHQucGF0aCYmXCJzdHJpbmdcIj09dHlwZW9mIHQucXVlcnkmJlwic3RyaW5nXCI9PXR5cGVvZiB0LnNjaGVtZSYmXCJzdHJpbmdcIj09dHlwZW9mIHQuZnNQYXRoJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiB0LndpdGgmJlwiZnVuY3Rpb25cIj09dHlwZW9mIHQudG9TdHJpbmd9c2NoZW1lO2F1dGhvcml0eTtwYXRoO3F1ZXJ5O2ZyYWdtZW50O2NvbnN0cnVjdG9yKHQsZSxyLG4saSxvPSExKXtcIm9iamVjdFwiPT10eXBlb2YgdD8odGhpcy5zY2hlbWU9dC5zY2hlbWV8fGgsdGhpcy5hdXRob3JpdHk9dC5hdXRob3JpdHl8fGgsdGhpcy5wYXRoPXQucGF0aHx8aCx0aGlzLnF1ZXJ5PXQucXVlcnl8fGgsdGhpcy5mcmFnbWVudD10LmZyYWdtZW50fHxoKToodGhpcy5zY2hlbWU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdHx8ZT90OlwiZmlsZVwifSh0LG8pLHRoaXMuYXV0aG9yaXR5PWV8fGgsdGhpcy5wYXRoPWZ1bmN0aW9uKHQsZSl7c3dpdGNoKHQpe2Nhc2VcImh0dHBzXCI6Y2FzZVwiaHR0cFwiOmNhc2VcImZpbGVcIjplP2VbMF0hPT1hJiYoZT1hK2UpOmU9YX1yZXR1cm4gZX0odGhpcy5zY2hlbWUscnx8aCksdGhpcy5xdWVyeT1ufHxoLHRoaXMuZnJhZ21lbnQ9aXx8aCxzKHRoaXMsbykpfWdldCBmc1BhdGgoKXtyZXR1cm4gbSh0aGlzLCExKX13aXRoKHQpe2lmKCF0KXJldHVybiB0aGlzO2xldHtzY2hlbWU6ZSxhdXRob3JpdHk6cixwYXRoOm4scXVlcnk6aSxmcmFnbWVudDpvfT10O3JldHVybiB2b2lkIDA9PT1lP2U9dGhpcy5zY2hlbWU6bnVsbD09PWUmJihlPWgpLHZvaWQgMD09PXI/cj10aGlzLmF1dGhvcml0eTpudWxsPT09ciYmKHI9aCksdm9pZCAwPT09bj9uPXRoaXMucGF0aDpudWxsPT09biYmKG49aCksdm9pZCAwPT09aT9pPXRoaXMucXVlcnk6bnVsbD09PWkmJihpPWgpLHZvaWQgMD09PW8/bz10aGlzLmZyYWdtZW50Om51bGw9PT1vJiYobz1oKSxlPT09dGhpcy5zY2hlbWUmJnI9PT10aGlzLmF1dGhvcml0eSYmbj09PXRoaXMucGF0aCYmaT09PXRoaXMucXVlcnkmJm89PT10aGlzLmZyYWdtZW50P3RoaXM6bmV3IGwoZSxyLG4saSxvKX1zdGF0aWMgcGFyc2UodCxlPSExKXtjb25zdCByPWMuZXhlYyh0KTtyZXR1cm4gcj9uZXcgbChyWzJdfHxoLEMocls0XXx8aCksQyhyWzVdfHxoKSxDKHJbN118fGgpLEMocls5XXx8aCksZSk6bmV3IGwoaCxoLGgsaCxoKX1zdGF0aWMgZmlsZShlKXtsZXQgcj1oO2lmKHQmJihlPWUucmVwbGFjZSgvXFxcXC9nLGEpKSxlWzBdPT09YSYmZVsxXT09PWEpe2NvbnN0IHQ9ZS5pbmRleE9mKGEsMik7LTE9PT10PyhyPWUuc3Vic3RyaW5nKDIpLGU9YSk6KHI9ZS5zdWJzdHJpbmcoMix0KSxlPWUuc3Vic3RyaW5nKHQpfHxhKX1yZXR1cm4gbmV3IGwoXCJmaWxlXCIscixlLGgsaCl9c3RhdGljIGZyb20odCl7Y29uc3QgZT1uZXcgbCh0LnNjaGVtZSx0LmF1dGhvcml0eSx0LnBhdGgsdC5xdWVyeSx0LmZyYWdtZW50KTtyZXR1cm4gcyhlLCEwKSxlfXRvU3RyaW5nKHQ9ITEpe3JldHVybiB5KHRoaXMsdCl9dG9KU09OKCl7cmV0dXJuIHRoaXN9c3RhdGljIHJldml2ZSh0KXtpZih0KXtpZih0IGluc3RhbmNlb2YgZilyZXR1cm4gdDt7Y29uc3QgZT1uZXcgbCh0KTtyZXR1cm4gZS5fZm9ybWF0dGVkPXQuZXh0ZXJuYWwsZS5fZnNQYXRoPXQuX3NlcD09PXU/dC5mc1BhdGg6bnVsbCxlfX1yZXR1cm4gdH19Y29uc3QgdT10PzE6dm9pZCAwO2NsYXNzIGwgZXh0ZW5kcyBme19mb3JtYXR0ZWQ9bnVsbDtfZnNQYXRoPW51bGw7Z2V0IGZzUGF0aCgpe3JldHVybiB0aGlzLl9mc1BhdGh8fCh0aGlzLl9mc1BhdGg9bSh0aGlzLCExKSksdGhpcy5fZnNQYXRofXRvU3RyaW5nKHQ9ITEpe3JldHVybiB0P3kodGhpcywhMCk6KHRoaXMuX2Zvcm1hdHRlZHx8KHRoaXMuX2Zvcm1hdHRlZD15KHRoaXMsITEpKSx0aGlzLl9mb3JtYXR0ZWQpfXRvSlNPTigpe2NvbnN0IHQ9eyRtaWQ6MX07cmV0dXJuIHRoaXMuX2ZzUGF0aCYmKHQuZnNQYXRoPXRoaXMuX2ZzUGF0aCx0Ll9zZXA9dSksdGhpcy5fZm9ybWF0dGVkJiYodC5leHRlcm5hbD10aGlzLl9mb3JtYXR0ZWQpLHRoaXMucGF0aCYmKHQucGF0aD10aGlzLnBhdGgpLHRoaXMuc2NoZW1lJiYodC5zY2hlbWU9dGhpcy5zY2hlbWUpLHRoaXMuYXV0aG9yaXR5JiYodC5hdXRob3JpdHk9dGhpcy5hdXRob3JpdHkpLHRoaXMucXVlcnkmJih0LnF1ZXJ5PXRoaXMucXVlcnkpLHRoaXMuZnJhZ21lbnQmJih0LmZyYWdtZW50PXRoaXMuZnJhZ21lbnQpLHR9fWNvbnN0IGc9ezU4OlwiJTNBXCIsNDc6XCIlMkZcIiw2MzpcIiUzRlwiLDM1OlwiJTIzXCIsOTE6XCIlNUJcIiw5MzpcIiU1RFwiLDY0OlwiJTQwXCIsMzM6XCIlMjFcIiwzNjpcIiUyNFwiLDM4OlwiJTI2XCIsMzk6XCIlMjdcIiw0MDpcIiUyOFwiLDQxOlwiJTI5XCIsNDI6XCIlMkFcIiw0MzpcIiUyQlwiLDQ0OlwiJTJDXCIsNTk6XCIlM0JcIiw2MTpcIiUzRFwiLDMyOlwiJTIwXCJ9O2Z1bmN0aW9uIGQodCxlLHIpe2xldCBuLGk9LTE7Zm9yKGxldCBvPTA7bzx0Lmxlbmd0aDtvKyspe2NvbnN0IHM9dC5jaGFyQ29kZUF0KG8pO2lmKHM+PTk3JiZzPD0xMjJ8fHM+PTY1JiZzPD05MHx8cz49NDgmJnM8PTU3fHw0NT09PXN8fDQ2PT09c3x8OTU9PT1zfHwxMjY9PT1zfHxlJiY0Nz09PXN8fHImJjkxPT09c3x8ciYmOTM9PT1zfHxyJiY1OD09PXMpLTEhPT1pJiYobis9ZW5jb2RlVVJJQ29tcG9uZW50KHQuc3Vic3RyaW5nKGksbykpLGk9LTEpLHZvaWQgMCE9PW4mJihuKz10LmNoYXJBdChvKSk7ZWxzZXt2b2lkIDA9PT1uJiYobj10LnN1YnN0cigwLG8pKTtjb25zdCBlPWdbc107dm9pZCAwIT09ZT8oLTEhPT1pJiYobis9ZW5jb2RlVVJJQ29tcG9uZW50KHQuc3Vic3RyaW5nKGksbykpLGk9LTEpLG4rPWUpOi0xPT09aSYmKGk9byl9fXJldHVybi0xIT09aSYmKG4rPWVuY29kZVVSSUNvbXBvbmVudCh0LnN1YnN0cmluZyhpKSkpLHZvaWQgMCE9PW4/bjp0fWZ1bmN0aW9uIHAodCl7bGV0IGU7Zm9yKGxldCByPTA7cjx0Lmxlbmd0aDtyKyspe2NvbnN0IG49dC5jaGFyQ29kZUF0KHIpOzM1PT09bnx8NjM9PT1uPyh2b2lkIDA9PT1lJiYoZT10LnN1YnN0cigwLHIpKSxlKz1nW25dKTp2b2lkIDAhPT1lJiYoZSs9dFtyXSl9cmV0dXJuIHZvaWQgMCE9PWU/ZTp0fWZ1bmN0aW9uIG0oZSxyKXtsZXQgbjtyZXR1cm4gbj1lLmF1dGhvcml0eSYmZS5wYXRoLmxlbmd0aD4xJiZcImZpbGVcIj09PWUuc2NoZW1lP2AvLyR7ZS5hdXRob3JpdHl9JHtlLnBhdGh9YDo0Nz09PWUucGF0aC5jaGFyQ29kZUF0KDApJiYoZS5wYXRoLmNoYXJDb2RlQXQoMSk+PTY1JiZlLnBhdGguY2hhckNvZGVBdCgxKTw9OTB8fGUucGF0aC5jaGFyQ29kZUF0KDEpPj05NyYmZS5wYXRoLmNoYXJDb2RlQXQoMSk8PTEyMikmJjU4PT09ZS5wYXRoLmNoYXJDb2RlQXQoMik/cj9lLnBhdGguc3Vic3RyKDEpOmUucGF0aFsxXS50b0xvd2VyQ2FzZSgpK2UucGF0aC5zdWJzdHIoMik6ZS5wYXRoLHQmJihuPW4ucmVwbGFjZSgvXFwvL2csXCJcXFxcXCIpKSxufWZ1bmN0aW9uIHkodCxlKXtjb25zdCByPWU/cDpkO2xldCBuPVwiXCIse3NjaGVtZTppLGF1dGhvcml0eTpvLHBhdGg6cyxxdWVyeTpoLGZyYWdtZW50OmN9PXQ7aWYoaSYmKG4rPWksbis9XCI6XCIpLChvfHxcImZpbGVcIj09PWkpJiYobis9YSxuKz1hKSxvKXtsZXQgdD1vLmluZGV4T2YoXCJAXCIpO2lmKC0xIT09dCl7Y29uc3QgZT1vLnN1YnN0cigwLHQpO289by5zdWJzdHIodCsxKSx0PWUubGFzdEluZGV4T2YoXCI6XCIpLC0xPT09dD9uKz1yKGUsITEsITEpOihuKz1yKGUuc3Vic3RyKDAsdCksITEsITEpLG4rPVwiOlwiLG4rPXIoZS5zdWJzdHIodCsxKSwhMSwhMCkpLG4rPVwiQFwifW89by50b0xvd2VyQ2FzZSgpLHQ9by5sYXN0SW5kZXhPZihcIjpcIiksLTE9PT10P24rPXIobywhMSwhMCk6KG4rPXIoby5zdWJzdHIoMCx0KSwhMSwhMCksbis9by5zdWJzdHIodCkpfWlmKHMpe2lmKHMubGVuZ3RoPj0zJiY0Nz09PXMuY2hhckNvZGVBdCgwKSYmNTg9PT1zLmNoYXJDb2RlQXQoMikpe2NvbnN0IHQ9cy5jaGFyQ29kZUF0KDEpO3Q+PTY1JiZ0PD05MCYmKHM9YC8ke1N0cmluZy5mcm9tQ2hhckNvZGUodCszMil9OiR7cy5zdWJzdHIoMyl9YCl9ZWxzZSBpZihzLmxlbmd0aD49MiYmNTg9PT1zLmNoYXJDb2RlQXQoMSkpe2NvbnN0IHQ9cy5jaGFyQ29kZUF0KDApO3Q+PTY1JiZ0PD05MCYmKHM9YCR7U3RyaW5nLmZyb21DaGFyQ29kZSh0KzMyKX06JHtzLnN1YnN0cigyKX1gKX1uKz1yKHMsITAsITEpfXJldHVybiBoJiYobis9XCI/XCIsbis9cihoLCExLCExKSksYyYmKG4rPVwiI1wiLG4rPWU/YzpkKGMsITEsITEpKSxufWZ1bmN0aW9uIHYodCl7dHJ5e3JldHVybiBkZWNvZGVVUklDb21wb25lbnQodCl9Y2F0Y2h7cmV0dXJuIHQubGVuZ3RoPjM/dC5zdWJzdHIoMCwzKSt2KHQuc3Vic3RyKDMpKTp0fX1jb25zdCBiPS8oJVswLTlBLVphLXpdWzAtOUEtWmEtel0pKy9nO2Z1bmN0aW9uIEModCl7cmV0dXJuIHQubWF0Y2goYik/dC5yZXBsYWNlKGIsKHQ9PnYodCkpKTp0fXZhciBBPXIoNDcwKTtjb25zdCB3PUEucG9zaXh8fEEseD1cIi9cIjt2YXIgUDshZnVuY3Rpb24odCl7dC5qb2luUGF0aD1mdW5jdGlvbih0LC4uLmUpe3JldHVybiB0LndpdGgoe3BhdGg6dy5qb2luKHQucGF0aCwuLi5lKX0pfSx0LnJlc29sdmVQYXRoPWZ1bmN0aW9uKHQsLi4uZSl7bGV0IHI9dC5wYXRoLG49ITE7clswXSE9PXgmJihyPXgrcixuPSEwKTtsZXQgaT13LnJlc29sdmUociwuLi5lKTtyZXR1cm4gbiYmaVswXT09PXgmJiF0LmF1dGhvcml0eSYmKGk9aS5zdWJzdHJpbmcoMSkpLHQud2l0aCh7cGF0aDppfSl9LHQuZGlybmFtZT1mdW5jdGlvbih0KXtpZigwPT09dC5wYXRoLmxlbmd0aHx8dC5wYXRoPT09eClyZXR1cm4gdDtsZXQgZT13LmRpcm5hbWUodC5wYXRoKTtyZXR1cm4gMT09PWUubGVuZ3RoJiY0Nj09PWUuY2hhckNvZGVBdCgwKSYmKGU9XCJcIiksdC53aXRoKHtwYXRoOmV9KX0sdC5iYXNlbmFtZT1mdW5jdGlvbih0KXtyZXR1cm4gdy5iYXNlbmFtZSh0LnBhdGgpfSx0LmV4dG5hbWU9ZnVuY3Rpb24odCl7cmV0dXJuIHcuZXh0bmFtZSh0LnBhdGgpfX0oUHx8KFA9e30pKX0pKCksTElCPW59KSgpO2NvbnN0e1VSSTogbGFuZ3VhZ2VfY2xpZW50X1VSSSxVdGlsc309TElCO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3NlcnZpY2VzL2xhbmd1YWdlLWNsaWVudC50c1xuLyogcHJvdmlkZWQgZGVwZW5kZW5jeSAqLyB2YXIgbGFuZ3VhZ2VfY2xpZW50X2NvbnNvbGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQzNjQpO1xuZnVuY3Rpb24gbGFuZ3VhZ2VfY2xpZW50X2RlZmluZV9wcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgICBpZiAoa2V5IGluIG9iaikge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBvYmpba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gb2JqO1xufVxuXG5cblxuXG5cblxuY2xhc3MgTGFuZ3VhZ2VDbGllbnQgZXh0ZW5kcyBiYXNlX3NlcnZpY2UuQmFzZVNlcnZpY2Uge1xuICAgICRjb25uZWN0KCkge1xuICAgICAgICBzd2l0Y2godGhpcy5zZXJ2ZXJEYXRhLnR5cGUpe1xuICAgICAgICAgICAgY2FzZSBcIndlYndvcmtlclwiOlxuICAgICAgICAgICAgICAgIGlmICgnd29ya2VyJyBpbiB0aGlzLnNlcnZlckRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kY29ubmVjdFdvcmtlcih0aGlzLnNlcnZlckRhdGEud29ya2VyLCB0aGlzLnNlcnZlckRhdGEuaW5pdGlhbGl6YXRpb25PcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyB3b3JrZXIgcHJvdmlkZWRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInNvY2tldFwiOlxuICAgICAgICAgICAgICAgIGlmICgnc29ja2V0JyBpbiB0aGlzLnNlcnZlckRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zb2NrZXQgPSB0aGlzLnNlcnZlckRhdGEuc29ja2V0O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiRjb25uZWN0U29ja2V0KHRoaXMuc2VydmVyRGF0YS5pbml0aWFsaXphdGlvbk9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHNvY2tldFVybCBwcm92aWRlZFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gc2VydmVyIHR5cGU6IFwiICsgdGhpcy5zZXJ2ZXJEYXRhLnR5cGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgICRjb25uZWN0U29ja2V0KGluaXRpYWxpemF0aW9uT3B0aW9ucykge1xuICAgICAgICBsaXN0ZW4oe1xuICAgICAgICAgICAgd2ViU29ja2V0OiB0aGlzLnNvY2tldCxcbiAgICAgICAgICAgIG9uQ29ubmVjdGlvbjogKGNvbm5lY3Rpb24pPT57XG4gICAgICAgICAgICAgICAgdGhpcy4kaW5pdENvbm5lY3Rpb24oY29ubmVjdGlvbiwgaW5pdGlhbGl6YXRpb25PcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0aGlzLnNvY2tldC5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuT1BFTikgdGhpcy5zb2NrZXQuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ29wZW4nKSk7XG4gICAgfVxuICAgICRjb25uZWN0V29ya2VyKHdvcmtlciwgaW5pdGlhbGl6YXRpb25PcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSAoMCxicm93c2VyLmNyZWF0ZVByb3RvY29sQ29ubmVjdGlvbikobmV3IGJyb3dzZXIuQnJvd3Nlck1lc3NhZ2VSZWFkZXIod29ya2VyKSwgbmV3IGJyb3dzZXIuQnJvd3Nlck1lc3NhZ2VXcml0ZXIod29ya2VyKSk7XG4gICAgICAgIHRoaXMuJGluaXRDb25uZWN0aW9uKGNvbm5lY3Rpb24sIGluaXRpYWxpemF0aW9uT3B0aW9ucyk7XG4gICAgfVxuICAgICRpbml0Q29ubmVjdGlvbihjb25uZWN0aW9uLCBpbml0aWFsaXphdGlvbk9wdGlvbnMpIHtcbiAgICAgICAgY29ubmVjdGlvbi5saXN0ZW4oKTtcbiAgICAgICAgdGhpcy5pc0Nvbm5lY3RlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbiA9IGNvbm5lY3Rpb247XG4gICAgICAgIHRoaXMuc2VuZEluaXRpYWxpemUoaW5pdGlhbGl6YXRpb25PcHRpb25zKTtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uLm9uTm90aWZpY2F0aW9uKCd0ZXh0RG9jdW1lbnQvcHVibGlzaERpYWdub3N0aWNzJywgKHJlc3VsdCk9PntcbiAgICAgICAgICAgIGxldCBwb3N0TWVzc2FnZSA9IHtcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogTWVzc2FnZVR5cGUudmFsaWRhdGUsXG4gICAgICAgICAgICAgICAgXCJkb2N1bWVudFVyaVwiOiByZXN1bHQudXJpLFxuICAgICAgICAgICAgICAgIFwidmFsdWVcIjogcmVzdWx0LmRpYWdub3N0aWNzXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5jdHgucG9zdE1lc3NhZ2UocG9zdE1lc3NhZ2UpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uLm9uTm90aWZpY2F0aW9uKCd3aW5kb3cvc2hvd01lc3NhZ2UnLCAocGFyYW1zKT0+e1xuICAgICAgICAgICAgdGhpcy5zaG93TG9nKHBhcmFtcyk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb24ub25Ob3RpZmljYXRpb24oJ3dpbmRvdy9sb2dNZXNzYWdlJywgKHBhcmFtcyk9PntcbiAgICAgICAgICAgIHRoaXMuc2hvd0xvZyhwYXJhbXMpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uLm9uTm90aWZpY2F0aW9uKCckL2xvZ1RyYWNlJywgKHBhcmFtcyk9PntcbiAgICAgICAgICAgIHRoaXMuc2hvd1RyYWNlKHBhcmFtcyk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb24ub25SZXF1ZXN0KCd3aW5kb3cvc2hvd01lc3NhZ2VSZXF1ZXN0JywgKHBhcmFtcyk9PntcbiAgICAgICAgICAgIHRoaXMuc2hvd0xvZyhwYXJhbXMpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uLm9uUmVxdWVzdCgnd29ya3NwYWNlL2NvbmZpZ3VyYXRpb24nLCAocGFyYW1zKT0+e1xuICAgICAgICAgICAgbGFuZ3VhZ2VfY2xpZW50X2NvbnNvbGUubG9nKHBhcmFtcyk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb24ub25SZXF1ZXN0KCdjbGllbnQvcmVnaXN0ZXJDYXBhYmlsaXR5JywgKHBhcmFtcyk9PntcbiAgICAgICAgICAgIGxhbmd1YWdlX2NsaWVudF9jb25zb2xlLmxvZyhwYXJhbXMpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uLm9uUmVxdWVzdCgnd29ya3NwYWNlL2FwcGx5RWRpdCcsIGFzeW5jIChwYXJhbXMpPT57XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCk9PntcbiAgICAgICAgICAgICAgICBjb25zdCBjYWxsYmFja0lkID0gdGhpcy5jYWxsYmFja0lkKys7XG4gICAgICAgICAgICAgICAgdGhpcy5jYWxsYmFja3NbY2FsbGJhY2tJZF0gPSAocmVzdWx0KT0+e1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0LmFwcGxpZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IocmVzdWx0LmZhaWx1cmVSZWFzb24pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgbGV0IHBvc3RNZXNzYWdlID0ge1xuICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogTWVzc2FnZVR5cGUuYXBwbHlFZGl0LFxuICAgICAgICAgICAgICAgICAgICBcInNlcnZpY2VOYW1lXCI6IHRoaXMuc2VydmljZU5hbWUsXG4gICAgICAgICAgICAgICAgICAgIFwidmFsdWVcIjogcGFyYW1zLmVkaXQsXG4gICAgICAgICAgICAgICAgICAgIFwiY2FsbGJhY2tJZFwiOiBjYWxsYmFja0lkXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0aGlzLmN0eC5wb3N0TWVzc2FnZShwb3N0TWVzc2FnZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbi5vbkVycm9yKChlKT0+e1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbi5vbkNsb3NlKCgpPT57XG4gICAgICAgICAgICB0aGlzLmlzQ29ubmVjdGVkID0gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyAkcmVjb25uZWN0KCkge1xuICAgICAgICBPYmplY3QudmFsdWVzKHRoaXMuZG9jdW1lbnRzKS5mb3JFYWNoKChkb2N1bWVudCk9PnRoaXMucmVtb3ZlRG9jdW1lbnQoZG9jdW1lbnQpKTtcbiAgICAgICAgYXdhaXQgdGhpcy5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMuJGNvbm5lY3QoKTtcbiAgICB9XG4gICAgc2VuZEFwcGxpZWRSZXN1bHQocmVzdWx0LCBjYWxsYmFja0lkKSB7XG4gICAgICAgIGlmICghdGhpcy5pc0Nvbm5lY3RlZCB8fCAhdGhpcy5jYWxsYmFja3NbY2FsbGJhY2tJZF0pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNhbGxiYWNrc1tjYWxsYmFja0lkXShyZXN1bHQpO1xuICAgIH1cbiAgICBzaG93TG9nKHBhcmFtcykge1xuICAgICAgICBzd2l0Y2gocGFyYW1zLnR5cGUpe1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIGxhbmd1YWdlX2NsaWVudF9jb25zb2xlLmVycm9yKHBhcmFtcy5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBsYW5ndWFnZV9jbGllbnRfY29uc29sZS53YXJuKHBhcmFtcy5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICBsYW5ndWFnZV9jbGllbnRfY29uc29sZS5pbmZvKHBhcmFtcy5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgbGFuZ3VhZ2VfY2xpZW50X2NvbnNvbGUubG9nKHBhcmFtcy5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBzaG93VHJhY2UocGFyYW1zKSB7XG4gICAgICAgIGxhbmd1YWdlX2NsaWVudF9jb25zb2xlLmxvZyhwYXJhbXMubWVzc2FnZSk7XG4gICAgICAgIGlmIChwYXJhbXMudmVyYm9zZSkge1xuICAgICAgICAgICAgbGFuZ3VhZ2VfY2xpZW50X2NvbnNvbGUubG9nKHBhcmFtcy52ZXJib3NlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhZGREb2N1bWVudChkb2N1bWVudCkge1xuICAgICAgICBzdXBlci5hZGREb2N1bWVudChkb2N1bWVudCk7XG4gICAgICAgIGNvbnN0IHRleHREb2N1bWVudE1lc3NhZ2UgPSB7XG4gICAgICAgICAgICB0ZXh0RG9jdW1lbnQ6IGRvY3VtZW50XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZW5xdWV1ZUlmTm90Q29ubmVjdGVkKCgpPT50aGlzLmNvbm5lY3Rpb24uc2VuZE5vdGlmaWNhdGlvbigndGV4dERvY3VtZW50L2RpZE9wZW4nLCB0ZXh0RG9jdW1lbnRNZXNzYWdlKSk7XG4gICAgfVxuICAgIGVucXVldWVJZk5vdENvbm5lY3RlZChjYWxsYmFjaykge1xuICAgICAgICBpZiAoIXRoaXMuaXNDb25uZWN0ZWQgfHwgIXRoaXMuaXNJbml0aWFsaXplZCkge1xuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0c1F1ZXVlLnB1c2goY2FsbGJhY2spO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW1vdmVEb2N1bWVudChkb2N1bWVudCkge1xuICAgICAgICBzdXBlci5yZW1vdmVEb2N1bWVudChkb2N1bWVudCk7XG4gICAgICAgIHRoaXMuZW5xdWV1ZUlmTm90Q29ubmVjdGVkKCgpPT50aGlzLmNvbm5lY3Rpb24uc2VuZE5vdGlmaWNhdGlvbigndGV4dERvY3VtZW50L2RpZENsb3NlJywge1xuICAgICAgICAgICAgICAgIHRleHREb2N1bWVudDoge1xuICAgICAgICAgICAgICAgICAgICB1cmk6IGRvY3VtZW50LnVyaVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcbiAgICB9XG4gICAgYXN5bmMgZGlzcG9zZSgpIHtcbiAgICAgICAgdmFyIF90aGlzX2Nvbm5lY3Rpb247XG4gICAgICAgIChfdGhpc19jb25uZWN0aW9uID0gdGhpcy5jb25uZWN0aW9uKSA9PT0gbnVsbCB8fCBfdGhpc19jb25uZWN0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpc19jb25uZWN0aW9uLmRpc3Bvc2UoKTtcbiAgICB9XG4gICAgYXN5bmMgY2xvc2VDb25uZWN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuY29ubmVjdGlvbikgcmV0dXJuO1xuICAgICAgICBhd2FpdCB0aGlzLmRpc3Bvc2UoKTtcbiAgICAgICAgYXdhaXQgdGhpcy5jb25uZWN0aW9uLnNlbmRSZXF1ZXN0KFwic2h1dGRvd25cIik7XG4gICAgICAgIGF3YWl0IHRoaXMuY29ubmVjdGlvbi5zZW5kTm90aWZpY2F0aW9uKCdleGl0Jyk7XG4gICAgICAgIGlmICh0aGlzLnNvY2tldCkgdGhpcy5zb2NrZXQuY2xvc2UoKTtcbiAgICAgICAgdGhpcy5pc0Nvbm5lY3RlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBzZW5kSW5pdGlhbGl6ZShpbml0aWFsaXphdGlvbk9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzQ29ubmVjdGVkKSByZXR1cm47XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSB7XG4gICAgICAgICAgICBjYXBhYmlsaXRpZXM6IHRoaXMuY2xpZW50Q2FwYWJpbGl0aWVzLFxuICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25PcHRpb25zOiBpbml0aWFsaXphdGlvbk9wdGlvbnMsXG4gICAgICAgICAgICBwcm9jZXNzSWQ6IG51bGwsXG4gICAgICAgICAgICByb290VXJpOiBudWxsXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLndvcmtzcGFjZVVyaSkge1xuICAgICAgICAgICAgbWVzc2FnZS53b3Jrc3BhY2VGb2xkZXJzID0gW1xuICAgICAgICAgICAgICAgIHRoaXMud29ya3NwYWNlRm9sZGVyXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbi5zZW5kUmVxdWVzdChcImluaXRpYWxpemVcIiwgbWVzc2FnZSkudGhlbigocGFyYW1zKT0+e1xuICAgICAgICAgICAgdGhpcy5pc0luaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuc2VydmljZUNhcGFiaWxpdGllcyA9IHBhcmFtcy5jYXBhYmlsaXRpZXM7XG4gICAgICAgICAgICBjb25zdCBzZXJ2aWNlTmFtZSA9IHRoaXMuc2VydmljZU5hbWU7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyh0aGlzLmRvY3VtZW50cykuZm9yRWFjaCgoZG9jdW1lbnRVcmkpPT57XG4gICAgICAgICAgICAgICAgY29uc3QgcG9zdE1lc3NhZ2UgPSB7XG4gICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBNZXNzYWdlVHlwZS5jYXBhYmlsaXRpZXNDaGFuZ2UsXG4gICAgICAgICAgICAgICAgICAgIFwidmFsdWVcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgW3NlcnZpY2VOYW1lXTogdGhpcy5zZXJ2aWNlQ2FwYWJpbGl0aWVzXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50VXJpOiBkb2N1bWVudFVyaVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGhpcy5jdHgucG9zdE1lc3NhZ2UocG9zdE1lc3NhZ2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb24uc2VuZE5vdGlmaWNhdGlvbignaW5pdGlhbGl6ZWQnLCB7fSkudGhlbigoKT0+e1xuICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbi5zZW5kTm90aWZpY2F0aW9uKCd3b3Jrc3BhY2UvZGlkQ2hhbmdlQ29uZmlndXJhdGlvbicsIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3M6IHt9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXF1ZXN0c1F1ZXVlLmZvckVhY2goKHJlcXVlc3RDYWxsYmFjayk9PnJlcXVlc3RDYWxsYmFjaygpKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlcXVlc3RzUXVldWUgPSBbXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXBwbHlEZWx0YXMoaWRlbnRpZmllciwgZGVsdGFzKSB7XG4gICAgICAgIHZhciBfdGhpc19zZXJ2aWNlQ2FwYWJpbGl0aWVzLCBfdGhpc19zZXJ2aWNlQ2FwYWJpbGl0aWVzMTtcbiAgICAgICAgc3VwZXIuYXBwbHlEZWx0YXMoaWRlbnRpZmllciwgZGVsdGFzKTtcbiAgICAgICAgaWYgKCF0aGlzLmlzQ29ubmVjdGVkIHx8ICF0aGlzLnNlcnZpY2VDYXBhYmlsaXRpZXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKChfdGhpc19zZXJ2aWNlQ2FwYWJpbGl0aWVzID0gdGhpcy5zZXJ2aWNlQ2FwYWJpbGl0aWVzKSA9PT0gbnVsbCB8fCBfdGhpc19zZXJ2aWNlQ2FwYWJpbGl0aWVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpc19zZXJ2aWNlQ2FwYWJpbGl0aWVzLnRleHREb2N1bWVudFN5bmMpID09PSBicm93c2VyX21haW4uVGV4dERvY3VtZW50U3luY0tpbmQuTm9uZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoKF90aGlzX3NlcnZpY2VDYXBhYmlsaXRpZXMxID0gdGhpcy5zZXJ2aWNlQ2FwYWJpbGl0aWVzKSA9PT0gbnVsbCB8fCBfdGhpc19zZXJ2aWNlQ2FwYWJpbGl0aWVzMSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXNfc2VydmljZUNhcGFiaWxpdGllczEudGV4dERvY3VtZW50U3luYykgIT09IGJyb3dzZXJfbWFpbi5UZXh0RG9jdW1lbnRTeW5jS2luZC5JbmNyZW1lbnRhbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0VmFsdWUoaWRlbnRpZmllciwgdGhpcy5nZXREb2N1bWVudChpZGVudGlmaWVyLnVyaSkuZ2V0VGV4dCgpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0ZXh0RG9jdW1lbnRDaGFuZ2UgPSB7XG4gICAgICAgICAgICB0ZXh0RG9jdW1lbnQ6IHtcbiAgICAgICAgICAgICAgICB1cmk6IGlkZW50aWZpZXIudXJpLFxuICAgICAgICAgICAgICAgIHZlcnNpb246IGlkZW50aWZpZXIudmVyc2lvblxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbnRlbnRDaGFuZ2VzOiBkZWx0YXNcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uLnNlbmROb3RpZmljYXRpb24oJ3RleHREb2N1bWVudC9kaWRDaGFuZ2UnLCB0ZXh0RG9jdW1lbnRDaGFuZ2UpO1xuICAgIH1cbiAgICBzZXRWYWx1ZShpZGVudGlmaWVyLCB2YWx1ZSkge1xuICAgICAgICB2YXIgX3RoaXNfc2VydmljZUNhcGFiaWxpdGllcztcbiAgICAgICAgc3VwZXIuc2V0VmFsdWUoaWRlbnRpZmllciwgdmFsdWUpO1xuICAgICAgICBpZiAoIXRoaXMuaXNDb25uZWN0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKChfdGhpc19zZXJ2aWNlQ2FwYWJpbGl0aWVzID0gdGhpcy5zZXJ2aWNlQ2FwYWJpbGl0aWVzKSA9PT0gbnVsbCB8fCBfdGhpc19zZXJ2aWNlQ2FwYWJpbGl0aWVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpc19zZXJ2aWNlQ2FwYWJpbGl0aWVzLnRleHREb2N1bWVudFN5bmMpID09PSBicm93c2VyX21haW4uVGV4dERvY3VtZW50U3luY0tpbmQuTm9uZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRleHREb2N1bWVudENoYW5nZSA9IHtcbiAgICAgICAgICAgIHRleHREb2N1bWVudDoge1xuICAgICAgICAgICAgICAgIHVyaTogaWRlbnRpZmllci51cmksXG4gICAgICAgICAgICAgICAgdmVyc2lvbjogaWRlbnRpZmllci52ZXJzaW9uXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29udGVudENoYW5nZXM6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IHZhbHVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb24uc2VuZE5vdGlmaWNhdGlvbigndGV4dERvY3VtZW50L2RpZENoYW5nZScsIHRleHREb2N1bWVudENoYW5nZSk7XG4gICAgfVxuICAgIGFzeW5jIGRvSG92ZXIoZG9jdW1lbnQsIHBvc2l0aW9uKSB7XG4gICAgICAgIHZhciBfdGhpc19zZXJ2aWNlQ2FwYWJpbGl0aWVzO1xuICAgICAgICBpZiAoIXRoaXMuaXNJbml0aWFsaXplZCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoKF90aGlzX3NlcnZpY2VDYXBhYmlsaXRpZXMgPSB0aGlzLnNlcnZpY2VDYXBhYmlsaXRpZXMpID09PSBudWxsIHx8IF90aGlzX3NlcnZpY2VDYXBhYmlsaXRpZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzX3NlcnZpY2VDYXBhYmlsaXRpZXMuaG92ZXJQcm92aWRlcikpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGxldCBvcHRpb25zID0ge1xuICAgICAgICAgICAgdGV4dERvY3VtZW50OiB7XG4gICAgICAgICAgICAgICAgdXJpOiBkb2N1bWVudC51cmlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwb3NpdGlvbjogcG9zaXRpb25cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdGlvbi5zZW5kUmVxdWVzdCgndGV4dERvY3VtZW50L2hvdmVyJywgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIGRvQ29tcGxldGUoZG9jdW1lbnQsIHBvc2l0aW9uKSB7XG4gICAgICAgIHZhciBfdGhpc19zZXJ2aWNlQ2FwYWJpbGl0aWVzO1xuICAgICAgICBpZiAoIXRoaXMuaXNJbml0aWFsaXplZCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoKF90aGlzX3NlcnZpY2VDYXBhYmlsaXRpZXMgPSB0aGlzLnNlcnZpY2VDYXBhYmlsaXRpZXMpID09PSBudWxsIHx8IF90aGlzX3NlcnZpY2VDYXBhYmlsaXRpZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzX3NlcnZpY2VDYXBhYmlsaXRpZXMuY29tcGxldGlvblByb3ZpZGVyKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICB0ZXh0RG9jdW1lbnQ6IHtcbiAgICAgICAgICAgICAgICB1cmk6IGRvY3VtZW50LnVyaVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBvc2l0aW9uOiBwb3NpdGlvblxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0aW9uLnNlbmRSZXF1ZXN0KCd0ZXh0RG9jdW1lbnQvY29tcGxldGlvbicsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBkb1Jlc29sdmUoaXRlbSkge1xuICAgICAgICB2YXIgX3RoaXNfc2VydmljZUNhcGFiaWxpdGllc19jb21wbGV0aW9uUHJvdmlkZXIsIF90aGlzX3NlcnZpY2VDYXBhYmlsaXRpZXM7XG4gICAgICAgIGlmICghdGhpcy5pc0luaXRpYWxpemVkKSByZXR1cm4gbnVsbDtcbiAgICAgICAgaWYgKCEoKF90aGlzX3NlcnZpY2VDYXBhYmlsaXRpZXMgPSB0aGlzLnNlcnZpY2VDYXBhYmlsaXRpZXMpID09PSBudWxsIHx8IF90aGlzX3NlcnZpY2VDYXBhYmlsaXRpZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfdGhpc19zZXJ2aWNlQ2FwYWJpbGl0aWVzX2NvbXBsZXRpb25Qcm92aWRlciA9IF90aGlzX3NlcnZpY2VDYXBhYmlsaXRpZXMuY29tcGxldGlvblByb3ZpZGVyKSA9PT0gbnVsbCB8fCBfdGhpc19zZXJ2aWNlQ2FwYWJpbGl0aWVzX2NvbXBsZXRpb25Qcm92aWRlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXNfc2VydmljZUNhcGFiaWxpdGllc19jb21wbGV0aW9uUHJvdmlkZXIucmVzb2x2ZVByb3ZpZGVyKSkgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpb24uc2VuZFJlcXVlc3QoJ2NvbXBsZXRpb25JdGVtL3Jlc29sdmUnLCBpdGVtW1wiaXRlbVwiXSk7XG4gICAgfVxuICAgIGFzeW5jIGRvVmFsaWRhdGlvbihkb2N1bWVudCkge1xuICAgICAgICAvL1RPRE86IHRleHREb2N1bWVudC9kaWFnbm9zdGljIGNhcGFiaWxpdHlcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBhc3luYyBmb3JtYXQoZG9jdW1lbnQsIHJhbmdlLCBmb3JtYXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzSW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoISh0aGlzLnNlcnZpY2VDYXBhYmlsaXRpZXMgJiYgKHRoaXMuc2VydmljZUNhcGFiaWxpdGllcy5kb2N1bWVudFJhbmdlRm9ybWF0dGluZ1Byb3ZpZGVyIHx8IHRoaXMuc2VydmljZUNhcGFiaWxpdGllcy5kb2N1bWVudEZvcm1hdHRpbmdQcm92aWRlcikpKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLnNlcnZpY2VDYXBhYmlsaXRpZXMuZG9jdW1lbnRSYW5nZUZvcm1hdHRpbmdQcm92aWRlcikge1xuICAgICAgICAgICAgbGV0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgdGV4dERvY3VtZW50OiB7XG4gICAgICAgICAgICAgICAgICAgIHVyaTogZG9jdW1lbnQudXJpXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBmb3JtYXRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0aW9uLnNlbmRSZXF1ZXN0KCd0ZXh0RG9jdW1lbnQvZm9ybWF0dGluZycsIG9wdGlvbnMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgdGV4dERvY3VtZW50OiB7XG4gICAgICAgICAgICAgICAgICAgIHVyaTogZG9jdW1lbnQudXJpXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBmb3JtYXQsXG4gICAgICAgICAgICAgICAgcmFuZ2U6IHJhbmdlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdGlvbi5zZW5kUmVxdWVzdCgndGV4dERvY3VtZW50L3JhbmdlRm9ybWF0dGluZycsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldEdsb2JhbE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICBzdXBlci5zZXRHbG9iYWxPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBjb25maWdDaGFuZ2VzID0ge1xuICAgICAgICAgICAgc2V0dGluZ3M6IG9wdGlvbnNcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5lbnF1ZXVlSWZOb3RDb25uZWN0ZWQoKCk9PnRoaXMuY29ubmVjdGlvbi5zZW5kTm90aWZpY2F0aW9uKCd3b3Jrc3BhY2UvZGlkQ2hhbmdlQ29uZmlndXJhdGlvbicsIGNvbmZpZ0NoYW5nZXMpKTtcbiAgICB9XG4gICAgc2V0V29ya3NwYWNlKHdvcmtzcGFjZVVyaSkge1xuICAgICAgICB2YXIgX3RoaXNfc2VydmljZUNhcGFiaWxpdGllc193b3Jrc3BhY2Vfd29ya3NwYWNlRm9sZGVycywgX3RoaXNfc2VydmljZUNhcGFiaWxpdGllc193b3Jrc3BhY2UsIF90aGlzX3NlcnZpY2VDYXBhYmlsaXRpZXM7XG4gICAgICAgIHN1cGVyLnNldFdvcmtzcGFjZSh3b3Jrc3BhY2VVcmkpO1xuICAgICAgICBpZiAoISgoX3RoaXNfc2VydmljZUNhcGFiaWxpdGllcyA9IHRoaXMuc2VydmljZUNhcGFiaWxpdGllcykgPT09IG51bGwgfHwgX3RoaXNfc2VydmljZUNhcGFiaWxpdGllcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF90aGlzX3NlcnZpY2VDYXBhYmlsaXRpZXNfd29ya3NwYWNlID0gX3RoaXNfc2VydmljZUNhcGFiaWxpdGllcy53b3Jrc3BhY2UpID09PSBudWxsIHx8IF90aGlzX3NlcnZpY2VDYXBhYmlsaXRpZXNfd29ya3NwYWNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX3RoaXNfc2VydmljZUNhcGFiaWxpdGllc193b3Jrc3BhY2Vfd29ya3NwYWNlRm9sZGVycyA9IF90aGlzX3NlcnZpY2VDYXBhYmlsaXRpZXNfd29ya3NwYWNlLndvcmtzcGFjZUZvbGRlcnMpID09PSBudWxsIHx8IF90aGlzX3NlcnZpY2VDYXBhYmlsaXRpZXNfd29ya3NwYWNlX3dvcmtzcGFjZUZvbGRlcnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzX3NlcnZpY2VDYXBhYmlsaXRpZXNfd29ya3NwYWNlX3dvcmtzcGFjZUZvbGRlcnMuY2hhbmdlTm90aWZpY2F0aW9ucykpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRyZWNvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXNzYWdlID0ge1xuICAgICAgICAgICAgYWRkZWQ6IFtcbiAgICAgICAgICAgICAgICB0aGlzLndvcmtzcGFjZUZvbGRlclxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIHJlbW92ZWQ6IFtdXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpb24uc2VuZFJlcXVlc3QoJ3dvcmtzcGFjZS9kaWRDaGFuZ2VXb3Jrc3BhY2VGb2xkZXJzJywgbWVzc2FnZSk7XG4gICAgfVxuICAgIGdldCB3b3Jrc3BhY2VGb2xkZXIoKSB7XG4gICAgICAgIGxldCB3b3Jrc3BhY2VVcmkgPSB0aGlzLndvcmtzcGFjZVVyaTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHVyaTogbGFuZ3VhZ2VfY2xpZW50X1VSSS5maWxlKHdvcmtzcGFjZVVyaSkudG9TdHJpbmcoKSxcbiAgICAgICAgICAgIG5hbWU6IHdvcmtzcGFjZVVyaS5zcGxpdChcIi9cIikucG9wKClcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXN5bmMgZmluZERvY3VtZW50SGlnaGxpZ2h0cyhkb2N1bWVudCwgcG9zaXRpb24pIHtcbiAgICAgICAgdmFyIF90aGlzX3NlcnZpY2VDYXBhYmlsaXRpZXM7XG4gICAgICAgIGlmICghdGhpcy5pc0luaXRpYWxpemVkKSByZXR1cm4gW107XG4gICAgICAgIGlmICghKChfdGhpc19zZXJ2aWNlQ2FwYWJpbGl0aWVzID0gdGhpcy5zZXJ2aWNlQ2FwYWJpbGl0aWVzKSA9PT0gbnVsbCB8fCBfdGhpc19zZXJ2aWNlQ2FwYWJpbGl0aWVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpc19zZXJ2aWNlQ2FwYWJpbGl0aWVzLmRvY3VtZW50SGlnaGxpZ2h0UHJvdmlkZXIpKSByZXR1cm4gW107XG4gICAgICAgIGxldCBvcHRpb25zID0ge1xuICAgICAgICAgICAgdGV4dERvY3VtZW50OiB7XG4gICAgICAgICAgICAgICAgdXJpOiBkb2N1bWVudC51cmlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwb3NpdGlvbjogcG9zaXRpb25cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdGlvbi5zZW5kUmVxdWVzdCgndGV4dERvY3VtZW50L2RvY3VtZW50SGlnaGxpZ2h0Jywgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIHByb3ZpZGVTaWduYXR1cmVIZWxwKGRvY3VtZW50LCBwb3NpdGlvbikge1xuICAgICAgICB2YXIgX3RoaXNfc2VydmljZUNhcGFiaWxpdGllcztcbiAgICAgICAgaWYgKCF0aGlzLmlzSW5pdGlhbGl6ZWQpIHJldHVybiBudWxsO1xuICAgICAgICBpZiAoISgoX3RoaXNfc2VydmljZUNhcGFiaWxpdGllcyA9IHRoaXMuc2VydmljZUNhcGFiaWxpdGllcykgPT09IG51bGwgfHwgX3RoaXNfc2VydmljZUNhcGFiaWxpdGllcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXNfc2VydmljZUNhcGFiaWxpdGllcy5zaWduYXR1cmVIZWxwUHJvdmlkZXIpKSByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICB0ZXh0RG9jdW1lbnQ6IHtcbiAgICAgICAgICAgICAgICB1cmk6IGRvY3VtZW50LnVyaVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBvc2l0aW9uOiBwb3NpdGlvblxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0aW9uLnNlbmRSZXF1ZXN0KCd0ZXh0RG9jdW1lbnQvc2lnbmF0dXJlSGVscCcsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBnZXRTZW1hbnRpY1Rva2Vucyhkb2N1bWVudCwgcmFuZ2UpIHtcbiAgICAgICAgdmFyIF90aGlzX3NlcnZpY2VDYXBhYmlsaXRpZXM7XG4gICAgICAgIGlmICghdGhpcy5pc0luaXRpYWxpemVkKSByZXR1cm4gbnVsbDtcbiAgICAgICAgaWYgKCEoKF90aGlzX3NlcnZpY2VDYXBhYmlsaXRpZXMgPSB0aGlzLnNlcnZpY2VDYXBhYmlsaXRpZXMpID09PSBudWxsIHx8IF90aGlzX3NlcnZpY2VDYXBhYmlsaXRpZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzX3NlcnZpY2VDYXBhYmlsaXRpZXMuc2VtYW50aWNUb2tlbnNQcm92aWRlcikpIHJldHVybiBudWxsO1xuICAgICAgICBpZiAoIXRoaXMuc2VydmljZUNhcGFiaWxpdGllcy5zZW1hbnRpY1Rva2Vuc1Byb3ZpZGVyLnJhbmdlKSB7XG4gICAgICAgICAgICBsZXQgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICB0ZXh0RG9jdW1lbnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgdXJpOiBkb2N1bWVudC51cmlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdGlvbi5zZW5kUmVxdWVzdCgndGV4dERvY3VtZW50L3NlbWFudGljVG9rZW5zL2Z1bGwnLCBvcHRpb25zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBvcHRpb25zID0ge1xuICAgICAgICAgICAgICAgIHRleHREb2N1bWVudDoge1xuICAgICAgICAgICAgICAgICAgICB1cmk6IGRvY3VtZW50LnVyaVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcmFuZ2U6IHJhbmdlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdGlvbi5zZW5kUmVxdWVzdCgndGV4dERvY3VtZW50L3NlbWFudGljVG9rZW5zL3JhbmdlJywgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZ2V0Q29kZUFjdGlvbnMoZG9jdW1lbnQsIHJhbmdlLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpc19zZXJ2aWNlQ2FwYWJpbGl0aWVzO1xuICAgICAgICBpZiAoIXRoaXMuaXNJbml0aWFsaXplZCkgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmICghKChfdGhpc19zZXJ2aWNlQ2FwYWJpbGl0aWVzID0gdGhpcy5zZXJ2aWNlQ2FwYWJpbGl0aWVzKSA9PT0gbnVsbCB8fCBfdGhpc19zZXJ2aWNlQ2FwYWJpbGl0aWVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpc19zZXJ2aWNlQ2FwYWJpbGl0aWVzLmNvZGVBY3Rpb25Qcm92aWRlcikpIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHRleHREb2N1bWVudDoge1xuICAgICAgICAgICAgICAgIHVyaTogZG9jdW1lbnQudXJpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmFuZ2U6IHJhbmdlLFxuICAgICAgICAgICAgY29udGV4dDogY29udGV4dFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0aW9uLnNlbmRSZXF1ZXN0KCd0ZXh0RG9jdW1lbnQvY29kZUFjdGlvbicsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBleGVjdXRlQ29tbWFuZChjb21tYW5kLCBhcmdzKSB7XG4gICAgICAgIHZhciBfdGhpc19zZXJ2aWNlQ2FwYWJpbGl0aWVzLCBfdGhpc19zZXJ2aWNlQ2FwYWJpbGl0aWVzMTtcbiAgICAgICAgaWYgKCF0aGlzLmlzSW5pdGlhbGl6ZWQpIHJldHVybiBQcm9taXNlLnJlc29sdmUobnVsbCk7XG4gICAgICAgIGlmICghKChfdGhpc19zZXJ2aWNlQ2FwYWJpbGl0aWVzID0gdGhpcy5zZXJ2aWNlQ2FwYWJpbGl0aWVzKSA9PT0gbnVsbCB8fCBfdGhpc19zZXJ2aWNlQ2FwYWJpbGl0aWVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpc19zZXJ2aWNlQ2FwYWJpbGl0aWVzLmV4ZWN1dGVDb21tYW5kUHJvdmlkZXIpIHx8ICEoKF90aGlzX3NlcnZpY2VDYXBhYmlsaXRpZXMxID0gdGhpcy5zZXJ2aWNlQ2FwYWJpbGl0aWVzKSA9PT0gbnVsbCB8fCBfdGhpc19zZXJ2aWNlQ2FwYWJpbGl0aWVzMSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXNfc2VydmljZUNhcGFiaWxpdGllczEuZXhlY3V0ZUNvbW1hbmRQcm92aWRlci5jb21tYW5kcy5pbmNsdWRlcyhjb21tYW5kKSkpIHJldHVybiBQcm9taXNlLnJlc29sdmUobnVsbCk7XG4gICAgICAgIGxldCBvcHRpb25zID0ge1xuICAgICAgICAgICAgY29tbWFuZCxcbiAgICAgICAgICAgIGFyZ3VtZW50czogYXJnc1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0aW9uLnNlbmRSZXF1ZXN0KCd3b3Jrc3BhY2UvZXhlY3V0ZUNvbW1hbmQnLCBvcHRpb25zKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3Ioc2VydmVyRGF0YSwgY3R4LCB3b3Jrc3BhY2VVcmkpe1xuICAgICAgICBzdXBlcihzZXJ2ZXJEYXRhLm1vZGVzLCB3b3Jrc3BhY2VVcmkpO1xuICAgICAgICBsYW5ndWFnZV9jbGllbnRfZGVmaW5lX3Byb3BlcnR5KHRoaXMsIFwiJHNlcnZpY2VcIiwgdm9pZCAwKTtcbiAgICAgICAgbGFuZ3VhZ2VfY2xpZW50X2RlZmluZV9wcm9wZXJ0eSh0aGlzLCBcImlzQ29ubmVjdGVkXCIsIGZhbHNlKTtcbiAgICAgICAgbGFuZ3VhZ2VfY2xpZW50X2RlZmluZV9wcm9wZXJ0eSh0aGlzLCBcImlzSW5pdGlhbGl6ZWRcIiwgZmFsc2UpO1xuICAgICAgICBsYW5ndWFnZV9jbGllbnRfZGVmaW5lX3Byb3BlcnR5KHRoaXMsIFwic29ja2V0XCIsIHZvaWQgMCk7XG4gICAgICAgIGxhbmd1YWdlX2NsaWVudF9kZWZpbmVfcHJvcGVydHkodGhpcywgXCJjb25uZWN0aW9uXCIsIHZvaWQgMCk7XG4gICAgICAgIGxhbmd1YWdlX2NsaWVudF9kZWZpbmVfcHJvcGVydHkodGhpcywgXCJyZXF1ZXN0c1F1ZXVlXCIsIFtdKTtcbiAgICAgICAgbGFuZ3VhZ2VfY2xpZW50X2RlZmluZV9wcm9wZXJ0eSh0aGlzLCBcImNhbGxiYWNrSWRcIiwgMCk7XG4gICAgICAgIGxhbmd1YWdlX2NsaWVudF9kZWZpbmVfcHJvcGVydHkodGhpcywgXCJjYWxsYmFja3NcIiwge30pO1xuICAgICAgICBsYW5ndWFnZV9jbGllbnRfZGVmaW5lX3Byb3BlcnR5KHRoaXMsIFwic2VydmVyRGF0YVwiLCB2b2lkIDApO1xuICAgICAgICBsYW5ndWFnZV9jbGllbnRfZGVmaW5lX3Byb3BlcnR5KHRoaXMsIFwiY3R4XCIsIHZvaWQgMCk7XG4gICAgICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgICAgICB0aGlzLnNlcnZlckRhdGEgPSBzZXJ2ZXJEYXRhO1xuICAgICAgICB0aGlzLiRjb25uZWN0KCk7XG4gICAgfVxufVxuXG59KSgpO1xuXG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfZXhwb3J0c19fO1xuLyoqKioqKi8gfSkoKVxuO1xufSk7Il0sIm5hbWVzIjpbIndlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwicm9vdCIsImZhY3RvcnkiLCJleHBvcnRzIiwibW9kdWxlIiwiZGVmaW5lIiwiYW1kIiwiYSIsImkiLCJfX3dlYnBhY2tfbW9kdWxlc19fIiwiX191bnVzZWRfd2VicGFja19leHBvcnRzIiwiX193ZWJwYWNrX3JlcXVpcmVfXyIsInByb2Nlc3MiLCJjb25zb2xlIiwiX3R5cGVvZiIsIm9iaiIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiY29uc3RydWN0b3IiLCJwcm90b3R5cGUiLCJfY2xhc3NDYWxsQ2hlY2siLCJpbnN0YW5jZSIsIkNvbnN0cnVjdG9yIiwiVHlwZUVycm9yIiwiX3JlcXVpcmUiLCJfcmVxdWlyZSRjb2RlcyIsImNvZGVzIiwiRVJSX0FNQklHVU9VU19BUkdVTUVOVCIsIkVSUl9JTlZBTElEX0FSR19UWVBFIiwiRVJSX0lOVkFMSURfQVJHX1ZBTFVFIiwiRVJSX0lOVkFMSURfUkVUVVJOX1ZBTFVFIiwiRVJSX01JU1NJTkdfQVJHUyIsIkFzc2VydGlvbkVycm9yIiwiX3JlcXVpcmUyIiwiaW5zcGVjdCIsIl9yZXF1aXJlJHR5cGVzIiwidHlwZXMiLCJpc1Byb21pc2UiLCJpc1JlZ0V4cCIsIm9iamVjdEFzc2lnbiIsIk9iamVjdCIsImFzc2lnbiIsIm9iamVjdElzIiwiaXMiLCJlcnJvckNhY2hlIiwiTWFwIiwiaXNEZWVwRXF1YWwiLCJpc0RlZXBTdHJpY3RFcXVhbCIsInBhcnNlRXhwcmVzc2lvbkF0IiwiZmluZE5vZGVBcm91bmQiLCJkZWNvZGVyIiwibGF6eUxvYWRDb21wYXJpc29uIiwiY29tcGFyaXNvbiIsImVzY2FwZVNlcXVlbmNlc1JlZ0V4cCIsIm1ldGEiLCJlc2NhcGVGbiIsInN0ciIsImNoYXJDb2RlQXQiLCJ3YXJuZWQiLCJhc3NlcnQiLCJvayIsIk5PX0VYQ0VQVElPTl9TRU5USU5FTCIsImlubmVyRmFpbCIsIm1lc3NhZ2UiLCJFcnJvciIsImZhaWwiLCJhY3R1YWwiLCJleHBlY3RlZCIsIm9wZXJhdG9yIiwic3RhY2tTdGFydEZuIiwiYXJnc0xlbiIsImFyZ3VtZW50cyIsImxlbmd0aCIsImludGVybmFsTWVzc2FnZSIsInVuZGVmaW5lZCIsIndhcm4iLCJlbWl0V2FybmluZyIsImJpbmQiLCJlcnJBcmdzIiwiZXJyIiwiZ2VuZXJhdGVkTWVzc2FnZSIsImlubmVyT2siLCJmbiIsImFyZ0xlbiIsInZhbHVlIiwiX2xlbiIsImFyZ3MiLCJBcnJheSIsIl9rZXkiLCJhcHBseSIsImNvbmNhdCIsImVxdWFsIiwibm90RXF1YWwiLCJkZWVwRXF1YWwiLCJub3REZWVwRXF1YWwiLCJkZWVwU3RyaWN0RXF1YWwiLCJub3REZWVwU3RyaWN0RXF1YWwiLCJzdHJpY3RFcXVhbCIsIm5vdFN0cmljdEVxdWFsIiwiQ29tcGFyaXNvbiIsImtleXMiLCJfdGhpcyIsImZvckVhY2giLCJrZXkiLCJ0ZXN0IiwiY29tcGFyZUV4Y2VwdGlvbktleSIsImIiLCJuYW1lIiwiZXhwZWN0ZWRFeGNlcHRpb24iLCJtc2ciLCJwdXNoIiwiaXNQcm90b3R5cGVPZiIsImNhbGwiLCJnZXRBY3R1YWwiLCJlIiwiY2hlY2tJc1Byb21pc2UiLCJ0aGVuIiwiY2F0Y2giLCJ3YWl0Rm9yQWN0dWFsIiwicHJvbWlzZUZuIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZXN1bHRQcm9taXNlIiwiZXhwZWN0c0Vycm9yIiwiZXJyb3IiLCJkZXRhaWxzIiwiZm5UeXBlIiwiZXhwZWN0c05vRXJyb3IiLCJ0aHJvd3MiLCJfbGVuMiIsIl9rZXkyIiwicmVqZWN0cyIsIl9sZW4zIiwiX2tleTMiLCJyZXN1bHQiLCJkb2VzTm90VGhyb3ciLCJfbGVuNCIsIl9rZXk0IiwiZG9lc05vdFJlamVjdCIsIl9sZW41IiwiX2tleTUiLCJpZkVycm9yIiwibmV3RXJyIiwib3JpZ1N0YWNrIiwic3RhY2siLCJ0bXAyIiwic3BsaXQiLCJzaGlmdCIsInRtcDEiLCJwb3MiLCJpbmRleE9mIiwic2xpY2UiLCJqb2luIiwic3RyaWN0IiwiX2xlbjYiLCJfa2V5NiIsIl9vYmplY3RTcHJlYWQiLCJ0YXJnZXQiLCJzb3VyY2UiLCJvd25LZXlzIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwiZmlsdGVyIiwic3ltIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsIl9kZWZpbmVQcm9wZXJ0eSIsImRlZmluZVByb3BlcnR5IiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJfZGVmaW5lUHJvcGVydGllcyIsInByb3BzIiwiZGVzY3JpcHRvciIsIl9jcmVhdGVDbGFzcyIsInByb3RvUHJvcHMiLCJzdGF0aWNQcm9wcyIsIl9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuIiwic2VsZiIsIl9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQiLCJSZWZlcmVuY2VFcnJvciIsIl9pbmhlcml0cyIsInN1YkNsYXNzIiwic3VwZXJDbGFzcyIsImNyZWF0ZSIsIl9zZXRQcm90b3R5cGVPZiIsIl93cmFwTmF0aXZlU3VwZXIiLCJDbGFzcyIsIl9jYWNoZSIsIl9pc05hdGl2ZUZ1bmN0aW9uIiwiaGFzIiwiZ2V0Iiwic2V0IiwiV3JhcHBlciIsIl9jb25zdHJ1Y3QiLCJfZ2V0UHJvdG90eXBlT2YiLCJpc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QiLCJSZWZsZWN0IiwiY29uc3RydWN0Iiwic2hhbSIsIlByb3h5IiwiRGF0ZSIsInRvU3RyaW5nIiwiUGFyZW50IiwiRnVuY3Rpb24iLCJvIiwicCIsInNldFByb3RvdHlwZU9mIiwiX19wcm90b19fIiwiZ2V0UHJvdG90eXBlT2YiLCJlbmRzV2l0aCIsInNlYXJjaCIsInRoaXNfbGVuIiwic3Vic3RyaW5nIiwicmVwZWF0IiwiY291bnQiLCJNYXRoIiwiZmxvb3IiLCJtYXhDb3VudCIsImxvZyIsImJsdWUiLCJncmVlbiIsInJlZCIsIndoaXRlIiwia1JlYWRhYmxlT3BlcmF0b3IiLCJzdHJpY3RFcXVhbE9iamVjdCIsIm5vdFN0cmljdEVxdWFsT2JqZWN0Iiwibm90SWRlbnRpY2FsIiwia01heFNob3J0TGVuZ3RoIiwiY29weUVycm9yIiwiaW5zcGVjdFZhbHVlIiwidmFsIiwiY29tcGFjdCIsImN1c3RvbUluc3BlY3QiLCJkZXB0aCIsIm1heEFycmF5TGVuZ3RoIiwiSW5maW5pdHkiLCJzaG93SGlkZGVuIiwiYnJlYWtMZW5ndGgiLCJzaG93UHJveHkiLCJzb3J0ZWQiLCJnZXR0ZXJzIiwiY3JlYXRlRXJyRGlmZiIsIm90aGVyIiwicmVzIiwibGFzdFBvcyIsImVuZCIsInNraXBwZWQiLCJhY3R1YWxJbnNwZWN0ZWQiLCJhY3R1YWxMaW5lcyIsImV4cGVjdGVkTGluZXMiLCJpbmRpY2F0b3IiLCJpbnB1dExlbmd0aCIsIm1heExlbmd0aCIsInN0ZGVyciIsImlzVFRZIiwiY29sdW1ucyIsInBvcCIsIm1heExpbmVzIiwibWF4IiwiX2FjdHVhbExpbmVzIiwicHJpbnRlZExpbmVzIiwic2tpcHBlZE1zZyIsImN1ciIsImV4cGVjdGVkTGluZSIsImFjdHVhbExpbmUiLCJkaXZlcmdpbmdMaW5lcyIsIl9FcnJvciIsIm9wdGlvbnMiLCJsaW1pdCIsInN0YWNrVHJhY2VMaW1pdCIsIlN0cmluZyIsImdldENvbG9yRGVwdGgiLCJiYXNlIiwiX3JlcyIsImtub3duT3BlcmF0b3JzIiwiY29kZSIsImNhcHR1cmVTdGFja1RyYWNlIiwiY3VzdG9tIiwicmVjdXJzZVRpbWVzIiwiY3R4IiwidXRpbCIsImNyZWF0ZUVycm9yVHlwZSIsIkJhc2UiLCJnZXRNZXNzYWdlIiwiYXJnMSIsImFyZzIiLCJhcmczIiwiTm9kZUVycm9yIiwiX0Jhc2UiLCJvbmVPZiIsInRoaW5nIiwiaXNBcnJheSIsImxlbiIsIm1hcCIsInN0YXJ0c1dpdGgiLCJzdWJzdHIiLCJpbmNsdWRlcyIsInN0YXJ0IiwiZGV0ZXJtaW5lciIsInJlcGxhY2UiLCJ0eXBlIiwicmVhc29uIiwiaW5zcGVjdGVkIiwiUmFuZ2VFcnJvciIsImlucHV0IiwiX3NsaWNlZFRvQXJyYXkiLCJhcnIiLCJfYXJyYXlXaXRoSG9sZXMiLCJfaXRlcmFibGVUb0FycmF5TGltaXQiLCJfbm9uSXRlcmFibGVSZXN0IiwiX2FyciIsIl9uIiwiX2QiLCJfZSIsIl9pIiwiX3MiLCJuZXh0IiwiZG9uZSIsInJlZ2V4RmxhZ3NTdXBwb3J0ZWQiLCJmbGFncyIsImFycmF5RnJvbVNldCIsImFycmF5IiwiYXJyYXlGcm9tTWFwIiwib2JqZWN0R2V0T3duUHJvcGVydHlTeW1ib2xzIiwibnVtYmVySXNOYU4iLCJOdW1iZXIiLCJpc05hTiIsInVuY3VycnlUaGlzIiwiZiIsImhhc093blByb3BlcnR5IiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJvYmplY3RUb1N0cmluZyIsImlzQW55QXJyYXlCdWZmZXIiLCJpc0FycmF5QnVmZmVyVmlldyIsImlzRGF0ZSIsImlzTWFwIiwiaXNTZXQiLCJpc05hdGl2ZUVycm9yIiwiaXNCb3hlZFByaW1pdGl2ZSIsImlzTnVtYmVyT2JqZWN0IiwiaXNTdHJpbmdPYmplY3QiLCJpc0Jvb2xlYW5PYmplY3QiLCJpc0JpZ0ludE9iamVjdCIsImlzU3ltYm9sT2JqZWN0IiwiaXNGbG9hdDMyQXJyYXkiLCJpc0Zsb2F0NjRBcnJheSIsImlzTm9uSW5kZXgiLCJwb3ciLCJnZXRPd25Ob25JbmRleFByb3BlcnRpZXMiLCJjb21wYXJlIiwieCIsInkiLCJtaW4iLCJPTkxZX0VOVU1FUkFCTEUiLCJrU3RyaWN0Iiwia0xvb3NlIiwia05vSXRlcmF0b3IiLCJrSXNBcnJheSIsImtJc1NldCIsImtJc01hcCIsImFyZVNpbWlsYXJSZWdFeHBzIiwiUmVnRXhwIiwiYXJlU2ltaWxhckZsb2F0QXJyYXlzIiwiYnl0ZUxlbmd0aCIsIm9mZnNldCIsImFyZVNpbWlsYXJUeXBlZEFycmF5cyIsIlVpbnQ4QXJyYXkiLCJidWZmZXIiLCJieXRlT2Zmc2V0IiwiYXJlRXF1YWxBcnJheUJ1ZmZlcnMiLCJidWYxIiwiYnVmMiIsImlzRXF1YWxCb3hlZFByaW1pdGl2ZSIsInZhbDEiLCJ2YWwyIiwidmFsdWVPZiIsIkJvb2xlYW4iLCJCaWdJbnQiLCJpbm5lckRlZXBFcXVhbCIsIm1lbW9zIiwidmFsMVRhZyIsInZhbDJUYWciLCJrZXlzMSIsImtleXMyIiwia2V5Q2hlY2siLCJnZXRUaW1lIiwiX2tleXMiLCJfa2V5czIiLCJzaXplIiwiZ2V0RW51bWVyYWJsZXMiLCJrIiwiaXRlcmF0aW9uVHlwZSIsImFLZXlzIiwiYktleXMiLCJzeW1ib2xLZXlzQSIsInN5bWJvbEtleXNCIiwiX3N5bWJvbEtleXNCIiwicG9zaXRpb24iLCJ2YWwyTWVtb0EiLCJ2YWwyTWVtb0IiLCJhcmVFcSIsIm9iakVxdWl2IiwiZGVsZXRlIiwic2V0SGFzRXF1YWxFbGVtZW50IiwibWVtbyIsInNldFZhbHVlcyIsImZpbmRMb29zZU1hdGNoaW5nUHJpbWl0aXZlcyIsInByaW0iLCJzZXRNaWdodEhhdmVMb29zZVByaW0iLCJhbHRWYWx1ZSIsIm1hcE1pZ2h0SGF2ZUxvb3NlUHJpbSIsIml0ZW0iLCJjdXJCIiwic2V0RXF1aXYiLCJhVmFsdWVzIiwiU2V0IiwiYWRkIiwiYlZhbHVlcyIsIl92YWwiLCJtYXBIYXNFcXVhbEVudHJ5Iiwia2V5MSIsIml0ZW0xIiwia2V5MiIsIm1hcEVxdWl2IiwiYUVudHJpZXMiLCJfYUVudHJpZXMkaSIsIml0ZW0yIiwiYkVudHJpZXMiLCJfaTIiLCJfYkVudHJpZXMkX2kiLCJrZXlzQSIsIkdldEludHJpbnNpYyIsImNhbGxCaW5kIiwiJGluZGV4T2YiLCJjYWxsQm91bmRJbnRyaW5zaWMiLCJhbGxvd01pc3NpbmciLCJpbnRyaW5zaWMiLCJzZXRGdW5jdGlvbkxlbmd0aCIsIiRUeXBlRXJyb3IiLCIkYXBwbHkiLCIkY2FsbCIsIiRyZWZsZWN0QXBwbHkiLCIkZGVmaW5lUHJvcGVydHkiLCIkbWF4Iiwib3JpZ2luYWxGdW5jdGlvbiIsImZ1bmMiLCJhcHBseUJpbmQiLCJub3ciLCJ0aW1lcyIsImciLCJ3aW5kb3ciLCJmdW5jdGlvbnMiLCJpbmZvIiwidGltZSIsInRpbWVFbmQiLCJ0cmFjZSIsImRpciIsImNvbnNvbGVBc3NlcnQiLCJ0dXBsZSIsImxhYmVsIiwiZHVyYXRpb24iLCJmb3JtYXQiLCJvYmplY3QiLCJleHByZXNzaW9uIiwiJFN5bnRheEVycm9yIiwiZ29wZCIsImRlZmluZURhdGFQcm9wZXJ0eSIsInByb3BlcnR5Iiwibm9uRW51bWVyYWJsZSIsIm5vbldyaXRhYmxlIiwibm9uQ29uZmlndXJhYmxlIiwibG9vc2UiLCJkZXNjIiwiaGFzU3ltYm9scyIsInRvU3RyIiwib3JpZ0RlZmluZVByb3BlcnR5IiwiaXNGdW5jdGlvbiIsImhhc1Byb3BlcnR5RGVzY3JpcHRvcnMiLCJzdXBwb3J0c0Rlc2NyaXB0b3JzIiwicHJlZGljYXRlIiwiZGVmaW5lUHJvcGVydGllcyIsInByZWRpY2F0ZXMiLCJFdmFsRXJyb3IiLCJTeW50YXhFcnJvciIsIlVSSUVycm9yIiwiZmlyc3RTb3VyY2UiLCJ0byIsIm5leHRTb3VyY2UiLCJrZXlzQXJyYXkiLCJuZXh0SW5kZXgiLCJuZXh0S2V5IiwicG9seWZpbGwiLCJpc0NhbGxhYmxlIiwiZm9yRWFjaEFycmF5IiwicmVjZWl2ZXIiLCJmb3JFYWNoU3RyaW5nIiwic3RyaW5nIiwiY2hhckF0IiwiZm9yRWFjaE9iamVjdCIsImxpc3QiLCJ0aGlzQXJnIiwiRVJST1JfTUVTU0FHRSIsImZ1bmNUeXBlIiwiY29uY2F0dHkiLCJqIiwic2xpY3kiLCJhcnJMaWtlIiwiam9pbnkiLCJqb2luZXIiLCJ0aGF0IiwiYm91bmQiLCJiaW5kZXIiLCJib3VuZExlbmd0aCIsImJvdW5kQXJncyIsIkVtcHR5IiwiaW1wbGVtZW50YXRpb24iLCIkRXJyb3IiLCIkRXZhbEVycm9yIiwiJFJhbmdlRXJyb3IiLCIkUmVmZXJlbmNlRXJyb3IiLCIkVVJJRXJyb3IiLCIkRnVuY3Rpb24iLCJnZXRFdmFsbGVkQ29uc3RydWN0b3IiLCJleHByZXNzaW9uU3ludGF4IiwiJGdPUEQiLCJ0aHJvd1R5cGVFcnJvciIsIlRocm93VHlwZUVycm9yIiwiY2FsbGVlIiwiY2FsbGVlVGhyb3dzIiwiZ09QRHRocm93cyIsImhhc1Byb3RvIiwiZ2V0UHJvdG8iLCJuZWVkc0V2YWwiLCJUeXBlZEFycmF5IiwiSU5UUklOU0lDUyIsIkFnZ3JlZ2F0ZUVycm9yIiwiQXJyYXlCdWZmZXIiLCJBdG9taWNzIiwiQmlnSW50NjRBcnJheSIsIkJpZ1VpbnQ2NEFycmF5IiwiRGF0YVZpZXciLCJkZWNvZGVVUkkiLCJkZWNvZGVVUklDb21wb25lbnQiLCJlbmNvZGVVUkkiLCJlbmNvZGVVUklDb21wb25lbnQiLCJldmFsIiwiRmxvYXQzMkFycmF5IiwiRmxvYXQ2NEFycmF5IiwiRmluYWxpemF0aW9uUmVnaXN0cnkiLCJJbnQ4QXJyYXkiLCJJbnQxNkFycmF5IiwiSW50MzJBcnJheSIsImlzRmluaXRlIiwiSlNPTiIsInBhcnNlRmxvYXQiLCJwYXJzZUludCIsIlNoYXJlZEFycmF5QnVmZmVyIiwiVWludDhDbGFtcGVkQXJyYXkiLCJVaW50MTZBcnJheSIsIlVpbnQzMkFycmF5IiwiV2Vha01hcCIsIldlYWtSZWYiLCJXZWFrU2V0IiwiZXJyb3JQcm90byIsImRvRXZhbCIsImdlbiIsIkxFR0FDWV9BTElBU0VTIiwiaGFzT3duIiwiJGNvbmNhdCIsIiRzcGxpY2VBcHBseSIsInNwbGljZSIsIiRyZXBsYWNlIiwiJHN0clNsaWNlIiwiJGV4ZWMiLCJleGVjIiwicmVQcm9wTmFtZSIsInJlRXNjYXBlQ2hhciIsInN0cmluZ1RvUGF0aCIsImZpcnN0IiwibGFzdCIsIm1hdGNoIiwibnVtYmVyIiwicXVvdGUiLCJzdWJTdHJpbmciLCJnZXRCYXNlSW50cmluc2ljIiwiaW50cmluc2ljTmFtZSIsImFsaWFzIiwicGFydHMiLCJpbnRyaW5zaWNCYXNlTmFtZSIsImludHJpbnNpY1JlYWxOYW1lIiwic2tpcEZ1cnRoZXJDYWNoaW5nIiwiaXNPd24iLCJwYXJ0IiwiaGFzQXJyYXlMZW5ndGhEZWZpbmVCdWciLCJmb28iLCIkT2JqZWN0Iiwib3JpZ1N5bWJvbCIsImhhc1N5bWJvbFNoYW0iLCJoYXNOYXRpdmVTeW1ib2xzIiwic3ltT2JqIiwic3ltVmFsIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsInN5bXMiLCJoYXNUb1N0cmluZ1RhZ1NoYW1zIiwidG9TdHJpbmdUYWciLCIkaGFzT3duIiwiaW5oZXJpdHMiLCJjdG9yIiwic3VwZXJDdG9yIiwic3VwZXJfIiwiVGVtcEN0b3IiLCJoYXNUb1N0cmluZ1RhZyIsImNhbGxCb3VuZCIsIiR0b1N0cmluZyIsImlzU3RhbmRhcmRBcmd1bWVudHMiLCJpc0FyZ3VtZW50cyIsImlzTGVnYWN5QXJndW1lbnRzIiwic3VwcG9ydHNTdGFuZGFyZEFyZ3VtZW50cyIsImZuVG9TdHIiLCJyZWZsZWN0QXBwbHkiLCJiYWRBcnJheUxpa2UiLCJpc0NhbGxhYmxlTWFya2VyIiwiXyIsImNvbnN0cnVjdG9yUmVnZXgiLCJpc0VTNkNsYXNzRm4iLCJpc0VTNkNsYXNzRnVuY3Rpb24iLCJmblN0ciIsInRyeUZ1bmN0aW9uT2JqZWN0IiwidHJ5RnVuY3Rpb25Ub1N0ciIsIm9iamVjdENsYXNzIiwiZm5DbGFzcyIsImdlbkNsYXNzIiwiZGRhQ2xhc3MiLCJkZGFDbGFzczIiLCJkZGFDbGFzczMiLCJpc0lFNjgiLCJpc0REQSIsImlzRG9jdW1lbnREb3RBbGwiLCJkb2N1bWVudCIsImFsbCIsInN0ckNsYXNzIiwiaXNGblJlZ2V4IiwiZ2V0R2VuZXJhdG9yRnVuYyIsIkdlbmVyYXRvckZ1bmN0aW9uIiwiaXNHZW5lcmF0b3JGdW5jdGlvbiIsImdlbmVyYXRvckZ1bmMiLCJnZXRQb2x5ZmlsbCIsInNoaW0iLCJOYU4iLCJzaGltTnVtYmVySXNOYU4iLCJ0ZXN0SXNOYU4iLCJ3aGljaFR5cGVkQXJyYXkiLCJpc1R5cGVkQXJyYXkiLCJzaGltT2JqZWN0SXMiLCJ0ZXN0T2JqZWN0SXMiLCJrZXlzU2hpbSIsImlzQXJncyIsImlzRW51bWVyYWJsZSIsImhhc0RvbnRFbnVtQnVnIiwiaGFzUHJvdG9FbnVtQnVnIiwiZG9udEVudW1zIiwiZXF1YWxzQ29uc3RydWN0b3JQcm90b3R5cGUiLCJleGNsdWRlZEtleXMiLCIkYXBwbGljYXRpb25DYWNoZSIsIiRjb25zb2xlIiwiJGV4dGVybmFsIiwiJGZyYW1lIiwiJGZyYW1lRWxlbWVudCIsIiRmcmFtZXMiLCIkaW5uZXJIZWlnaHQiLCIkaW5uZXJXaWR0aCIsIiRvbm1vemZ1bGxzY3JlZW5jaGFuZ2UiLCIkb25tb3pmdWxsc2NyZWVuZXJyb3IiLCIkb3V0ZXJIZWlnaHQiLCIkb3V0ZXJXaWR0aCIsIiRwYWdlWE9mZnNldCIsIiRwYWdlWU9mZnNldCIsIiRwYXJlbnQiLCIkc2Nyb2xsTGVmdCIsIiRzY3JvbGxUb3AiLCIkc2Nyb2xsWCIsIiRzY3JvbGxZIiwiJHNlbGYiLCIkd2Via2l0SW5kZXhlZERCIiwiJHdlYmtpdFN0b3JhZ2VJbmZvIiwiJHdpbmRvdyIsImhhc0F1dG9tYXRpb25FcXVhbGl0eUJ1ZyIsImVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlSWZOb3RCdWdneSIsImlzT2JqZWN0IiwiaXNTdHJpbmciLCJ0aGVLZXlzIiwic2tpcFByb3RvIiwic2tpcENvbnN0cnVjdG9yIiwib3JpZ0tleXMiLCJvcmlnaW5hbEtleXMiLCJzaGltT2JqZWN0S2V5cyIsImtleXNXb3Jrc1dpdGhBcmd1bWVudHMiLCJjYWNoZWRTZXRUaW1lb3V0IiwiY2FjaGVkQ2xlYXJUaW1lb3V0IiwiZGVmYXVsdFNldFRpbW91dCIsImRlZmF1bHRDbGVhclRpbWVvdXQiLCJzZXRUaW1lb3V0IiwiY2xlYXJUaW1lb3V0IiwicnVuVGltZW91dCIsImZ1biIsInJ1bkNsZWFyVGltZW91dCIsIm1hcmtlciIsInF1ZXVlIiwiZHJhaW5pbmciLCJjdXJyZW50UXVldWUiLCJxdWV1ZUluZGV4IiwiY2xlYW5VcE5leHRUaWNrIiwiZHJhaW5RdWV1ZSIsInRpbWVvdXQiLCJydW4iLCJuZXh0VGljayIsIkl0ZW0iLCJ0aXRsZSIsImJyb3dzZXIiLCJlbnYiLCJhcmd2IiwidmVyc2lvbiIsInZlcnNpb25zIiwibm9vcCIsIm9uIiwiYWRkTGlzdGVuZXIiLCJvbmNlIiwib2ZmIiwicmVtb3ZlTGlzdGVuZXIiLCJyZW1vdmVBbGxMaXN0ZW5lcnMiLCJlbWl0IiwicHJlcGVuZExpc3RlbmVyIiwicHJlcGVuZE9uY2VMaXN0ZW5lciIsImxpc3RlbmVycyIsImJpbmRpbmciLCJjd2QiLCJjaGRpciIsInVtYXNrIiwiaGFzRGVzY3JpcHRvcnMiLCJnT1BEIiwiJGZsb29yIiwiZnVuY3Rpb25MZW5ndGhJc0NvbmZpZ3VyYWJsZSIsImZ1bmN0aW9uTGVuZ3RoSXNXcml0YWJsZSIsIl9fdW51c2VkX3dlYnBhY2tfbW9kdWxlIiwiX193ZWJwYWNrX2V4cG9ydHNfXyIsImQiLCJCYXNlU2VydmljZSIsInZzY29kZV9sYW5ndWFnZXNlcnZlcl9wcm90b2NvbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fIiwidnNjb2RlX2xhbmd1YWdlc2VydmVyX3Byb3RvY29sX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCIsIm4iLCJfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyIsInZzY29kZV9sYW5ndWFnZXNlcnZlcl90ZXh0ZG9jdW1lbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyIsIl9kZWZpbmVfcHJvcGVydHkiLCJhZGREb2N1bWVudCIsImRvY3VtZW50cyIsInVyaSIsIlYiLCJsYW5ndWFnZUlkIiwidGV4dCIsImdldERvY3VtZW50IiwicmVtb3ZlRG9jdW1lbnQiLCJnZXREb2N1bWVudFZhbHVlIiwiX3RoaXNfZ2V0RG9jdW1lbnQiLCJnZXRUZXh0Iiwic2V0VmFsdWUiLCJpZGVudGlmaWVyIiwic2V0R2xvYmFsT3B0aW9ucyIsImdsb2JhbE9wdGlvbnMiLCJzZXRXb3Jrc3BhY2UiLCJ3b3Jrc3BhY2VVcmkiLCJzZXRPcHRpb25zIiwiZG9jdW1lbnRVcmkiLCJtZXJnZSIsInJMIiwiZ2V0T3B0aW9uIiwib3B0aW9uTmFtZSIsImFwcGx5RGVsdGFzIiwiZGVsdGFzIiwidXBkYXRlIiwiZG9Db21wbGV0ZSIsImRvSG92ZXIiLCJkb1Jlc29sdmUiLCJkb1ZhbGlkYXRpb24iLCJyYW5nZSIsInByb3ZpZGVTaWduYXR1cmVIZWxwIiwiZmluZERvY3VtZW50SGlnaGxpZ2h0cyIsIm9wdGlvbnNUb0ZpbHRlckRpYWdub3N0aWNzIiwiX3RoaXNfZ2xvYmFsT3B0aW9uc19lcnJvckNvZGVzVG9JZ25vcmUiLCJfdGhpc19nbG9iYWxPcHRpb25zX2Vycm9yQ29kZXNUb1RyZWF0QXNXYXJuaW5nIiwiX3RoaXNfZ2xvYmFsT3B0aW9uc19lcnJvckNvZGVzVG9UcmVhdEFzSW5mbyIsIl90aGlzX2dsb2JhbE9wdGlvbnNfZXJyb3JNZXNzYWdlc1RvSWdub3JlIiwiX3RoaXNfZ2xvYmFsT3B0aW9uc19lcnJvck1lc3NhZ2VzVG9UcmVhdEFzV2FybmluZyIsIl90aGlzX2dsb2JhbE9wdGlvbnNfZXJyb3JNZXNzYWdlc1RvVHJlYXRBc0luZm8iLCJlcnJvckNvZGVzVG9JZ25vcmUiLCJlcnJvckNvZGVzVG9UcmVhdEFzV2FybmluZyIsImVycm9yQ29kZXNUb1RyZWF0QXNJbmZvIiwiZXJyb3JNZXNzYWdlc1RvSWdub3JlIiwiZXJyb3JNZXNzYWdlc1RvVHJlYXRBc1dhcm5pbmciLCJlcnJvck1lc3NhZ2VzVG9UcmVhdEFzSW5mbyIsImdldFNlbWFudGljVG9rZW5zIiwiZGlzcG9zZSIsImNsb3NlQ29ubmVjdGlvbiIsImdldENvZGVBY3Rpb25zIiwiY29udGV4dCIsImV4ZWN1dGVDb21tYW5kIiwiY29tbWFuZCIsInNlbmRBcHBsaWVkUmVzdWx0IiwiY2FsbGJhY2tJZCIsIm1vZGUiLCJ0ZXh0RG9jdW1lbnQiLCJkaWFnbm9zdGljIiwiZHluYW1pY1JlZ2lzdHJhdGlvbiIsInJlbGF0ZWREb2N1bWVudFN1cHBvcnQiLCJwdWJsaXNoRGlhZ25vc3RpY3MiLCJyZWxhdGVkSW5mb3JtYXRpb24iLCJ2ZXJzaW9uU3VwcG9ydCIsInRhZ1N1cHBvcnQiLCJ2YWx1ZVNldCIsIkRpYWdub3N0aWNUYWciLCJVbm5lY2Vzc2FyeSIsIkRlcHJlY2F0ZWQiLCJob3ZlciIsImNvbnRlbnRGb3JtYXQiLCJzeW5jaHJvbml6YXRpb24iLCJ3aWxsU2F2ZSIsImRpZFNhdmUiLCJ3aWxsU2F2ZVdhaXRVbnRpbCIsImZvcm1hdHRpbmciLCJjb21wbGV0aW9uIiwiY29tcGxldGlvbkl0ZW0iLCJzbmlwcGV0U3VwcG9ydCIsImNvbW1pdENoYXJhY3RlcnNTdXBwb3J0IiwiZG9jdW1lbnRhdGlvbkZvcm1hdCIsImRlcHJlY2F0ZWRTdXBwb3J0IiwicHJlc2VsZWN0U3VwcG9ydCIsImNvbnRleHRTdXBwb3J0Iiwic2lnbmF0dXJlSGVscCIsInNpZ25hdHVyZUluZm9ybWF0aW9uIiwiYWN0aXZlUGFyYW1ldGVyU3VwcG9ydCIsImRvY3VtZW50SGlnaGxpZ2h0Iiwic2VtYW50aWNUb2tlbnMiLCJtdWx0aWxpbmVUb2tlblN1cHBvcnQiLCJvdmVybGFwcGluZ1Rva2VuU3VwcG9ydCIsInRva2VuVHlwZXMiLCJ0b2tlbk1vZGlmaWVycyIsImZvcm1hdHMiLCJyZXF1ZXN0cyIsImZ1bGwiLCJkZWx0YSIsImF1Z21lbnRzU3ludGF4VG9rZW5zIiwiY29kZUFjdGlvbiIsIndvcmtzcGFjZSIsImRpZENoYW5nZUNvbmZpZ3VyYXRpb24iLCJhcHBseUVkaXQiLCJ3b3Jrc3BhY2VFZGl0IiwiZmFpbHVyZUhhbmRsaW5nIiwibm9ybWFsaXplc0xpbmVFbmRpbmdzIiwiZG9jdW1lbnRDaGFuZ2VzIiwibWVyZ2VPYmplY3RzIiwib2JqMSIsIm9iajIiLCJleGNsdWRlVW5kZWZpbmVkIiwiZXhjbHVkZVVuZGVmaW5lZFZhbHVlcyIsIm1lcmdlZE9iamVjdHMiLCJmaWx0ZXJlZEVudHJpZXMiLCJlbnRyaWVzIiwiZnJvbUVudHJpZXMiLCJub3RFbXB0eSIsIm1lcmdlUmFuZ2VzIiwicmFuZ2VzIiwic29ydCIsImNvbXBhcmVQb2ludHMiLCJjbXAiLCJpc0VtcHR5Iiwicm93IiwiY29sdW1uIiwicDEiLCJwMiIsImNoZWNrVmFsdWVBZ2FpbnN0UmVnZXhwQXJyYXkiLCJyZWdleHBBcnJheSIsImNvbnZlcnRUb1VyaSIsImZpbGVQYXRoIiwiVVJJIiwiZmlsZSIsImlzQnVmZmVyIiwiYXJnIiwiY29weSIsImZpbGwiLCJyZWFkVUludDgiLCJpc0FyZ3VtZW50c09iamVjdCIsIkJpZ0ludFN1cHBvcnRlZCIsIlN5bWJvbFN1cHBvcnRlZCIsIk9iamVjdFRvU3RyaW5nIiwibnVtYmVyVmFsdWUiLCJzdHJpbmdWYWx1ZSIsImJvb2xlYW5WYWx1ZSIsImJpZ0ludFZhbHVlIiwic3ltYm9sVmFsdWUiLCJjaGVja0JveGVkUHJpbWl0aXZlIiwicHJvdG90eXBlVmFsdWVPZiIsImlzVmlldyIsImlzRGF0YVZpZXciLCJpc1VpbnQ4QXJyYXkiLCJpc1VpbnQ4Q2xhbXBlZEFycmF5IiwiaXNVaW50MTZBcnJheSIsImlzVWludDMyQXJyYXkiLCJpc0ludDhBcnJheSIsImlzSW50MTZBcnJheSIsImlzSW50MzJBcnJheSIsImlzQmlnSW50NjRBcnJheSIsImlzQmlnVWludDY0QXJyYXkiLCJpc01hcFRvU3RyaW5nIiwid29ya2luZyIsImlzU2V0VG9TdHJpbmciLCJpc1dlYWtNYXBUb1N0cmluZyIsImlzV2Vha01hcCIsImlzV2Vha1NldFRvU3RyaW5nIiwiaXNXZWFrU2V0IiwiaXNBcnJheUJ1ZmZlclRvU3RyaW5nIiwiaXNBcnJheUJ1ZmZlciIsImlzRGF0YVZpZXdUb1N0cmluZyIsIlNoYXJlZEFycmF5QnVmZmVyQ29weSIsImlzU2hhcmVkQXJyYXlCdWZmZXJUb1N0cmluZyIsImlzU2hhcmVkQXJyYXlCdWZmZXIiLCJpc0FzeW5jRnVuY3Rpb24iLCJpc01hcEl0ZXJhdG9yIiwiaXNTZXRJdGVyYXRvciIsImlzR2VuZXJhdG9yT2JqZWN0IiwiaXNXZWJBc3NlbWJseUNvbXBpbGVkTW9kdWxlIiwibWV0aG9kIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImRlc2NyaXB0b3JzIiwiZm9ybWF0UmVnRXhwIiwib2JqZWN0cyIsInN0cmluZ2lmeSIsImlzTnVsbCIsImRlcHJlY2F0ZSIsIm5vRGVwcmVjYXRpb24iLCJkZXByZWNhdGVkIiwidGhyb3dEZXByZWNhdGlvbiIsInRyYWNlRGVwcmVjYXRpb24iLCJkZWJ1Z3MiLCJkZWJ1Z0VudlJlZ2V4IiwiTk9ERV9ERUJVRyIsImRlYnVnRW52IiwidG9VcHBlckNhc2UiLCJkZWJ1Z2xvZyIsInBpZCIsIm9wdHMiLCJzZWVuIiwic3R5bGl6ZSIsInN0eWxpemVOb0NvbG9yIiwiY29sb3JzIiwiaXNCb29sZWFuIiwiX2V4dGVuZCIsImlzVW5kZWZpbmVkIiwic3R5bGl6ZVdpdGhDb2xvciIsImZvcm1hdFZhbHVlIiwic3R5bGVzIiwic3R5bGVUeXBlIiwic3R5bGUiLCJhcnJheVRvSGFzaCIsImhhc2giLCJpZHgiLCJyZXQiLCJwcmltaXRpdmUiLCJmb3JtYXRQcmltaXRpdmUiLCJ2aXNpYmxlS2V5cyIsImlzRXJyb3IiLCJmb3JtYXRFcnJvciIsImJyYWNlcyIsInRvVVRDU3RyaW5nIiwib3V0cHV0IiwiZm9ybWF0QXJyYXkiLCJmb3JtYXRQcm9wZXJ0eSIsInJlZHVjZVRvU2luZ2xlU3RyaW5nIiwic2ltcGxlIiwiaXNOdW1iZXIiLCJsIiwibGluZSIsIm51bUxpbmVzRXN0IiwicmVkdWNlIiwicHJldiIsImFyIiwiaXNOdWxsT3JVbmRlZmluZWQiLCJpc1N5bWJvbCIsInJlIiwiaXNQcmltaXRpdmUiLCJwYWQiLCJtb250aHMiLCJ0aW1lc3RhbXAiLCJnZXRIb3VycyIsImdldE1pbnV0ZXMiLCJnZXRTZWNvbmRzIiwiZ2V0RGF0ZSIsImdldE1vbnRoIiwib3JpZ2luIiwicHJvcCIsImtDdXN0b21Qcm9taXNpZmllZFN5bWJvbCIsInByb21pc2lmeSIsIm9yaWdpbmFsIiwicHJvbWlzZVJlc29sdmUiLCJwcm9taXNlUmVqZWN0IiwicHJvbWlzZSIsInJlamVjdCIsImNhbGxiYWNraWZ5T25SZWplY3RlZCIsImNiIiwibmV3UmVhc29uIiwiY2FsbGJhY2tpZnkiLCJjYWxsYmFja2lmaWVkIiwibWF5YmVDYiIsInJlaiIsIl9fY3JlYXRlQmluZGluZyIsIm0iLCJrMiIsIl9fZXNNb2R1bGUiLCJfX2V4cG9ydFN0YXIiLCJjcmVhdGVNZXNzYWdlQ29ubmVjdGlvbiIsIkJyb3dzZXJNZXNzYWdlV3JpdGVyIiwiQnJvd3Nlck1lc3NhZ2VSZWFkZXIiLCJyaWxfMSIsImRlZmF1bHQiLCJpbnN0YWxsIiwiYXBpXzEiLCJBYnN0cmFjdE1lc3NhZ2VSZWFkZXIiLCJsaXN0ZW4iLCJjYWxsYmFjayIsIl9vbkRhdGEiLCJldmVudCIsInBvcnQiLCJFbWl0dGVyIiwiX21lc3NhZ2VMaXN0ZW5lciIsImZpcmUiLCJkYXRhIiwiYWRkRXZlbnRMaXN0ZW5lciIsImZpcmVFcnJvciIsIm9ubWVzc2FnZSIsIkFic3RyYWN0TWVzc2FnZVdyaXRlciIsIndyaXRlIiwicG9zdE1lc3NhZ2UiLCJoYW5kbGVFcnJvciIsImVycm9yQ291bnQiLCJyZWFkZXIiLCJ3cml0ZXIiLCJsb2dnZXIiLCJOdWxsTG9nZ2VyIiwiQ29ubmVjdGlvblN0cmF0ZWd5IiwiY29ubmVjdGlvblN0cmF0ZWd5IiwiTWVzc2FnZUJ1ZmZlciIsIkFic3RyYWN0TWVzc2FnZUJ1ZmZlciIsImVtcHR5QnVmZmVyIiwiZnJvbVN0cmluZyIsIl9lbmNvZGluZyIsIlRleHRFbmNvZGVyIiwiZW5jb2RlIiwiZW5jb2RpbmciLCJhc2NpaURlY29kZXIiLCJkZWNvZGUiLCJUZXh0RGVjb2RlciIsImFzTmF0aXZlIiwiYWxsb2NOYXRpdmUiLCJSZWFkYWJsZVN0cmVhbVdyYXBwZXIiLCJvbkNsb3NlIiwibGlzdGVuZXIiLCJzb2NrZXQiLCJEaXNwb3NhYmxlIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsIm9uRXJyb3IiLCJvbkVuZCIsIm9uRGF0YSIsImJsb2IiLCJhcnJheUJ1ZmZlciIsIlJBTCIsIldyaXRhYmxlU3RyZWFtV3JhcHBlciIsInNlbmQiLCJjbG9zZSIsIl90ZXh0RW5jb2RlciIsIl9yaWwiLCJmcmVlemUiLCJtZXNzYWdlQnVmZmVyIiwiYXBwbGljYXRpb25Kc29uIiwiZW5jb2RlciIsImNoYXJzZXQiLCJwYXJzZSIsInN0cmVhbSIsImFzUmVhZGFibGVTdHJlYW0iLCJhc1dyaXRhYmxlU3RyZWFtIiwidGltZXIiLCJtcyIsImhhbmRsZSIsInNldEltbWVkaWF0ZSIsInNldEludGVydmFsIiwiY2xlYXJJbnRlcnZhbCIsIlJJTCIsIlByb2dyZXNzVHlwZSIsIlByb2dyZXNzVG9rZW4iLCJDb25uZWN0aW9uT3B0aW9ucyIsIldyaXRlYWJsZVN0cmVhbU1lc3NhZ2VXcml0ZXIiLCJNZXNzYWdlV3JpdGVyIiwiUmVhZGFibGVTdHJlYW1NZXNzYWdlUmVhZGVyIiwiTWVzc2FnZVJlYWRlciIsIlNoYXJlZEFycmF5UmVjZWl2ZXJTdHJhdGVneSIsIlNoYXJlZEFycmF5U2VuZGVyU3RyYXRlZ3kiLCJDYW5jZWxsYXRpb25Ub2tlbiIsIkNhbmNlbGxhdGlvblRva2VuU291cmNlIiwiRXZlbnQiLCJMUlVDYWNoZSIsIlRvdWNoIiwiTGlua2VkTWFwIiwiUGFyYW1ldGVyU3RydWN0dXJlcyIsIk5vdGlmaWNhdGlvblR5cGU5IiwiTm90aWZpY2F0aW9uVHlwZTgiLCJOb3RpZmljYXRpb25UeXBlNyIsIk5vdGlmaWNhdGlvblR5cGU2IiwiTm90aWZpY2F0aW9uVHlwZTUiLCJOb3RpZmljYXRpb25UeXBlNCIsIk5vdGlmaWNhdGlvblR5cGUzIiwiTm90aWZpY2F0aW9uVHlwZTIiLCJOb3RpZmljYXRpb25UeXBlMSIsIk5vdGlmaWNhdGlvblR5cGUwIiwiTm90aWZpY2F0aW9uVHlwZSIsIkVycm9yQ29kZXMiLCJSZXNwb25zZUVycm9yIiwiUmVxdWVzdFR5cGU5IiwiUmVxdWVzdFR5cGU4IiwiUmVxdWVzdFR5cGU3IiwiUmVxdWVzdFR5cGU2IiwiUmVxdWVzdFR5cGU1IiwiUmVxdWVzdFR5cGU0IiwiUmVxdWVzdFR5cGUzIiwiUmVxdWVzdFR5cGUyIiwiUmVxdWVzdFR5cGUxIiwiUmVxdWVzdFR5cGUwIiwiUmVxdWVzdFR5cGUiLCJNZXNzYWdlIiwiTWVzc2FnZVN0cmF0ZWd5IiwiQ2FuY2VsbGF0aW9uU3RyYXRlZ3kiLCJDYW5jZWxsYXRpb25TZW5kZXJTdHJhdGVneSIsIkNhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kiLCJDb25uZWN0aW9uRXJyb3IiLCJDb25uZWN0aW9uRXJyb3JzIiwiTG9nVHJhY2VOb3RpZmljYXRpb24iLCJTZXRUcmFjZU5vdGlmaWNhdGlvbiIsIlRyYWNlRm9ybWF0IiwiVHJhY2VWYWx1ZXMiLCJUcmFjZSIsIm1lc3NhZ2VzXzEiLCJsaW5rZWRNYXBfMSIsImRpc3Bvc2FibGVfMSIsImV2ZW50c18xIiwiY2FuY2VsbGF0aW9uXzEiLCJzaGFyZWRBcnJheUNhbmNlbGxhdGlvbl8xIiwibWVzc2FnZVJlYWRlcl8xIiwibWVzc2FnZVdyaXRlcl8xIiwibWVzc2FnZUJ1ZmZlcl8xIiwiY29ubmVjdGlvbl8xIiwicmFsXzEiLCJJcyIsIk5vbmUiLCJpc0NhbmNlbGxhdGlvblJlcXVlc3RlZCIsIm9uQ2FuY2VsbGF0aW9uUmVxdWVzdGVkIiwiQ2FuY2VsbGVkIiwiY2FuZGlkYXRlIiwiYm9vbGVhbiIsInNob3J0Y3V0RXZlbnQiLCJNdXRhYmxlVG9rZW4iLCJjYW5jZWwiLCJfaXNDYW5jZWxsZWQiLCJfZW1pdHRlciIsInRva2VuIiwiX3Rva2VuIiwiUmVxdWVzdENhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kiLCJJZENhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kiLCJDYW5jZWxOb3RpZmljYXRpb24iLCJQcm9ncmVzc05vdGlmaWNhdGlvbiIsIlN0YXJSZXF1ZXN0SGFuZGxlciIsIk9mZiIsIk1lc3NhZ2VzIiwiQ29tcGFjdCIsIlZlcmJvc2UiLCJ0b0xvd2VyQ2FzZSIsIlRleHQiLCJjYW5jZWxVbmRpc3BhdGNoZWQiLCJraW5kIiwiY3JlYXRlQ2FuY2VsbGF0aW9uVG9rZW5Tb3VyY2UiLCJzZW5kQ2FuY2VsbGF0aW9uIiwiY29ubiIsImlkIiwic2VuZE5vdGlmaWNhdGlvbiIsImNsZWFudXAiLCJzZW5kZXIiLCJoYW5kbGVNZXNzYWdlIiwiY2FuY2VsbGF0aW9uU3RyYXRlZ3kiLCJtZXNzYWdlU3RyYXRlZ3kiLCJDb25uZWN0aW9uU3RhdGUiLCJtZXNzYWdlUmVhZGVyIiwibWVzc2FnZVdyaXRlciIsIl9sb2dnZXIiLCJzZXF1ZW5jZU51bWJlciIsIm5vdGlmaWNhdGlvblNlcXVlbmNlTnVtYmVyIiwidW5rbm93blJlc3BvbnNlU2VxdWVuY2VOdW1iZXIiLCJzdGFyUmVxdWVzdEhhbmRsZXIiLCJyZXF1ZXN0SGFuZGxlcnMiLCJzdGFyTm90aWZpY2F0aW9uSGFuZGxlciIsIm5vdGlmaWNhdGlvbkhhbmRsZXJzIiwicHJvZ3Jlc3NIYW5kbGVycyIsIm1lc3NhZ2VRdWV1ZSIsInJlc3BvbnNlUHJvbWlzZXMiLCJrbm93bkNhbmNlbGVkUmVxdWVzdHMiLCJyZXF1ZXN0VG9rZW5zIiwidHJhY2VGb3JtYXQiLCJ0cmFjZXIiLCJzdGF0ZSIsIk5ldyIsImVycm9yRW1pdHRlciIsImNsb3NlRW1pdHRlciIsInVuaGFuZGxlZE5vdGlmaWNhdGlvbkVtaXR0ZXIiLCJ1bmhhbmRsZWRQcm9ncmVzc0VtaXR0ZXIiLCJkaXNwb3NlRW1pdHRlciIsImNyZWF0ZVJlcXVlc3RRdWV1ZUtleSIsImNyZWF0ZVJlc3BvbnNlUXVldWVLZXkiLCJjcmVhdGVOb3RpZmljYXRpb25RdWV1ZUtleSIsImFkZE1lc3NhZ2VUb1F1ZXVlIiwiaXNSZXF1ZXN0IiwiaXNSZXNwb25zZSIsIl9tZXNzYWdlIiwiaXNMaXN0ZW5pbmciLCJMaXN0ZW5pbmciLCJpc0Nsb3NlZCIsIkNsb3NlZCIsImlzRGlzcG9zZWQiLCJEaXNwb3NlZCIsImNsb3NlSGFuZGxlciIsInJlYWRFcnJvckhhbmRsZXIiLCJ3cml0ZUVycm9ySGFuZGxlciIsInRyaWdnZXJNZXNzYWdlUXVldWUiLCJwcm9jZXNzTWVzc2FnZVF1ZXVlIiwiaGFuZGxlUmVxdWVzdCIsImlzTm90aWZpY2F0aW9uIiwiaGFuZGxlTm90aWZpY2F0aW9uIiwiaGFuZGxlUmVzcG9uc2UiLCJoYW5kbGVJbnZhbGlkTWVzc2FnZSIsImNhbmNlbElkIiwicGFyYW1zIiwidG9DYW5jZWwiLCJzdHJhdGVneSIsInJlc3BvbnNlIiwidHJhY2VTZW5kaW5nUmVzcG9uc2UiLCJjYW5jZWxsYXRpb25Ub2tlbiIsInRyYWNlUmVjZWl2ZWROb3RpZmljYXRpb24iLCJyZXF1ZXN0TWVzc2FnZSIsInJlcGx5IiwicmVzdWx0T3JFcnJvciIsInN0YXJ0VGltZSIsImpzb25ycGMiLCJ0b0pzb24iLCJyZXBseUVycm9yIiwicmVwbHlTdWNjZXNzIiwidHJhY2VSZWNlaXZlZFJlcXVlc3QiLCJlbGVtZW50IiwicmVxdWVzdEhhbmRsZXIiLCJoYW5kbGVyIiwidG9rZW5LZXkiLCJjYW5jZWxsYXRpb25Tb3VyY2UiLCJoYW5kbGVyUmVzdWx0IiwibnVtYmVyT2ZQYXJhbXMiLCJJbnZhbGlkUGFyYW1zIiwicGFyYW1ldGVyU3RydWN0dXJlcyIsImJ5TmFtZSIsImJ5UG9zaXRpb24iLCJJbnRlcm5hbEVycm9yIiwiTWV0aG9kTm90Rm91bmQiLCJyZXNwb25zZU1lc3NhZ2UiLCJyZXNwb25zZVByb21pc2UiLCJ0cmFjZVJlY2VpdmVkUmVzcG9uc2UiLCJub3RpZmljYXRpb25IYW5kbGVyIiwicmVzcG9uc2VIYW5kbGVyIiwic3RyaW5naWZ5VHJhY2UiLCJ0cmFjZVNlbmRpbmdSZXF1ZXN0IiwibG9nTFNQTWVzc2FnZSIsInRyYWNlU2VuZGluZ05vdGlmaWNhdGlvbiIsInRpbWVyU3RhcnQiLCJsc3BNZXNzYWdlIiwiaXNMU1BNZXNzYWdlIiwidGhyb3dJZkNsb3NlZE9yRGlzcG9zZWQiLCJ0aHJvd0lmTGlzdGVuaW5nIiwiQWxyZWFkeUxpc3RlbmluZyIsInRocm93SWZOb3RMaXN0ZW5pbmciLCJ1bmRlZmluZWRUb051bGwiLCJwYXJhbSIsIm51bGxUb1VuZGVmaW5lZCIsImlzTmFtZWRQYXJhbSIsImNvbXB1dGVTaW5nbGVQYXJhbSIsImF1dG8iLCJjb21wdXRlTWVzc2FnZVBhcmFtcyIsImNvbm5lY3Rpb24iLCJtZXNzYWdlUGFyYW1zIiwicGFyYW1TdGFydCIsInBhcmFtRW5kIiwibm90aWZpY2F0aW9uTWVzc2FnZSIsIm9uTm90aWZpY2F0aW9uIiwib25Qcm9ncmVzcyIsIl90eXBlIiwic2VuZFByb2dyZXNzIiwib25VbmhhbmRsZWRQcm9ncmVzcyIsInNlbmRSZXF1ZXN0IiwiZGlzcG9zYWJsZSIsImVuYWJsZUNhbmNlbGxhdGlvbiIsInJlc29sdmVXaXRoQ2xlYW51cCIsInIiLCJyZWplY3RXaXRoQ2xlYW51cCIsIk1lc3NhZ2VXcml0ZUVycm9yIiwib25SZXF1ZXN0IiwiaGFzUGVuZGluZ1Jlc3BvbnNlIiwiX3ZhbHVlIiwiX3RyYWNlciIsInNlbmROb3RpZmljYXRpb25PclRyYWNlT3B0aW9ucyIsIl9zZW5kTm90aWZpY2F0aW9uIiwiX3RyYWNlRm9ybWF0Iiwib25VbmhhbmRsZWROb3RpZmljYXRpb24iLCJvbkRpc3Bvc2UiLCJQZW5kaW5nUmVzcG9uc2VSZWplY3RlZCIsInZhbHVlcyIsInZlcmJvc2UiLCJfZGlzcG9zYWJsZSIsIkNhbGxiYWNrTGlzdCIsImJ1Y2tldCIsIl9jYWxsYmFja3MiLCJfY29udGV4dHMiLCJyZW1vdmUiLCJmb3VuZENhbGxiYWNrV2l0aERpZmZlcmVudENvbnRleHQiLCJpbnZva2UiLCJjYWxsYmFja3MiLCJjb250ZXh0cyIsIl9ldmVudCIsInRoaXNBcmdzIiwiZGlzcG9zYWJsZXMiLCJfb3B0aW9ucyIsIm9uRmlyc3RMaXN0ZW5lckFkZCIsIl9ub29wIiwib25MYXN0TGlzdGVuZXJSZW1vdmUiLCJzdHJpbmdBcnJheSIsImV2ZXJ5IiwiZWxlbSIsIl9hIiwiRmlyc3QiLCJBc09sZCIsIkxhc3QiLCJBc05ldyIsImNsZWFyIiwiX21hcCIsIl9oZWFkIiwiX3RhaWwiLCJfc2l6ZSIsIl9zdGF0ZSIsInRvdWNoIiwicHJldmlvdXMiLCJhZGRJdGVtTGFzdCIsImFkZEl0ZW1GaXJzdCIsInJlbW92ZUl0ZW0iLCJjYWxsYmFja2ZuIiwiY3VycmVudCIsInRyaW1PbGQiLCJuZXdTaXplIiwiY3VycmVudFNpemUiLCJ0b0pTT04iLCJmcm9tSlNPTiIsIl9saW1pdCIsImNoZWNrVHJpbSIsInJhdGlvIiwiX3JhdGlvIiwicGVlayIsInJvdW5kIiwiQ1IiLCJMRiIsIkNSTEYiLCJhcHBlbmQiLCJjaHVuayIsInRvQXBwZW5kIiwiX2NodW5rcyIsIl90b3RhbExlbmd0aCIsInRyeVJlYWRIZWFkZXJzIiwibG93ZXJDYXNlS2V5cyIsImNodW5rSW5kZXgiLCJjaHVua0J5dGVzUmVhZCIsIl9yZWFkIiwiaGVhZGVycyIsImhlYWRlciIsImluZGV4IiwidHJpbSIsInRyeVJlYWRCb2R5IiwibnVtYmVyT2ZCeXRlcyIsImJ5dGVDb3VudCIsInJlc3VsdE9mZnNldCIsImNodW5rUGFydCIsInNlbWFwaG9yZV8xIiwib25QYXJ0aWFsTWVzc2FnZSIsImFzRXJyb3IiLCJmaXJlQ2xvc2UiLCJwYXJ0aWFsTWVzc2FnZUVtaXR0ZXIiLCJmaXJlUGFydGlhbE1lc3NhZ2UiLCJSZXNvbHZlZE1lc3NhZ2VSZWFkZXJPcHRpb25zIiwiZnJvbU9wdGlvbnMiLCJjb250ZW50RGVjb2RlciIsImNvbnRlbnREZWNvZGVycyIsImNvbnRlbnRUeXBlRGVjb2RlciIsImNvbnRlbnRUeXBlRGVjb2RlcnMiLCJwYXJ0aWFsTWVzc2FnZVRpbWVvdXQiLCJfcGFydGlhbE1lc3NhZ2VUaW1lb3V0IiwibmV4dE1lc3NhZ2VMZW5ndGgiLCJtZXNzYWdlVG9rZW4iLCJwYXJ0aWFsTWVzc2FnZVRpbWVyIiwicmVhZGFibGUiLCJjb250ZW50TGVuZ3RoIiwiYm9keSIsInNldFBhcnRpYWxNZXNzYWdlVGltZXIiLCJjbGVhclBhcnRpYWxNZXNzYWdlVGltZXIiLCJyZWFkU2VtYXBob3JlIiwibG9jayIsImJ5dGVzIiwid2FpdGluZ1RpbWUiLCJTZW1hcGhvcmUiLCJDb250ZW50TGVuZ3RoIiwiUmVzb2x2ZWRNZXNzYWdlV3JpdGVyT3B0aW9ucyIsImNvbnRlbnRUeXBlRW5jb2RlciIsImNvbnRlbnRFbmNvZGVyIiwid3JpdGVTZW1hcGhvcmUiLCJwYXlsb2FkIiwiZG9Xcml0ZSIsIkFic3RyYWN0TWVzc2FnZVNpZ25hdHVyZSIsIlBhcnNlRXJyb3IiLCJJbnZhbGlkUmVxdWVzdCIsImpzb25ycGNSZXNlcnZlZEVycm9yUmFuZ2VTdGFydCIsInNlcnZlckVycm9yU3RhcnQiLCJNZXNzYWdlUmVhZEVycm9yIiwiQ29ubmVjdGlvbkluYWN0aXZlIiwiU2VydmVyTm90SW5pdGlhbGl6ZWQiLCJVbmtub3duRXJyb3JDb2RlIiwianNvbnJwY1Jlc2VydmVkRXJyb3JSYW5nZUVuZCIsInNlcnZlckVycm9yRW5kIiwiX3BhcmFtZXRlclN0cnVjdHVyZXMiLCJfcmFsIiwicmFsIiwidGh1bmsiLCJfd2FpdGluZyIsInJ1bk5leHQiLCJhY3RpdmUiLCJfYWN0aXZlIiwiX2NhcGFjaXR5IiwiZG9SdW5OZXh0IiwiY2FwYWNpdHkiLCJDYW5jZWxsYXRpb25TdGF0ZSIsIkNvbnRpbnVlIiwicmVxdWVzdCIsImJ1ZmZlcnMiLCIkY2FuY2VsbGF0aW9uRGF0YSIsIl9jb25uIiwic3RvcmUiLCJTaGFyZWRBcnJheUJ1ZmZlckNhbmNlbGxhdGlvblRva2VuIiwibG9hZCIsIlNoYXJlZEFycmF5QnVmZmVyQ2FuY2VsbGF0aW9uVG9rZW5Tb3VyY2UiLCJjcmVhdGVQcm90b2NvbENvbm5lY3Rpb24iLCJicm93c2VyXzEiLCJMU1BFcnJvckNvZGVzIiwibHNwUmVzZXJ2ZWRFcnJvclJhbmdlU3RhcnQiLCJSZXF1ZXN0RmFpbGVkIiwiU2VydmVyQ2FuY2VsbGVkIiwiQ29udGVudE1vZGlmaWVkIiwiUmVxdWVzdENhbmNlbGxlZCIsImxzcFJlc2VydmVkRXJyb3JSYW5nZUVuZCIsInZzY29kZV9qc29ucnBjXzEiLCJQcm90b2NvbE5vdGlmaWNhdGlvblR5cGUiLCJQcm90b2NvbE5vdGlmaWNhdGlvblR5cGUwIiwiUHJvdG9jb2xSZXF1ZXN0VHlwZSIsIlByb3RvY29sUmVxdWVzdFR5cGUwIiwiUmVnaXN0cmF0aW9uVHlwZSIsIk1lc3NhZ2VEaXJlY3Rpb24iLCJDYWxsSGllcmFyY2h5T3V0Z29pbmdDYWxsc1JlcXVlc3QiLCJDYWxsSGllcmFyY2h5SW5jb21pbmdDYWxsc1JlcXVlc3QiLCJDYWxsSGllcmFyY2h5UHJlcGFyZVJlcXVlc3QiLCJtZXNzYWdlRGlyZWN0aW9uIiwiY2xpZW50VG9TZXJ2ZXIiLCJDb2xvclByZXNlbnRhdGlvblJlcXVlc3QiLCJEb2N1bWVudENvbG9yUmVxdWVzdCIsIkNvbmZpZ3VyYXRpb25SZXF1ZXN0Iiwic2VydmVyVG9DbGllbnQiLCJEZWNsYXJhdGlvblJlcXVlc3QiLCJfX25vRHluYW1pY0ltcG9ydCIsIkRpYWdub3N0aWNSZWZyZXNoUmVxdWVzdCIsIldvcmtzcGFjZURpYWdub3N0aWNSZXF1ZXN0IiwiRG9jdW1lbnREaWFnbm9zdGljUmVxdWVzdCIsIkRvY3VtZW50RGlhZ25vc3RpY1JlcG9ydEtpbmQiLCJEaWFnbm9zdGljU2VydmVyQ2FuY2VsbGF0aW9uRGF0YSIsInJldHJpZ2dlclJlcXVlc3QiLCJGdWxsIiwiVW5jaGFuZ2VkIiwicGFydGlhbFJlc3VsdCIsIldpbGxEZWxldGVGaWxlc1JlcXVlc3QiLCJEaWREZWxldGVGaWxlc05vdGlmaWNhdGlvbiIsIkRpZFJlbmFtZUZpbGVzTm90aWZpY2F0aW9uIiwiV2lsbFJlbmFtZUZpbGVzUmVxdWVzdCIsIkRpZENyZWF0ZUZpbGVzTm90aWZpY2F0aW9uIiwiV2lsbENyZWF0ZUZpbGVzUmVxdWVzdCIsIkZpbGVPcGVyYXRpb25QYXR0ZXJuS2luZCIsImZvbGRlciIsIkZvbGRpbmdSYW5nZVJlcXVlc3QiLCJJbXBsZW1lbnRhdGlvblJlcXVlc3QiLCJJbmxheUhpbnRSZWZyZXNoUmVxdWVzdCIsIklubGF5SGludFJlc29sdmVSZXF1ZXN0IiwiSW5sYXlIaW50UmVxdWVzdCIsIklubGluZVZhbHVlUmVmcmVzaFJlcXVlc3QiLCJJbmxpbmVWYWx1ZVJlcXVlc3QiLCJXb3Jrc3BhY2VTeW1ib2xSZXF1ZXN0IiwiQ29kZUFjdGlvblJlc29sdmVSZXF1ZXN0IiwiQ29kZUFjdGlvblJlcXVlc3QiLCJEb2N1bWVudFN5bWJvbFJlcXVlc3QiLCJEb2N1bWVudEhpZ2hsaWdodFJlcXVlc3QiLCJSZWZlcmVuY2VzUmVxdWVzdCIsIkRlZmluaXRpb25SZXF1ZXN0IiwiU2lnbmF0dXJlSGVscFJlcXVlc3QiLCJTaWduYXR1cmVIZWxwVHJpZ2dlcktpbmQiLCJIb3ZlclJlcXVlc3QiLCJDb21wbGV0aW9uUmVzb2x2ZVJlcXVlc3QiLCJDb21wbGV0aW9uUmVxdWVzdCIsIkNvbXBsZXRpb25UcmlnZ2VyS2luZCIsIlB1Ymxpc2hEaWFnbm9zdGljc05vdGlmaWNhdGlvbiIsIldhdGNoS2luZCIsIlJlbGF0aXZlUGF0dGVybiIsIkZpbGVDaGFuZ2VUeXBlIiwiRGlkQ2hhbmdlV2F0Y2hlZEZpbGVzTm90aWZpY2F0aW9uIiwiV2lsbFNhdmVUZXh0RG9jdW1lbnRXYWl0VW50aWxSZXF1ZXN0IiwiV2lsbFNhdmVUZXh0RG9jdW1lbnROb3RpZmljYXRpb24iLCJUZXh0RG9jdW1lbnRTYXZlUmVhc29uIiwiRGlkU2F2ZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbiIsIkRpZENsb3NlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uIiwiRGlkQ2hhbmdlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uIiwiVGV4dERvY3VtZW50Q29udGVudENoYW5nZUV2ZW50IiwiRGlkT3BlblRleHREb2N1bWVudE5vdGlmaWNhdGlvbiIsIlRleHREb2N1bWVudFN5bmNLaW5kIiwiVGVsZW1ldHJ5RXZlbnROb3RpZmljYXRpb24iLCJMb2dNZXNzYWdlTm90aWZpY2F0aW9uIiwiU2hvd01lc3NhZ2VSZXF1ZXN0IiwiU2hvd01lc3NhZ2VOb3RpZmljYXRpb24iLCJNZXNzYWdlVHlwZSIsIkRpZENoYW5nZUNvbmZpZ3VyYXRpb25Ob3RpZmljYXRpb24iLCJFeGl0Tm90aWZpY2F0aW9uIiwiU2h1dGRvd25SZXF1ZXN0IiwiSW5pdGlhbGl6ZWROb3RpZmljYXRpb24iLCJJbml0aWFsaXplRXJyb3JDb2RlcyIsIkluaXRpYWxpemVSZXF1ZXN0IiwiV29ya0RvbmVQcm9ncmVzc09wdGlvbnMiLCJUZXh0RG9jdW1lbnRSZWdpc3RyYXRpb25PcHRpb25zIiwiU3RhdGljUmVnaXN0cmF0aW9uT3B0aW9ucyIsIlBvc2l0aW9uRW5jb2RpbmdLaW5kIiwiRmFpbHVyZUhhbmRsaW5nS2luZCIsIlJlc291cmNlT3BlcmF0aW9uS2luZCIsIlVucmVnaXN0cmF0aW9uUmVxdWVzdCIsIlJlZ2lzdHJhdGlvblJlcXVlc3QiLCJEb2N1bWVudFNlbGVjdG9yIiwiTm90ZWJvb2tDZWxsVGV4dERvY3VtZW50RmlsdGVyIiwiTm90ZWJvb2tEb2N1bWVudEZpbHRlciIsIlRleHREb2N1bWVudEZpbHRlciIsIlR5cGVIaWVyYXJjaHlTdWJ0eXBlc1JlcXVlc3QiLCJUeXBlSGllcmFyY2h5UHJlcGFyZVJlcXVlc3QiLCJNb25pa2VyUmVxdWVzdCIsIk1vbmlrZXJLaW5kIiwiVW5pcXVlbmVzc0xldmVsIiwiTGlua2VkRWRpdGluZ1JhbmdlUmVxdWVzdCIsIlNob3dEb2N1bWVudFJlcXVlc3QiLCJTZW1hbnRpY1Rva2Vuc1JlZ2lzdHJhdGlvblR5cGUiLCJTZW1hbnRpY1Rva2Vuc1JlZnJlc2hSZXF1ZXN0IiwiU2VtYW50aWNUb2tlbnNSYW5nZVJlcXVlc3QiLCJTZW1hbnRpY1Rva2Vuc0RlbHRhUmVxdWVzdCIsIlNlbWFudGljVG9rZW5zUmVxdWVzdCIsIlRva2VuRm9ybWF0IiwiV29ya0RvbmVQcm9ncmVzc0NhbmNlbE5vdGlmaWNhdGlvbiIsIldvcmtEb25lUHJvZ3Jlc3NDcmVhdGVSZXF1ZXN0IiwiV29ya0RvbmVQcm9ncmVzcyIsIlNlbGVjdGlvblJhbmdlUmVxdWVzdCIsIkRpZENoYW5nZVdvcmtzcGFjZUZvbGRlcnNOb3RpZmljYXRpb24iLCJXb3Jrc3BhY2VGb2xkZXJzUmVxdWVzdCIsIlR5cGVEZWZpbml0aW9uUmVxdWVzdCIsIkFwcGx5V29ya3NwYWNlRWRpdFJlcXVlc3QiLCJFeGVjdXRlQ29tbWFuZFJlcXVlc3QiLCJQcmVwYXJlUmVuYW1lUmVxdWVzdCIsIlJlbmFtZVJlcXVlc3QiLCJQcmVwYXJlU3VwcG9ydERlZmF1bHRCZWhhdmlvciIsIkRvY3VtZW50T25UeXBlRm9ybWF0dGluZ1JlcXVlc3QiLCJEb2N1bWVudFJhbmdlRm9ybWF0dGluZ1JlcXVlc3QiLCJEb2N1bWVudEZvcm1hdHRpbmdSZXF1ZXN0IiwiRG9jdW1lbnRMaW5rUmVzb2x2ZVJlcXVlc3QiLCJEb2N1bWVudExpbmtSZXF1ZXN0IiwiQ29kZUxlbnNSZWZyZXNoUmVxdWVzdCIsIkNvZGVMZW5zUmVzb2x2ZVJlcXVlc3QiLCJDb2RlTGVuc1JlcXVlc3QiLCJXb3Jrc3BhY2VTeW1ib2xSZXNvbHZlUmVxdWVzdCIsIkRpZENsb3NlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbiIsIkRpZFNhdmVOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uIiwiRGlkQ2hhbmdlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbiIsIk5vdGVib29rQ2VsbEFycmF5Q2hhbmdlIiwiRGlkT3Blbk5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24iLCJOb3RlYm9va0RvY3VtZW50U3luY1JlZ2lzdHJhdGlvblR5cGUiLCJOb3RlYm9va0RvY3VtZW50IiwiTm90ZWJvb2tDZWxsIiwiRXhlY3V0aW9uU3VtbWFyeSIsIk5vdGVib29rQ2VsbEtpbmQiLCJUeXBlSGllcmFyY2h5U3VwZXJ0eXBlc1JlcXVlc3QiLCJ2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfdHlwZXNfMSIsInByb3RvY29sX2ltcGxlbWVudGF0aW9uXzEiLCJwcm90b2NvbF90eXBlRGVmaW5pdGlvbl8xIiwicHJvdG9jb2xfd29ya3NwYWNlRm9sZGVyXzEiLCJwcm90b2NvbF9jb25maWd1cmF0aW9uXzEiLCJwcm90b2NvbF9jb2xvclByb3ZpZGVyXzEiLCJwcm90b2NvbF9mb2xkaW5nUmFuZ2VfMSIsInByb3RvY29sX2RlY2xhcmF0aW9uXzEiLCJwcm90b2NvbF9zZWxlY3Rpb25SYW5nZV8xIiwicHJvdG9jb2xfcHJvZ3Jlc3NfMSIsInByb3RvY29sX2NhbGxIaWVyYXJjaHlfMSIsInByb3RvY29sX3NlbWFudGljVG9rZW5zXzEiLCJwcm90b2NvbF9zaG93RG9jdW1lbnRfMSIsInByb3RvY29sX2xpbmtlZEVkaXRpbmdSYW5nZV8xIiwicHJvdG9jb2xfZmlsZU9wZXJhdGlvbnNfMSIsInByb3RvY29sX21vbmlrZXJfMSIsInByb3RvY29sX3R5cGVIaWVyYXJjaHlfMSIsInByb3RvY29sX2lubGluZVZhbHVlXzEiLCJwcm90b2NvbF9pbmxheUhpbnRfMSIsInByb3RvY29sX2RpYWdub3N0aWNfMSIsInByb3RvY29sX25vdGVib29rXzEiLCJsYW5ndWFnZSIsInNjaGVtZSIsInBhdHRlcm4iLCJvYmplY3RMaXRlcmFsIiwibm90ZWJvb2tUeXBlIiwibm90ZWJvb2siLCJDcmVhdGUiLCJSZW5hbWUiLCJEZWxldGUiLCJBYm9ydCIsIlRyYW5zYWN0aW9uYWwiLCJUZXh0T25seVRyYW5zYWN0aW9uYWwiLCJVbmRvIiwiVVRGOCIsIlVURjE2IiwiVVRGMzIiLCJoYXNJZCIsImRvY3VtZW50U2VsZWN0b3IiLCJ3b3JrRG9uZVByb2dyZXNzIiwiaGFzV29ya0RvbmVQcm9ncmVzcyIsInVua25vd25Qcm90b2NvbFZlcnNpb24iLCJXYXJuaW5nIiwiSW5mbyIsIkxvZyIsIkluY3JlbWVudGFsIiwiaXNJbmNyZW1lbnRhbCIsInJhbmdlTGVuZ3RoIiwiaXNGdWxsIiwiTWFudWFsIiwiQWZ0ZXJEZWxheSIsIkZvY3VzT3V0IiwiQ3JlYXRlZCIsIkNoYW5nZWQiLCJEZWxldGVkIiwiYmFzZVVyaSIsIldvcmtzcGFjZUZvbGRlciIsIkNoYW5nZSIsIkludm9rZWQiLCJUcmlnZ2VyQ2hhcmFjdGVyIiwiVHJpZ2dlckZvckluY29tcGxldGVDb21wbGV0aW9ucyIsIkNvbnRlbnRDaGFuZ2UiLCJJZGVudGlmaWVyIiwicHJvamVjdCIsImdyb3VwIiwiZ2xvYmFsIiwiJGltcG9ydCIsIiRleHBvcnQiLCJsb2NhbCIsIk1hcmt1cCIsIkNvZGUiLCJleGVjdXRpb25PcmRlciIsInN1Y2Nlc3MiLCJ1aW50ZWdlciIsImVxdWFscyIsIm9uZSIsIkRvY3VtZW50VXJpIiwibWV0YWRhdGEiLCJkaWZmIiwidHdvIiwiZXhlY3V0aW9uU3VtbWFyeSIsImVxdWFsc01ldGFkYXRhIiwib25lQXJyYXkiLCJvdGhlckFycmF5Iiwib25lS2V5cyIsIm90aGVyS2V5cyIsImNlbGxzIiwiaW50ZWdlciIsInR5cGVkQXJyYXkiLCJyZWdpc3RyYXRpb25NZXRob2QiLCJkZWxldGVDb3VudCIsIlJlbGF0aXZlIiwiY2hlY2siLCJBbm5vdGF0ZWRUZXh0RWRpdCIsIkNoYW5nZUFubm90YXRpb24iLCJDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllciIsIkNvZGVBY3Rpb24iLCJDb2RlQWN0aW9uQ29udGV4dCIsIkNvZGVBY3Rpb25LaW5kIiwiQ29kZUFjdGlvblRyaWdnZXJLaW5kIiwiQ29kZURlc2NyaXB0aW9uIiwiQ29kZUxlbnMiLCJDb2xvciIsIkNvbG9ySW5mb3JtYXRpb24iLCJDb2xvclByZXNlbnRhdGlvbiIsIkNvbW1hbmQiLCJDb21wbGV0aW9uSXRlbSIsIkNvbXBsZXRpb25JdGVtS2luZCIsIkNvbXBsZXRpb25JdGVtTGFiZWxEZXRhaWxzIiwiQ29tcGxldGlvbkl0ZW1UYWciLCJDb21wbGV0aW9uTGlzdCIsIkNyZWF0ZUZpbGUiLCJEZWxldGVGaWxlIiwiRGlhZ25vc3RpYyIsIkRpYWdub3N0aWNSZWxhdGVkSW5mb3JtYXRpb24iLCJEaWFnbm9zdGljU2V2ZXJpdHkiLCJEb2N1bWVudEhpZ2hsaWdodCIsIkRvY3VtZW50SGlnaGxpZ2h0S2luZCIsIkRvY3VtZW50TGluayIsIkRvY3VtZW50U3ltYm9sIiwiRU9MIiwiRm9sZGluZ1JhbmdlIiwiRm9sZGluZ1JhbmdlS2luZCIsIkZvcm1hdHRpbmdPcHRpb25zIiwiSG92ZXIiLCJJbmxheUhpbnQiLCJJbmxheUhpbnRLaW5kIiwiSW5sYXlIaW50TGFiZWxQYXJ0IiwiSW5saW5lVmFsdWVDb250ZXh0IiwiSW5saW5lVmFsdWVFdmFsdWF0YWJsZUV4cHJlc3Npb24iLCJJbmxpbmVWYWx1ZVRleHQiLCJJbmxpbmVWYWx1ZVZhcmlhYmxlTG9va3VwIiwiSW5zZXJ0UmVwbGFjZUVkaXQiLCJJbnNlcnRUZXh0Rm9ybWF0IiwiSW5zZXJ0VGV4dE1vZGUiLCJMb2NhdGlvbiIsIkxvY2F0aW9uTGluayIsIk1hcmtlZFN0cmluZyIsIk1hcmt1cENvbnRlbnQiLCJNYXJrdXBLaW5kIiwiT3B0aW9uYWxWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyIiwiUGFyYW1ldGVySW5mb3JtYXRpb24iLCJQb3NpdGlvbiIsIlJhbmdlIiwiUmVuYW1lRmlsZSIsIlNlbGVjdGlvblJhbmdlIiwiU2VtYW50aWNUb2tlbk1vZGlmaWVycyIsIlNlbWFudGljVG9rZW5UeXBlcyIsIlNlbWFudGljVG9rZW5zIiwiU2lnbmF0dXJlSW5mb3JtYXRpb24iLCJTeW1ib2xJbmZvcm1hdGlvbiIsIlN5bWJvbEtpbmQiLCJTeW1ib2xUYWciLCJUZXh0RG9jdW1lbnQiLCJUZXh0RG9jdW1lbnRFZGl0IiwiVGV4dERvY3VtZW50SWRlbnRpZmllciIsIlRleHREb2N1bWVudEl0ZW0iLCJUZXh0RWRpdCIsIlZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIiLCJXb3Jrc3BhY2VDaGFuZ2UiLCJXb3Jrc3BhY2VFZGl0IiwiV29ya3NwYWNlU3ltYm9sIiwiTUlOX1ZBTFVFIiwiTUFYX1ZBTFVFIiwiY2hhcmFjdGVyIiwidGhyZWUiLCJmb3VyIiwidGFyZ2V0VXJpIiwidGFyZ2V0UmFuZ2UiLCJ0YXJnZXRTZWxlY3Rpb25SYW5nZSIsIm9yaWdpblNlbGVjdGlvblJhbmdlIiwiYWxwaGEiLCJudW1iZXJSYW5nZSIsImNvbG9yIiwidGV4dEVkaXQiLCJhZGRpdGlvbmFsVGV4dEVkaXRzIiwiQ29tbWVudCIsIkltcG9ydHMiLCJSZWdpb24iLCJzdGFydExpbmUiLCJlbmRMaW5lIiwic3RhcnRDaGFyYWN0ZXIiLCJlbmRDaGFyYWN0ZXIiLCJjb2xsYXBzZWRUZXh0IiwiZGVmaW5lZCIsImxvY2F0aW9uIiwiSW5mb3JtYXRpb24iLCJIaW50IiwiaHJlZiIsInNldmVyaXR5IiwiY29kZURlc2NyaXB0aW9uIiwibmV3VGV4dCIsImluc2VydCIsImRlbCIsIm5lZWRzQ29uZmlybWF0aW9uIiwiZGVzY3JpcHRpb24iLCJhbm5vdGF0aW9uIiwiYW5ub3RhdGlvbklkIiwiZWRpdHMiLCJvdmVyd3JpdGUiLCJpZ25vcmVJZkV4aXN0cyIsIm9sZFVyaSIsIm5ld1VyaSIsInJlY3Vyc2l2ZSIsImlnbm9yZUlmTm90RXhpc3RzIiwiY2hhbmdlcyIsImNoYW5nZSIsIlRleHRFZGl0Q2hhbmdlSW1wbCIsImNoYW5nZUFubm90YXRpb25zIiwiZWRpdCIsImFzc2VydENoYW5nZUFubm90YXRpb25zIiwibWFuYWdlIiwiQ2hhbmdlQW5ub3RhdGlvbnMiLCJhbm5vdGF0aW9ucyIsIl9hbm5vdGF0aW9ucyIsIl9jb3VudGVyIiwiaWRPckFubm90YXRpb24iLCJuZXh0SWQiLCJfdGV4dEVkaXRDaGFuZ2VzIiwiX3dvcmtzcGFjZUVkaXQiLCJfY2hhbmdlQW5ub3RhdGlvbnMiLCJ0ZXh0RWRpdENoYW5nZSIsImluaXREb2N1bWVudENoYW5nZXMiLCJnZXRUZXh0RWRpdENoYW5nZSIsInRleHREb2N1bWVudEVkaXQiLCJpbml0Q2hhbmdlcyIsImNyZWF0ZUZpbGUiLCJvcHRpb25zT3JBbm5vdGF0aW9uIiwib3BlcmF0aW9uIiwicmVuYW1lRmlsZSIsImRlbGV0ZUZpbGUiLCJQbGFpblRleHQiLCJNYXJrZG93biIsIk1ldGhvZCIsIkZpZWxkIiwiVmFyaWFibGUiLCJJbnRlcmZhY2UiLCJNb2R1bGUiLCJQcm9wZXJ0eSIsIlVuaXQiLCJWYWx1ZSIsIkVudW0iLCJLZXl3b3JkIiwiU25pcHBldCIsIkZpbGUiLCJSZWZlcmVuY2UiLCJGb2xkZXIiLCJFbnVtTWVtYmVyIiwiQ29uc3RhbnQiLCJTdHJ1Y3QiLCJPcGVyYXRvciIsIlR5cGVQYXJhbWV0ZXIiLCJhc0lzIiwiYWRqdXN0SW5kZW50YXRpb24iLCJkZXRhaWwiLCJpdGVtcyIsImlzSW5jb21wbGV0ZSIsImZyb21QbGFpblRleHQiLCJwbGFpblRleHQiLCJjb250ZW50cyIsImRvY3VtZW50YXRpb24iLCJwYXJhbWV0ZXJzIiwiUmVhZCIsIldyaXRlIiwiTmFtZXNwYWNlIiwiUGFja2FnZSIsIktleSIsIk51bGwiLCJjb250YWluZXJOYW1lIiwic2VsZWN0aW9uUmFuZ2UiLCJjaGlsZHJlbiIsInRhZ3MiLCJRdWlja0ZpeCIsIlJlZmFjdG9yIiwiUmVmYWN0b3JFeHRyYWN0IiwiUmVmYWN0b3JJbmxpbmUiLCJSZWZhY3RvclJld3JpdGUiLCJTb3VyY2UiLCJTb3VyY2VPcmdhbml6ZUltcG9ydHMiLCJTb3VyY2VGaXhBbGwiLCJBdXRvbWF0aWMiLCJkaWFnbm9zdGljcyIsIm9ubHkiLCJ0cmlnZ2VyS2luZCIsImtpbmRPckNvbW1hbmRPckVkaXQiLCJjaGVja0tpbmQiLCJpc1ByZWZlcnJlZCIsInRhYlNpemUiLCJpbnNlcnRTcGFjZXMiLCJwYXJlbnQiLCJyZXN1bHRJZCIsInZhcmlhYmxlTmFtZSIsImNhc2VTZW5zaXRpdmVMb29rdXAiLCJmcmFtZUlkIiwic3RvcHBlZExvY2F0aW9uIiwiVHlwZSIsIlBhcmFtZXRlciIsInRvb2x0aXAiLCJ0ZXh0RWRpdHMiLCJwYWRkaW5nTGVmdCIsInBhZGRpbmdSaWdodCIsImNvbnRlbnQiLCJGdWxsVGV4dERvY3VtZW50IiwibGluZUNvdW50IiwicG9zaXRpb25BdCIsIm9mZnNldEF0IiwiYXBwbHlFZGl0cyIsInNvcnRlZEVkaXRzIiwibWVyZ2VTb3J0IiwibGFzdE1vZGlmaWVkT2Zmc2V0Iiwic3RhcnRPZmZzZXQiLCJlbmRPZmZzZXQiLCJsZWZ0IiwicmlnaHQiLCJsZWZ0SWR4IiwicmlnaHRJZHgiLCJfdXJpIiwiX2xhbmd1YWdlSWQiLCJfdmVyc2lvbiIsIl9jb250ZW50IiwiX2xpbmVPZmZzZXRzIiwiZ2V0TGluZU9mZnNldHMiLCJsaW5lT2Zmc2V0cyIsImlzTGluZVN0YXJ0IiwiY2giLCJsb3ciLCJoaWdoIiwibWlkIiwibGluZU9mZnNldCIsIm5leHRMaW5lT2Zmc2V0IiwiYXZhaWxhYmxlVHlwZWRBcnJheXMiLCJnbG9iYWxUaGlzIiwidHlwZWRBcnJheXMiLCIkc2xpY2UiLCJjYWNoZSIsInByb3RvIiwic3VwZXJQcm90byIsInRyeVR5cGVkQXJyYXlzIiwidHJ5QWxsVHlwZWRBcnJheXMiLCJmb3VuZCIsImdldHRlciIsInRyeVNsaWNlcyIsInRyeUFsbFNsaWNlcyIsInRhZyIsInBvc3NpYmxlTmFtZXMiLCJvdXQiLCJfX3VudXNlZF93ZWJwYWNrX19fd2VicGFja19tb2R1bGVfXyIsImdldFdlbGxmb3JtZWRSYW5nZSIsImFkZGVkTGluZU9mZnNldHMiLCJjb21wdXRlTGluZU9mZnNldHMiLCJlbnN1cmVCZWZvcmVFT0wiLCJpc0VPTCIsImdldFdlbGxmb3JtZWRFZGl0Iiwic3BhbnMiLCJpc0F0TGluZVN0YXJ0IiwidGV4dE9mZnNldCIsImNoYXIiLCJfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18iLCJtb2R1bGVJZCIsImNhY2hlZE1vZHVsZSIsImRlZmluaXRpb24iLCJMYW5ndWFnZUNsaWVudCIsIm1haW4iLCJtZXNzYWdlcyIsIkRpc3Bvc2FibGVDb2xsZWN0aW9uIiwiV2ViU29ja2V0TWVzc2FnZVJlYWRlciIsImV2ZW50cyIsInJlYWRNZXNzYWdlIiwib25NZXNzYWdlIiwiV2ViU29ja2V0TWVzc2FnZVdyaXRlciIsImNyZWF0ZVdlYlNvY2tldENvbm5lY3Rpb24iLCJDb25zb2xlTG9nZ2VyIiwiZGVidWciLCJ3ZWJTb2NrZXQiLCJvbkNvbm5lY3Rpb24iLCJvbm9wZW4iLCJ0b1NvY2tldCIsIm9uZXJyb3IiLCJvbmNsb3NlIiwiYnJvd3Nlcl9tYWluIiwiYmFzZV9zZXJ2aWNlIiwiQmFzZU1lc3NhZ2UiLCJkb2N1bWVudElkZW50aWZpZXIiLCJzZXNzaW9uSWQiLCJJbml0TWVzc2FnZSIsImluaXQiLCJGb3JtYXRNZXNzYWdlIiwiQ29tcGxldGVNZXNzYWdlIiwiY29tcGxldGUiLCJSZXNvbHZlQ29tcGxldGlvbk1lc3NhZ2UiLCJyZXNvbHZlQ29tcGxldGlvbiIsIkhvdmVyTWVzc2FnZSIsIlZhbGlkYXRlTWVzc2FnZSIsInZhbGlkYXRlIiwiQ2hhbmdlTWVzc2FnZSIsIkRlbHRhc01lc3NhZ2UiLCJhcHBseURlbHRhIiwiQ2hhbmdlTW9kZU1lc3NhZ2UiLCJjaGFuZ2VNb2RlIiwiQ2hhbmdlT3B0aW9uc01lc3NhZ2UiLCJjaGFuZ2VPcHRpb25zIiwiQ2xvc2VEb2N1bWVudE1lc3NhZ2UiLCJjbG9zZURvY3VtZW50IiwiQ2xvc2VDb25uZWN0aW9uTWVzc2FnZSIsIkdsb2JhbE9wdGlvbnNNZXNzYWdlIiwic2VydmljZU5hbWUiLCJDb25maWd1cmVGZWF0dXJlc01lc3NhZ2UiLCJjb25maWd1cmVGZWF0dXJlcyIsIlNpZ25hdHVyZUhlbHBNZXNzYWdlIiwiRG9jdW1lbnRIaWdobGlnaHRNZXNzYWdlIiwiR2V0U2VtYW50aWNUb2tlbnNNZXNzYWdlIiwiR2V0Q29kZUFjdGlvbnNNZXNzYWdlIiwiU2V0V29ya3NwYWNlTWVzc2FnZSIsIkV4ZWN1dGVDb21tYW5kTWVzc2FnZSIsIkFwcGxpZWRFZGl0TWVzc2FnZSIsImFwcGxpZWRFZGl0IiwiTElCIiwidCIsInMiLCJoIiwibGFzdEluZGV4T2YiLCJub3JtYWxpemUiLCJpc0Fic29sdXRlIiwicmVsYXRpdmUiLCJjIiwidSIsIl9tYWtlTG9uZyIsImRpcm5hbWUiLCJiYXNlbmFtZSIsImV4dG5hbWUiLCJleHQiLCJzZXAiLCJkZWxpbWl0ZXIiLCJ3aW4zMiIsInBvc2l4IiwiVXRpbHMiLCJQIiwicGxhdGZvcm0iLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJhdXRob3JpdHkiLCJwYXRoIiwicXVlcnkiLCJmcmFnbWVudCIsImlzVXJpIiwiZnNQYXRoIiwid2l0aCIsIkMiLCJmcm9tIiwicmV2aXZlIiwiX2Zvcm1hdHRlZCIsImV4dGVybmFsIiwiX2ZzUGF0aCIsIl9zZXAiLCIkbWlkIiwiZnJvbUNoYXJDb2RlIiwidiIsIkEiLCJ3Iiwiam9pblBhdGgiLCJyZXNvbHZlUGF0aCIsImxhbmd1YWdlX2NsaWVudF9VUkkiLCJsYW5ndWFnZV9jbGllbnRfY29uc29sZSIsImxhbmd1YWdlX2NsaWVudF9kZWZpbmVfcHJvcGVydHkiLCIkY29ubmVjdCIsInNlcnZlckRhdGEiLCIkY29ubmVjdFdvcmtlciIsIndvcmtlciIsImluaXRpYWxpemF0aW9uT3B0aW9ucyIsIiRjb25uZWN0U29ja2V0IiwiJGluaXRDb25uZWN0aW9uIiwicmVhZHlTdGF0ZSIsIldlYlNvY2tldCIsIk9QRU4iLCJkaXNwYXRjaEV2ZW50IiwiaXNDb25uZWN0ZWQiLCJzZW5kSW5pdGlhbGl6ZSIsInNob3dMb2ciLCJzaG93VHJhY2UiLCJhcHBsaWVkIiwiZmFpbHVyZVJlYXNvbiIsIiRyZWNvbm5lY3QiLCJ0ZXh0RG9jdW1lbnRNZXNzYWdlIiwiZW5xdWV1ZUlmTm90Q29ubmVjdGVkIiwiaXNJbml0aWFsaXplZCIsInJlcXVlc3RzUXVldWUiLCJfdGhpc19jb25uZWN0aW9uIiwiY2FwYWJpbGl0aWVzIiwiY2xpZW50Q2FwYWJpbGl0aWVzIiwicHJvY2Vzc0lkIiwicm9vdFVyaSIsIndvcmtzcGFjZUZvbGRlcnMiLCJ3b3Jrc3BhY2VGb2xkZXIiLCJzZXJ2aWNlQ2FwYWJpbGl0aWVzIiwiY2FwYWJpbGl0aWVzQ2hhbmdlIiwic2V0dGluZ3MiLCJyZXF1ZXN0Q2FsbGJhY2siLCJfdGhpc19zZXJ2aWNlQ2FwYWJpbGl0aWVzIiwiX3RoaXNfc2VydmljZUNhcGFiaWxpdGllczEiLCJ0ZXh0RG9jdW1lbnRTeW5jIiwidGV4dERvY3VtZW50Q2hhbmdlIiwiY29udGVudENoYW5nZXMiLCJob3ZlclByb3ZpZGVyIiwiY29tcGxldGlvblByb3ZpZGVyIiwiX3RoaXNfc2VydmljZUNhcGFiaWxpdGllc19jb21wbGV0aW9uUHJvdmlkZXIiLCJyZXNvbHZlUHJvdmlkZXIiLCJkb2N1bWVudFJhbmdlRm9ybWF0dGluZ1Byb3ZpZGVyIiwiZG9jdW1lbnRGb3JtYXR0aW5nUHJvdmlkZXIiLCJjb25maWdDaGFuZ2VzIiwiX3RoaXNfc2VydmljZUNhcGFiaWxpdGllc193b3Jrc3BhY2Vfd29ya3NwYWNlRm9sZGVycyIsIl90aGlzX3NlcnZpY2VDYXBhYmlsaXRpZXNfd29ya3NwYWNlIiwiY2hhbmdlTm90aWZpY2F0aW9ucyIsImFkZGVkIiwicmVtb3ZlZCIsImRvY3VtZW50SGlnaGxpZ2h0UHJvdmlkZXIiLCJzaWduYXR1cmVIZWxwUHJvdmlkZXIiLCJzZW1hbnRpY1Rva2Vuc1Byb3ZpZGVyIiwiY29kZUFjdGlvblByb3ZpZGVyIiwiZXhlY3V0ZUNvbW1hbmRQcm92aWRlciIsImNvbW1hbmRzIiwibW9kZXMiXSwic291cmNlUm9vdCI6IiJ9